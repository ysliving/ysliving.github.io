<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>码农印象</title>
  
  
  <link href="https://ysluckly.github.io/atom.xml" rel="self"/>
  
  <link href="https://ysluckly.github.io/"/>
  <updated>2022-02-20T11:58:02.073Z</updated>
  <id>https://ysluckly.github.io/</id>
  
  <author>
    <name>码农印象</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>休闲娱乐-小游戏</title>
    <link href="https://ysluckly.github.io/2022/02/02/undefined/"/>
    <id>https://ysluckly.github.io/2022/02/02/undefined/</id>
    <published>2022-02-01T17:00:10.000Z</published>
    <updated>2022-02-20T11:58:02.073Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>休闲小游戏是小游戏的一种。一般都是在看技术博客累的时候玩的，后来发展成网页游戏。并成为网络游戏集，并加以利用加入网络等元素，可以和网友进行比拼，使得休闲小游戏得以发展。</p></blockquote><h4 id="①、2048-小游戏-点击进入…"><a href="#①、2048-小游戏-点击进入…" class="headerlink" title="①、2048-小游戏 | 点击进入…"></a>①、2048-小游戏 | <a href="https://ysluckly.github.io/games/2048/index.html">点击进入…</a></h4><h4 id="②、五子棋-小游戏-点击进入…"><a href="#②、五子棋-小游戏-点击进入…" class="headerlink" title="②、五子棋- 小游戏 | 点击进入…"></a>②、五子棋- 小游戏 | <a href="https://ysluckly.github.io/games/gobang/index.html">点击进入…</a></h4><h4 id="③、圈小猫-小游戏-点击进入…"><a href="#③、圈小猫-小游戏-点击进入…" class="headerlink" title="③、圈小猫-小游戏 | 点击进入…"></a>③、圈小猫-小游戏 | <a href="https://ysluckly.github.io/games/cat/index.html">点击进入…</a></h4><h4 id="④、3D元素周期表-小游戏-点击进入…"><a href="#④、3D元素周期表-小游戏-点击进入…" class="headerlink" title="④、3D元素周期表-小游戏 | 点击进入…"></a>④、3D元素周期表-小游戏 | <a href="https://ysliving.github.io/games/element/index.html">点击进入…</a></h4><h4 id="⑤、弹钢琴-小游戏-点击进入…"><a href="#⑤、弹钢琴-小游戏-点击进入…" class="headerlink" title="⑤、弹钢琴-小游戏 | 点击进入…"></a>⑤、弹钢琴-小游戏 | <a href="https://ysluckly.github.io/games/piano/index.html">点击进入…</a></h4><h4 id="⑥、吃豆人-小游戏-点击进入…"><a href="#⑥、吃豆人-小游戏-点击进入…" class="headerlink" title="⑥、吃豆人-小游戏 | 点击进入…"></a>⑥、吃豆人-小游戏 | <a href="https://ysluckly.github.io/games/PacMan/index.html">点击进入…</a></h4>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;休闲小游戏是小游戏的一种。一般都是在看技术博客累的时候玩的，后来发展成网页游戏。并成为网络游戏集，并加以利用加入网络等元素，可以和网友进行比拼，使得休闲小游戏得以发展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;①、2048-小游戏-点击</summary>
      
    
    
    
    <category term="工具" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="game" scheme="https://ysluckly.github.io/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud系列之接入SkyWalking进行链路追踪和日志收集</title>
    <link href="https://ysluckly.github.io/2021/09/26/spring-cloud-skywalking/"/>
    <id>https://ysluckly.github.io/2021/09/26/spring-cloud-skywalking/</id>
    <published>2021-09-26T10:08:00.000Z</published>
    <updated>2022-02-19T09:27:58.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一段时间一直在研究升级公司项目的架构，在不断学习和试错后，最终确定了一套基于 k8s 的高可用架构体系，未来几期会将这套架构体系的架设过程和注意事项以系列文章的形式分享出来，敬请期待！</p><p>由于集群和分布式规模的扩大，对微服务链路的监控和日志收集，越来越有必要性，所以在筛选了了一些方案后，发现 SkyWalking 完美符合我们的预期，对链路追踪和日志收集都有不错的实现。</p><h2 id="SkyWalking-简介"><a href="#SkyWalking-简介" class="headerlink" title="SkyWalking 简介"></a>SkyWalking 简介</h2><p>SkyWalking 是一款 APM（应用程序监控）系统，转为微服务、云原生、基于容器的架构而设计。主要包含了一下核心功能</p><ol><li>对服务、运行实例、API进行指标分析</li><li>链路检测，检查缓慢的服务和API</li><li>对基础设施（VM、网络、磁盘、数据库）进行监控</li><li>对超出阈值的情况进行警报</li><li>等等</li></ol><p>开源地址：<a href="https://github.com/apache/skywalking">apache&#x2F;skywalking</a></p><p>官网：<a href="https://skywalking.apache.org/">Apache SkyWalking</a></p><h2 id="SpringCloud-整合-SkyWalking"><a href="#SpringCloud-整合-SkyWalking" class="headerlink" title="SpringCloud 整合 SkyWalking"></a>SpringCloud 整合 SkyWalking</h2><h3 id="1-搭建-SkyWalking-服务"><a href="#1-搭建-SkyWalking-服务" class="headerlink" title="1. 搭建 SkyWalking 服务"></a>1. 搭建 SkyWalking 服务</h3><p>在使用 SkyWalking 进行链路追踪和日志收集之前，需要先搭建起一套 SkyWalking 的服务，然后才能通过 agent 将 SpringCloud 的运行状态和日志发送给 SkyWalking 进行解析和展示。</p><p>SkyWalking 的搭建方式有很多中，我这里介绍两种 docker-compose（非高可用，快速启动，方便测试、学习） 和 k8s（高可用、生产级别）</p><h4 id="docker-compose-的方式"><a href="#docker-compose-的方式" class="headerlink" title="docker-compose 的方式"></a>docker-compose 的方式</h4><p>docker 和 docker-compose 的安装不是本文的重点，所以有需要可以自行查询。</p><p>以下操作会启动三个容器</p><ol><li><code>elasticsearch</code> 作为 skywalking 的存储，保存链路和日志数据等</li><li><code>oap</code> 数据接收和分析 Observability Analysis Platform</li><li><code>ui</code> web端的数据展示</li></ol><pre><code class="bash"># 创建配置文件保存的目录mkdir -p /data/docker/admin/skywalking# 切换到刚创建的目录cd /data/docker/admin/skywalking# 将下面的 docker-compose.yml 文件保存到这个目录vi docker-compose.yml# 拉去镜像并启动docker-compose up -d# 查看日志docker-compose logs -f</code></pre><p>docker-compose.yml</p><pre><code class="yaml">version: &#39;3.8&#39;services:  elasticsearch:    image: docker.elastic.co/elasticsearch/elasticsearch:7.14.1    container_name: elasticsearch    restart: always    ports:      - 9200:9200    healthcheck:      test: [&quot;CMD-SHELL&quot;, &quot;curl --silent --fail localhost:9200/_cluster/health || exit 1&quot;]      interval: 30s      timeout: 10s      retries: 3      start_period: 40s    environment:      - discovery.type=single-node      - bootstrap.memory_lock=true      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;      - TZ=Asia/Shanghai    ulimits:      memlock:        soft: -1        hard: -1  oap:    image: apache/skywalking-oap-server:8.7.0-es7    container_name: oap    depends_on:      - elasticsearch    links:      - elasticsearch    restart: always    ports:      - 11800:11800      - 12800:12800    healthcheck:      test: [&quot;CMD-SHELL&quot;, &quot;/skywalking/bin/swctl&quot;]      interval: 30s      timeout: 10s      retries: 3      start_period: 40s    environment:      TZ: Asia/Shanghai      SW_STORAGE: elasticsearch7      SW_STORAGE_ES_CLUSTER_NODES: elasticsearch:9200  ui:    image: apache/skywalking-ui:8.7.0    container_name: ui    depends_on:      - oap    links:      - oap    restart: always    ports:      - 8088:8080    environment:      TZ: Asia/Shanghai      SW_OAP_ADDRESS: http://oap:12800</code></pre><p>启动之后浏览器访问 <code>服务ip:8080</code> 即可</p><h4 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h4><p>等待更新。。</p><h3 id="2-下载-agent-代理包"><a href="#2-下载-agent-代理包" class="headerlink" title="2. 下载 agent 代理包"></a>2. 下载 agent 代理包</h3><p>点击链接进行下载，<a href="https://archive.apache.org/dist/skywalking/8.7.0/apache-skywalking-apm-8.7.0.tar.gz">skywalking-apm-8.7</a></p><blockquote><p>其他版本可以看 <a href="https://archive.apache.org/dist/skywalking/">apache 归档站</a>，找到对应版本的 <code>.tar.gz</code> 后缀的包，进行下载</p></blockquote><p>通过命令或者软件进行解压 <code>tar -zxvf apache-skywalking-apm-8.7.0.tar.gz</code></p><h3 id="3-java-命令使用代码启动-jar-包"><a href="#3-java-命令使用代码启动-jar-包" class="headerlink" title="3. java 命令使用代码启动 jar 包"></a>3. java 命令使用代码启动 jar 包</h3><p>springcloud&#x2F;springboot 一般是通过 <code>java -jar xxx.jar</code> 进行启动。我们只需要在其中加上 <code>-javaagent</code> 参数即可，如下</p><p>其中 <strong>自定义服务名</strong> 可以改为应用名 如 <code>lemes-auth</code>，<strong>服务ip</strong> 为第一步搭建的 SkyWalking 服务的ip，<strong>端口11800</strong> 为启动的 oap 这个容器的端口</p><pre><code class="bash">java -javaagent:上一步解压目录/agent/skywalking-agent.jar=agent.service_name=自定义服务名,collector.backend_service=服务ip:11800 -jar xx.jar</code></pre><p>执行命令启动后，访问以下接口，就可以在第一步 <code>服务ip:8080</code> 中看到访问的链接和调用链路。</p><p><img src="https://img.saodiyang.com/picgo_qiniu20210926164151.png" alt="链路追踪"><br><img src="https://img.saodiyang.com/picgo_qiniu20210926164350.png" alt="拓扑图"></p><h3 id="4-开启日志收集"><a href="#4-开启日志收集" class="headerlink" title="4. 开启日志收集"></a>4. 开启日志收集</h3><p>本文主要以 log4j2 来介绍，其他的大同小异，可以网上找教程。SpringCloud 集成 log4j2 不是本文重点，所以请自行 Google。</p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>要开启日志收集，必须要添加依赖，如下</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.apache.skywalking&lt;/groupId&gt;    &lt;artifactId&gt;apm-toolkit-log4j-2.x&lt;/artifactId&gt;    &lt;version&gt;8.7.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="修改-log4j2-xml"><a href="#修改-log4j2-xml" class="headerlink" title="修改 log4j2.xml"></a>修改 log4j2.xml</h4><p>需要修改 log4j2.xml 主要添加下面两个关键点</p><ul><li>添加 <code>%traceId</code> 来打印 traceid</li><li>声明 GRPCLogClientAppender</li></ul><p>完整内容如下</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;&lt;!-- Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，     你会看到log4j2内部各种详细输出。可以设置成OFF(关闭) 或 Error(只输出错误信息)。--&gt;&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;&lt;configuration status=&quot;WARN&quot; monitorInterval=&quot;30&quot;&gt;    &lt;Properties&gt;        &lt;Property name=&quot;log.path&quot;&gt;logs/lemes-auth&lt;/Property&gt;        &lt;Property name=&quot;logging.lemes.pattern&quot;&gt;            %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level] [%traceId] [%logger&#123;50&#125;.%M:%L] - %msg%n        &lt;/Property&gt;    &lt;/Properties&gt;    &lt;Appenders&gt;        &lt;!-- 输出控制台日志的配置 --&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;            &lt;ThresholdFilter level=&quot;debug&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;!-- 输出日志的格式 --&gt;            &lt;PatternLayout pattern=&quot;$&#123;logging.lemes.pattern&#125;&quot;/&gt;        &lt;/Console&gt;        &lt;RollingRandomAccessFile name=&quot;debugRollingFile&quot; fileName=&quot;$&#123;log.path&#125;/debug.log&quot;                                 filePattern=&quot;$&#123;log.path&#125;/debug/$$&#123;date:yyyy-MM&#125;/debug.%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;&gt;            &lt;ThresholdFilter level=&quot;debug&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;PatternLayout charset=&quot;UTF-8&quot; pattern=&quot;$&#123;logging.lemes.pattern&#125;&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;DefaultRolloverStrategy max=&quot;30&quot;/&gt;        &lt;/RollingRandomAccessFile&gt;        &lt;GRPCLogClientAppender name=&quot;grpc-log&quot;&gt;            &lt;PatternLayout pattern=&quot;$&#123;logging.lemes.pattern&#125;&quot;/&gt;        &lt;/GRPCLogClientAppender&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!-- ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF --&gt;        &lt;Logger name=&quot;com.lenovo.lemes&quot; level=&quot;debug&quot;/&gt;        &lt;Logger name=&quot;org.apache.kafka&quot; level=&quot;warn&quot;/&gt;        &lt;Root level=&quot;info&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;debugRollingFile&quot;/&gt;            &lt;AppenderRef ref=&quot;grpc-log&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/configuration&gt;</code></pre><h4 id="启动命令中声明上报日志"><a href="#启动命令中声明上报日志" class="headerlink" title="启动命令中声明上报日志"></a>启动命令中声明上报日志</h4><p>在上一步的 agent 中添加上报日志的参数 <code>plugin.toolkit.log.grpc.reporter.server_host=服务ip,plugin.toolkit.log.grpc.reporter.server_port=11800</code></p><p>完整如下</p><pre><code class="bash">java -javaagent:上一步解压目录/agent/skywalking-agent.jar=agent.service_name=自定义服务名,collector.backend_service=服务ip:11800,plugin.toolkit.log.grpc.reporter.server_host=服务ip,plugin.toolkit.log.grpc.reporter.server_port=11800 -jar xx.jar</code></pre><h4 id="日志收集效果"><a href="#日志收集效果" class="headerlink" title="日志收集效果"></a>日志收集效果</h4><p>这样启动日志中就会打印 traceid , <code>N/A</code> 代表的是非请求的日志，有 traceid 的为 api 请求日志</p><p><img src="https://img.saodiyang.com/picgo_qiniu20210926170409.png" alt="traceid"></p><p>在 skywalking 中就能看到我们上报的日志</p><p><img src="https://img.saodiyang.com/picgo_qiniu20210926170953.png" alt="skywalking 日志上报"></p><p>重点：SkyWalking 可以在链路追踪中查看当前请求的所有日志（不同实例&#x2F;模块）</p><p><img src="https://img.saodiyang.com/picgo_qiniu20210926171217.png" alt="SkyWalking 链路日志"></p><p><img src="https://img.saodiyang.com/picgo_qiniu20210926171256.png" alt="SkyWalking 链路日志"></p><h3 id="5-兼容-spring-cloud-gateway"><a href="#5-兼容-spring-cloud-gateway" class="headerlink" title="5. 兼容 spring-cloud-gateway"></a>5. 兼容 spring-cloud-gateway</h3><p>经过上面的步骤之后，链路已经搭建完成，查看发现了一个问题，gateway 模块的 <code>traceId</code> 和 业务模块的 <code>traceId</code> 不统一。</p><p><img src="https://img.saodiyang.com/picgo_qiniu20210926164350.png" alt="拓扑图"></p><p>这是由于 SkyWalking 对于 <code>spring-cloud-gateway</code> 的支持不是默认的，所以需要将 <code>agent/optional-plugins/apm-spring-cloud-gateway-2.1.x-plugin-8.7.0.jar</code> 复制到 <code>agent/plugins</code> 下，然后重启即可。</p><p><img src="https://img.saodiyang.com/picgo_qiniu20210926180619.png" alt="优化过 gateway 的拓扑图"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>SkyWalking 上面这两个功能就已经非常强大，能够有效帮助我们优化我们的程序，监控系统的问题，并及时报警。日志收集也解决的在大规模分布式集群下日志查询难的问题。</p><p>SkyWalking 还支持 VM、浏览器、k8s等监控，后续如果有实践，将会逐步更新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前一段时间一直在研究升级公司项目的架构，在不断学习和试错后，最终确定了一套基于 k8s 的高可用架构体系，未来几期会将这套架构体系的架设过程</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="java" scheme="https://ysluckly.github.io/tags/java/"/>
    
    <category term="SpringCloud" scheme="https://ysluckly.github.io/tags/SpringCloud/"/>
    
    <category term="SkyWalking" scheme="https://ysluckly.github.io/tags/SkyWalking/"/>
    
  </entry>
  
  <entry>
    <title>3-hexo添加自定义图标</title>
    <link href="https://ysluckly.github.io/2020/12/28/3-hexo-add-icon/"/>
    <id>https://ysluckly.github.io/2020/12/28/3-hexo-add-icon/</id>
    <published>2020-12-28T14:00:00.000Z</published>
    <updated>2022-02-19T09:27:58.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>鉴于许多人问过如何添加自定义图标，这里就详细说明一下，以备后人乘凉。</p><p>这篇文章主要讲解是从 <a href="https://www.iconfont.cn/">iconfont</a> 添加图标。</p><h2 id="二、添加彩色图标"><a href="#二、添加彩色图标" class="headerlink" title="二、添加彩色图标"></a>二、添加彩色图标</h2><h3 id="2-1-登录并添加图标"><a href="#2-1-登录并添加图标" class="headerlink" title="2.1 登录并添加图标"></a>2.1 登录并添加图标</h3><p>访问 <a href="https://www.iconfont.cn/">iconfont</a>，点击如下图位置登录，可以使用 <code>Github</code> 账号登录。</p><p><img src="https://img.saodiyang.com/picgo_qiniu20201228230707.png" alt="iconfont 登录"></p><p>登录成功后，搜索合适的图标，然后点击添加到购物车，如下图所示。</p><p><img src="https://img.saodiyang.com/picgo_qiniu20201228231118.png"></p><p>添加了多个后，可以点击右上角的“购物车”，添加到项目，点击加号创建项目，如下图所示。</p><p><img src="https://img.saodiyang.com/picgo_qiniu20201228231558.png"></p><p>添加完成后回到项目页面，找到自己刚刚创建的项目。</p><blockquote><p>如果没有到项目页面，可以点击上面菜单进入：资源管理 -&gt; 我的项目</p></blockquote><h3 id="2-2-引入-3-hexo-中"><a href="#2-2-引入-3-hexo-中" class="headerlink" title="2.2 引入 3-hexo 中"></a>2.2 引入 3-hexo 中</h3><p>点击下载到本地，解压并复制其中的 <code>iconfont.js</code> 到项目 <code>3-hexo/source/js/</code> 下，并改名 <code>custom-iconfont.js</code>。</p><p><img src="https://img.saodiyang.com/picgo_qiniu20201229003210.png"></p><p>在文件 <code>3-hexo/layout/_partial/meta.ejs</code> 最后追加下面一行。</p><pre><code class="html">&lt;script src=&quot;&lt;%=theme.blog_path?theme.blog_path.lastIndexOf(&quot;/&quot;) === theme.blog_path.length-1?theme.blog_path.slice(0, theme.blog_path.length-1):theme.blog_path:&#39;&#39; %&gt;/js/custom-iconfont.js?v=&lt;%=theme.version%&gt;&quot; &gt;&lt;/script&gt;</code></pre><h3 id="2-3-在配置文件中添加生效"><a href="#2-3-在配置文件中添加生效" class="headerlink" title="2.3 在配置文件中添加生效"></a>2.3 在配置文件中添加生效</h3><p>修改 <code>3-hexo/_config.yml</code> 如下图所示</p><p><img src="https://img.saodiyang.com/picgo_qiniu20201229001129.png"></p><p>完成！</p><blockquote><p>图标名如上面的 <code>gitee</code> 可以在 网站上修改，如下图所示<br><img src="https://img.saodiyang.com/picgo_qiniu20201229002057.png"></p></blockquote><h2 id="三、添加黑白图标"><a href="#三、添加黑白图标" class="headerlink" title="三、添加黑白图标"></a>三、添加黑白图标</h2><p><code>link.theme=white</code></p><h3 id="3-1-同-2-1"><a href="#3-1-同-2-1" class="headerlink" title="3.1 同 2.1"></a>3.1 同 2.1</h3><h3 id="3-2-引入-3-hexo-中"><a href="#3-2-引入-3-hexo-中" class="headerlink" title="3.2 引入 3-hexo 中"></a>3.2 引入 3-hexo 中</h3><p>点击生成代码，如下图所示。</p><p><img src="https://img.saodiyang.com/picgo_qiniu20201228231715.png"></p><p>复制生成的代码，修改 <code>font-family</code> 的值为 <code>custom-iconfont</code>，添加到 <code>3-hexo/source/css/_partial/font.styl</code> 最后，并写入图标信息，<code>content</code> 可以移到图标上进行复制，注意前面斜杠转译和去掉后面的分号。</p><pre><code class="css">@font-face &#123;  font-family: &#39;custom-iconfont&#39;;  /* project id 2298064 */  src: url(&#39;//at.alicdn.com/t/font_2298064_34vkk4c9945.eot&#39;);  src: url(&#39;//at.alicdn.com/t/font_2298064_34vkk4c9945.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),  url(&#39;//at.alicdn.com/t/font_2298064_34vkk4c9945.woff2&#39;) format(&#39;woff2&#39;),  url(&#39;//at.alicdn.com/t/font_2298064_34vkk4c9945.woff&#39;) format(&#39;woff&#39;),  url(&#39;//at.alicdn.com/t/font_2298064_34vkk4c9945.ttf&#39;) format(&#39;truetype&#39;),  url(&#39;//at.alicdn.com/t/font_2298064_34vkk4c9945.svg#iconfont&#39;) format(&#39;svg&#39;);&#125;.icon-gitee:before &#123;  content: &quot;\e602&quot;;&#125;.icon-youtubeautored:before &#123;  content: &quot;\e649&quot;;&#125;</code></pre><h3 id="3-3-在配置文件中添加生效-同2-2"><a href="#3-3-在配置文件中添加生效-同2-2" class="headerlink" title="3.3 在配置文件中添加生效 同2.2"></a>3.3 在配置文件中添加生效 同2.2</h3><p>结束！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;鉴于许多人问过如何添加自定义图标，这里就详细说明一下，以备后人乘凉。&lt;/p&gt;
&lt;p&gt;这篇文章主要讲解是从 &lt;a href=&quot;</summary>
      
    
    
    
    <category term="工具" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="hexo" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
    <category term="hexo" scheme="https://ysluckly.github.io/tags/hexo/"/>
    
    <category term="3-hexo" scheme="https://ysluckly.github.io/tags/3-hexo/"/>
    
  </entry>
  
  <entry>
    <title>一文看懂JavaScript中的Promise</title>
    <link href="https://ysluckly.github.io/2020/10/20/know-javascript-promise/"/>
    <id>https://ysluckly.github.io/2020/10/20/know-javascript-promise/</id>
    <published>2020-10-20T11:43:44.000Z</published>
    <updated>2022-02-19T09:27:58.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Promise-是什么"><a href="#一、Promise-是什么" class="headerlink" title="一、Promise 是什么"></a>一、Promise 是什么</h2><p><code>Promise</code> 是 <code>ES6</code> 提供的原生对象，用来处理异步操作</p><p>它有三种状态</p><ul><li><code>pending</code>: 初始状态，不是成功或失败状态。</li><li><code>fulfilled</code>: 意味着操作成功完成。</li><li><code>rejected</code>: 意味着操作失败。</li></ul><h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><h3 id="2-1-创建-Promise"><a href="#2-1-创建-Promise" class="headerlink" title="2.1 创建 Promise"></a>2.1 创建 Promise</h3><p>通过 <code>new Promise</code> 来实例化，支持链式调用</p><pre><code class="javascript">new Promise((resolve, reject)=&gt;&#123;  // 逻辑&#125;).then(()=&gt;&#123;  //当上面&quot;逻辑&quot;中调用 resolve() 时触发此方法&#125;).catch(()=&gt;&#123;  //当上面&quot;逻辑&quot;中调用 reject() 时触发此方法&#125;)</code></pre><h3 id="2-2-执行顺序"><a href="#2-2-执行顺序" class="headerlink" title="2.2 执行顺序"></a>2.2 执行顺序</h3><p><code>Promise</code>一旦创建就立即执行，并且无法中途取消，执行逻辑和顺序可以从下面的示例中获得</p><p>如下，可修改 <code>if</code> 条件来改变异步结果，下面打印开始的数字是执行顺序</p><p><a href="https://jsbin.com/cijuwakeha/1/edit?js,console">在线调试此示例 - jsbin</a></p><pre><code class="javascript">console.log(&#39;1.开始创建并执行 Promise&#39;)new Promise(function(resolve, reject) &#123;  console.log(&#39;2.由于创建会立即执行，所以会立即执行到本行&#39;)  setTimeout(()=&gt;&#123; // 模拟异步请求    console.log(&#39;4. 1s之期已到，开始执行异步操作&#39;)    if (true) &#123;        // 一般我们符合预期的结果时调用 resolve()，会在 .then 中继续执行        resolve(&#39;成功&#39;)    &#125; else &#123;        // 不符合预期时调用 reject()，会在 .catch 中继续执行        reject(&#39;不符合预期&#39;)    &#125;  &#125;, 1000)&#125;).then((res)=&gt;&#123;  console.log(&#39;5.调用了then，接收数据：&#39; + res)&#125;).catch((error)=&gt;&#123;  console.log(&#39;5.调用了catch，错误信息：&#39; + error)&#125;)console.log(&#39;3.本行为同步操作，所以先于 Promise 内的异步操作（setTimeout）&#39;)</code></pre><p>执行结果如下</p><pre><code class="javascript">&quot;1.开始创建并执行 Promise&quot;&quot;2.由于创建会立即执行，所以会立即执行到本行&quot;&quot;3.本行为同步操作，所以先于 Promise 内的异步操作（setTimeout）&quot;&quot;4. 1s之期已到，开始执行异步操作&quot;&quot;5.调用了then，接收数据：成功&quot;</code></pre><h3 id="2-3-用函数封装-Promise"><a href="#2-3-用函数封装-Promise" class="headerlink" title="2.3 用函数封装 Promise"></a>2.3 用函数封装 Promise</h3><p>这是比较常用的方法，如下用 <code>setTimeout</code> 模拟异步请求，封装通用请求函数</p><p><a href="https://jsbin.com/figuhohoki/1/edit?js,console">在线调试此示例 - jsbin</a></p><pre><code class="javascript">// 这是一个异步方法function ajax(url)&#123;  return new Promise(resolve=&gt;&#123;    console.log(&#39;异步方法开始执行&#39;)    setTimeout(()=&gt;&#123;      console.log(&#39;异步方法执行完成&#39;)      resolve(url+&#39;的结果集&#39;)    &#125;, 1000)  &#125;)&#125;// 调用请求函数，并接受处理返回结果ajax(&#39;/user/list&#39;).then((res)=&gt;&#123;  console.log(res)&#125;)</code></pre><p>执行结果</p><pre><code class="javascript">&quot;异步方法开始执行&quot;&quot;异步方法执行完成&quot;&quot;/user/list的结果集&quot;</code></pre><h2 id="三、高级用法"><a href="#三、高级用法" class="headerlink" title="三、高级用法"></a>三、高级用法</h2><h3 id="3-1-同时支持Callback与Promise"><a href="#3-1-同时支持Callback与Promise" class="headerlink" title="3.1 同时支持Callback与Promise"></a>3.1 同时支持Callback与Promise</h3><p><a href="https://jsbin.com/qitewirina/1/edit?js,console">在线调试此示例 - jsbin</a></p><pre><code class="javascript">function ajax(url, success, fail) &#123;  if (typeof success === &#39;function&#39;) &#123;    setTimeout(() =&gt; &#123;      if (true) &#123;        success(&#123;user: &#39;羊&#39;&#125;)      &#125; else if (typeof fail === &#39;function&#39;) &#123;        console.log(typeof fail)        fail(&#39;用户不存在&#39;)      &#125;    &#125;, 1000)  &#125; else &#123;    return new Promise((resolve, reject) =&gt; &#123;      this.ajax(url, resolve, reject)    &#125;)  &#125;&#125;// callback 调用方式ajax(&#39;/user/get&#39;, (res)=&gt;&#123;  console.log(&#39;Callback请求成功！返回结果:&#39;, res)&#125;, (error)=&gt;&#123;  console.log(&#39;Callback请求失败！错误信息:&#39;, error)&#125;)// Promise 调用方式ajax(&#39;/user/get&#39;).then((res)=&gt;&#123;  console.log(&#39;Pormise请求成功！返回结果：&#39;, res)&#125;).catch((error)=&gt;&#123;  console.log(&#39;Promise请求失败！返回结果：&#39;, error)&#125;)</code></pre><p>执行结果</p><pre><code class="javascript">Callback请求成功！返回结果: &#123;user: &quot;羊&quot;&#125;Pormise请求成功！返回结果： &#123;user: &quot;羊&quot;&#125;</code></pre><h3 id="3-2-链式调用"><a href="#3-2-链式调用" class="headerlink" title="3.2 链式调用"></a>3.2 链式调用</h3><p><code>.then</code> 支持返回 <code>Promise</code> 对象进行链式调用</p><pre><code class="javascript">ajax(&#39;/user/info&#39;).then((res)=&gt;&#123;  // 用户信息查询成功后，可以根据返回结果查询后续信息  console.log(&#39;用户信息:&#39;, res)  return ajax(&#39;/user/score&#39;)&#125;).then((res)=&gt;&#123;  console.log(&#39;用户成绩:&#39;, res)  return ajax(&#39;/user/friends&#39;)&#125;).then((res)=&gt;&#123;  console.log(&#39;用户朋友:&#39;, res)&#125;)</code></pre><h3 id="3-3-Promise-all"><a href="#3-3-Promise-all" class="headerlink" title="3.3 Promise.all"></a>3.3 Promise.all</h3><p><code>Promise.all</code> 方法用于将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例。<br><a href="https://jsbin.com/xojifuzapo/1/edit?js,console">在线调试此示例 - jsbin</a></p><pre><code class="javascript">// 生成一个Promise对象的数组var promises = [2, 3, 5, 7, 11, 13].map(function(id)&#123;  return new Promise((resolve, reject)=&gt;&#123;    if (id % 3 === 0) &#123;      resolve(id)    &#125; else &#123;      reject(id)    &#125;  &#125;);&#125;);Promise.all(promises).then(function(post) &#123;  console.log(&#39;全部通过&#39;)&#125;).catch(function(reason)&#123;  console.log(&#39;未全部通过，有问题id：&#39;+reason)&#125;);</code></pre><p>执行结果</p><pre><code class="javascript">未全部通过，有问题id：2</code></pre><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">mozilla web docs</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Promise-是什么&quot;&gt;&lt;a href=&quot;#一、Promise-是什么&quot; class=&quot;headerlink&quot; title=&quot;一、Promise 是什么&quot;&gt;&lt;/a&gt;一、Promise 是什么&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt; 是 &lt;co</summary>
      
    
    
    
    <category term="大前端" scheme="https://ysluckly.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://ysluckly.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Docker 技术整理</title>
    <link href="https://ysluckly.github.io/2020/09/01/Docker-summary/"/>
    <id>https://ysluckly.github.io/2020/09/01/Docker-summary/</id>
    <published>2020-09-01T14:11:00.000Z</published>
    <updated>2022-02-19T09:27:58.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-1-什么是docker"><a href="#1-1-什么是docker" class="headerlink" title="1.1 什么是docker"></a>1.1 什么是docker</h3><p>Docker 诞生于 2013 年初，由 dotCloud 公司（后改名为 Docker Inc）基于 Go 语言实现并开源的项目。此项目后来加入 Linux基金会，遵从了 Apache 2.0 协议</p><p>Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。Docker 是在 Linux 容器技术（LXC）的基础上进行了封装，让用户可以快速并可靠的将应用程序从一台运行到另一台上。</p><p>使用容器部署应用被称为<strong>容器化</strong>，容器化技术的几大优势：</p><ol><li><strong>灵活</strong>：甚至复杂的应用也可以被容器化</li><li><strong>轻量</strong>：容器利用和共享宿主机内核，从而在利用系统资源比虚拟机更加的有效</li><li><strong>可移植</strong>：你可以在本地构建，在云端部署并在任何地方运行</li><li><strong>松耦合</strong>：容器是高度封装和自给自足的，允许你在不破环其他容器的情况下替换或升级任何一个</li><li><strong>可扩展</strong>：你可以通过数据中心来新增和自动分发容器</li><li><strong>安全</strong>：容器依赖强约束和独立的进程</li></ol><h3 id="1-2-和传统虚拟机的区别"><a href="#1-2-和传统虚拟机的区别" class="headerlink" title="1.2 和传统虚拟机的区别"></a>1.2 和传统虚拟机的区别</h3><p>容器在Linux上本地运行，并与其他容器共享主机的内核。它运行一个离散进程，不占用任何其他可执行文件更多的内存，从而使其轻巧。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/93990/1598693996043-1d7fecba-79fd-489c-b933-2d23c37680a8.png" alt="image.png"></p><h3 id="1-3-相关链接"><a href="#1-3-相关链接" class="headerlink" title="1.3 相关链接"></a>1.3 相关链接</h3><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a></p><h2 id="二、Image镜像"><a href="#二、Image镜像" class="headerlink" title="二、Image镜像"></a>二、Image镜像</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也<strong>不会被改变</strong>。</p><ol><li><strong>父镜像</strong>：每个镜像都可能依赖于有一个或多个下层组成的另一个镜像。下层那个镜像就是上层镜像的父镜像</li><li><strong>基础镜像</strong>：一个没有任何父镜像的镜像，被称为基础镜像</li><li><strong>镜像ID</strong>：所有镜像都是通过一个 64 位十六进制字符串（256 bit 的值）来标识的。为了简化使用，前 12 个自负可以组成一个短ID，可以在命令行中使用。短ID还是有一定的碰撞几率，所以服务器总是返回长ID</li></ol><h3 id="2-2-从仓库下载镜像"><a href="#2-2-从仓库下载镜像" class="headerlink" title="2.2 从仓库下载镜像"></a>2.2 从仓库下载镜像</h3><p>可以通过 <code>docker pull</code> 命令从仓库获取所需要的镜像</p><pre><code>docker pull [选项] [Docker Registry 地址]&lt;镜像名&gt;:&lt;标签&gt;</code></pre><p><strong>选项:</strong></p><ol><li>–all-tags,-a : 拉去所有 tagged 镜像</li><li>–disable-content-trust：忽略镜像的校验，默认</li><li>–platform：如果服务器是开启多平台支持的，则需要设置平台</li><li>–quiet,-q：静默执行，不打印详细信息</li></ol><p>标签： 下载指定标签的镜像，默认 <code>latest</code></p><p><strong>示例</strong></p><pre><code># 从 Docker Hub 下载最新的 debian 镜像docker pull debian# 从 Docker Hub 下载 jessie 版 debian 镜像docker pull debian:jessie# 下载指定摘要(sha256)的镜像docker pull ubuntu@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code></pre><h3 id="2-3-列出本地镜像"><a href="#2-3-列出本地镜像" class="headerlink" title="2.3 列出本地镜像"></a>2.3 列出本地镜像</h3><pre><code># 列出已下载的镜像 image_name: 指定列出某个镜像docker images [选项] [image_name]</code></pre><p><strong>选项</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>–all, -a</td><td>展示所有镜像(包括 intermediate 镜像)</td></tr><tr><td>–digests</td><td>展示摘要</td></tr><tr><td>–filter, -f</td><td>添加过滤条件</td></tr><tr><td>–format</td><td>使用 Go 模版更好的展示</td></tr><tr><td>–no-trunc</td><td>不删减输出</td></tr><tr><td>–quiet, -q</td><td>静默输出，仅仅展示 IDs</td></tr></tbody></table><p><strong>示例</strong></p><pre><code># 展示本地所有下载的镜像docker images# 在本地查找镜像名是 &quot;java&quot; 标签是 &quot;8&quot; 的 奖项docker images: java:8# 查找悬挂镜像docker images --filter &quot;dangling=true&quot;# 过滤 lable 为 &quot;com.example.version&quot; 的值为 0.1 的镜像docker images --filter &quot;label=com.example.version=0.1&quot;</code></pre><h3 id="2-4-Dockerfile创建镜像"><a href="#2-4-Dockerfile创建镜像" class="headerlink" title="2.4 Dockerfile创建镜像"></a>2.4 Dockerfile创建镜像</h3><p>为了方便分享和快速部署，我们可以使用 <code>docker build</code> 来创建一个新的镜像，首先创建一个文件 Dockerfile，如下</p><pre><code># This is a commentFROM ubuntu:14.04MAINTAINER Chris &lt;jaytp@qq.com&gt;RUN apt-get -qq updateRUN apt-get -qqy install ruby ruby-devRUN gem install sinatra</code></pre><p>然后在此 Dockerfile 所在目录执行 <code>docker build -t yelog/ubuntu:v1 .</code> 来生成镜像，所属组织&#x2F;镜像名:标签</p><h3 id="2-5-上传镜像"><a href="#2-5-上传镜像" class="headerlink" title="2.5 上传镜像"></a>2.5 上传镜像</h3><p>用户可以通过 <code>docker push</code> 命令，把自己创建的镜像上传到仓库中来共享。例如，用户在 Docker Hub 上完成注册后，可以推送自己的镜像到仓库中。</p><pre><code>docker push yelog/ubuntu</code></pre><h3 id="2-6-导出和载入镜像"><a href="#2-6-导出和载入镜像" class="headerlink" title="2.6 导出和载入镜像"></a>2.6 导出和载入镜像</h3><p>docker 支持将镜像导出为文件，然后可以再从文件导入到本地镜像仓库</p><pre><code># 导出docker load --input yelog_ubuntu_v1.tar# 载入docker load &lt; yelog_ubuntu_v1.tar</code></pre><h3 id="2-7-移除本地镜像"><a href="#2-7-移除本地镜像" class="headerlink" title="2.7 移除本地镜像"></a>2.7 移除本地镜像</h3><pre><code># -f 强制删除docker rmi [-f] yelog/ubuntu:v1# 删除悬挂镜像docker rmi $(docker images -f &quot;dangling=true&quot; -q)# 删除所有未被容器使用的镜像docker image prune -a</code></pre><h2 id="三、容器"><a href="#三、容器" class="headerlink" title="三、容器"></a>三、容器</h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><p>容器和镜像，就像面向对象中的 <strong>类</strong> 和 <strong>示例</strong> 一样，镜像是静态的定义，容器是镜像运行的实体，容器可以被创建、启动、停止、删除和暂停等</p><p>容器的实质是进城，耽于直接的宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 root 文件系统、网络配置和进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p><h3 id="3-2-创建容器"><a href="#3-2-创建容器" class="headerlink" title="3.2 创建容器"></a>3.2 创建容器</h3><p>我们可以通过命令 <code>docker run</code> 命令创建容器</p><p>如下，启动一个容器，执行命令输出 “Hello word”，之后终止容器</p><pre><code>docker run ubuntu:14.04 /bin/echo &#39;Hello world&#39;</code></pre><p>下面的命令则是启动一个 bash 终端，允许用户进行交互</p><pre><code>docker run -t -i ubuntu:14.04 /bin/bash</code></pre><p><code>-t</code> 让 Dcoker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上</p><p><code>-i</code> 责让容器的标准输入保持打开</p><p>更多参数可选</p><table><thead><tr><th>-a stdin</th><th>指定标准输入输出内容类型</th></tr></thead><tbody><tr><td>-d</td><td>后台运行容器，并返回容器ID</td></tr><tr><td>-i</td><td>以交互模式运行容器，通常与 -t 同时使用</td></tr><tr><td>-P</td><td>随机端口映射，容器端口内部随即映射到宿主机的端口上</td></tr><tr><td>-p</td><td>指定端口映射， -p 宿主机端口:容器端口</td></tr><tr><td>-t</td><td>为容器重新分配一个伪输入终，通常与 -i 同时使用</td></tr><tr><td>–name&#x3D;”gate”</td><td>为容器指定一个名称</td></tr><tr><td>–dns 8.8.8.8</td><td>指定容器的 DNS 服务器，默认与宿主机一致</td></tr><tr><td>–dns-search example.com</td><td>指定容器 DNS 搜索域名，默认与宿主机一致</td></tr><tr><td>-h “gate”</td><td>指定容器的 hostname</td></tr><tr><td>-e username&#x3D;’gate’</td><td>设置环境变量</td></tr><tr><td>–env-file&#x3D;[]</td><td>从指定文件读入环境变量</td></tr><tr><td>–cpuset&#x3D;”0-2” or –cpuset&#x3D;”0,1,2”</td><td>绑定容器到指定 CPU 运行</td></tr><tr><td>-m</td><td>设置容器使用内存最大值</td></tr><tr><td>–net&#x3D;”bridge”</td><td>指定容器的网络连接类型支持 bridge&#x2F;host&#x2F;none&#x2F;container</td></tr><tr><td>–link&#x3D;[]</td><td>添加链接到另一个容器</td></tr><tr><td>–expose&#x3D;[]</td><td>开放一个端口或一组端口</td></tr><tr><td>–volume,-v</td><td>绑定一个卷</td></tr></tbody></table><p>当利用 <code>docker run</code> 来创建容器时，Dcoker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像外面挂在一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟借口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h3 id="3-3-启动容器"><a href="#3-3-启动容器" class="headerlink" title="3.3 启动容器"></a>3.3 启动容器</h3><pre><code># 创建一个名为 test 的容器，容器任务是：打印一行 Hello worddocker run --name=&#39;test&#39; ubuntu:14.04 /bin/echo &#39;Hello world&#39;# 查看所有可用容器 [-a]包括终止在内的所有容器docker ps -a# 启动指定 name 的容器docker start test# 重启指定 name 的容器docker restart test# 查看日志运行日志（每次启动的日志均被查询出来）$ docker logs testHello worldHello world</code></pre><h3 id="3-4-守护态运行"><a href="#3-4-守护态运行" class="headerlink" title="3.4 守护态运行"></a>3.4 守护态运行</h3><p>前面创建的容器都是执行任务（打印Hello world）后，容器就终止了。更多的时候，我们需要让 Docker 容器在后台以守护态（Daemonized）形式运行。此时，可以通过添加 <code>-d</code> 参数来实现</p><blockquote><p>注意：docker是否会长久运行，和 docker run 指定的命令有关</p></blockquote><pre><code># 创建 docker 后台守护进程的容器docker run --name=&#39;test2&#39; -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;# 查看容器$ docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES237e555d4457        ubuntu:14.04        &quot;/bin/sh -c &#39;while t…&quot;   52 seconds ago      Up 51 seconds                                           test2# 获取容器的输出信息$ docker logs test2hello worldhello worldhello world</code></pre><h3 id="3-5-进入容器"><a href="#3-5-进入容器" class="headerlink" title="3.5 进入容器"></a>3.5 进入容器</h3><p>上一步我们已经实现了容器守护态长久运行，某些时候需要进入容器进行操作，可以使用 <code>attach</code> 、<code>exec</code> 进入容器。</p><pre><code># 不安全的，ctrl+d 退出时容器也会终止docker attach [容器Name]# 以交互式命令行进入，安全的，推荐使用docker exec -it [容器Name] /bin/bash</code></pre><p><strong>命令优化</strong></p><ol><li>使用 <code>docker exec</code> 命令时，好用，但是命令过长，我们可以通过自定义命令来简化使用</li><li>创建文件 <code>/user/bin/ctn</code> 命令文件，内容如下</li></ol><pre><code>docker exec -it $1 /bin/bash</code></pre><ol><li>检查环境变量有没有配置目录 <code>/usr/bin</code> （一般是有配置在环境变量里面的，不过最好再确认一下）</li></ol><pre><code>$PATHbash: /usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games: No such file or directory</code></pre><ol><li>完成上面步骤后，就可以直接通过命令 <code>ctn</code> 来进入容器</li></ol><blockquote><p>注意：如果是使用非 root 账号创建的命令，而 docker 命令是 root 权限，可能存在权限问题，可以通过设置 <code>chmod 777 /usr/bin/ctn</code> 设置权限，使用 <code>sudo ctn [容器Name]</code> 即可进入容器</p></blockquote><pre><code>$ ctn [容器Name]</code></pre><ol><li>使用上面命令时，容器Name 需要手动输入，容器出错。我们可以借助 <code>complete</code> 命令来补全 容器Name，在 <code>~/.bashrc</code> （作用于当前用户，如果想要所要用户上校，可以修改 <code>/etc/bashrc</code>）文件中添加一行，内容如下。保存后执行 <code>source ~/.bashrc</code> 使之生效，之后我们输入 <code>ctn</code> 后，按 <code>tab</code> 就会提示或自动补全容器名了了</li></ol><pre><code># ctn auto completecomplete -W &quot;$(docker ps --format&quot;&#123;&#123;.Names&#125;&#125;&quot;)&quot; ctn</code></pre><blockquote><p>注意： 由于提示的 容器Name 是 <code>~/.bashrc</code> 生效时的列表，所有如果之后 docker 容器列表有变动，需要重新执行 <code>source ~/.bashrc</code> 使之更新提示列表</p></blockquote><h3 id="3-6-终止容器"><a href="#3-6-终止容器" class="headerlink" title="3.6 终止容器"></a>3.6 终止容器</h3><p>通过 <code>docker stop [容器Name]</code> 来终止一个<strong>运行中</strong>的容器</p><pre><code># 终止容器名为 test2 的容器docker stop test2# 查看正在运行中的容器docker ps# 查看所有容器（包括终止的）docker ps -a</code></pre><h3 id="3-7-将容器保存为镜像"><a href="#3-7-将容器保存为镜像" class="headerlink" title="3.7 将容器保存为镜像"></a>3.7 将容器保存为镜像</h3><p>我们修改一个容器后，可以经当前容器状态打包成镜像，方便下次直接通过镜像仓库生成当前状态的容器。</p><pre><code># 创建容器docker run -t -i training/sinatra /bin/bash# 添加两个应用gem install json# 将修改后的容器打包成新的镜像docker commit -m &quot;Added json gem&quot; -a &quot;Docker Newbee&quot; 0b2616b0e5a8 ouruser/sinatra:v2</code></pre><h3 id="3-8-导出-x2F-导入容器"><a href="#3-8-导出-x2F-导入容器" class="headerlink" title="3.8 导出&#x2F;导入容器"></a>3.8 导出&#x2F;导入容器</h3><p>容器 -&gt;导出&gt; 容器快照文件 -&gt;导入&gt; 本地镜像仓库 -&gt;新建&gt; 容器</p><pre><code>$ docker ps -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES2a8bffa405c8        ubuntu:14.04        &quot;/bin/sh -c &#39;while t…&quot;   About an hour ago   Up 3 seconds                                            test2# 导出$ docker export 2a8bffa405c8 &gt; ubuntu.tar# 导入为镜像$ docker ubuntu.tar | docker import - test/ubuntu:v1.0# 从指定 URL 或者某个目录导入$ docker import http://example.com/exampleimage.tgz example/imagerepo</code></pre><blockquote><p>注意：用户既可以通过 <code>docker load</code> 来导入镜像存储文件到本地镜像仓库，也可以使用 <code>docker import</code> 来导入一个容器快找到本地镜像仓库，两者的区别在于容器快照将丢失所有的历史记录和元数据信息，仅保存容器当时的状态，而镜像存储文件将保存完成的记录，体积要更大。所有容器快照文件导入时需要重新指定标签等元数据信息。</p></blockquote><h3 id="3-9-删除容器"><a href="#3-9-删除容器" class="headerlink" title="3.9 删除容器"></a>3.9 删除容器</h3><p>可以使用 <code>docker rm [容器Name]</code> 来删除一个终止状态的容器，如果容器还未终止，可以先使用 <code>docker stop [容器Name]</code> 来终止容器，再进行删除操作</p><pre><code>docker rm test2# 删除容器 -f: 强制删除，无视是否运行$ docker [-f] rm myubuntu# 删除所有已关闭的容器$ docker rm $(docker ps -a -q)</code></pre><h3 id="3-10-查看容器状态"><a href="#3-10-查看容器状态" class="headerlink" title="3.10 查看容器状态"></a>3.10 查看容器状态</h3><pre><code>docker stats $(docker ps --format=&#123;&#123;.Names&#125;&#125;)</code></pre><h2 id="四、数据卷"><a href="#四、数据卷" class="headerlink" title="四、数据卷"></a>四、数据卷</h2><h3 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h3><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多特性：</p><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>卷会一直存在，直到没有容器使用</li></ul><blockquote><p>数据卷类似于 Linux 下对目录或文件进行 mount</p></blockquote><h3 id="4-2-创建数据卷"><a href="#4-2-创建数据卷" class="headerlink" title="4.2 创建数据卷"></a>4.2 创建数据卷</h3><p>在用 <code>docker run</code> 命令的时候，使用 <code>-v</code> 标记来创建一个数据卷并挂在在容器里，可同时挂在多个。</p><pre><code># 创建一个 web 容器，并加载一个数据卷到容器的 /webapp 目录docker run -d -P --name web -v /webapp training/webapp python app.py# 挂载一个宿主机目录 /data/webapp 到容器中的 /opt/webappdocker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py# 默认是读写权限，也可以指定为只读docker run -d -P --name web -v /src/webapp:/opt/webapp:ro# 挂载单个文件docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash</code></pre><h3 id="4-3-数据卷容器"><a href="#4-3-数据卷容器" class="headerlink" title="4.3 数据卷容器"></a>4.3 数据卷容器</h3><p>如果需要多个容器共享数据，最好创建数据卷容器，就是一个正常的容器，撰文用来提供数据卷供其他容器挂载的</p><pre><code># 创建一个数据卷容器 dbdatadocker run -d -v /dbdata --name dbdata training/postgres echo Data-only container for postgres# 其他容器挂载 dbdata 容器的数据卷docker run -d --volumes-from dbdata --name db1 training/postgresdocker run -d --volumes-from dbdata --name db2 training/postgres</code></pre><h2 id="五、网络"><a href="#五、网络" class="headerlink" title="五、网络"></a>五、网络</h2><h3 id="5-1-外部访问容器"><a href="#5-1-外部访问容器" class="headerlink" title="5.1 外部访问容器"></a>5.1 外部访问容器</h3><p>在容器内运行一些服务，需要外部可以访问到这些服务，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><p>当使用 <code>-P</code> 标记时，Docker 会随即映射一个 <code>49000～49900</code> 的端口到内部容器开放的网络端口。</p><p>使用 <code>docker ps</code> 可以查看端口映射情况</p><pre><code>$ docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES7f43807dc042        training/webapp     &quot;python app.py&quot;          3 seconds ago       Up 2 seconds        0.0.0.0:32770-&gt;5000/tcp             amazing_liskov</code></pre><p>-p 指定端口映射，支持格式 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code></p><pre><code># 不限制ip访问docker run -d -p 5000:5000 training/webapp python app.py# 只允许宿主机回环地址访问docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py# 宿主机自动分配绑定端口docker run -d -p 127.0.0.1::5000 training/webapp python app.py# 指定 udp 端口docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py# 指定多个端口映射docker run -d -p 5000:5000  -p 3000:80 training/webapp python app.py# 查看映射端口配置$ docker port amazing_liskov5000/tcp -&gt; 0.0.0.0:32770</code></pre><h3 id="5-2-容器互联"><a href="#5-2-容器互联" class="headerlink" title="5.2 容器互联"></a>5.2 容器互联</h3><p>容器除了跟宿主机端口映射外，还有一种容器间交互的方式，可以在源&#x2F;目标容器之间建立一个隧道，目标容器可以看到源容器指定的信息。</p><p>可以通过 <code>--link name:alias</code> 来连接容器，下面就是 “web容器连接db容器” 的例子</p><pre><code># 创建 容器dbdocker run -d --name db training/postgres# 创建 容器web 并连接到 容器dbdocker run -d -P --name web --link db:db training/webapp python app.py# 进入 容器web，测试连通性$ ctn web$ ping dbPING db (172.17.0.3) 56(84) bytes of data.64 bytes from db (172.17.0.3): icmp_seq=1 ttl=64 time=0.254 ms64 bytes from db (172.17.0.3): icmp_seq=2 ttl=64 time=0.190 ms64 bytes from db (172.17.0.3): icmp_seq=3 ttl=64 time=0.389 ms</code></pre><h3 id="5-3-访问控制"><a href="#5-3-访问控制" class="headerlink" title="5.3 访问控制"></a>5.3 访问控制</h3><p>容器想要访问外部网络，需要宿主机的转发支持。在 Linux 系统中，通过以下命令检查是否打开</p><pre><code>$ sysctl net.ipv4.ip_forwardnet.ipv4.ip_forward = 1</code></pre><p>如果是 0，说明没有开启转发，则需要手动打开。</p><pre><code>$ sysctl -w net.ipv4.ip_forward=1</code></pre><h3 id="5-4-配置-docker0-桥接"><a href="#5-4-配置-docker0-桥接" class="headerlink" title="5.4 配置 docker0 桥接"></a>5.4 配置 docker0 桥接</h3><p>Docker 服务默认会创建一个 <code>docker0</code> 网桥，他在内核层连通了其他物理或虚拟网卡，这就将容器和主机都放在同一个物理网络。</p><p>Docker 默认制定了 <code>docker0</code> 接口的IP地址和子网掩码，让主机和容器间可以通过网桥相互通信，他还给了 MTU（接口允许接收的最大单元），通常是 1500 Bytes，或宿主机网络路由上支持的默认值。这些都可以在服务启动的时候进行配置。</p><ul><li><code>--bip=CIDR</code> ip地址加子网掩码格式，如 192.168.1.5&#x2F;24</li><li><code>--mtu=BYTES</code> 覆盖默认的 Docker MTU 配置</li></ul><p>可以通过 <code>brctl show</code> 来查看网桥和端口连接信息</p><h3 id="5-5-网络配置文件"><a href="#5-5-网络配置文件" class="headerlink" title="5.5 网络配置文件"></a>5.5 网络配置文件</h3><p>Docker 1.2.0 开始支持在运行中的容器里编辑 <code>/etc/hosts</code> 、<code>/etc/hostsname</code> 和 <code>/etc/resolve.conf</code> 文件，修改都是临时的，重新容器将会丢失修改，通过 <code>docker commit</code> 也不会被提交。</p><h2 id="六、Dockerfile"><a href="#六、Dockerfile" class="headerlink" title="六、Dockerfile"></a>六、Dockerfile</h2><h3 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a>6.1 介绍</h3><p>Dockerfile 是由一行行命令组成的命令集合，分为四个部分：</p><ol><li>基础镜像信息</li><li>维护着信息</li><li>镜像操作指令</li><li>容器启动时执行指令</li></ol><p>如下：</p><pre><code># 最前面一般放这个 Dockerfile 的介绍、版本、作者及使用说明等# This dockerfile uses the ubuntu image# VERSION 2 - EDITION 1# Author: docker_user# Command format: Instruction [arguments / command] ..# 使用的基础镜像，必须放在非注释第一行FROM ubuntu# 维护着信息信息： 名字 联系方式MAINTAINER docker_user docker_user@email.com# 构建镜像的命令：对镜像做的调整都在这里RUN echo &quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot; &gt;&gt; /etc/apt/sources.listRUN apt-get update &amp;&amp; apt-get install -y nginxRUN echo &quot;\ndaemon off;&quot; &gt;&gt; /etc/nginx/nginx.conf# 创建/运行 容器时的操作指令 # 可以理解为 docker run 后跟的运行指令CMD /usr/sbin/nginx</code></pre><h3 id="6-2-指令"><a href="#6-2-指令" class="headerlink" title="6.2 指令"></a>6.2 指令</h3><p>指令一般格式为 <code>INSTRUCTION args</code>，包括 <code>FORM</code> 、 <code>MAINTAINER</code> 、<code>RUN</code> 等</p><table><thead><tr><th>FORM</th><th>第一条指令必须是 <code>FORM</code> 指令，并且如果在同一个<code>Dockerfile</code> 中创建多个镜像，可以使用多个 <code>FROM</code> 指令（每个镜像一次）</th><th>FORM ubuntuFORM ubuntu:14.04</th></tr></thead><tbody><tr><td>MAINTAINER</td><td>维护者信息</td><td>MAINTAINER Chris <a href="mailto:&#x78;&#120;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;">&#x78;&#120;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;</a></td></tr><tr><td>RUN</td><td>每条 RUN 指令在当前镜像基础上执行命令，并提交为新的镜像。当命令过长时可以使用 <code>\</code> 来换行</td><td>在 shell 终端中运行命令<code>RUN apt-get update &amp;&amp; apt-get install -y nginx</code>在 <code>exec</code> 中执行:<code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code></td></tr><tr><td>CMD</td><td>指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。</td><td><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> 使用 <code>exec</code> 执行，推荐方式；<code>CMD command param1 param2</code> 在 <code>/bin/sh</code> 中执行，提供给需要交互的应用；<code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> 提供给 <code>ENTRYPOINT</code> 的默认参数；</td></tr><tr><td>EXPOSE</td><td>告诉服务端容器暴露的端口号，</td><td>EXPOSE <port></td></tr><tr><td>ENV</td><td>指定环境变量</td><td>ENV PG_MAJOR 9.3ENV PATH &#x2F;usr&#x2F;local&#x2F;postgres-$PG_MAJOR&#x2F;bin:$PATH</td></tr><tr><td>ADD</td><td><code>ADD  </code>该命令将复制指定的 <code> </code>到容器中的 <code>。其中 </code> 可以是 <code>Dockerfile</code> 所在目录的一个相对路径，也可以是一个<code>URL</code>；还可以是一个 tar文件（自动解压为目录）</td><td></td></tr><tr><td>COPY</td><td>格式为 <code>COPY  </code>复制本地主机的 <code>（为 Dockerfile 所在目录的相对路径）到容器中的</code> 。当使用本地目录为源目录时，推荐使用 <code>COPY</code></td><td></td></tr><tr><td>ENTRYPOINT</td><td>配置容器启动执行的命令，并且不可被 <code>docker run</code> 提供的参数覆盖每个Docekrfile 中只能有一个 <code>ENTRYPOINT</code> ，当指定多个时，只有最后一个起效</td><td>两种格式<code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]``ENTRYPOINT command param1 param2</code>（shell中执行）</td></tr><tr><td>VOLUME</td><td>创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</td><td>VOLUME [“&#x2F;data”]</td></tr><tr><td>USER</td><td>指定运行容器时的用户名或 UID，后续的 <code>RUN</code> 也会使用指定用户</td><td>USER daemon</td></tr><tr><td>WORKDIR</td><td>为后续的 <code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code> 指令配置工作目录。可以使用多个 <code>WORKDIR</code> 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。</td><td>格式为 <code>WORKDIR /path/to/workdir</code>。 WORKDIR &#x2F;aWORKDIR bWORKDIR cRUN pwd最后的路径为 &#x2F;a&#x2F;b&#x2F;c</td></tr><tr><td>ONBUILD</td><td>配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。</td><td>格式为 <code>ONBUILD [INSTRUCTION]</code>。</td></tr></tbody></table><h3 id="6-3-创建镜像"><a href="#6-3-创建镜像" class="headerlink" title="6.3 创建镜像"></a>6.3 创建镜像</h3><p>编写完成 Dockerfile 之后，可以通过 <code>docker build</code> 命令来创建镜像</p><p><code>docker build [选项] 路径</code> 该命令江都区指定路径下（包括子目录）的Dockerfile，并将该路径下所有内容发送给 Docker 服务端，有服务端来创建镜像。可以通过 <code>.dockerignore</code> 文件来让 Docker 忽略路径下的目录与文件</p><pre><code># 使用 -t 指定镜像的标签信息docker build -t myrepo/myimage .</code></pre><h2 id="七、Docker-Compose"><a href="#七、Docker-Compose" class="headerlink" title="七、Docker Compose"></a>七、Docker Compose</h2><h3 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h3><p>Docker Compose 是 Docker 官方编排项目之一，负责快速在集群中部署分布式应用。维护地址：<a href="https://github.com/docker/compose%EF%BC%8C%E7%94%B1">https://github.com/docker/compose，由</a> Python 编写，实际调用 Docker提供的API实现。</p><p>Dockerfile 可以让用户管理一个单独的应用容器，而 Compose 则允许用户在一个模版（YAML格式）中定义一组相关联的应用容器（被称为一个project&#x2F;项目），例如一个 web容器再加上数据库、redis等。</p><h3 id="7-2-安装"><a href="#7-2-安装" class="headerlink" title="7.2 安装"></a>7.2 安装</h3><pre><code># 使用 pip 进行安装pip install -U docker-compose# 查看用法docker-ompose -h# 添加 bash 补全命令curl -L https://raw.githubusercontent.com/docker/compose/1.2.0/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</code></pre><h3 id="7-3-使用"><a href="#7-3-使用" class="headerlink" title="7.3 使用"></a>7.3 使用</h3><p>术语</p><ul><li>服务&#x2F;service： 一个应用容器，实际上可以运行多个相同镜像的实例</li><li>项目&#x2F;project： 有一组关联的应用容器组成的完成业务单元</li></ul><p>示例：创建一个 Haproxy 挂载三个 Web 容器</p><p>创建一个 <code>compose-haproxy-web</code> 目录，作为项目工作目录，并在其中分别创建两个子目录： <code>haproxy</code> 和 <code>web</code> 。</p><pre><code>compose-haproxy-webcompose-haproxy-webgit clone https://github.com/yelog/compose-haproxy-web.git</code></pre><p>目录长这样：</p><pre><code>compose-haproxy-web├── docker-compose.yml├── haproxy│   └── haproxy.cfg└── web    ├── Dockerfile    ├── index.html    └── index.py</code></pre><p>在该目录执行 <code>docker-compose up</code> 命令，会整合输出所有容器的输出</p><pre><code>$ docker-compose upStarting compose-haproxy-web_webb_1 ... doneStarting compose-haproxy-web_webc_1 ... doneStarting compose-haproxy-web_weba_1 ... doneRecreating compose-haproxy-web_haproxy_1 ... doneAttaching to compose-haproxy-web_webb_1, compose-haproxy-web_weba_1, compose-haproxy-web_webc_1, compose-haproxy-web_haproxy_1haproxy_1  | [NOTICE] 244/131022 (1) : haproxy version is 2.2.2haproxy_1  | [NOTICE] 244/131022 (1) : path to executable is /usr/local/sbin/haproxyhaproxy_1  | [ALERT] 244/131022 (1) : parsing [/usr/local/etc/haproxy/haproxy.cfg:14] : &#39;listen&#39; cannot handle unexpected argument &#39;:70&#39;.haproxy_1  | [ALERT] 244/131022 (1) : parsing [/usr/local/etc/haproxy/haproxy.cfg:14] : please use the &#39;bind&#39; keyword for listening addresses.haproxy_1  | [ALERT] 244/131022 (1) : Error(s) found in configuration file : /usr/local/etc/haproxy/haproxy.cfghaproxy_1  | [ALERT] 244/131022 (1) : Fatal errors found in configuration.compose-haproxy-web_haproxy_1 exited with code 1</code></pre><p>此时访问本地的 80 端口，会经过 haproxy 自动转发到后端的某个 web 容器上，刷新页面，可以观察到访问的容器地址的变化。</p><h3 id="7-4-命令说明"><a href="#7-4-命令说明" class="headerlink" title="7.4 命令说明"></a>7.4 命令说明</h3><p>大部分命令都可以运行在一个或多个服务上。如果没有特别的说明，命令则应用在项目所有的服务上。</p><p>执行 <code>docker-compose [COMMAND] --help</code> 查看具体某个命令的使用说明</p><p>使用格式</p><pre><code>docker-compose [options] [COMMAND] [ARGS...]</code></pre><table><thead><tr><th>build</th><th>构建&#x2F;重建服务服务一旦构建后，将会带上一个标记名，例如 web_db可以随时在项目目录运行 <code>docker-compose build</code> 来重新构建服务</th></tr></thead><tbody><tr><td>help</td><td>获得一个命令的信息</td></tr><tr><td>kill</td><td>通过发送 <code>SIGKILL</code> 信号来强制停止服务容器，支持通过参数来指定发送信号，例如<code>docker-compose kill -s SIGINT</code></td></tr><tr><td>logs</td><td>查看服务的输出</td></tr><tr><td>port</td><td>打印绑定的公共端口</td></tr><tr><td>ps</td><td>列出所有容器</td></tr><tr><td>pull</td><td>拉去服务镜像</td></tr><tr><td>rm</td><td>删除停止的服务容器</td></tr><tr><td>run</td><td>在一个服务上执行一个命令<code>docker-compose run ubuntu ping docker.com</code></td></tr><tr><td>scale</td><td>设置同一个服务运行的容器个数通过 <code>service=num</code> 的参数来设置数量<code>docker-compose scale web=2 worker=3</code></td></tr><tr><td>start</td><td>启动一个已经存在的服务容器</td></tr><tr><td>stop</td><td>停止一个已经运行的容器，但不删除。可以通过 <code>docker-compose start</code> 再次启动</td></tr><tr><td>up</td><td>构建、创建、启动、链接一个服务相关的容器链接服务都将被启动，除非他们已经运行<code>docker-compose up -d</code> 将后台运行并启动<code>docker-compose up</code> 已存在容器将会重新创建<code>docker-compose up --no-recreate</code> 将不会重新创建容器</td></tr></tbody></table><h3 id="7-5-环境变量"><a href="#7-5-环境变量" class="headerlink" title="7.5 环境变量"></a>7.5 环境变量</h3><p>环境变量可以用来配置 Compose 的行为</p><p>以 <code>Docker_</code> 开头的变量用来配置 Docker 命令行客户端使用的一样</p><table><thead><tr><th>COMPOSE_PROJECT_NAME</th><th>设置通过 Compose 启动的每一个容器前添加的项目名称，默认是当前工作目录的名字。</th></tr></thead><tbody><tr><td>COMPOSE_FILE</td><td>设置要使用的 <code>docker-compose.yml</code> 的路径。默认路径是当前工作目录。</td></tr><tr><td>DOCKER_HOST</td><td>设置 Docker daemon 的地址。默认使用 <code>unix:///var/run/docker.sock</code>，与 Docker 客户端采用的默认值一致。</td></tr><tr><td>DOCKER_TLS_VERIFY</td><td>如果设置不为空，则与 Docker daemon 交互通过 TLS 进行。</td></tr><tr><td>DOCKER_CERT_PATH</td><td>配置 TLS 通信所需要的验证（<code>ca.pem</code>、<code>cert.pem</code> 和 <code>key.pem</code>）文件的路径，默认是 <code>~/.docker</code> 。</td></tr></tbody></table><h3 id="7-6-docker-compose-yml"><a href="#7-6-docker-compose-yml" class="headerlink" title="7.6 docker-compose.yml"></a>7.6 docker-compose.yml</h3><p>默认模版文件是 <code>docker-compose.yml</code> ，启动定义了每个服务都必须经过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile) 来自动构建。</p><p>其他大部分指令跟 <code>docker run</code> 类似</p><p>如果使用 <code>build</code> 指令，在 Dockerfile 中设置的选项（如 <code>CMD</code> 、<code>EXPOSE</code> 等）将会被自动获取，无需在 <code>docker-compose.yml</code> 中再次设置。</p><pre><code>**image**</code></pre><p>指定镜像名称或镜像ID，如果本地仓库不存在，将尝试从远程仓库拉去此镜像</p><pre><code>image: ubuntuimage: orchardup/postgresqlimage: a4bc65fd**build**</code></pre><p>指定 <code>Dockerfile</code> 所在文件的路径。<code>Compose</code> 将利用它自动构建这个镜像，然后使用这个镜像。</p><pre><code>build: /path/to/build/dir**command**</code></pre><p>覆盖容器启动默认执行命令</p><pre><code>command: bundle exec thin -p 3000**links**</code></pre><p>链接到其他服务中的容器，使用服务名称或别名</p><pre><code>links:    - db  - db:database  - redis</code></pre><p>别名会自动在服务器中的 <code>/etc/hosts</code> 里创建。例如：</p><pre><code>172.17.2.186  db172.17.2.186  database172.17.2.187  redis**external_links**</code></pre><p>连接到 <code>docker-compose.yml</code> 外部的容器，甚至并非 <code>Compose</code> 管理的容器。</p><pre><code>external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql</code></pre><p><strong><code>ports</code></strong></p><p>暴露端口信息 <code>HOST:CONTAINER</code></p><p>格式或者仅仅指定容器的端口（宿主机会随机分配端口）</p><pre><code>ports: - &quot;3000&quot; - &quot;8000:8000&quot; - &quot;49100:22&quot; - &quot;127.0.0.1:8001:8001&quot;</code></pre><blockquote><p><em>注：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 你可能会得到错误得结果，因为 <code>YAML</code> 将会解析 <code>xx:yy</code> 这种数字格式为 60 进制。所以建议采用字符串格式。</em></p></blockquote><pre><code>**expose**</code></pre><p>暴露端口，但不映射到宿主机，只被连接的服务访问</p><pre><code>expose: - &quot;3000&quot; - &quot;8000&quot;</code></pre><p><strong><code>volumes</code></strong></p><p>卷挂载路径设置。可以设置宿主机路径 （<code>HOST:CONTAINER</code>） 或加上访问模式 （<code>HOST:CONTAINER:ro</code>）。</p><pre><code>volumes: - /var/lib/mysql - cache/:/tmp/cache - ~/configs:/etc/configs/:ro</code></pre><p>**<br>**</p><p><strong><code>volumes_from</code></strong></p><p>从另一个服务或容器挂载它的所有卷。</p><pre><code>volumes_from: - service_name - container_name</code></pre><pre><code>environment</code></pre><p>设置环境变量。你可以使用数组或字典两种格式。</p><p>只给定名称的变量会自动获取它在 Compose 主机上的值，可以用来防止泄露不必要的数据。</p><pre><code>environment:  RACK_ENV: development  SESSION_SECRET:environment:  - RACK_ENV=development  - SESSION_SECRET</code></pre><p><strong><code>env_file</code></strong></p><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p><p>如果通过 <code>docker-compose -f FILE</code> 指定了模板文件，则 <code>env_file</code> 中路径会基于模板文件路径。</p><p>如果有变量名称与 <code>environment</code> 指令冲突，则以后者为准。</p><pre><code>env_file: .envenv_file:  - ./common.env  - ./apps/web.env  - /opt/secrets.env</code></pre><p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p><pre><code># common.env: Set Rails/Rack environmentRACK_ENV=development</code></pre><p><strong><code>extends</code></strong></p><p>基于已有的服务进行扩展。例如我们已经有了一个 webapp 服务，模板文件为 <code>common.yml</code>。</p><pre><code># common.ymlwebapp:  build: ./webapp  environment:    - DEBUG=false    - SEND_EMAILS=false</code></pre><p>编写一个新的 <code>development.yml</code> 文件，使用 <code>common.yml</code> 中的 webapp 服务进行扩展。</p><pre><code># development.ymlweb:  extends:    file: common.yml    service: webapp  ports:    - &quot;8000:8000&quot;  links:    - db  environment:    - DEBUG=truedb:  image: postgres</code></pre><p>后者会自动继承 common.yml 中的 webapp 服务及相关环节变量。</p><p>**<br>**</p><p><strong><code>net</code></strong></p><p>设置网络模式。使用和 <code>docker client</code> 的 <code>--net</code> 参数一样的值。</p><pre><code>net: &quot;bridge&quot;net: &quot;none&quot;net: &quot;container:[name or id]&quot;net: &quot;host&quot;</code></pre><p>**<br>**</p><p><strong><code>pid</code></strong></p><p>跟主机系统共享进程命名空间。打开该选项的容器可以相互通过进程 ID 来访问和操作。</p><pre><code>pid: &quot;host&quot;</code></pre><p><strong><code>dns</code></strong></p><p>配置 DNS 服务器。可以是一个值，也可以是一个列表。</p><pre><code>dns: 8.8.8.8dns:  - 8.8.8.8  - 9.9.9.9</code></pre><p><strong><code>cap_add, cap_drop</code></strong></p><p>添加或放弃容器的 Linux 能力（Capabiliity）。</p><pre><code>cap_add:  - ALLcap_drop:  - NET_ADMIN  - SYS_ADMIN</code></pre><p>**<br>**</p><p><strong><code>dns_search</code></strong></p><p>配置 DNS 搜索域。可以是一个值，也可以是一个列表。</p><pre><code class="yaml">dns_search: example.comdns_search:  - domain1.example.com  - domain2.example.com</code></pre><p>**<br>**</p><p><strong><code>working_dir, entrypoint, user, hostname, domainname, mem_limit, privileged, restart, stdin_open, tty, cpu_shares</code></strong></p><p>这些都是和 <code>docker run</code> 支持的选项类似。</p><h2 id="八、安全"><a href="#八、安全" class="headerlink" title="八、安全"></a>八、安全</h2><h3 id="8-1-内核命名空间"><a href="#8-1-内核命名空间" class="headerlink" title="8.1 内核命名空间"></a>8.1 内核命名空间</h3><p>当使用 <code>docker run</code> 启动一个容器时，在后台 Docker 为容器创建一个独立的命名空间和控制集合。命名空间踢空了最基础的也是最直接的隔离，在容器中运行的进程不会被运行在主机上的进程和其他容器发现和作用。</p><h3 id="8-2-控制组"><a href="#8-2-控制组" class="headerlink" title="8.2 控制组"></a>8.2 控制组</h3><p>控制组是 Linux 容器机制的另一个关键组件，负责实现资源的审计和限制。</p><p>它提供了很多特性，确保哥哥容器可以公平地分享主机的内存、CPU、磁盘IO等资源；当然，更重要的是，控制组确保了当容器内的资源使用产生压力时不会连累主机系统。</p><h3 id="8-3-内核能力机制"><a href="#8-3-内核能力机制" class="headerlink" title="8.3 内核能力机制"></a>8.3 内核能力机制</h3><p>能力机制是 Linux 内核的一个强大特性，可以提供细粒度的权限访问控制。 可以作用在进程上，也可以作用在文件上。</p><p>例如一个服务需要绑定低于 1024 的端口权限，并不需要 root 权限，那么它只需要被授权 <code>net_bind_service</code> 能力即可。</p><p>默认情况下， Docker 启动的容器被严格限制只允许使用内核的一部分能力。</p><p>使用能力机制加强 Docker 容器的安全有很多好处，可以按需分配给容器权限，这样，即便攻击者在容器中取得了 root 权限，也不能获取宿主机较高权限，能进行的破坏也是有限的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.docker.com/engine/reference/commandline/images/">https://docs.docker.com/engine/reference/commandline/images/</a></p><p><a href="http://www.dockerinfo.net/">http://www.dockerinfo.net/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是docker&quot;&gt;&lt;a href=&quot;#1-1-什么是docker&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="运维" scheme="https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="docker" scheme="https://ysluckly.github.io/tags/docker/"/>
    
    <category term="linux" scheme="https://ysluckly.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>3-hexo评论设置</title>
    <link href="https://ysluckly.github.io/2020/05/23/3-hexo-comment/"/>
    <id>https://ysluckly.github.io/2020/05/23/3-hexo-comment/</id>
    <published>2020-05-23T14:26:23.000Z</published>
    <updated>2022-02-19T09:27:58.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前 <code>3-hexo</code> 已经集成了评论系统有 <code>gitalk</code> 、<code>gitment</code>、 <code>disqus</code> 、<code>来必力</code>、<code>utteranc</code></p><h2 id="一、gitalk"><a href="#一、gitalk" class="headerlink" title="一、gitalk"></a>一、gitalk</h2><p>gitalk 是一款基于 Github Issue 和 Preact 开发的评论插件 官网: <a href="https://gitalk.github.io/">https://gitalk.github.io/</a></p><h3 id="1-登录-github-，注册应用"><a href="#1-登录-github-，注册应用" class="headerlink" title="1. 登录 github ，注册应用"></a>1. 登录 github ，注册应用</h3><p><a href="https://github.com/settings/applications/new">点击进行注册</a> ，如下</p><p><img src="https://i.loli.net/2020/05/23/6BmnUbX5gzPHqk1.png" alt="注册应用"></p><p>注册完后，可得到 <code>Client ID</code> 和 <code>Client Secret</code></p><h3 id="2-新建存放评论的仓库"><a href="#2-新建存放评论的仓库" class="headerlink" title="2. 新建存放评论的仓库"></a>2. 新建存放评论的仓库</h3><p>因为 <code>gitalk</code> 是基于 Github 的 Issue 的，所以需要指定一个仓库，用来承接 gitalk 的评论，我们一般使用 Github Page 来做我们博客的评论，所以，新建仓库名为 <code>xxx.github.io</code>，其中 xxx 为你的 Github 用户名</p><h3 id="3-配置主题"><a href="#3-配置主题" class="headerlink" title="3. 配置主题"></a>3. 配置主题</h3><p>在主题下 <code>_config.yml</code> 中找到如下配置，启用评论，并使用 <code>gitalk</code></p><pre><code class="yaml">##########评论设置#############comment:  on: true  type: gitalk</code></pre><p>在主题下 <code>_config.yml</code> 中找到 gitalk 配置，将 第1步 得到的  <code>Client ID</code> 和 <code>Client Secret</code> 复制到如下位置</p><pre><code class="yaml">gitalk:  githubID:    # 填你的 github 用户名  repo:  xxx.github.io     # 承载评论的仓库，一般使用 Github Page 仓库  ClientID:   # 第1步获得 Client ID  ClientSecret:  # 第1步获得 Client Secret  adminUser:     # Github 用户名  distractionFreeMode: true  language: zh-CN  perPage: 10</code></pre><h2 id="二、来必力"><a href="#二、来必力" class="headerlink" title="二、来必力"></a>二、来必力</h2><h3 id="1-创建来必力账号，并选择-City-免费版"><a href="#1-创建来必力账号，并选择-City-免费版" class="headerlink" title="1. 创建来必力账号，并选择 City 免费版"></a>1. 创建来必力账号，并选择 City 免费版</h3><p>官网<a href="http://livere.com/">http://livere.com/</a> ，创建账号，点击上面的安装，选择 City 免费版</p><p><img src="https://i.loli.net/2020/05/23/mLYfjrJ1UgOIpiD.png" alt="选择 city 免费版"></p><p>复制获取到的代码中的 <code>data-uid</code></p><p><img src="http://yelog-img.test.upcdn.net/447D431A-998C-4327-9463-A51D7CE91CE3.png" alt="复制 data-uid"></p><h3 id="2-主题选择使用来必力评论"><a href="#2-主题选择使用来必力评论" class="headerlink" title="2. 主题选择使用来必力评论"></a>2. 主题选择使用来必力评论</h3><p>在主题下 <code>_config.yml</code>  </p><p>在找到来必力配置如下，第一步中复制的 <code>data-uid</code> 粘贴到下面 <code>data_uid</code> 处</p><pre><code class="yaml">livere:  data_uid: xxxxxx</code></pre><p>找到以下代码， 开启并选择 livere (来必力)</p><pre><code class="yaml">##########评论设置#############comment:  on: true  type: livere</code></pre><h2 id="三、utteranc"><a href="#三、utteranc" class="headerlink" title="三、utteranc"></a>三、utteranc</h2><p>官网地址：<a href="https://utteranc.es/">https://utteranc.es/</a></p><h3 id="1-安装-utterances"><a href="#1-安装-utterances" class="headerlink" title="1. 安装 utterances"></a>1. 安装 utterances</h3><p><a href="https://github.com/apps/utterances">点我进行安装</a></p><h3 id="2-配置主题"><a href="#2-配置主题" class="headerlink" title="2. 配置主题"></a>2. 配置主题</h3><p>在主题下 <code>_config.yml</code> 中找到 <code>utteranc</code> 的配置 ，修改 <code>repo</code> 为自己的仓库名</p><pre><code class="yaml">utteranc:  repo: xxx/xxx.github.io # 承载评论的仓库，填上自己的仓库  issue_term: pathname    # Issue 与 博客文章 之间映射关系  label: utteranc         # 创建的 Issue 添加的标签  theme: github-light     # 主题，可选主题请查看官方文档 https://utteranc.es/#heading-theme# 官方文档 https://utteranc.es/# 使用说明 https://yelog.org//2020/05/23/3-hexo-comment/</code></pre><p>在主题下 <code>_config.yml</code> 中找到如下配置，启用评论，并使用 <code>utteranc</code></p><pre><code class="yaml">comment:  on: true  type: utteranc</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;目前 &lt;code&gt;3-hexo&lt;/code&gt; 已经集成了评论系统有 &lt;code&gt;gitalk&lt;/code&gt; 、&lt;code&gt;gitment&lt;/</summary>
      
    
    
    
    <category term="工具" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="hexo" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
    <category term="3-hexo" scheme="https://ysluckly.github.io/tags/3-hexo/"/>
    
  </entry>
  
  <entry>
    <title>3-hexo支持mermaid图表</title>
    <link href="https://ysluckly.github.io/2019/11/12/3-hexo-support-mermaid/"/>
    <id>https://ysluckly.github.io/2019/11/12/3-hexo-support-mermaid/</id>
    <published>2019-11-12T01:55:37.000Z</published>
    <updated>2022-02-19T09:27:58.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h2><h3 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h3><ol><li>安装hexo插件<pre><code class="bash">npm install hexo-filter-mermaid-diagrams</code></pre></li><li>修改<code>themes/3-hexo/_config.yml</code> 的 <code>mermaid.on</code>，开启主题支持<pre><code class="yml"># Mermaid 支持mermaid:  on: true  cdn: //cdn.jsdelivr.net/npm/mermaid@8.4.2/dist/mermaid.min.js  #cdn: //cdnjs.cloudflare.com/ajax/libs/mermaid/8.3.1/mermaid.min.js  options: # 更多配置信息可以参考 https://mermaidjs.github.io/#/mermaidAPI theme: &#39;default&#39; startOnLoad: true flowchart:   useMaxWidth: false   htmlLabels: true</code></pre></li><li>在markdown中，像写代码块一样写图表<br><img src="//img.saodiyang.com/FuBTJvG5xIOIcKZPnO9UX5GCwthK.png"></li></ol><h2 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h2><p>以下示例源码可以在这边查看 <a href="https://github.com/yelog/blog/blob/master/source/_posts/tools/3-hexo%E6%94%AF%E6%8C%81mermaid%E5%9B%BE%E8%A1%A8.md">本文源码</a><br>更多示例可以查看官网：<a href="https://mermaidjs.github.io/">https://mermaidjs.github.io</a></p><h3 id="1-flowchart"><a href="#1-flowchart" class="headerlink" title="1. flowchart"></a>1. flowchart</h3><pre><code class="mermaid">graph TD;    A--&gt;B;    A--&gt;C;    B--&gt;D;    C--&gt;D;</code></pre><pre><code class="mermaid">graph TB    c1--&gt;a2    subgraph one    a1--&gt;a2    end    subgraph two    b1--&gt;b2    end    subgraph three    c1--&gt;c2    end</code></pre><h3 id="2-Sequence-diagrams"><a href="#2-Sequence-diagrams" class="headerlink" title="2.Sequence diagrams"></a>2.Sequence diagrams</h3><pre><code class="mermaid">sequenceDiagram    participant Alice    participant Bob    Alice-&gt;&gt;John: Hello John, how are you?    loop Healthcheck        John-&gt;&gt;John: Fight against hypochondria    end    Note right of John: Rational thoughts &lt;br/&gt;prevail!    John--&gt;&gt;Alice: Great!    John-&gt;&gt;Bob: How about you?    Bob--&gt;&gt;John: Jolly good!</code></pre><h3 id="3-Class-diagrams"><a href="#3-Class-diagrams" class="headerlink" title="3.Class diagrams"></a>3.Class diagrams</h3><pre><code class="mermaid">classDiagram     Animal &lt;|-- Duck     Animal &lt;|-- Fish     Animal &lt;|-- Zebra     Animal : +int age     Animal : +String gender     Animal: +isMammal()     Animal: +mate()     class Duck&#123;         +String beakColor         +swim()         +quack()     &#125;     class Fish&#123;         -int sizeInFeet         -canEat()     &#125;     class Zebra&#123;         +bool is_wild         +run()     &#125;</code></pre><h3 id="4-State-diagrams"><a href="#4-State-diagrams" class="headerlink" title="4.State diagrams"></a>4.State diagrams</h3><pre><code class="mermaid">stateDiagram       [*] --&gt; Active       state Active &#123;           [*] --&gt; NumLockOff           NumLockOff --&gt; NumLockOn : EvNumLockPressed           NumLockOn --&gt; NumLockOff : EvNumLockPressed           --           [*] --&gt; CapsLockOff           CapsLockOff --&gt; CapsLockOn : EvCapsLockPressed           CapsLockOn --&gt; CapsLockOff : EvCapsLockPressed           --           [*] --&gt; ScrollLockOff           ScrollLockOff --&gt; ScrollLockOn : EvCapsLockPressed           ScrollLockOn --&gt; ScrollLockOff : EvCapsLockPressed       &#125;</code></pre><h3 id="5-Gantt-diagrams"><a href="#5-Gantt-diagrams" class="headerlink" title="5.Gantt diagrams"></a>5.Gantt diagrams</h3><pre><code class="mermaid">gantt       dateFormat  YYYY-MM-DD       title Adding GANTT diagram functionality to mermaid       section A section       Completed task            :done,    des1, 2014-01-06,2014-01-08       Active task               :active,  des2, 2014-01-09, 3d       Future task               :         des3, after des2, 5d       Future task2              :         des4, after des3, 5d       section Critical tasks       Completed task in the critical line :crit, done, 2014-01-06,24h       Implement parser and jison          :crit, done, after des1, 2d       Create tests for parser             :crit, active, 3d       Future task in critical line        :crit, 5d       Create tests for renderer           :2d       Add to mermaid                      :1d       section Documentation       Describe gantt syntax               :active, a1, after des1, 3d       Add gantt diagram to demo page      :after a1  , 20h       Add another diagram to demo page    :doc1, after a1  , 48h       section Last section       Describe gantt syntax               :after doc1, 3d       Add gantt diagram to demo page      :20h       Add another diagram to demo page    :48h</code></pre><h3 id="6-Pie-chart-diagrams"><a href="#6-Pie-chart-diagrams" class="headerlink" title="6.Pie chart diagrams"></a>6.Pie chart diagrams</h3><pre><code class="mermaid">pie    &quot;Dogs&quot; : 386    &quot;Cats&quot; : 85    &quot;Rats&quot; : 15</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、说明&quot;&gt;&lt;a href=&quot;#一、说明&quot; class=&quot;headerlink&quot; title=&quot;一、说明&quot;&gt;&lt;/a&gt;一、说明&lt;/h2&gt;&lt;h3 id=&quot;开启&quot;&gt;&lt;a href=&quot;#开启&quot; class=&quot;headerlink&quot; title=&quot;开启&quot;&gt;&lt;/a&gt;开启&lt;/h</summary>
      
    
    
    
    <category term="工具" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="hexo" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
    <category term="hexo" scheme="https://ysluckly.github.io/tags/hexo/"/>
    
    <category term="3-hexo" scheme="https://ysluckly.github.io/tags/3-hexo/"/>
    
  </entry>
  
  <entry>
    <title>3-hexo 添加音乐插件</title>
    <link href="https://ysluckly.github.io/2019/10/08/3-hexo-add-music/"/>
    <id>https://ysluckly.github.io/2019/10/08/3-hexo-add-music/</id>
    <published>2019-10-08T02:44:30.000Z</published>
    <updated>2022-02-19T09:27:58.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h2><h3 id="1-复制网易云音乐插件代码"><a href="#1-复制网易云音乐插件代码" class="headerlink" title="1. 复制网易云音乐插件代码"></a>1. 复制网易云音乐插件代码</h3><p>前往<a href="https://music.163.com/">网易云音乐官网</a>，搜索一个作为背景音乐的歌曲，并进入播放页面，点击 <strong>生成外链播放器</strong><br><img src="https://i.loli.net/2019/10/08/RgSUj1i8vXNk5IP.png" alt="生成外链播放器"></p><p>设置好想要显示的样式后，复制 html 代码</p><p><img src="https://i.loli.net/2019/10/08/rbHRZEoB4mzip75.png"></p><p>最好外层在加一个 <code>div</code>，如下，可直接将上一步复制的 <code>iframe</code> 替换下方里面的 <code>iframe</code></p><pre><code class="html">&lt;div id=&quot;musicMouseDrag&quot; style=&quot;position:fixed; z-index: 9999; bottom: 0; right: 0;&quot;&gt;    &lt;div id=&quot;musicDragArea&quot; style=&quot;position: absolute; top: 0; left: 0; width: 100%;height: 10px;cursor: move; z-index: 10;&quot;&gt;&lt;/div&gt;    &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=38592976&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;</code></pre><h3 id="2-将插件引入到主题中"><a href="#2-将插件引入到主题中" class="headerlink" title="2. 将插件引入到主题中"></a>2. 将插件引入到主题中</h3><p>将上一步加过 <code>div</code> 的代码粘贴到主题下 <code>layout/_partial/footer.ejs</code> 的最后面<br><img src="https://i.loli.net/2019/10/08/FRJOKxLECcvinmf.png" alt="效果"></p><h3 id="3-调整位置"><a href="#3-调整位置" class="headerlink" title="3. 调整位置"></a>3. 调整位置</h3><p>默认给的样式是显示在右下角，可以通过调整上一步粘贴的 <code>div</code> 的 <code>style</code> 中 <code>bottom</code> 和 <code>right</code> 来调整位置。</p><h3 id="4-自由拖动"><a href="#4-自由拖动" class="headerlink" title="4. 自由拖动"></a>4. 自由拖动</h3><p>如果需要自由拖动，在刚才添加的代码后面，再添加下面代码即可，鼠标就可以在音乐控件的 <strong>上边沿</strong> 点击拖动</p><pre><code class="html">&lt;!--以下代码是为了支持随时拖动音乐控件的位置，如没有需求，可去掉下面代码--&gt;&lt;script&gt;    var $DOC = $(document)    $(&#39;#musicMouseDrag&#39;).on(&#39;mousedown&#39;, function (e) &#123;      // 阻止文本选中      $DOC.bind(&quot;selectstart&quot;, function () &#123;        return false;      &#125;);      $(&#39;#musicDragArea&#39;).css(&#39;height&#39;, &#39;100%&#39;);      var $moveTarget = $(&#39;#musicMouseDrag&#39;);      $moveTarget.css(&#39;border&#39;, &#39;1px dashed grey&#39;)      var div_x = e.pageX - $moveTarget.offset().left;      var div_y = e.pageY - $moveTarget.offset().top;      $DOC.on(&#39;mousemove&#39;, function (e) &#123;        var targetX = e.pageX - div_x;        var targetY = e.pageY - div_y;        targetX = targetX &lt; 0 ? 0 : (targetX + $moveTarget.outerWidth() &gt;= window.innerWidth) ? window.innerWidth - $moveTarget.outerWidth() : targetX;        targetY = targetY &lt; 0 ? 0 : (targetY + $moveTarget.outerHeight() &gt;= window.innerHeight) ? window.innerHeight - $moveTarget.outerHeight() : targetY;        $moveTarget.css(&#123;&#39;left&#39;: targetX + &#39;px&#39;, &#39;top&#39;: targetY + &#39;px&#39;, &#39;bottom&#39;: &#39;inherit&#39;, &#39;right&#39;: &#39;inherit&#39;&#125;)      &#125;).on(&#39;mouseup&#39;, function () &#123;        $DOC.unbind(&quot;selectstart&quot;);        $DOC.off(&#39;mousemove&#39;)        $DOC.off(&#39;mouseup&#39;)        $moveTarget.css(&#39;border&#39;, &#39;none&#39;)        $(&#39;#musicDragArea&#39;).css(&#39;height&#39;, &#39;10px&#39;);      &#125;)    &#125;)&lt;/script&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;网易云音乐&quot;&gt;&lt;a href=&quot;#网易云音乐&quot; class=&quot;headerlink&quot; title=&quot;网易云音乐&quot;&gt;&lt;/a&gt;网易云音乐&lt;/h2&gt;&lt;h3 id=&quot;1-复制网易云音乐插件代码&quot;&gt;&lt;a href=&quot;#1-复制网易云音乐插件代码&quot; class=&quot;header</summary>
      
    
    
    
    <category term="工具" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="hexo" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
    <category term="hexo" scheme="https://ysluckly.github.io/tags/hexo/"/>
    
    <category term="3-hexo" scheme="https://ysluckly.github.io/tags/3-hexo/"/>
    
  </entry>
  
  <entry>
    <title>3-hexo支持jsfiddle渲染</title>
    <link href="https://ysluckly.github.io/2019/09/24/3-hexo-jsfiddle/"/>
    <id>https://ysluckly.github.io/2019/09/24/3-hexo-jsfiddle/</id>
    <published>2019-09-24T01:59:37.000Z</published>
    <updated>2022-02-19T09:27:58.540Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-canvas-粒子效果"><a href="#1-canvas-粒子效果" class="headerlink" title="1. canvas 粒子效果"></a>1. canvas 粒子效果</h3><script async src="//jsfiddle.net/yelog/eqc7zdLo/embed/result,js,html,css/"></script><h3 id="2-复选框动画"><a href="#2-复选框动画" class="headerlink" title="2. 复选框动画"></a>2. 复选框动画</h3><script async src="//jsfiddle.net/yelog/5g9jf31t/1/embed/result,html,css/"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-canvas-粒子效果&quot;&gt;&lt;a href=&quot;#1-canvas-粒子效果&quot; class=&quot;headerlink&quot; title=&quot;1. canvas 粒子效果&quot;&gt;&lt;/a&gt;1. canvas 粒子效果&lt;/h3&gt;&lt;script async src=&quot;//jsfidd</summary>
      
    
    
    
    <category term="工具" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="hexo" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
    <category term="hexo" scheme="https://ysluckly.github.io/tags/hexo/"/>
    
    <category term="3-hexo" scheme="https://ysluckly.github.io/tags/3-hexo/"/>
    
  </entry>
  
  <entry>
    <title>3-hexo文章内toc生成</title>
    <link href="https://ysluckly.github.io/2019/09/24/3-hexo-toc/"/>
    <id>https://ysluckly.github.io/2019/09/24/3-hexo-toc/</id>
    <published>2019-09-24T01:48:20.000Z</published>
    <updated>2022-02-19T09:27:58.545Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="1-如何使用"><a href="#1-如何使用" class="headerlink" title="1. 如何使用"></a>1. 如何使用</h2><h3 id="1-1-关键字"><a href="#1-1-关键字" class="headerlink" title="1.1 关键字"></a>1.1 关键字</h3><p>只要在在文章中使用如下关键字，不区分大小写，便可以在相应位置显示目录导航，效果文章开头<br><img src="https://i.loli.net/2020/05/23/Zq9jCWfwxNBpcOm.png" alt="toc"></p><h3 id="1-2-小标题2jlksjdflksdjflksjdflksjdflkaj-sdfjka-lskdjfla-skjdf-lajsdflkjal-sdjkf-laskjdf"><a href="#1-2-小标题2jlksjdflksdjflksjdflksjdflkaj-sdfjka-lskdjfla-skjdf-lajsdflkjal-sdjkf-laskjdf" class="headerlink" title="1.2 小标题2jlksjdflksdjflksjdflksjdflkaj;sdfjka;lskdjfla;skjdf;lajsdflkjal;sdjkf;laskjdf"></a>1.2 小标题2jlksjdflksdjflksjdflksjdflkaj;sdfjka;lskdjfla;skjdf;lajsdflkjal;sdjkf;laskjdf</h3><p>占位<br>占位</p><h4 id="1-3-小标题"><a href="#1-3-小标题" class="headerlink" title="1.3 小标题"></a>1.3 小标题</h4><p>占位<br>占位<br>占位</p><h2 id="2-标题二"><a href="#2-标题二" class="headerlink" title="2. 标题二"></a>2. 标题二</h2><p>占位<br><br>占位<br><br>占位<br></p><h3 id="2-1-小标题"><a href="#2-1-小标题" class="headerlink" title="2.1 小标题"></a>2.1 小标题</h3><p>占位<br><br>占位<br></p><h3 id="2-2-小标题2"><a href="#2-2-小标题2" class="headerlink" title="2.2 小标题2"></a>2.2 小标题2</h3><p>占位<br><br>占位<br><br>占位<br><br>占位<br><br>占位<br></p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><p>占位<br><br>占位<br><br>占位<br><br>占位<br><br>占位<br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;1-如何使用&quot;&gt;&lt;a href=&quot;#1-如何使用&quot; class=&quot;headerlink&quot; title=&quot;1. 如何使用&quot;&gt;&lt;/a&gt;1. 如何使用&lt;/h2&gt;&lt;h3 id=&quot;1-1-关键字&quot;&gt;&lt;a href=&quot;#1-1-关键字&quot; class=</summary>
      
    
    
    
    <category term="工具" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="hexo" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
    <category term="hexo" scheme="https://ysluckly.github.io/tags/hexo/"/>
    
    <category term="3-hexo" scheme="https://ysluckly.github.io/tags/3-hexo/"/>
    
  </entry>
  
  <entry>
    <title>[记]《知识分子的不幸》-王小波</title>
    <link href="https://ysluckly.github.io/2019/06/09/misfortune-intellectual/"/>
    <id>https://ysluckly.github.io/2019/06/09/misfortune-intellectual/</id>
    <published>2019-06-09T13:31:09.000Z</published>
    <updated>2022-02-19T09:27:58.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章发表于1996年第二期《东方》杂志，同样收录于《沉默的大多数》一书中。</p><h2 id="所想"><a href="#所想" class="headerlink" title="所想"></a>所想</h2><p>文章一开头就抛出了一个问题：什么是知识分子最害怕的事？想起了高晓松在晓说中提到过这个问题，晓松肯定是看过这篇文章的。</p><p>王小波说：“<strong>知识分子最怕活在不理智的年代。”所谓不理智的年代，就是伽利略低头认罪，承认地球不转的年代，也是拉瓦斯上断头台的年代；是茨威格服毒自杀的年代，也是老舍跳太平湖的年代。</strong>“</p><p>王小波和他的美国老师谈论了一个问题：”有信仰比无信仰要好。“，由于王小波是经历过文革的，所以王小波一开始是抵触这种思想的，尤其是 <strong>课间祷告 <strong>让王小波想起了文革中的 <strong>早请示</strong>。但老师最终说服了他，“</strong>不管是信神，还是自珍自重，人活在世界上总得有点信念才成。就我个人而言，虽是无神论者，我也有个人操守，从不逾越。</strong>”</p><p>国内的学者，只搞学术研究，不搞意识形态，这由不了自己。有朝一日它成了意识形态，你的话就是罪状。言论不自由，不理智，民族狂热，这不就是知识分子最怕的事情吗？</p><p>王小波崇拜墨子：其一，他思维缜密，其二，他敢赤裸裸地谈利害。（有了他，我也敢说自己是中华民族的赤诚分子，不怕国学家说我是全盘西化了。）</p><p>营造意识形态则是灭绝思想额丰饶。中国的人文知识分子，有种以天下为己任的使命感，总觉得自己该搞出些老百姓当信仰的东西。</p><p>国学，这种东西实在厉害。最可怕之处就在于那个“国”字。顶着这个字，谁敢有不同意见？抢到了这个制高点，就可以压制一切不同意见；所以很容易落入思想流氓的手中变成一种凶器。</p><p>目前正值 “<strong>中美贸易战</strong>”，各种自媒体为了点击量、关注度。煽动民族狂热情绪，导致民众根本容不得半点不同意见，不讲道理，“盲目爱国“。</p><p>认真思索，真诚的明辨是非，有这种态度大概就可算是善良了吧。</p><p>人活在世上，自会形成信念，一种学问、一本书，假如不对我的价值观发生变化，就不值得一学，不值得一看。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这篇文章发表于1996年第二期《东方》杂志，同样收录于《沉默的大多数》一书中。&lt;/p&gt;
&lt;h2 id=&quot;所想&quot;&gt;&lt;a href=&quot;#所想&quot; </summary>
      
    
    
    
    <category term="读书" scheme="https://ysluckly.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="阅读笔记" scheme="https://ysluckly.github.io/categories/%E8%AF%BB%E4%B9%A6/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="reading" scheme="https://ysluckly.github.io/tags/reading/"/>
    
  </entry>
  
  <entry>
    <title>人们在一本叫《活着》的书中纷纷死去</title>
    <link href="https://ysluckly.github.io/2019/05/02/to-live/"/>
    <id>https://ysluckly.github.io/2019/05/02/to-live/</id>
    <published>2019-05-02T09:46:16.000Z</published>
    <updated>2022-02-19T09:27:58.532Z</updated>
    
    <content type="html"><![CDATA[<p>有那么一个年代，离我们很近，它腥风血雨，连活着都是一件奢侈的事。</p><p>在富贵的一生中，每次出现看似被上天眷顾的福气后（如有庆长跑第一、凤霞嫁了人并怀了孩子），读者还在替富贵开心的时候，他们却以各种方式迅速死去，最终富贵亲手埋葬了他所有的亲人。</p><p>一本 12w 左右的小说，但是在没有华丽词藻的情况下，在顺畅流利的写作手法、跌宕起伏的剧情、第一人称的代入感下一口气读完了。期间多次痛哭流涕（一点儿没夸张），不得不放下书本，洗过脸后才能继续阅读。所以已经多年没写书评的我，还是忍不住为她写下书评。</p><blockquote><p>人是为了活着本身而活着，而不是为了活着之外的任何事物所活着。</p></blockquote><p>这是作者在中文序言中的一句话，在当今生活着的我，初读序言中的这句话，并无任何共鸣，甚至还行吐槽两句。随着富贵将他的”一生”娓娓道来，你就会明白在那样的时代背景下，活着已经是一件不容易的事。 所以作者在日文版序言中说到：</p><blockquote><p>在旁人眼中富贵的一生是苦熬的一生；可是对于富贵自己，我相信他更多地感受到了幸福。</p></blockquote><p>因为他相信自己的妻子是世上最好的妻子，他相信自己的子女也是世上最好的子女，还有他的女婿他的外孙，还有他的那头也叫富贵的牛，还有一起上火锅的朋友们，还有生活的点点滴滴……</p><p>富贵的真是一路跌下去的一生，从”富家少爷”赌光了家产、气死了爹爹。由于母亲生病，为母亲求医路上被国民党抓壮丁，被俘虏后，放回家中。却发现母亲已死，女儿也由于生病变成了聋哑人。本想着大难之后必有后福，却只是悲惨一生的开端。儿子有庆由于和县长夫人血型匹配，遭抽血而亡、女儿凤霞产子大出血而亡、妻子家珍失去儿女后，失去了最后与病魔争斗的信念，也走了、女婿二喜在工地被水泥板拍死、外孙苦根难得吃到豆子，却被豆子撑死。最后只剩下自己和一个也叫作富贵的老牛。</p><p>春生想自杀前，找到富贵告别，在被家珍原谅，并答应不会自杀，在这种情况下坚持了一个月，最终还是自杀了。那种时代背景下的无奈，那种窒息感。。。</p><p>富贵的一生跨越了地主、解放战争、人民公社运动、大炼钢铁、自然灾害和文化大革命，从一个人的视角看到每个时代下的一个小小的缩影，但却比任何其他的描述更让人深刻了解到这些时代背景下人们的生活状态。</p><p>在那时，活着不仅是幸运，也更需要勇气。</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1556806574463&di=868e65579acfc800020db78de3c07ac4&imgtype=0&src=http://s1.sinaimg.cn/large/001Pe7mxzy76VARpXvdc3"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有那么一个年代，离我们很近，它腥风血雨，连活着都是一件奢侈的事。&lt;/p&gt;
&lt;p&gt;在富贵的一生中，每次出现看似被上天眷顾的福气后（如有庆长跑第一、凤霞嫁了人并怀了孩子），读者还在替富贵开心的时候，他们却以各种方式迅速死去，最终富贵亲手埋葬了他所有的亲人。&lt;/p&gt;
&lt;p&gt;一本 </summary>
      
    
    
    
    <category term="读书" scheme="https://ysluckly.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="阅读笔记" scheme="https://ysluckly.github.io/categories/%E8%AF%BB%E4%B9%A6/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="reading" scheme="https://ysluckly.github.io/tags/reading/"/>
    
    <category term="活着" scheme="https://ysluckly.github.io/tags/%E6%B4%BB%E7%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>shell速查表</title>
    <link href="https://ysluckly.github.io/2018/09/08/shell-command/"/>
    <id>https://ysluckly.github.io/2018/09/08/shell-command/</id>
    <published>2018-09-08T03:48:24.000Z</published>
    <updated>2022-02-19T09:27:58.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><pre><code class="bash">#!/bin/bashmsg=&quot;hello world&quot;echo $msg</code></pre><blockquote><p><strong>变量名的命名须遵循如下规则：</strong></p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul></blockquote><h2 id="2-传参"><a href="#2-传参" class="headerlink" title="2. 传参"></a>2. 传参</h2><pre><code class="bash">#!/bin/bashecho &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;;</code></pre><blockquote><p><strong>脚本内获取参数的格式为：</strong><br>$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……<br><strong>另外，还有几个特殊字符用来处理参数：</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>$#</code></td><td>传递到脚本的参数个数</td></tr><tr><td><code>$*</code></td><td>以一个单字符串显示所有向脚本传递的参数。<br>如<code>&quot;$*&quot;</code>用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</td></tr><tr><td><code>$$</code></td><td>脚本运行的当前进程ID号</td></tr><tr><td><code>$!</code></td><td>后台运行的最后一个进程的ID号</td></tr><tr><td><code>$@</code></td><td>与<code>$*</code>相同，但是使用时加引号，并在引号中返回每个参数。<br>如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</td></tr><tr><td><code>$-</code></td><td>显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td><code>$?</code></td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table></blockquote><h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3. 数组"></a>3. 数组</h2><p>&#96;&#96;&#96;bash<br>#!&#x2F;bin&#x2F;bash<br>my_array&#x3D;(A B “C” D)<br>echo “第一个元素为: ${my_array[0]}”<br>echo “第二个元素为: ${my_array[1]}”<br>echo “第三个元素为: ${my_array[2]}”<br>echo “第四个元素为: ${my_array[3]}”</p><p>echo “数组的元素为: ${my_array[*]}”<br>echo “数组的元素为: ${my_array[@]}”</p><p>echo “数组元素个数为: $</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-变量&quot;&gt;&lt;a href=&quot;#1-变量&quot; class=&quot;headerlink&quot; title=&quot;1. 变量&quot;&gt;&lt;/a&gt;1. 变量&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;#!/bin/bash
msg=&amp;quot;hello world&amp;quot;</summary>
      
    
    
    
    <category term="运维" scheme="https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="linux" scheme="https://ysluckly.github.io/tags/linux/"/>
    
    <category term="shell" scheme="https://ysluckly.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>nginx配置记录</title>
    <link href="https://ysluckly.github.io/2018/02/08/nginx-config/"/>
    <id>https://ysluckly.github.io/2018/02/08/nginx-config/</id>
    <published>2018-02-08T01:19:09.000Z</published>
    <updated>2022-02-19T09:27:58.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="启用https"><a href="#启用https" class="headerlink" title="启用https"></a>启用https</h2><h3 id="1-购买免费证书"><a href="#1-购买免费证书" class="headerlink" title="1.购买免费证书"></a>1.购买免费证书</h3><p>登录阿里云 -&gt; 控制台 -&gt; 安全（云盾） -&gt; CA证书服务 -&gt; 购买证书<br><img src="http://img.saodiyang.com/Fr8xZ-Z1ylYPcoN1PCTk_5SDm6TM.png" alt="购买免费证书"></p><h3 id="2-补全证书信息"><a href="#2-补全证书信息" class="headerlink" title="2.补全证书信息"></a>2.补全证书信息</h3><p>点击补全，绑定域名</p><h3 id="3-下载并配置"><a href="#3-下载并配置" class="headerlink" title="3.下载并配置"></a>3.下载并配置</h3><p>选择下载 证书for nginx<br><img src="http://img.saodiyang.com/FnMUOU4IZY2ZbMZcqggp4v7JHtej.png" alt="下载证书"></p><p>上面这个页面有相关的配置信息，下面简单介绍：</p><p>① 将下载文件中的 <code>*.pem</code>、<code>*.key</code>, 拷贝到 nginx 目录下 的 <code>cert</code> , 当然也可以是其他目录<br>② 修改 <code>nginx.conf</code></p><pre><code class="conf">server &#123;      listen       443 ssl;      server_name  xiangzhangshugongyi.com;      ssl_certificate      cert/214487958220243.pem;      ssl_certificate_key  cert/214487958220243.key;      ssl_session_cache    shared:SSL:1m;      ssl_session_timeout  5m;      ssl_ciphers  HIGH:!aNULL:!MD5;      ssl_prefer_server_ciphers  on;      location / &#123;          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;          proxy_set_header Host $http_host;          proxy_set_header X-Forwarded-Proto https;          proxy_redirect off;          proxy_connect_timeout      240;          proxy_send_timeout         240;          proxy_read_timeout         240;          # note, there is not SSL here! plain HTTP is used          proxy_pass http://127.0.0.1:8080;      &#125;  &#125;</code></pre><p>③ 重启 nginx，通过 证书绑定域名进行 https 访问到 服务器跑在 8080 的服务<br><img src="http://img.saodiyang.com/FtTXB9QIYoZOlPFKsGg-ImxbL58N.png" alt="通过https访问"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;启用https&quot;&gt;&lt;a href=&quot;#启用https&quot; class=&quot;headerlink&quot; title=&quot;启用https&quot;&gt;&lt;/a&gt;启用https&lt;/h2&gt;&lt;h3 id=&quot;1-购买免费证书&quot;&gt;&lt;a href=&quot;#1-购买免费证书&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="运维" scheme="https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="nginx" scheme="https://ysluckly.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Mac神器-BTT(BetterTouchTool)不完全教程</title>
    <link href="https://ysluckly.github.io/2017/12/13/Mac-BetterTouchTool/"/>
    <id>https://ysluckly.github.io/2017/12/13/Mac-BetterTouchTool/</id>
    <published>2017-12-13T09:04:25.000Z</published>
    <updated>2022-02-19T09:27:58.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="http://img.saodiyang.com/Fm6s-GR0yVJgdndJwftdj9eXL7LB.png" alt="BetterTouchTool"><br>BetterTouchTool 是一款专为Mac用户开发的 窗口管理&#x2F;<code>Trackpad</code>(触控板)&#x2F;<code>Magic Mouse</code>(苹果鼠标)&#x2F;<code>Keyboard</code>(键盘)&#x2F;<code>TouchBar</code> 功能增强制作的软件。</p><p>这款软件不但可以设置全局的 手势&#x2F;快捷键&#x2F;TouchBar ，还可以给不同的应用定义不同的姿势，再配合上 Alfred 的 workflow，简直各种高难度姿势都能玩的出来。</p><p>本文主要介绍以下功能：</p><ol><li>窗口管理</li><li>帮 Trackpad 定义各种姿势</li><li>帮 Magic Mouse 定义各种姿势</li><li>帮 Keyboard 定义各种姿势</li><li>帮任何应用自定义 TouchBar</li></ol><p><em>本文以 macbook pro 2017 touchbar 版为例</em></p><h2 id="1-窗口管理"><a href="#1-窗口管理" class="headerlink" title="1. 窗口管理"></a>1. 窗口管理</h2><p>这个功能无需过多配置，默认配置即可很好使用（和windows的理念相似）</p><ul><li>将窗口移到左右边缘，最大化至半屏</li><li>将窗口移到上边缘，最大化至全屏</li></ul><p><img src="http://img.saodiyang.com/lhfTY9ysdWOzOOKprnh0X6MTfoT8.gif" alt="窗口管理"><br>如果对默认配置不满意，也可以在如下图所示的位置来调整窗口展示：<br><img src="http://img.saodiyang.com/FkluTBqX_n2UXj2ICsOE1tW1yFan.png" alt="窗口管理配置"></p><h2 id="2-帮-Trackpad-定义各种姿势"><a href="#2-帮-Trackpad-定义各种姿势" class="headerlink" title="2. 帮 Trackpad 定义各种姿势"></a>2. 帮 Trackpad 定义各种姿势</h2><h3 id="姿势选择"><a href="#姿势选择" class="headerlink" title="姿势选择"></a>姿势选择</h3><p>在界面选择 Trackpad（触摸板） -&gt; Add New Gesture（添加一个新姿势）</p><p>左边可以选择生效的范围：全局或者某个应用</p><p><img src="http://img.saodiyang.com/FsPEIn9TlNOwHkWHgyD32snaT7bY.jpg" alt="选择触摸板姿势"><br>如上图所示，姿势包括但不限于如：</p><ol><li>单指：左下角单击、单指轻拍右上角、单指轻拍上边中点</li><li>双指：两个手指捏、张开两指以两指中心为圆轴逆时针、中指拍住中央食指轻拍面板、双指从上边缘下滑</li><li>三指：三指轻拍、三指拍顶端、三指点击并向上滑、两指轻拍住，拍左、右二指固定拍住，左一下滑</li><li>四指：四指双轻拍、中指无名小拍住，食单击、食中指无名拍住，小单击</li><li>五指：五手指轻拍、五手指上滑</li></ol><p>上面只是列一些典型，更多姿势可以在上图中浏览。</p><h3 id="绑定功能"><a href="#绑定功能" class="headerlink" title="绑定功能"></a>绑定功能</h3><p><img src="http://img.saodiyang.com/FjNWJgoefc34vGaUhruvWQr2R--5.png" alt="定义姿势功能"></p><p>选择过姿势之后，也可以选择在按住某个功能键的时候才能使用（左下角）。</p><p>右边是绑定功能：快捷键或动作。</p><ul><li><p>绑定快捷键举例：<br>比如 给chrome 设置 姿势（两指从触控板下边缘滑入），弹出开发者模式（快捷键绑定：command+option+i），如下图：<br><img src="http://img.saodiyang.com/Fnuaa2qtpdf28autM22l3RPRtCau.jpg" alt="给chrome设置姿势，弹出开发者模式"></p></li><li><p>绑定动作举例：<br>设置 在任何应用内，五指下滑 锁屏，如下图<br><img src="http://img.saodiyang.com/FuTHBQJRvDVem9c14G608eXKtR7R.png" alt="五指下滑锁屏"></p></li></ul><h2 id="3-帮-Magic-Mouse-定义各种姿势"><a href="#3-帮-Magic-Mouse-定义各种姿势" class="headerlink" title="3. 帮 Magic Mouse 定义各种姿势"></a>3. 帮 Magic Mouse 定义各种姿势</h2><p>这个功能设置和 Trackpad 设置 大同小异，所以这边就不多讲，直接图示几个功能。<br><img src="http://img.saodiyang.com/FgwGsolKj59jVnOkgI5vb4zdxNwm.png" alt="两指上滑呼出Mission Control"></p><p>我快捷键设置了 option+E 鼠标取词翻译（欧陆词典），然后绑定到双指轻拍鼠标，即可触发翻译。<br><img src="http://img.saodiyang.com/FsuJ3xU8k5ANQkuXdgpy0Xxkhdme.png" alt="双指轻拍-取词翻译"></p><h2 id="4-帮-Keyboard-定义各种姿势"><a href="#4-帮-Keyboard-定义各种姿势" class="headerlink" title="4. 帮 Keyboard 定义各种姿势"></a>4. 帮 Keyboard 定义各种姿势</h2><p>这个功能比较简单，设置一些 键盘快捷键或录制案件序列 来触发 一些动作或者其他快捷键功能。</p><h2 id="5-帮任何应用自定义-TouchBar"><a href="#5-帮任何应用自定义-TouchBar" class="headerlink" title="5. 帮任何应用自定义 TouchBar"></a>5. 帮任何应用自定义 TouchBar</h2><p>这个重磅功能，可以帮助不支持touchbar的软件定制 TouchBar，是不是有点厉害。</p><p>下面就以我给 IntelliJ IDEA 定制 TouchBar 为例 (没有F1 ~ F12 功能键，debug真的很痛苦，这个软件真的是雪中送炭)，展示一下使用效果</p><p><img src="http://img.saodiyang.com/Fl0oSr-rNLr3f23_E_ZTlMEo46l1.png" alt="定制 TouchBar"></p><p>如上图所示，我给 IntelliJ IDEA 添加了 四个功能 step over&#x2F;step into&#x2F;resume&#x2F;evaluate</p><p>添加完之后，切到 IntelliJ IDEA 软件中时，TouchBar 就显示我们添加的四个功能键， 如下图所示<br><img src="http://img.saodiyang.com/Fi4MOmPsZDPj0Z2UEUxOqCbeIV1o.png" alt="IntelliJ IDEA 定制 TouchBar"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>BTT还有其他很方便的功能，这盘就介绍到这里，等之后更新了 Alfred 的 workflow 开发指南之后，再一起更新一篇有意思的 BTT+Alfred 效率流。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://img.saodiyang.com/Fm6s-GR0yVJgdndJwftdj9eXL7LB.png&quot; a</summary>
      
    
    
    
    <category term="工具" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="软件记录" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="mac" scheme="https://ysluckly.github.io/tags/mac/"/>
    
    <category term="efficiency" scheme="https://ysluckly.github.io/tags/efficiency/"/>
    
  </entry>
  
  <entry>
    <title>[转]谈谈Java中的语法糖</title>
    <link href="https://ysluckly.github.io/2017/11/27/java-grammatical-sugar/"/>
    <id>https://ysluckly.github.io/2017/11/27/java-grammatical-sugar/</id>
    <published>2017-11-27T14:51:45.000Z</published>
    <updated>2022-02-19T09:27:58.486Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言本身功能来说没有什么影响，只是为了方便程序员的开发，提高开发效率。说白了，语法糖就是对现有语法的一个封装。</p></blockquote><p>Java作为一种与平台无关的高级语言，当然也含有语法糖，这些语法糖并不被虚拟机所支持，在编译成字节码阶段就自动转换成简单常用语法。一般来说Java中的语法糖主要有以下几种：</p><ol><li>泛型与类型擦除</li><li>自动装箱与拆箱，变长参数、</li><li>增强for循环</li><li>内部类与枚举类</li></ol><h2 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h2><p>Java语言并不是一开始就支持泛型的。在早期的JDK中，只能通过Object类是所有类型的父类和强制类型转换来实现泛型的功能。强制类型转换的缺点就是把编译期间的问题延迟到运行时，JVM并不能为我们提供编译期间的检查。</p><p>在JDK1.5中，Java语言引入了泛型机制。但是这种泛型机制是通过类型擦除来实现的，即Java中的泛型只在程序源代码中有效（源代码阶段提供类型检查），在编译后的字节码中自动用强制类型转换进行替代。也就是说，Java语言中的泛型机制其实就是一颗语法糖，相较与C++、C#相比，其泛型实现实在是不那么优雅。</p><pre><code class="java">/*** 在源代码中存在泛型*/public static void main(String[] args) &#123;    Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();    map.put(&quot;hello&quot;,&quot;你好&quot;);    String hello = map.get(&quot;hello&quot;);    System.out.println(hello);&#125;</code></pre><p>当上述源代码被编译为class文件后，泛型被擦除且引入强制类型转换</p><pre><code class="java">public static void main(String[] args) &#123;    HashMap map = new HashMap(); //类型擦除    map.put(&quot;hello&quot;, &quot;你好&quot;);    String hello = (String)map.get(&quot;hello&quot;);//强制转换    System.out.println(hello);&#125;</code></pre><h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h2><blockquote><p>Java中的自动装箱与拆箱指的是基本数据类型与他们的包装类型之间的相互转换。</p></blockquote><p>我们知道Java是一门面向对象的语言，在Java世界中有一句话是这么说的：“万物皆对象”。但是Java中的基本数据类型却不是对象，他们不需要进行new操作，也不能调用任何方法，这在使用的时候有诸多不便。因此Java为这些基本类型提供了包装类，并且为了使用方便，提供了自动装箱与拆箱功能。自动装箱与拆箱在使用的过程中，其实是一个语法糖，内部还是调用了相应的函数进行转换。</p><p>下面代码演示了自动装箱和拆箱功能</p><pre><code class="java">public static void main(String[] args) &#123;    Integer a = 1;    int b = 2;    int c = a + b;    System.out.println(c);&#125;</code></pre><p>经过编译后，代码如下</p><pre><code class="java">public static void main(String[] args) &#123;    Integer a = Integer.valueOf(1); // 自动装箱    byte b = 2;    int c = a.intValue() + b;//自动拆箱    System.out.println(c);&#125;</code></pre><h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2><blockquote><p>所谓变长参数，就是方法可以接受长度不定确定的参数</p></blockquote><p>变长参数特性是在JDK1.5中引入的，使用变长参数有两个条件，一是变长的那一部分参数具有相同的类型，二是变长参数必须位于方法参数列表的最后面。变长参数同样是Java中的语法糖，其内部实现是Java数组。</p><pre><code class="java">public class Varargs &#123;    public static void print(String... args) &#123;        for(String str : args)&#123;            System.out.println(str);        &#125;    &#125;    public static void main(String[] args) &#123;        print(&quot;hello&quot;, &quot;world&quot;);    &#125;&#125;</code></pre><p>编译为class文件后如下，从中可以很明显的看出变长参数内部是通过数组实现的</p><pre><code class="java">public class Varargs &#123;    public Varargs() &#123;    &#125;    public static void print(String... args) &#123;        String[] var1 = args;        int var2 = args.length;        //增强for循环的数组实现方式        for(int var3 = 0; var3 &lt; var2; ++var3) &#123;            String str = var1[var3];            System.out.println(str);        &#125;    &#125;    public static void main(String[] args) &#123;        //变长参数转换为数组        print(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;);    &#125;&#125;</code></pre><h2 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h2><blockquote><p>增强for循环与普通for循环相比，功能更强并且代码更简洁</p></blockquote><p>增强for循环的对象要么是一个数组，要么实现了Iterable接口。这个语法糖主要用来对数组或者集合进行遍历，其在循环过程中不能改变集合的大小。</p><pre><code class="java">public static void main(String[] args) &#123;    String[] params = new String[]&#123;&quot;hello&quot;,&quot;world&quot;&#125;;    //增强for循环对象为数组    for(String str : params)&#123;        System.out.println(str);    &#125;    List&lt;String&gt; lists = Arrays.asList(&quot;hello&quot;,&quot;world&quot;);    //增强for循环对象实现Iterable接口    for(String str : lists)&#123;        System.out.println(str);    &#125;&#125;</code></pre><p>编译后的class文件为</p><pre><code class="java">public static void main(String[] args) &#123;   String[] params = new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;;   String[] lists = params;   int var3 = params.length;   //数组形式的增强for退化为普通for   for(int str = 0; str &lt; var3; ++str) &#123;       String str1 = lists[str];       System.out.println(str1);   &#125;   List var6 = Arrays.asList(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;);   Iterator var7 = var6.iterator();   //实现Iterable接口的增强for使用iterator接口进行遍历   while(var7.hasNext()) &#123;       String var8 = (String)var7.next();       System.out.println(var8);   &#125;&#125;</code></pre><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><blockquote><p>内部类就是定义在一个类内部的类</p></blockquote><p>Java语言中之所以引入内部类，是因为有些时候一个类只在另一个类中有用，我们不想让其在另外一个地方被使用。内部类之所以是语法糖，是因为其只是一个编译时的概念，一旦编译完成，编译器就会为内部类生成一个单独的class文件，名为outer$innter.class。</p><pre><code class="java">public class Outer &#123;    class Inner&#123;    &#125;&#125;</code></pre><p>使用javac编译后，生成两个class文件Outer.class和Outer$Inner.class，其中Outer$Inner.class的内容如下：</p><pre><code class="java">class Outer$Inner &#123;    Outer$Inner(Outer var1) &#123;        this.this$0 = var1;    &#125;&#125;</code></pre><p>内部类分为四种：成员内部类、局部内部类、匿名内部类、静态内部类，每一种都有其用法，这里就不介绍了</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><blockquote><p>枚举类型就是一些具有相同特性的类常量</p></blockquote><p>java中类的定义使用class，枚举类的定义使用enum。在Java的字节码结构中，其实并没有枚举类型，枚举类型只是一个语法糖，在编译完成后被编译成一个普通的类。这个类继承java.lang.Enum，并被final关键字修饰。</p><pre><code class="java">public enum Fruit &#123;    APPLE,ORINGE&#125;</code></pre><p>使用jad对编译后的class文件进行反编译后得到</p><pre><code class="java">//继承java.lang.Enum并声明为finalpublic final class Fruit extends Enum&#123;    public static Fruit[] values()    &#123;        return (Fruit[])$VALUES.clone();    &#125;    public static Fruit valueOf(String s)    &#123;        return (Fruit)Enum.valueOf(Fruit, s);    &#125;    private Fruit(String s, int i)    &#123;        super(s, i);    &#125;    //枚举类型常量    public static final Fruit APPLE;    public static final Fruit ORANGE;    private static final Fruit $VALUES[];//使用数组进行维护    static    &#123;        APPLE = new Fruit(&quot;APPLE&quot;, 0);        ORANGE = new Fruit(&quot;ORANGE&quot;, 1);        $VALUES = (new Fruit[] &#123;            APPLE, ORANGE        &#125;);    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言本身功能来说没有什么影响，只是为了方便程序员的开发，提高开发效率。说白了，语法糖就是对现有语法的一个封装。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="java" scheme="https://ysluckly.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL事务及隔离级别</title>
    <link href="https://ysluckly.github.io/2017/11/09/PostgreSQL%E4%BA%8B%E7%89%A9%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>https://ysluckly.github.io/2017/11/09/PostgreSQL%E4%BA%8B%E7%89%A9%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2017-11-08T16:07:33.000Z</published>
    <updated>2022-02-19T09:27:58.489Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>PostgreSQL中提供了多种数据完整性的保证机制。如：约束、触发器、事务和锁管理等。</p><p>事务主要是为了保证一组相关数据库的操作能全部执行成功，从而保证数据的完整性。锁机制主要是控制多个用户对同一数据进行操作，使用锁机制可以解决并发问题。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是用户对一个数据库操作的一个序列，这些操作要么全做，要么全不做，是一个不可分割的单位。</p><p>事务管理的常用语句如下：</p><pre><code class="sql">BEGIN;SQL语句1;SQL语句2;...COMMIT;</code></pre><p>事务块是指包围在BEGIN和COMMIT之间的语句。在PostgreSQL9中，常用的事务块管理语句含义如下：</p><blockquote><p><strong>START TRANSACTION</strong>：此命令表示开始一个新的事务块.<br><strong>BEGIN</strong>：初始化一个事务块。在BEGIN命令后的语句都将在一个事务里面执行，知道遇见COMMIT或ROLLBACK。它和START TRANSACTION是一样的。<br><strong>COMMIT</strong>：提交事务。<br><strong>ROLLBACK</strong>：事务失败时执行回滚操作。<br><strong>SET TRANSACTION</strong>：设置当前事务的特性。对后面的事务没有影响。</p></blockquote><h3 id="事务隔离及并发控制"><a href="#事务隔离及并发控制" class="headerlink" title="事务隔离及并发控制"></a>事务隔离及并发控制</h3><p>PostgreSQL是一个支持多用户的数据库，当多个用户操作同一数据库时，并发控制要保证所有用户可以高效的访问的同时不破坏数据的完整性。</p><p>数据库中数据的并发操作经常发生，而对数据的并发操作会带来下面的一些问题：</p><ol><li>脏读<br>一个事务读取了另一个未提交事务写入的数据。</li><li>不可重复读<br>一个事务重新读取前面读取过的数据，发现该数据已经被另一个已经提交的事务修改。</li><li>幻读<br>一个事务重新执行一个查询，返回符合查询条件的行的集合，发现满足查询条件的行的集合因为其它最近提交的事务而发生了改变。</li></ol><p>SQL标准定义了四个级别的事务隔离。</p><p>| 隔离级别 | 脏读 | 幻读 | 不可重复性读取 |<br>| :- | :- |<br>|读未提交    |可能    |可能    |可能|<br>|读已提交    |不可能|    可能    |可能|<br>|可重复读    |不可能    |可能    |不可能|<br>|可串行读    |不可能    |不可能    |不可能|</p><p>在PostgreSQL中，可以请求4种隔离级别中的任意一种。但是在内部，实际上只有两种独立的隔离级别，分别对应已提交和可串行化。如果选择了读未提交的级别，实际上使用的是读已提交，在选择可重复读级别的时候，实际上用的是可串行化，所以实际的隔离级别可能比选择的更严格。这是SQL标准允许的：4种隔离级别只定义了哪种现象不能发生，但是没有定义哪种现象一定发生。</p><p>PostgreSQL只提供两种隔离级别的原因是，这是把标准的隔离级别与多版本并发控制架构映射相关的唯一合理方法。</p><ol><li>读已提交<br>这是PostgreSQL中默认的隔离级别，当一个事务运行在这个隔离级别时，一个SELECT查询只能看到查询开始前已提交的数据，而无法看到未提交的数据或者在查询期间其他的事务已提交的数据。</li><li>可串行化<br>可串行化提供最严格的事务隔离。这个级别模拟串行的事务执行，就好像事务是一个接着一个串行的执行。不过，这个级别的应用必须准备在串行化失败的时候重新启动事务。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;PostgreSQL中提供了多种数据完整性的保证机制。如：约束、触发器、事务和锁管理等。&lt;/p&gt;
&lt;p&gt;事务主要是为了保证一组相关数据库的操</summary>
      
    
    
    
    <category term="数据库" scheme="https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="PostgreSQL" scheme="https://ysluckly.github.io/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>linux下修改按键ESC&lt;=&gt;CAPSLOCK和Control=&gt;ALT_R</title>
    <link href="https://ysluckly.github.io/2017/10/20/linux%E4%B8%8B%E4%BF%AE%E6%94%B9%E6%8C%89%E9%94%AEESC%3C=%3ECAPSLOCK%E5%92%8CControl=%3EALT_R/"/>
    <id>https://ysluckly.github.io/2017/10/20/linux%E4%B8%8B%E4%BF%AE%E6%94%B9%E6%8C%89%E9%94%AEESC%3C=%3ECAPSLOCK%E5%92%8CControl=%3EALT_R/</id>
    <published>2017-10-20T09:38:49.000Z</published>
    <updated>2022-02-19T09:27:58.519Z</updated>
    
    <content type="html"><![CDATA[<p>使用 <code>vim</code> 过程中发现 <code>esc</code> 和 <code>ctrl</code> 按键很难按，小拇指没有那么长啊～～，而 <code>caps_lock</code> 和 <code>alt_r</code>(右alt) 很少用。</p><p>本教程将 <code>esc</code> 和 <code>caps_lock</code> 两个按键交换， <code>alt_r</code>(右alt) 改为 <code>ctrl</code>。</p><h2 id="一、-esc-与-caps-lock-按键交换"><a href="#一、-esc-与-caps-lock-按键交换" class="headerlink" title="一、 esc 与 caps_lock 按键交换"></a>一、 esc 与 caps_lock 按键交换</h2><p>①. 创建 <code>.xmodmaprc</code> 文件。<br>②. 加入以下内容：</p><pre><code class="bash">remove Lock = Caps_Lockadd Lock = Escapekeysym Caps_Lock = Escapekeysym Escape = Caps_Lock</code></pre><p>③. 执行 <code>xmodmap .xmodmaprc</code> 使之生效。</p><h2 id="二、-将-右alt-改为-ctrl"><a href="#二、-将-右alt-改为-ctrl" class="headerlink" title="二、 将 右alt 改为 ctrl"></a>二、 将 右alt 改为 ctrl</h2><p>①. 查看需要修改键位的 keysym<br>通过 <code>xev | grep keycode</code> 获取右 <code>alt</code> 的 keysym 为 <code>Alt_R</code>。如下图所示：<br><img src="http://img.saodiyang.com/FvuqjLi5czeBluMTyIfv_xUOcu5k.png" alt="通过xev获取右alt的keysym"></p><p>②. 查看 <code>Alt_R</code> 是哪个 modifier 使用的<br>通过 <code>xmodmap -pm</code> 查看，发现 <code>Alt_R</code> 是作为 modifier <code>mod1</code> 使用的。如下图所示：<br><img src="http://img.saodiyang.com/Fib8QjT-Ccx30DCf2rF4WkzHsbOH.png" alt="查看 Alt_R 是作为 mode1 使用的"></p><p>③. 修改 modifier</p><pre><code class="bash">xmodmap -e &#39;remove mod1 = Alt_R&#39; # 解除原来绑定xmodmap -e &#39;add control = Alt_R&#39; # 作为 control 使用</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 &lt;code&gt;vim&lt;/code&gt; 过程中发现 &lt;code&gt;esc&lt;/code&gt; 和 &lt;code&gt;ctrl&lt;/code&gt; 按键很难按，小拇指没有那么长啊～～，而 &lt;code&gt;caps_lock&lt;/code&gt; 和 &lt;code&gt;alt_r&lt;/code&gt;(右alt) 很少用。</summary>
      
    
    
    
    <category term="运维" scheme="https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="vim" scheme="https://ysluckly.github.io/tags/vim/"/>
    
    <category term="keybord" scheme="https://ysluckly.github.io/tags/keybord/"/>
    
    <category term="emacs" scheme="https://ysluckly.github.io/tags/emacs/"/>
    
    <category term="linux" scheme="https://ysluckly.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>[转]字符编解码的故事（ASCII，ANSI，Unicode，Utf-8区别）</title>
    <link href="https://ysluckly.github.io/2017/09/25/ascii-ansi-unicode-utf-8/"/>
    <id>https://ysluckly.github.io/2017/09/25/ascii-ansi-unicode-utf-8/</id>
    <published>2017-09-25T11:15:00.000Z</published>
    <updated>2022-02-19T09:27:58.527Z</updated>
    
    <content type="html"><![CDATA[<p>很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们认为8个开关状态作为原子单位很好，于是他们把这称为”字节”。</p><p>再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出更多的状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机”。</p><p>开始计算机只在美国用。八位的字节一共可以组合出256（2的8次方）种不同的状态。</p><p>他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端设备或者打印机遇上这些约定好的字节时，就要做一些约定的动作。遇上 00x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，对于终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20（十进制32）以下的字节状态称为”控制码”。</p><p>他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的 文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。</p><p>后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们用到的许多字母在ASCII中根本没有，为了也可以在计算机中保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称”扩展字符集”。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！</p><p>等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉，并且规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</p><p>中国人民看到这样很不错，于是就把这种汉字方案叫做”GB2312”。GB2312 是对 ASCII 的中文扩展。</p><p>但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人（如朱镕基的“镕”字）。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。</p><p>后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。</p><p>后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。</p><p>中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS”（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍：</p><p>“一个汉字算两个英文字符！一个汉字算两个英文字符……”</p><p>因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？</p><p>真是计算机的巴比伦塔命题啊！</p><p>正在这时，大天使加百列及时出现了——一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “UNICODE”。</p><p>UNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ascii里的那些”半角”字符，UNICODE 包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高 8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。</p><p>这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是 的，从 UNICODE 开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”一个字符”！同时，也都是统一的”两个字节”，请注意”字符”和”字节”两个术语的不同， “字节”是一个8位的物理存贮单元，而”字符”则是一个文化相关的符号。在UNICODE 中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。</p><p>从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE 对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS 趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE 方式工作的版本，从这时开始，WINDOWS 系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。</p><p>但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得 GBK 与UNICODE 在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。</p><p>如前所述，UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），这大概可以用到银河联邦成立那一天吧！</p><p>UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF16就是每次16个位，只不过为了传输时的可靠性，从UNICODE到 UTF时并不是直接的对应，而是要过一些算法和规则来转换。</p><p>受到过网络编程加持的计算机僧侣们都知道，在网络里传递信息时有一个很重要的问题，就是对于数据高低位的解读方式，一些计算机是采用低位先发送的方法，例如我们PC机采用的 INTEL 架构；而另一些是采用高位先发送的方式。在网络中交换数据时，为了核对双方对于高低位的认识是否是一致的，采用了一种很简便的方法，就是在文本流的开始时向对方发送一个标志符——如果之后的文本是高位在位，那就发送”FEFF”，反之，则发送”FFFE”。不信你可以用二进制方式打开一个UTF-X格式的文件，看看开头两个字节是不是这两个字节？</p><p>下面是Unicode和UTF-8转换的规则</p><pre><code class="xml">UnicodeUTF-80000 - 007F0xxxxxxx0080 - 07FF110xxxxx 10xxxxxx0800 - FFFF1110xxxx 10xxxxxx 10xxxxxx</code></pre><p>例如”汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以要用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 1100 0100 1001，将这个比特流按三字节模板的分段方法分为0110 110001 001001，依次代替模板中的x，得到：1110-0110 10-110001 10-001001，即E6 B1 89，这就是其UTF8的编码。</p><p>讲到这里，我们再顺便说说一个很著名的奇怪现象：当你在 windows 的记事本里新建一个文件，输入”联通”两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码！呵呵，有人说这就是联通之所以拼不过移动的原因。</p><p>其实这是因为GB2312编码与UTF8编码产生了编码冲撞的原因。</p><p>当一个软件打开一个文本时，它要做的第一件事是决定这个文本究竟是使用哪种字符集的哪种编码保存的。软件一般采用三种方式来决定文本的字符集和编码：</p><p>检测文件头标识，提示用户选择，根据一定的规则猜测</p><p>最标准的途径是检测文本最开头的几个字节，开头字节 Charset&#x2F;encoding,如下表：</p><pre><code class="xml">EF BB BF UTF-8FF FE UTF-16/UCS-2, little endianFE FF UTF-16/UCS-2, big endianFF FE 00 00 UTF-32/UCS-4, little endian.00 00 FE FF UTF-32/UCS-4, big-endian.</code></pre><p>当你新建一个文本文件时，记事本的编码默认是ANSI（代表系统默认编码，在中文系统中一般是GB系列编码）, 如果你在ANSI的编码输入汉字，那么他实际就是GB系列的编码方式，在这种编码下，”联通”的内码是：</p><pre><code class="xml">c1 1100 0001aa 1010 1010cd 1100 1101a8 1010 1000</code></pre><p>注意到了吗？第一二个字节、第三四个字节的起始部分的都是”110”和”10”，正好与UTF8规则里的两字节模板是一致的，</p><p>于是当我们再次打开记事本时，记事本就误认为这是一个UTF8编码的文件，让我们把第一个字节的110和第二个字节的10去掉，我们就得到了”00001 101010”，再把各位对齐，补上前导的0，就得到了”0000 0000 0110 1010”，不好意思，这是UNICODE的006A，也就是小写的字母”j”，而之后的两字节用UTF8解码之后是0368，这个字符什么也不是。这就是只有”联通”两个字的文件没有办法在记事本里正常显示的原因。</p><p>而如果你在”联通”之后多输入几个字，其他的字的编码不见得又恰好是110和10开始的字节，这样再次打开时，记事本就不会坚持这是一个utf8编码的文件，而会用ANSI的方式解读之，这时乱码又不出现了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们认为8个开关状态作为原子单位很好，于是他们把这称为”字节”。&lt;/p&gt;
&lt;p&gt;再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出更多的状态，状态开始变来</summary>
      
    
    
    
    <category term="运维" scheme="https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="encoding" scheme="https://ysluckly.github.io/tags/encoding/"/>
    
  </entry>
  
  <entry>
    <title>搭建dubbo+zookeeper平台</title>
    <link href="https://ysluckly.github.io/2017/09/25/%E6%90%AD%E5%BB%BAdubbo+zookeeper%E5%B9%B3%E5%8F%B0/"/>
    <id>https://ysluckly.github.io/2017/09/25/%E6%90%AD%E5%BB%BAdubbo+zookeeper%E5%B9%B3%E5%8F%B0/</id>
    <published>2017-09-25T08:29:07.000Z</published>
    <updated>2022-02-19T09:27:58.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将介绍在SpringMVC+Spring+Mybatis项目中添加 <code>dubbo</code> 作为 <code>rpc</code> 服务。</p><p>文末有项目代码地址。</p><h2 id="一-搭建zookeeper"><a href="#一-搭建zookeeper" class="headerlink" title="一.搭建zookeeper"></a>一.搭建zookeeper</h2><p>使用 docker 一句话创建：</p><pre><code class="bash">docker run -dit --name zookeeper --hostname zookeeper-host -v /data:/data -p 2181:2181 jplock/zookeeper:latest</code></pre><h2 id="二-安装zkui（非必须）"><a href="#二-安装zkui（非必须）" class="headerlink" title="二.安装zkui（非必须）"></a>二.安装zkui（非必须）</h2><p>这个项目为 zookeeper 提供一个 web 的管理界面。当然我们也可以直接在zookeeper中使用命令查看，所以此步骤可以忽略</p><p>在开始前需要安装 Java 环境、Maven 环境。</p><ol><li>到 <a href="https://github.com/DeemOpen/zkui">zkui</a> 的项目中下载代码。<pre><code class="bash">git clone https://github.com/DeemOpen/zkui.git</code></pre></li><li>执行 <code>mvn clean install</code> 生成jar文件。</li><li>将config.cfg复制到上一步生成的jar文件所在目录，然后修改配置文件中的zookeeper地址。</li><li>执行 <code>nohup java -jar zkui-2.0-SNAPSHOT-jar-with-dependencies.jar &amp;</code></li><li>测试 <code>http://localhost:9090</code>，如果能看到如下页面，表示安装成功。</li></ol><p><img src="http://img.saodiyang.com/Fherw3peRgh-grmGz6qkNri5J1aG.png" alt="登录页面"><br><img src="http://img.saodiyang.com/FvEVMOzSZBP4N4-Q14noQT_VsKF6.png" alt="首页"></p><h2 id="三-使用dubbo"><a href="#三-使用dubbo" class="headerlink" title="三.使用dubbo"></a>三.使用dubbo</h2><ol><li><p>在原来 SpringMVC+Spring+Mybatis 项目中，除了原来 spring 相关依赖外，还需要加入以下依赖</p><pre><code class="xml">&lt;dependency&gt;     &lt;groupId&gt;com.alibaba&lt;/groupId&gt;     &lt;artifactId&gt;dubbo&lt;/artifactId&gt;     &lt;version&gt;2.5.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;     &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;     &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;     &lt;version&gt;3.4.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;     &lt;groupId&gt;com.101tec&lt;/groupId&gt;     &lt;artifactId&gt;zkclient&lt;/artifactId&gt;     &lt;version&gt;0.2&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>定义服务接口</p><pre><code class="java">public interface IPersonService &#123; List&lt;Person&gt; listAll(); Person getById(Integer id); Integer delById(Person person); Integer updatePerson(Person person);&#125;</code></pre></li><li><p>定义服务实现类<br>&#96;&#96;&#96;java<br>@Service<br>public class PersonService implements IPersonService {</p><p> @Autowired<br> PersonMapper personMapper;</p><p> public List<Person> listAll() {<br> return personMapper.findAll();<br> }</p><p> public Person getById(Integer id) {<br> return personMapper.findOneById(id);<br> }</p><p> public Integer delById(Person person) {<br> return personMapper.del(person);<br> }</p><p> public Integer updatePerson(Person person) {<br> return personMapper.update(person);<br> }</p></li></ol><p>}</p><pre><code>4. 配置生产者，注册服务信息```xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;       xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd    http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;    &lt;!--定义了提供方应用信息，用于计算依赖关系；--&gt;    &lt;dubbo:application name=&quot;demotest-provider&quot; /&gt;    &lt;!-- 使用 zookeeper 注册中心暴露服务地址 --&gt;    &lt;dubbo:registry address=&quot;zookeeper://192.168.0.86:2181&quot;/&gt;    &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt;    &lt;!-- 和本地bean一样实现服务 --&gt;    &lt;bean id=&quot;personService&quot; class=&quot;com.ssm.service.PersonService&quot;/&gt;    &lt;!-- 声明需要暴露的服务接口 --&gt;    &lt;dubbo:service interface=&quot;com.ssm.iservice.IPersonService&quot; ref=&quot;personService&quot;/&gt;&lt;/beans&gt;</code></pre><ol start="5"><li><p>配置消费者，订阅服务<br>&#96;&#96;&#96;xml</p><?xml version="1.0" encoding="UTF-8"?><p><beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"xmlns="http://www.springframework.org/schema/beans"xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"></p> <!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --><p> &lt;dubbo:application name&#x3D;”demo-consumer”&#x2F;&gt;</p> <!-- 使用 zookeeper 注册中心暴露发现服务地址 --><p> &lt;dubbo:registry address&#x3D;”zookeeper:&#x2F;&#x2F;192.168.0.86:2181”&#x2F;&gt;</p> <!-- 生成远程服务代理，可以和本地bean一样使用demoService --><p> &lt;dubbo:reference id&#x3D;”personService” check&#x3D;”false” interface&#x3D;”com.ssm.iservice.IPersonService”&#x2F;&gt;</p></li></ol></beans>```6. 调用远程服务配置完成后，我们就可以像使用本地 bean 一样，使用 rpc 的 service；```java@Controllerpublic class IndexController {<pre><code>@AutowiredIPersonService personService;@RequestMapping(&quot;/index.html&quot;)public String index(Model model) &#123;    RpcContext.getContext().setAttachment(&quot;index&quot;, &quot;1&quot;);//测试ThreadLocal    List&lt;Person&gt; list = personService.listAll();    model.addAttribute(&quot;command&quot;,list);    return &quot;index&quot;;&#125;</code></pre><p>}</p><pre><code>## 最后至此，单机运行的 rpc 服务已搭建完成。代码传送文 [ssm](https://github.com/yelog/ssm)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文将介绍在SpringMVC+Spring+Mybatis项目中添加 &lt;code&gt;dubbo&lt;/code&gt; 作为 &lt;code&gt;rpc&lt;/c</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="dubbo" scheme="https://ysluckly.github.io/tags/dubbo/"/>
    
    <category term="zookeeper" scheme="https://ysluckly.github.io/tags/zookeeper/"/>
    
  </entry>
  
</feed>
