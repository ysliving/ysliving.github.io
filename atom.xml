<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>码农印象</title>
  
  
  <link href="https://ysluckly.github.io/atom.xml" rel="self"/>
  
  <link href="https://ysluckly.github.io/"/>
  <updated>2022-02-25T15:57:28.031Z</updated>
  <id>https://ysluckly.github.io/</id>
  
  <author>
    <name>码农印象</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL数据库面试题</title>
    <link href="https://ysluckly.github.io/2022/03/03/mysql/"/>
    <id>https://ysluckly.github.io/2022/03/03/mysql/</id>
    <published>2022-03-03T07:29:32.000Z</published>
    <updated>2022-02-25T15:57:28.031Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><ul><li><a href="about:blank#_37">数据库基础知识</a><ul><li><ul><li><a href="about:blank#_39">为什么要使用数据库</a><ul><li>  <a href="about:blank#SQL_63">什么是SQL？</a></li><li>  <a href="about:blank#MySQL_71">什么是MySQL?</a></li><li>  <a href="about:blank#_77">数据库三大范式是什么</a></li><li>  <a href="about:blank#mysql_89">mysql有关权限的表都有哪几个</a></li><li>  <a href="about:blank#MySQLbinlog_101">MySQL的binlog有有几种录入格式？分别有什么区别？</a></li></ul></li></ul></li><li>  <a href="about:blank#_115">数据类型</a></li><li><ul><li>  <a href="about:blank#mysql_117">mysql有哪些数据类型</a></li></ul></li><li>  <a href="about:blank#_184">引擎</a></li><li><ul><li><a href="about:blank#MySQLMyISAMInnoDB_186">MySQL存储引擎MyISAM与InnoDB区别</a><ul><li>  <a href="about:blank#MyISAMInnoDB_217">MyISAM索引与InnoDB索引的区别？</a></li><li>  <a href="about:blank#InnoDB4_226">InnoDB引擎的4大特性</a></li><li>  <a href="about:blank#_238">存储引擎选择</a></li></ul></li></ul></li><li>  <a href="about:blank#_250">索引</a></li><li><ul><li><a href="about:blank#_252">什么是索引？</a><ul><li>  <a href="about:blank#_262">索引有哪些优缺点？</a></li><li>  <a href="about:blank#_276">索引使用场景（重点）</a></li><li>  <a href="about:blank#_321">索引有哪几种类型？</a></li><li>  <a href="about:blank#bhash_345">索引的数据结构（b树，hash）</a></li><li>  <a href="about:blank#_383">索引的基本原理</a></li><li>  <a href="about:blank#_399">索引算法有哪些？</a></li><li>  <a href="about:blank#_420">索引设计的原则？</a></li><li>  <a href="about:blank#_429">创建索引的原则（重中之重）</a></li><li>  <a href="about:blank#_451">创建索引的三种方式，删除索引</a></li><li>  <a href="about:blank#_517">创建索引时需要注意什么？</a></li><li>  <a href="about:blank#_525">使用索引查询一定能提高查询的性能吗？为什么</a></li><li>  <a href="about:blank#_535">百万级别或以上的数据如何删除</a></li><li>  <a href="about:blank#_546">前缀索引</a></li><li>  <a href="about:blank#_558">什么是最左前缀原则？什么是最左匹配原则</a></li><li>  <a href="about:blank#BB_566">B树和B+树的区别</a></li><li>  <a href="about:blank#B_576">使用B树的好处</a></li><li>  <a href="about:blank#B_582">使用B+树的好处</a></li><li>  <a href="about:blank#HashB_588">Hash索引和B+树所有有什么区别或者说优劣呢?</a></li><li>  <a href="about:blank#BB_609">数据库为什么使用B+树而不是B树</a></li><li>  <a href="about:blank#B_619">B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，</a></li><li>  <a href="about:blank#_627">什么是聚簇索引？何时使用聚簇索引与非聚簇索引</a></li><li>  <a href="about:blank#_640">非聚簇索引一定会回表查询吗？</a></li><li>  <a href="about:blank#_648">联合索引是什么？为什么需要注意联合索引中的顺序？</a></li></ul></li></ul></li><li>  <a href="about:blank#_662">事务</a></li><li><ul><li><a href="about:blank#_664">什么是数据库事务？</a><ul><li>  <a href="about:blank#ACID_674">事物的四大特性(ACID)介绍一下?</a></li><li>  <a href="about:blank#_687">什么是脏读？幻读？不可重复读？</a></li><li>  <a href="about:blank#MySQL_695">什么是事务的隔离级别？MySQL的默认隔离级别是什么？</a></li></ul></li></ul></li><li>  <a href="about:blank#_725">锁</a></li><li><ul><li><a href="about:blank#MySQL_727">对MySQL的锁了解吗</a><ul><li>  <a href="about:blank#_735">隔离级别与锁的关系</a></li><li>  <a href="about:blank#InnoDB_747">按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</a></li><li>  <a href="about:blank#MySQL_772">从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了</a></li><li>  <a href="about:blank#MySQLInnoDB_788">MySQL中InnoDB引擎的行锁是怎么实现的？</a></li><li>  <a href="about:blank#InnoDB_798">InnoDB存储引擎的锁的算法有三种</a></li><li>  <a href="about:blank#_814">什么是死锁？怎么解决？</a></li><li>  <a href="about:blank#_830">数据库的乐观锁和悲观锁是什么？怎么实现的？</a></li></ul></li></ul></li><li>  <a href="about:blank#_848">视图</a></li><li><ul><li><a href="about:blank#_850">为什么要使用视图？什么是视图？</a><ul><li>  <a href="about:blank#_858">视图有哪些特点？</a></li><li>  <a href="about:blank#_881">视图的使用场景有哪些？</a></li><li>  <a href="about:blank#_899">视图的优点</a></li><li>  <a href="about:blank#_907">视图的缺点</a></li><li>  <a href="about:blank#_917">什么是游标？</a></li></ul></li></ul></li><li>  <a href="about:blank#_925">存储过程与函数</a></li><li><ul><li>  <a href="about:blank#_927">什么是存储过程？有哪些优缺点？</a></li></ul></li><li>  <a href="about:blank#_955">触发器</a></li><li><ul><li><a href="about:blank#_957">什么是触发器？触发器的使用场景有哪些？</a><ul><li>  <a href="about:blank#MySQL_971">MySQL中都有哪些触发器？</a></li></ul></li></ul></li><li>  <a href="about:blank#SQL_986">常用SQL语句</a></li><li><ul><li><a href="about:blank#SQL_988">SQL语句主要分为哪几类</a><ul><li>  <a href="about:blank#_1014">超键、候选键、主键、外键分别是什么？</a></li><li>  <a href="about:blank#SQL__1023">SQL 约束有哪几种？</a></li><li>  <a href="about:blank#_1035">六种关联查询</a></li><li>  <a href="about:blank#_1160">什么是子查询</a></li><li>  <a href="about:blank#_1168">子查询的三种情况</a></li><li>  <a href="about:blank#mysql_in__exists__1197">mysql中 in 和 exists 区别</a></li><li>  <a href="about:blank#varcharchar_1207">varchar与char的区别</a></li><li>  <a href="about:blank#varchar5050_1233">varchar(50)中50的涵义</a></li><li>  <a href="about:blank#int2020_1239">int(20)中20的涵义</a></li><li>  <a href="about:blank#mysql_1247">mysql为什么这么设计</a></li><li>  <a href="about:blank#mysqlint10char10varchar10_1253">mysql中int(10)和char(10)以及varchar(10)的区别</a></li><li>  <a href="about:blank#FLOATDOUBLE_1267">FLOAT和DOUBLE的区别是什么？</a></li><li>  <a href="about:blank#dropdeletetruncate_1274">drop、delete与truncate的区别</a></li><li>  <a href="about:blank#UNIONUNION_ALL_1289">UNION与UNION ALL的区别？</a></li></ul></li></ul></li><li>  <a href="about:blank#SQL_1298">SQL优化</a></li><li><ul><li><a href="about:blank#SQL_1300">如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</a><ul><li>  <a href="about:blank#SQL_1378">SQL的生命周期？</a></li><li>  <a href="about:blank#_1398">大表数据查询，怎么优化</a></li><li>  <a href="about:blank#_1408">超大分页怎么处理？</a></li><li>  <a href="about:blank#mysql__1431">mysql 分页</a></li><li>  <a href="about:blank#_1455">慢查询日志</a></li><li>  <a href="about:blank#sql_1479">关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</a></li><li>  <a href="about:blank#_1493">为什么要尽量设定一个主键？</a></li><li>  <a href="about:blank#IDUUID_1499">主键使用自增ID还是UUID？</a></li><li>  <a href="about:blank#not_null_1511">字段为什么要求定义为not null？</a></li><li>  <a href="about:blank#_1517">如果要存储用户的密码散列，应该使用什么字段进行存储？</a></li><li>  <a href="about:blank#_1523">优化查询过程中的数据访问</a></li><li>  <a href="about:blank#_1541">优化长难的查询语句</a></li><li>  <a href="about:blank#_1557">优化特定类型的查询语句</a></li><li>  <a href="about:blank#_1568">优化关联查询</a></li><li>  <a href="about:blank#_1575">优化子查询</a></li><li>  <a href="about:blank#LIMIT_1586">优化LIMIT分页</a></li><li>  <a href="about:blank#UNION_1593">优化UNION查询</a></li><li>  <a href="about:blank#WHERE_1599">优化WHERE子句</a></li></ul></li></ul></li><li>  <a href="about:blank#_1664">数据库优化</a></li><li><ul><li><a href="about:blank#_1666">为什么要优化</a><ul><li>  <a href="about:blank#_1676">数据库结构优化</a></li><li>  <a href="about:blank#MySQLcpu500_1706">MySQL数据库cpu飙升到500%的话他怎么处理？</a></li><li>  <a href="about:blank#CRUD_1718">大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</a></li><li><ul><li><a href="about:blank#_1744">垂直分表</a><ul><li><ul><li><a href="about:blank#_1750">适用场景</a><ul><li>  <a href="about:blank#_1755">缺点</a></li></ul></li></ul></li><li>  <a href="about:blank#_1785">水平分表：</a></li><li><ul><li><a href="about:blank#_1791">适用场景</a><ul><li>  <a href="about:blank#_1796">水平切分的缺点</a></li></ul></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#MySQL_1836">MySQL的复制原理以及流程</a></li><li>  <a href="about:blank#_1883">读写分离有哪些解决方案？</a></li><li>  <a href="about:blank#mysqldumpxtranbackup_1908">备份计划，mysqldump以及xtranbackup的实现原理</a></li><li>  <a href="about:blank#_1954">数据表损坏的修复方式有哪些？</a></li></ul></li></ul></li></ul></li></ul></li></ul><p>Java面试总结汇总，整理了包括Java基础知识，集合容器，并发编程，JVM，常用开源框架Spring，MyBatis，数据库，中间件等，包含了作为一个Java工程师在面试中需要用到或者可能用到的绝大部分知识。欢迎大家阅读，本人见识有限，写的博客难免有错误或者疏忽的地方，还望各位大佬指点，在此表示感激不尽。文章持续更新中…</p><table><thead><tr><th>序号</th><th>内容</th><th>链接地址</th></tr></thead><tbody><tr><td>1</td><td>Java基础知识面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104390612">https://thinkwon.blog.csdn.net/article/details/104390612</a></td></tr><tr><td>2</td><td>Java集合容器面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104588551">https://thinkwon.blog.csdn.net/article/details/104588551</a></td></tr><tr><td>3</td><td>Java异常面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104390689">https://thinkwon.blog.csdn.net/article/details/104390689</a></td></tr><tr><td>4</td><td>并发编程面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104863992">https://thinkwon.blog.csdn.net/article/details/104863992</a></td></tr><tr><td>5</td><td>JVM面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104390752">https://thinkwon.blog.csdn.net/article/details/104390752</a></td></tr><tr><td>6</td><td>Spring面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104397516">https://thinkwon.blog.csdn.net/article/details/104397516</a></td></tr><tr><td>7</td><td>Spring MVC面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104397427">https://thinkwon.blog.csdn.net/article/details/104397427</a></td></tr><tr><td>8</td><td>Spring Boot面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104397299">https://thinkwon.blog.csdn.net/article/details/104397299</a></td></tr><tr><td>9</td><td>Spring Cloud面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104397367">https://thinkwon.blog.csdn.net/article/details/104397367</a></td></tr><tr><td>10</td><td>MyBatis面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/101292950">https://thinkwon.blog.csdn.net/article/details/101292950</a></td></tr><tr><td>11</td><td>Redis面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/103522351">https://thinkwon.blog.csdn.net/article/details/103522351</a></td></tr><tr><td>12</td><td>MySQL数据库面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104778621">https://thinkwon.blog.csdn.net/article/details/104778621</a></td></tr><tr><td>13</td><td>消息中间件MQ与RabbitMQ面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104588612">https://thinkwon.blog.csdn.net/article/details/104588612</a></td></tr><tr><td>14</td><td>Dubbo面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104390006">https://thinkwon.blog.csdn.net/article/details/104390006</a></td></tr><tr><td>15</td><td>Linux面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104588679">https://thinkwon.blog.csdn.net/article/details/104588679</a></td></tr><tr><td>16</td><td>Tomcat面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104397665">https://thinkwon.blog.csdn.net/article/details/104397665</a></td></tr><tr><td>17</td><td>ZooKeeper面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104397719">https://thinkwon.blog.csdn.net/article/details/104397719</a></td></tr><tr><td>18</td><td>Netty面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104391081">https://thinkwon.blog.csdn.net/article/details/104391081</a></td></tr><tr><td>19</td><td>架构设计&amp;分布式&amp;数据结构与算法面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/105870730">https://thinkwon.blog.csdn.net/article/details/105870730</a></td></tr></tbody></table><h2 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>数据库基础知识</h2><h3 id="为什么要使用数据库"><a href="#为什么要使用数据库" class="headerlink" title="为什么要使用数据库"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>为什么要使用数据库</h3><p><strong>数据保存在内存</strong></p><p>优点： 存取速度快</p><p>缺点： 数据不能永久保存</p><p><strong>数据保存在文件</strong></p><p>优点： 数据永久保存</p><p>缺点：1）速度比内存操作慢，频繁的IO操作。2）查询数据不方便</p><p><strong>数据保存在数据库</strong></p><p>1）数据永久保存</p><p>2）使用SQL语句，查询方便效率高。</p><p>3）管理数据方便</p><h3 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是SQL？</h3><p>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</p><p>作用：用于存取数据、查询、更新和管理关系数据库系统。</p><h3 id="什么是MySQL"><a href="#什么是MySQL" class="headerlink" title="什么是MySQL?"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是MySQL?</h3><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</p><h3 id="数据库三大范式是什么"><a href="#数据库三大范式是什么" class="headerlink" title="数据库三大范式是什么"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>数据库三大范式是什么</h3><p>第一范式：每个列都不可以再拆分。</p><p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p><p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p><p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p><h3 id="mysql有关权限的表都有哪几个"><a href="#mysql有关权限的表都有哪几个" class="headerlink" title="mysql有关权限的表都有哪几个"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>mysql有关权限的表都有哪几个</h3><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：</p><ul><li>  user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li><li>  db权限表：记录各个帐号在各个数据库上的操作权限。</li><li>  table_priv权限表：记录数据表级的操作权限。</li><li>  columns_priv权限表：记录数据列级的操作权限。</li><li>  host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li></ul><h3 id="MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h3><p>有三种格式，statement，row和mixed。</p><ul><li>  statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li><li>  row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li><li>  mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li></ul><p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>数据类型</h2><h3 id="mysql有哪些数据类型"><a href="#mysql有哪些数据类型" class="headerlink" title="mysql有哪些数据类型"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>mysql有哪些数据类型</h3><table><thead><tr><th><strong>分类</strong></th><th><strong>类型名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>整数类型</strong></td><td>tinyInt</td><td>很小的整数(8位二进制)</td></tr><tr><td></td><td>smallint</td><td>小的整数(16位二进制)</td></tr><tr><td></td><td>mediumint</td><td>中等大小的整数(24位二进制)</td></tr><tr><td></td><td>int(integer)</td><td>普通大小的整数(32位二进制)</td></tr><tr><td><strong>小数类型</strong></td><td>float</td><td>单精度浮点数</td></tr><tr><td></td><td>double</td><td>双精度浮点数</td></tr><tr><td></td><td>decimal(m,d)</td><td>压缩严格的定点数</td></tr><tr><td><strong>日期类型</strong></td><td>year</td><td>YYYY 1901~2155</td></tr><tr><td></td><td>time</td><td>HH:MM:SS -838:59:59~838:59:59</td></tr><tr><td></td><td>date</td><td>YYYY-MM-DD 1000-01-01~9999-12-3</td></tr><tr><td></td><td>datetime</td><td>YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59</td></tr><tr><td></td><td>timestamp</td><td>YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC</td></tr><tr><td><strong>文本、二进制类型</strong></td><td>CHAR(M)</td><td>M为0~255之间的整数</td></tr><tr><td></td><td>VARCHAR(M)</td><td>M为0~65535之间的整数</td></tr><tr><td></td><td>TINYBLOB</td><td>允许长度0~255字节</td></tr><tr><td></td><td>BLOB</td><td>允许长度0~65535字节</td></tr><tr><td></td><td>MEDIUMBLOB</td><td>允许长度0~167772150字节</td></tr><tr><td></td><td>LONGBLOB</td><td>允许长度0~4294967295字节</td></tr><tr><td></td><td>TINYTEXT</td><td>允许长度0~255字节</td></tr><tr><td></td><td>TEXT</td><td>允许长度0~65535字节</td></tr><tr><td></td><td>MEDIUMTEXT</td><td>允许长度0~167772150字节</td></tr><tr><td></td><td>LONGTEXT</td><td>允许长度0~4294967295字节</td></tr><tr><td></td><td>VARBINARY(M)</td><td>允许长度0~M个字节的变长字节字符串</td></tr><tr><td></td><td>BINARY(M)</td><td>允许长度0~M个字节的定长字节字符串</td></tr></tbody></table><ul><li><p><code>1、整数类型</code>，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。<br>  <code>长度</code>：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。<br>  <code>例子</code>，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p></li><li><p><code>2、实数类型</code>，包括FLOAT、DOUBLE、DECIMAL。<br>  DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。<br>  而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。<br>  计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p></li><li><p><code>3、字符串类型</code>，包括VARCHAR、CHAR、TEXT、BLOB<br>  VARCHAR用于存储可变长字符串，它比定长类型更节省空间。<br>  VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。<br>  VARCHAR存储的内容超出设置的长度时，内容会被截断。<br>  CHAR是定长的，根据定义的字符串长度分配足够的空间。<br>  CHAR会根据需要使用空格进行填充方便比较。<br>  CHAR适合存储很短的字符串，或者所有值都接近同一个长度。<br>  CHAR存储的内容超出设置的长度时，内容同样会被截断。</p><p>  <strong>使用策略：</strong><br>  对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。<br>  对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。<br>  使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。<br>  尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。</p></li><li><p><code>4、枚举类型（ENUM）</code>，把不重复的数据存储为一个预定义的集合。<br>  有时可以使用ENUM代替常用的字符串类型。<br>  ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。<br>  ENUM在内部存储时，其实存的是整数。<br>  尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。<br>  排序是按照内部存储的整数</p></li><li><p><code>5、日期和时间类型</code>，尽量使用timestamp，空间效率高于datetime，<br>  用整数保存时间戳通常不方便处理。<br>  如果需要存储微妙，可以使用bigint存储。<br>  看到这里，这道真题是不是就比较容易回答了。</p></li></ul><h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>引擎</h2><h3 id="MySQL存储引擎MyISAM与InnoDB区别"><a href="#MySQL存储引擎MyISAM与InnoDB区别" class="headerlink" title="MySQL存储引擎MyISAM与InnoDB区别"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>MySQL存储引擎MyISAM与InnoDB区别</h3><p>存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p><p>常用的存储引擎有以下：</p><ul><li>  <strong>Innodb引擎</strong>：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li><li>  <strong>MyIASM引擎</strong>(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</li><li>  <strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li></ul><p><strong>MyISAM与InnoDB区别</strong></p><table><thead><tr><th></th><th>MyISAM</th><th>Innodb</th></tr></thead><tbody><tr><td>存储结构</td><td>每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td><td>所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td></tr><tr><td>存储空间</td><td>MyISAM可被压缩，存储空间较小</td><td>InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td></tr><tr><td>可移植性、备份及恢复</td><td>由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td><td>免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了</td></tr><tr><td>文件格式</td><td>数据和索引是分别存储的，数据<code>.MYD</code>，索引<code>.MYI</code></td><td>数据和索引是集中存储的，<code>.ibd</code></td></tr><tr><td>记录存储顺序</td><td>按记录插入顺序保存</td><td>按主键大小有序插入</td></tr><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td><td>表级锁定</td><td>行级锁定、表级锁定，锁定力度小并发能力高</td></tr><tr><td>SELECT</td><td>MyISAM更优</td><td></td></tr><tr><td>INSERT、UPDATE、DELETE</td><td></td><td>InnoDB更优</td></tr><tr><td>select count(*)</td><td>myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td><td></td></tr><tr><td>索引的实现方式</td><td>B+树索引，myisam 是堆表</td><td>B+树索引，Innodb 是索引组织表</td></tr><tr><td>哈希索引</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr></tbody></table><h3 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>MyISAM索引与InnoDB索引的区别？</h3><ul><li>  InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li><li>  InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li><li>  MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li><li>  InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li></ul><h3 id="InnoDB引擎的4大特性"><a href="#InnoDB引擎的4大特性" class="headerlink" title="InnoDB引擎的4大特性"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>InnoDB引擎的4大特性</h3><ul><li><p>  插入缓冲（insert buffer)</p></li><li><p>  二次写(double write)</p></li><li><p>  自适应哈希索引(ahi)</p></li><li><p>  预读(read ahead)</p></li></ul><h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>存储引擎选择</h3><p>如果没有特别的需求，使用默认的<code>Innodb</code>即可。</p><p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p><p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>索引</h2><h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是索引？</h3><p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p><p>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p><p>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</p><h3 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>索引有哪些优缺点？</h3><p>索引的优点</p><ul><li>  可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>  通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ul><p>索引的缺点</p><ul><li>  时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li><li>  空间方面：索引需要占物理空间。</li></ul><h3 id="索引使用场景（重点）"><a href="#索引使用场景（重点）" class="headerlink" title="索引使用场景（重点）"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>索引使用场景（重点）</h3><p>where</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzE5LzE2OTA0NTk2ZTFiNTU4YjI?x-oss-process=image/format,png" alt="img"></p><p>上图中，根据<code>id</code>查询记录，因为<code>id</code>字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。</p><pre><code>-- 增加一个没有建立索引的字段alter table innodb1 add sex char(1);-- 按sex检索时可选的索引为nullEXPLAIN SELECT * from innodb1 where sex=&#39;男&#39;;</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzE5LzE2OTA0NTk2Zjk1YTdmOTk?x-oss-process=image/format,png" alt="img"></p><blockquote><p>可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（<code>alter table 表名 add index(字段名)</code>），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。</p></blockquote><p>order by</p><p>当我们使用<code>order by</code>将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。</p><p>但是如果我们对该字段建立索引<code>alter table 表名 add index(字段名)</code>，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用<strong>取出索引表某个范围内的索引对应的数据</strong>，而不用像上述那<strong>取出所有数据</strong>进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）</p><p>join</p><blockquote><p>对<code>join</code>语句匹配关系（<code>on</code>）涉及的字段建立索引能够提高效率</p></blockquote><p>索引覆盖</p><p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在<code>select</code>后只写必要的查询字段，以增加索引覆盖的几率。</p><p>这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。</p><h3 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>索引有哪几种类型？</h3><p><strong>主键索引:</strong> 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p><p><strong>唯一索引:</strong> 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p><ul><li><p>  可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column);</code> 创建唯一索引</p></li><li><p>  可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column1,column2);</code> 创建唯一组合索引</p></li></ul><p><strong>普通索引:</strong> 基本的索引类型，没有唯一性的限制，允许为NULL值。</p><ul><li><p>  可以通过<code>ALTER TABLE table_name ADD INDEX index_name (column);</code>创建普通索引</p></li><li><p>  可以通过<code>ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);</code>创建组合索引</p></li></ul><p><strong>全文索引：</strong> 是目前搜索引擎使用的一种关键技术。</p><ul><li>  可以通过<code>ALTER TABLE table_name ADD FULLTEXT (column);</code>创建全文索引</li></ul><h3 id="索引的数据结构（b树，hash）"><a href="#索引的数据结构（b树，hash）" class="headerlink" title="索引的数据结构（b树，hash）"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>索引的数据结构（b树，hash）</h3><p>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有<strong>Hash索引</strong>，<strong>B+树索引</strong>等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p><p>1）B树索引</p><p>mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzI0LzE2NjBjMGYxNGRhY2Y2ZjU?x-oss-process=image/format,png" alt="img"></p><p>查询方式：</p><p>主键索引区:PI(关联保存的时数据的地址)按主键查询,</p><p>普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快</p><p>B+tree性质：</p><p>1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</p><p>2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p>3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</p><p>4.）B+ 树中，数据对象的插入和删除仅在叶节点上进行。</p><p>5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p><p>2）哈希索引</p><p>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzI0LzE2NjBjMGYxNThhNzZmOTQ?x-oss-process=image/format,png" alt="img"></p><h3 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>索引的基本原理</h3><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p><p>索引的原理很简单，就是把无序的数据变成有序的查询</p><ol><li><p> 把创建了索引的列的内容进行排序</p></li><li><p> 对排序结果生成倒排表</p></li><li><p> 在倒排表内容上拼上数据地址链</p></li><li><p> 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</p></li></ol><h3 id="索引算法有哪些？"><a href="#索引算法有哪些？" class="headerlink" title="索引算法有哪些？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>索引算法有哪些？</h3><p>索引算法有 BTree算法和Hash算法</p><p><strong>BTree算法</strong></p><p>BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：</p><pre><code>-- 只要它的查询条件是一个不以通配符开头的常量select * from user where name like &#39;jack%&#39;; -- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： select * from user where name like &#39;%jack&#39;; </code></pre><p><strong>Hash算法</strong></p><p>Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</p><h3 id="索引设计的原则？"><a href="#索引设计的原则？" class="headerlink" title="索引设计的原则？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>索引设计的原则？</h3><ol><li> 适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li><li> 基数较小的类，索引效果较差，没有必要在此列建立索引</li><li> 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li><li> 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li></ol><h3 id="创建索引的原则（重中之重）"><a href="#创建索引的原则（重中之重）" class="headerlink" title="创建索引的原则（重中之重）"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>创建索引的原则（重中之重）</h3><p>索引虽好，但也不是无限制的使用，最好符合一下几个原则</p><p>1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>2）较频繁作为查询条件的字段才去创建索引</p><p>3）更新频繁字段不适合创建索引</p><p>4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</p><p>5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p><p>6）定义有外键的数据列一定要建立索引。</p><p>7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p><p>8）对于定义为text、image和bit的数据类型的列不要建立索引。</p><h3 id="创建索引的三种方式，删除索引"><a href="#创建索引的三种方式，删除索引" class="headerlink" title="创建索引的三种方式，删除索引"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>创建索引的三种方式，删除索引</h3><p>第一种方式：在执行CREATE TABLE时创建索引</p><pre><code>CREATE TABLE user_index2 (    id INT auto_increment PRIMARY KEY,    first_name VARCHAR (16),    last_name VARCHAR (16),    id_card VARCHAR (18),    information text,    KEY name (first_name, last_name),    FULLTEXT KEY (information),    UNIQUE KEY (id_card));</code></pre><p>第二种方式：使用ALTER TABLE命令去增加索引</p><pre><code>ALTER TABLE table_name ADD INDEX index_name (column_list);</code></pre><p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p><p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p><p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p><p>第三种方式：使用CREATE INDEX命令创建</p><pre><code>CREATE INDEX index_name ON table_name (column_list);</code></pre><p>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p><p>删除索引</p><p>根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code></p><pre><code>alter table user_index drop KEY name;alter table user_index drop KEY id_card;alter table user_index drop KEY information;</code></pre><p>删除主键索引：<code>alter table 表名 drop primary key</code>（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzE5LzE2OTA0NTk2YjIxZTIwOWM?x-oss-process=image/format,png" alt="img"></p><p>需要取消自增长再行删除：</p><pre><code>alter table user_index-- 重新定义字段MODIFY id int,drop PRIMARY KEY</code></pre><p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p><h3 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>创建索引时需要注意什么？</h3><ul><li>  非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li><li>  取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li><li>  索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li></ul><h3 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>使用索引查询一定能提高查询的性能吗？为什么</h3><p>通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</p><ul><li>  索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</li><li>  基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li><li>  基于非唯一性索引的检索</li></ul><h3 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>百万级别或以上的数据如何删除</h3><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p><ol><li> 所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li><li> 然后删除其中无用数据（此过程需要不到两分钟）</li><li> 删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li><li> 与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li></ol><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>前缀索引</h3><p>语法：<code>index(field(10))</code>，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</p><p>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p><p>实操的难度：在于前缀截取的长度。</p><p>我们可以利用<code>select count(*)/count(distinct left(password,prefixLen));</code>，通过从调整<code>prefixLen</code>的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前<code>prefixLen</code>个字符几乎能确定唯一一条记录）</p><h3 id="什么是最左前缀原则？什么是最左匹配原则"><a href="#什么是最左前缀原则？什么是最左匹配原则" class="headerlink" title="什么是最左前缀原则？什么是最左匹配原则"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是最左前缀原则？什么是最左匹配原则</h3><ul><li>  顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li><li>  最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li>  =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li></ul><h3 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>B树和B+树的区别</h3><ul><li><p>  在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</p></li><li><p>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</p><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzIxLzE2NWZiNjgyZTc1OWNmMTI?x-oss-process=image/format,png" alt="img"></p></li></ul><h3 id="使用B树的好处"><a href="#使用B树的好处" class="headerlink" title="使用B树的好处"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>使用B树的好处</h3><p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p><h3 id="使用B-树的好处"><a href="#使用B-树的好处" class="headerlink" title="使用B+树的好处"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>使用B+树的好处</h3><p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p><h3 id="Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢?"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>Hash索引和B+树所有有什么区别或者说优劣呢?</h3><p>首先要知道Hash索引和B+树索引的底层实现原理：</p><p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</p><p>那么可以看出他们有以下的不同：</p><ul><li>  hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</li></ul><p>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p><ul><li>  hash索引不支持使用索引进行排序，原理同上。</li><li>  hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。</li><li>  hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</li><li>  hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</li></ul><p>因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。</p><h3 id="数据库为什么使用B-树而不是B树"><a href="#数据库为什么使用B-树而不是B树" class="headerlink" title="数据库为什么使用B+树而不是B树"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>数据库为什么使用B+树而不是B树</h3><ul><li>  B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</li><li>  B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</li><li>  B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li><li>  B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</li><li>  增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</li></ul><h3 id="B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，"><a href="#B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，" class="headerlink" title="B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，</h3><p>在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p><p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p><h3 id="什么是聚簇索引？何时使用聚簇索引与非聚簇索引"><a href="#什么是聚簇索引？何时使用聚簇索引与非聚簇索引" class="headerlink" title="什么是聚簇索引？何时使用聚簇索引与非聚簇索引"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是聚簇索引？何时使用聚簇索引与非聚簇索引</h3><ul><li>  聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li><li>  非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</li></ul><p>澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p><p>何时使用聚簇索引与非聚簇索引</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDE1NDQ5OS1kNTNhNWNlOWNlY2YyMmYzLnBuZw?x-oss-process=image/format,png" alt="img"></p><h3 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>非聚簇索引一定会回表查询吗？</h3><p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</p><p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行<code>select age from employee where age &lt; 20</code>的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p><h3 id="联合索引是什么？为什么需要注意联合索引中的顺序？"><a href="#联合索引是什么？为什么需要注意联合索引中的顺序？" class="headerlink" title="联合索引是什么？为什么需要注意联合索引中的顺序？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>联合索引是什么？为什么需要注意联合索引中的顺序？</h3><p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p><p>具体原因为:</p><p>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p><p>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>事务</h2><h3 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是数据库事务？</h3><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>事务最经典也经常被拿出来说例子就是转账了。</p><p>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><h3 id="事物的四大特性-ACID-介绍一下"><a href="#事物的四大特性-ACID-介绍一下" class="headerlink" title="事物的四大特性(ACID)介绍一下?"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>事物的四大特性(ACID)介绍一下?</h3><p>关系性数据库需要遵循ACID规则，具体内容如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzIwLzE2MzdiMDhiOTg2MTk0NTU?x-oss-process=image/format,png" alt="事务的特性"></p><ol><li> <strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li> <strong>一致性：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li><li> <strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li> <strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><h3 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是脏读？幻读？不可重复读？</h3><ul><li>  脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li><li>  不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li><li>  幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li></ul><h3 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h3><p>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻影读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><p><strong>SQL 标准定义了四个隔离级别：</strong></p><ul><li>  <strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li>  <strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li>  <strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li>  <strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><p>这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</p><p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是*<em>READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 \</em>*REPEATABLE-READ（可重读）**并不会有任何性能损失。</p><p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>锁</h2><h3 id="对MySQL的锁了解吗"><a href="#对MySQL的锁了解吗" class="headerlink" title="对MySQL的锁了解吗"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>对MySQL的锁了解吗</h3><p>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。</p><p>就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。</p><h3 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>隔离级别与锁的关系</h3><p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p><p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p><p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p><p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别<strong>锁定整个范围的键</strong>，并一直持有锁，直到事务完成。</p><h3 id="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"><a href="#按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法" class="headerlink" title="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</h3><p>在关系型数据库中，可以<strong>按照锁的粒度把数据库锁分</strong>为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p><p><strong>MyISAM和InnoDB存储引擎使用的锁：</strong></p><ul><li>  MyISAM采用表级锁(table-level locking)。</li><li>  InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</li></ul><p>行级锁，表级锁和页级锁对比</p><p><strong>行级锁</strong> 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p><p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p><p><strong>表级锁</strong> 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p><p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p><p><strong>页级锁</strong> 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p><p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p><h3 id="从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了"><a href="#从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了" class="headerlink" title="从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了</h3><p><strong>从锁的类别上来讲</strong>，有共享锁和排他锁。</p><p>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p><p>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p><p>用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。</p><p>锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。</p><p>他们的加锁开销从大到小，并发能力也是从大到小。</p><h3 id="MySQL中InnoDB引擎的行锁是怎么实现的？"><a href="#MySQL中InnoDB引擎的行锁是怎么实现的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是怎么实现的？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>MySQL中InnoDB引擎的行锁是怎么实现的？</h3><p>答：InnoDB是基于索引来完成行锁</p><p>例: select * from tab_with_index where id = 1 for update;</p><p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起</p><h3 id="InnoDB存储引擎的锁的算法有三种"><a href="#InnoDB存储引擎的锁的算法有三种" class="headerlink" title="InnoDB存储引擎的锁的算法有三种"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>InnoDB存储引擎的锁的算法有三种</h3><ul><li>  Record lock：单个行记录上的锁</li><li>  Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li>  Next-key lock：record+gap 锁定一个范围，包含记录本身</li></ul><p><strong>相关知识点：</strong></p><ol><li> innodb对于行的查询使用next-key lock</li><li> Next-locking keying为了解决Phantom Problem幻读问题</li><li> 当查询的索引含有唯一属性时，将next-key lock降级为record key</li><li> Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li><li> 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li></ol><h3 id="什么是死锁？怎么解决？"><a href="#什么是死锁？怎么解决？" class="headerlink" title="什么是死锁？怎么解决？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是死锁？怎么解决？</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><p>常见的解决死锁的方法</p><p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p><p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p><p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p><p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p><h3 id="数据库的乐观锁和悲观锁是什么？怎么实现的？"><a href="#数据库的乐观锁和悲观锁是什么？怎么实现的？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？怎么实现的？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h3><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p><p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p><p><strong>两种锁的使用场景</strong></p><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p><p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>视图</h2><h3 id="为什么要使用视图？什么是视图？"><a href="#为什么要使用视图？什么是视图？" class="headerlink" title="为什么要使用视图？什么是视图？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>为什么要使用视图？什么是视图？</h3><p>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</p><p>视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。</p><h3 id="视图有哪些特点？"><a href="#视图有哪些特点？" class="headerlink" title="视图有哪些特点？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>视图有哪些特点？</h3><p>视图的特点如下:</p><ul><li><p>  视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</p></li><li><p>  视图是由基本表(实表)产生的表(虚表)。</p></li><li><p>  视图的建立和删除不影响基本表。</p></li><li><p>  对视图内容的更新(添加，删除和修改)直接影响基本表。</p></li><li><p>  当视图来自多个基本表时，不允许添加和删除数据。</p></li></ul><p>视图的操作包括创建视图，查看视图，删除视图和修改视图。</p><h3 id="视图的使用场景有哪些？"><a href="#视图的使用场景有哪些？" class="headerlink" title="视图的使用场景有哪些？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>视图的使用场景有哪些？</h3><p>视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。</p><p>下面是视图的常见使用场景：</p><ul><li><p>  重用SQL语句；</p></li><li><p>  简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</p></li><li><p>  使用表的组成部分而不是整个表；</p></li><li><p>  保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</p></li><li><p>  更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</p></li></ul><h3 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>视图的优点</h3><ol><li> 查询简单化。视图能简化用户的操作</li><li> 数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li><li> 逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li></ol><h3 id="视图的缺点"><a href="#视图的缺点" class="headerlink" title="视图的缺点"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>视图的缺点</h3><ol><li><p> 性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</p></li><li><p>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的</p><p> 这些视图有如下特征：1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\SUM\MAX等聚合函数的视图。 4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外）</p></li></ol><h3 id="什么是游标？"><a href="#什么是游标？" class="headerlink" title="什么是游标？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是游标？</h3><p>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</p><h2 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>存储过程与函数</h2><h3 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是存储过程？有哪些优缺点？</h3><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p><p><strong>优点</strong></p><p>1）存储过程是预编译过的，执行效率高。</p><p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p><p>3）安全性高，执行存储过程需要有一定权限的用户。</p><p>4）存储过程可以重复使用，减少数据库开发人员的工作量。</p><p><strong>缺点</strong></p><p>1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</p><p>2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p><p>3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p><p>4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>触发器</h2><h3 id="什么是触发器？触发器的使用场景有哪些？"><a href="#什么是触发器？触发器的使用场景有哪些？" class="headerlink" title="什么是触发器？触发器的使用场景有哪些？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是触发器？触发器的使用场景有哪些？</h3><p>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</p><p>使用场景</p><ul><li>  可以通过数据库中的相关表实现级联更改。</li><li>  实时监控某张表中的某个字段的更改而需要做出相应的处理。</li><li>  例如可以生成某些业务的编号。</li><li>  注意不要滥用，否则会造成数据库及应用程序的维护困难。</li><li>  大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。</li></ul><h3 id="MySQL中都有哪些触发器？"><a href="#MySQL中都有哪些触发器？" class="headerlink" title="MySQL中都有哪些触发器？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>MySQL中都有哪些触发器？</h3><p>在MySQL数据库中有如下六种触发器：</p><ul><li>  Before Insert</li><li>  After Insert</li><li>  Before Update</li><li>  After Update</li><li>  Before Delete</li><li>  After Delete</li></ul><h2 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>常用SQL语句</h2><h3 id="SQL语句主要分为哪几类"><a href="#SQL语句主要分为哪几类" class="headerlink" title="SQL语句主要分为哪几类"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>SQL语句主要分为哪几类</h3><p>数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER</p><p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p><p>数据查询语言DQL（Data Query Language）SELECT</p><p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p><p>数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE</p><p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p><p>数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p><p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p><h3 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>超键、候选键、主键、外键分别是什么？</h3><ul><li>  超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li>  候选键：是最小超键，即没有冗余元素的超键。</li><li>  主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li><li>  外键：在一个表中存在的另一个表的主键称此表的外键。</li></ul><h3 id="SQL-约束有哪几种？"><a href="#SQL-约束有哪几种？" class="headerlink" title="SQL 约束有哪几种？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>SQL 约束有哪几种？</h3><blockquote><p>SQL 约束有哪几种？</p></blockquote><ul><li>  NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li><li>  UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li><li>  PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li><li>  FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li><li>  CHECK: 用于控制字段的值范围。</li></ul><h3 id="六种关联查询"><a href="#六种关联查询" class="headerlink" title="六种关联查询"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>六种关联查询</h3><ul><li>  交叉连接（CROSS JOIN）</li><li>  内连接（INNER JOIN）</li><li>  外连接（LEFT JOIN/RIGHT JOIN）</li><li>  联合查询（UNION与UNION ALL）</li><li>  全连接（FULL JOIN）</li><li>  交叉连接（CROSS JOIN）</li></ul><pre><code>SELECT * FROM A,B(,C)或者SELECT * FROM A CROSS JOIN B (CROSS JOIN C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER JOIN）SELECT * FROM A,B WHERE A.id=B.id或者SELECT * FROM A INNER JOIN B ON A.id=B.id多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN</code></pre><p>内连接分为三类</p><ul><li>  等值连接：ON A.id=B.id</li><li>  不等值连接：ON A.id &gt; B.id</li><li>  自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid</li></ul><p>外连接（LEFT JOIN/RIGHT JOIN）</p><ul><li>  左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN</li><li>  右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</li></ul><p>联合查询（UNION与UNION ALL）</p><pre><code>SELECT * FROM A UNION SELECT * FROM B UNION ...</code></pre><ul><li>  就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并</li><li>  如果使用UNION ALL，不会合并重复的记录行</li><li>  效率 UNION 高于 UNION ALL</li></ul><p>全连接（FULL JOIN）</p><ul><li>  MySQL不支持全连接</li><li>  可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</li></ul><pre><code>SELECT * FROM A LEFT JOIN B ON A.id=B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id=B.id</code></pre><p>表连接面试题</p><p>有2张表，1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录。</p><p>R表</p><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td></tr></tbody></table><p>S表</p><table><thead><tr><th>C</th><th>D</th></tr></thead><tbody><tr><td>c1</td><td>d1</td></tr><tr><td>c2</td><td>d2</td></tr><tr><td>c4</td><td>d3</td></tr></tbody></table><ol><li> 交叉连接(笛卡尔积):</li></ol><p>select r.<code>*</code>,s.<code>*</code> from r,s</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c1</td><td>d1</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td>c1</td><td>d1</td></tr><tr><td>a1</td><td>b1</td><td>c1</td><td>c2</td><td>d2</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td>c2</td><td>d2</td></tr><tr><td>a1</td><td>b1</td><td>c1</td><td>c4</td><td>d3</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c4</td><td>d3</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td>c4</td><td>d3</td></tr></tbody></table><ol start="2"><li><p>内连接结果：</p><p> select r.<code>*</code>,s.<code>*</code> from r inner join s on r.c=s.c</p></li></ol><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr></tbody></table><ol start="3"><li><p>左连接结果：</p><p> select r.<code>*</code>,s.<code>*</code> from r left join s on r.c=s.c</p></li></ol><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td></td><td></td></tr></tbody></table><ol start="4"><li><p>右连接结果：</p><p> select r.<code>*</code>,s.<code>*</code> from r right join s on r.c=s.c</p></li></ol><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>A</td><td>B</td><td>C</td><td>C</td><td>D</td></tr><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td></td><td></td><td></td><td>c4</td><td>d3</td></tr></tbody></table><ol start="5"><li><p>全表连接的结果（MySql不支持，Oracle支持）：</p><p> select r.<code>*</code>,s.<code>*</code> from r full join s on r.c=s.c</p></li></ol><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>c4</td><td>d3</td></tr></tbody></table><h3 id="什么是子查询"><a href="#什么是子查询" class="headerlink" title="什么是子查询"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是子查询</h3><ol><li><p> 条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果</p></li><li><p> 嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。</p></li></ol><h3 id="子查询的三种情况"><a href="#子查询的三种情况" class="headerlink" title="子查询的三种情况"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>子查询的三种情况</h3><ol><li> 子查询是单行单列的情况：结果集是一个值，父查询使用：=、 &lt;、 &gt; 等运算符</li></ol><pre><code>-- 查询工资最高的员工是谁？ select  * from employee where salary=(select max(salary) from employee);   </code></pre><ol start="2"><li> 子查询是多行单列的情况：结果集类似于一个数组，父查询使用：in 运算符</li></ol><pre><code>-- 查询工资最高的员工是谁？ select  * from employee where salary=(select max(salary) from employee);    </code></pre><ol start="3"><li> 子查询是多行多列的情况：结果集类似于一张虚拟表，不能用于where条件，用于select子句中做为子表</li></ol><pre><code>-- 1) 查询出2011年以后入职的员工信息-- 2) 查询所有的部门信息，与上面的虚拟表中的信息比对，找出所有部门ID相等的员工。select * from dept d,  (select * from employee where join_date &gt; &#39;2011-1-1&#39;) e where e.dept_id =  d.id;    -- 使用表连接：select d.*, e.* from  dept d inner join employee e on d.id = e.dept_id where e.join_date &gt;  &#39;2011-1-1&#39;  </code></pre><h3 id="mysql中-in-和-exists-区别"><a href="#mysql中-in-和-exists-区别" class="headerlink" title="mysql中 in 和 exists 区别"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>mysql中 in 和 exists 区别</h3><p>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p><ol><li> 如果查询的两个表大小相当，那么用in和exists差别不大。</li><li> 如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</li><li> not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</li></ol><h3 id="varchar与char的区别"><a href="#varchar与char的区别" class="headerlink" title="varchar与char的区别"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>varchar与char的区别</h3><p><strong>char的特点</strong></p><ul><li><p>  char表示定长字符串，长度是固定的；</p></li><li><p>  如果插入数据的长度小于char的固定长度时，则用空格填充；</p></li><li><p>  因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</p></li><li><p>  对于char来说，最多能存放的字符个数为255，和编码无关</p></li></ul><p><strong>varchar的特点</strong></p><ul><li><p>  varchar表示可变长字符串，长度是可变的；</p></li><li><p>  插入的数据是多长，就按照多长来存储；</p></li><li><p>  varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</p></li><li><p>  对于varchar来说，最多能存放的字符个数为65532</p></li></ul><p>总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。</p><h3 id="varchar-50-中50的涵义"><a href="#varchar-50-中50的涵义" class="headerlink" title="varchar(50)中50的涵义"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>varchar(50)中50的涵义</h3><p>最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。</p><h3 id="int-20-中20的涵义"><a href="#int-20-中20的涵义" class="headerlink" title="int(20)中20的涵义"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>int(20)中20的涵义</h3><p>是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；</p><p>不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</p><h3 id="mysql为什么这么设计"><a href="#mysql为什么这么设计" class="headerlink" title="mysql为什么这么设计"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>mysql为什么这么设计</h3><p>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；</p><h3 id="mysql中int-10-和char-10-以及varchar-10-的区别"><a href="#mysql中int-10-和char-10-以及varchar-10-的区别" class="headerlink" title="mysql中int(10)和char(10)以及varchar(10)的区别"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>mysql中int(10)和char(10)以及varchar(10)的区别</h3><ul><li><p>int(10)的10表示显示的数据的长度，不是存储数据的大小；chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。</p><p>  int(10) 10位的数据长度 9999999999，占32个字节，int型4位<br>  char(10) 10位固定字符串，不足补空格 最多10个字符<br>  varchar(10) 10位可变字符串，不足补空格 最多10个字符</p></li><li><p>  char(10)表示存储定长的10个字符，不足10个就用空格补齐，占用更多的存储空间</p></li><li><p>  varchar(10)表示存储10个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符</p></li></ul><h3 id="FLOAT和DOUBLE的区别是什么？"><a href="#FLOAT和DOUBLE的区别是什么？" class="headerlink" title="FLOAT和DOUBLE的区别是什么？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>FLOAT和DOUBLE的区别是什么？</h3><ul><li>  FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。</li><li>  DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。</li></ul><h3 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>drop、delete与truncate的区别</h3><p>三者都表示删除，但是三者有一些差别：</p><table><thead><tr><th align="center"></th><th align="center">Delete</th><th align="center">Truncate</th><th align="center">Drop</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">属于DML</td><td align="center">属于DDL</td><td align="center">属于DDL</td></tr><tr><td align="center">回滚</td><td align="center">可回滚</td><td align="center">不可回滚</td><td align="center">不可回滚</td></tr><tr><td align="center">删除内容</td><td align="center">表结构还在，删除表的全部或者一部分数据行</td><td align="center">表结构还在，删除表中的所有数据</td><td align="center">从数据库中删除表，所有的数据行，索引和权限也会被删除</td></tr><tr><td align="center">删除速度</td><td align="center">删除速度慢，需要逐行删除</td><td align="center">删除速度快</td><td align="center">删除速度最快</td></tr></tbody></table><p>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p><h3 id="UNION与UNION-ALL的区别？"><a href="#UNION与UNION-ALL的区别？" class="headerlink" title="UNION与UNION ALL的区别？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>UNION与UNION ALL的区别？</h3><ul><li>  如果使用UNION ALL，不会合并重复的记录行</li><li>  效率 UNION 高于 UNION ALL</li></ul><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>SQL优化</h2><h3 id="如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？"><a href="#如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？" class="headerlink" title="如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</h3><p>对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，<strong>对于查询语句，最重要的优化方式就是使用索引</strong>。 而<strong>执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20200310171131582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>执行计划包含的信息 <strong>id</strong> 有一组数字组成。表示一个查询中各个子查询的执行顺序;</p><ul><li>  id相同执行顺序由上至下。</li><li>  id不同，id值越大优先级越高，越先被执行。</li><li>  id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。</li></ul><p><strong>select_type</strong> 每个子查询的查询类型，一些常见的查询类型。</p><table><thead><tr><th>id</th><th>select_type</th><th>description</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>不包含任何子查询或union等查询</td></tr><tr><td>2</td><td>PRIMARY</td><td>包含子查询最外层查询就显示为 PRIMARY</td></tr><tr><td>3</td><td>SUBQUERY</td><td>在select或 where字句中包含的查询</td></tr><tr><td>4</td><td>DERIVED</td><td>from字句中包含的查询</td></tr><tr><td>5</td><td>UNION</td><td>出现在union后的查询语句中</td></tr><tr><td>6</td><td>UNION RESULT</td><td>从UNION中获取结果集，例如上文的第三个例子</td></tr></tbody></table><p><strong>table</strong> 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划id <strong>partitions</strong> 表分区、表创建的时候可以指定通过那个列进行表分区。 举个例子：</p><pre><code>create table tmp (    id int unsigned not null AUTO_INCREMENT,    name varchar(255),    PRIMARY KEY (id)) engine = innodbpartition by key (id) partitions 5;</code></pre><p><strong>type</strong>(非常重要，可以看到有没有走索引) 访问类型</p><ul><li>  ALL 扫描全表数据</li><li>  index 遍历索引</li><li>  range 索引范围查找</li><li>  index_subquery 在子查询中使用 ref</li><li>  unique_subquery 在子查询中使用 eq_ref</li><li>  ref_or_null 对Null进行索引的优化的 ref</li><li>  fulltext 使用全文索引</li><li>  ref 使用非唯一索引查找数据</li><li>  eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。</li></ul><p><strong>possible_keys</strong> 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。</p><p><strong>key</strong> 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。</p><p><strong>TIPS</strong>:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中</p><p><strong>key_length</strong> 索引长度</p><p><strong>ref</strong> 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p><p><strong>rows</strong> 返回估算的结果集数目，并不是一个准确的值。</p><p><strong>extra</strong> 的信息非常丰富，常见的有：</p><ol><li> Using index 使用覆盖索引</li><li> Using where 使用了用where子句来过滤结果集</li><li> Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。</li><li> Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册</li></ol><pre><code>【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。 说明： 1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 2） ref 指的是使用普通的索引（normal index）。 3） range 对索引进行范围检索。 反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。</code></pre><h3 id="SQL的生命周期？"><a href="#SQL的生命周期？" class="headerlink" title="SQL的生命周期？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>SQL的生命周期？</h3><ol><li><p> 应用服务器与数据库服务器建立一个连接</p></li><li><p> 数据库进程拿到请求sql</p></li><li><p> 解析并生成执行计划，执行</p></li><li><p> 读取数据到内存并进行逻辑处理</p></li><li><p> 通过步骤一的连接，发送结果到客户端</p></li><li><p>关掉连接，释放资源</p><p> <img src="https://img-blog.csdnimg.cn/20200310170936478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol><h3 id="大表数据查询，怎么优化"><a href="#大表数据查询，怎么优化" class="headerlink" title="大表数据查询，怎么优化"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>大表数据查询，怎么优化</h3><ol><li> 优化shema、sql语句+索引；</li><li> 第二加缓存，memcached, redis；</li><li> 主从复制，读写分离；</li><li> 垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li><li> 水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</li></ol><h3 id="超大分页怎么处理？"><a href="#超大分页怎么处理？" class="headerlink" title="超大分页怎么处理？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>超大分页怎么处理？</h3><p>超大的分页一般从两个方向上来解决.</p><ul><li>  数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于<code>select * from table where age &gt; 20 limit 1000000,10</code>这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为<code>select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</code>.这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以<code>select * from table where id &gt; 1000000 limit 10</code>,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</li><li>  从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li></ul><p>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.</p><p>在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.</p><pre><code>【推荐】利用延迟关联或者子查询优化超多分页场景。 说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 正例：先快速定位需要获取的id段，然后再关联： SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</code></pre><h3 id="mysql-分页"><a href="#mysql-分页" class="headerlink" title="mysql 分页"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>mysql 分页</h3><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)</p><pre><code>mysql&gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 </code></pre><p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</p><pre><code>mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. </code></pre><p>如果只给定一个参数，它表示返回最大的记录行数目：</p><pre><code>mysql&gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行 </code></pre><p>换句话说，LIMIT n 等价于 LIMIT 0,n。</p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>慢查询日志</h3><blockquote><p>用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。</p></blockquote><p>开启慢查询日志</p><p>配置项：<code>slow_query_log</code></p><p>可以使用<code>show variables like ‘slov_query_log’</code>查看是否开启，如果状态值为<code>OFF</code>，可以使用<code>set GLOBAL slow_query_log = on</code>来开启，它会在<code>datadir</code>下产生一个<code>xxx-slow.log</code>的文件。</p><p>设置临界时间</p><p>配置项：<code>long_query_time</code></p><p>查看：<code>show VARIABLES like &#39;long_query_time&#39;</code>，单位秒</p><p>设置：<code>set long_query_time=0.5</code></p><p>实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉</p><p>查看日志，一旦SQL超过了我们设置的临界时间就会被记录到<code>xxx-slow.log</code>中</p><h3 id="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"><a href="#关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？" class="headerlink" title="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h3><p>在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。</p><p>慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？</p><p>所以优化也是针对这三个方向来的，</p><ul><li>  首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li><li>  分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li><li>  如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li></ul><h3 id="为什么要尽量设定一个主键？"><a href="#为什么要尽量设定一个主键？" class="headerlink" title="为什么要尽量设定一个主键？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>为什么要尽量设定一个主键？</h3><p>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p><h3 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>主键使用自增ID还是UUID？</h3><p>推荐使用自增ID，不要使用UUID。</p><p>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</p><p>总之，在数据量大一些的情况下，用自增主键性能会好一些。</p><p>关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</p><h3 id="字段为什么要求定义为not-null？"><a href="#字段为什么要求定义为not-null？" class="headerlink" title="字段为什么要求定义为not null？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>字段为什么要求定义为not null？</h3><p>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</p><h3 id="如果要存储用户的密码散列，应该使用什么字段进行存储？"><a href="#如果要存储用户的密码散列，应该使用什么字段进行存储？" class="headerlink" title="如果要存储用户的密码散列，应该使用什么字段进行存储？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>如果要存储用户的密码散列，应该使用什么字段进行存储？</h3><p>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</p><h3 id="优化查询过程中的数据访问"><a href="#优化查询过程中的数据访问" class="headerlink" title="优化查询过程中的数据访问"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>优化查询过程中的数据访问</h3><ul><li>  访问数据太多导致查询性能下降</li><li>  确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</li><li>  确认MySQL服务器是否在分析大量不必要的数据行</li><li>  避免犯如下SQL语句错误</li><li>  查询不需要的数据。解决办法：使用limit解决</li><li>  多表关联返回全部列。解决办法：指定列名</li><li>  总是返回全部列。解决办法：避免使用SELECT *</li><li>  重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</li><li>  是否在扫描额外的记录。解决办法：</li><li>  使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：</li><li>  使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</li><li>  改变数据库和表的结构，修改数据表范式</li><li>  重写SQL语句，让优化器可以以更优的方式执行查询。</li></ul><h3 id="优化长难的查询语句"><a href="#优化长难的查询语句" class="headerlink" title="优化长难的查询语句"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>优化长难的查询语句</h3><ul><li>  一个复杂查询还是多个简单查询</li><li>  MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多</li><li>  使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。</li><li>  切分查询</li><li>  将一个大的查询分为多个小的相同的查询</li><li>  一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。</li><li>  分解关联查询，让缓存的效率更高。</li><li>  执行单个查询可以减少锁的竞争。</li><li>  在应用层做关联更容易对数据库进行拆分。</li><li>  查询效率会有大幅提升。</li><li>  较少冗余记录的查询。</li></ul><h3 id="优化特定类型的查询语句"><a href="#优化特定类型的查询语句" class="headerlink" title="优化特定类型的查询语句"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>优化特定类型的查询语句</h3><ul><li>  count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)</li><li>  MyISAM中，没有任何where条件的count(*)非常快。</li><li>  当有where条件时，MyISAM的count统计不一定比其它引擎快。</li><li>  可以使用explain查询近似值，用近似值替代count(*)</li><li>  增加汇总表</li><li>  使用缓存</li></ul><h3 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>优化关联查询</h3><ul><li>  确定ON或者USING子句中是否有索引。</li><li>  确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。</li></ul><h3 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>优化子查询</h3><ul><li>  用关联查询替代</li><li>  优化GROUP BY和DISTINCT</li><li>  这两种查询据可以使用索引来优化，是最有效的优化方法</li><li>  关联查询中，使用标识列分组的效率更高</li><li>  如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。</li><li>  WITH ROLLUP超级聚合，可以挪到应用程序处理</li></ul><h3 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>优化LIMIT分页</h3><ul><li>  LIMIT偏移量大的时候，查询效率较低</li><li>  可以记录上次查询的最大ID，下次查询时直接根据该ID来查询</li></ul><h3 id="优化UNION查询"><a href="#优化UNION查询" class="headerlink" title="优化UNION查询"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>优化UNION查询</h3><ul><li>  UNION ALL的效率高于UNION</li></ul><h3 id="优化WHERE子句"><a href="#优化WHERE子句" class="headerlink" title="优化WHERE子句"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>优化WHERE子句</h3><p>解题方法</p><p>对于此类考题，先说明如何定位低效SQL语句，然后根据SQL语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑以上几个方面，数据访问的问题，长难查询句的问题还是一些特定类型优化的问题，逐一回答。</p><p>SQL语句优化的一些方法？</p><ul><li>  1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li><li>  2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</li></ul><pre><code>select id from t where num is null-- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=</code></pre><ul><li>  3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</li><li>  4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</li></ul><pre><code>select id from t where num=10 or num=20-- 可以这样查询：select id from t where num=10 union all select id from t where num=20</code></pre><ul><li>  5.in 和 not in 也要慎用，否则会导致全表扫描，如：</li></ul><pre><code>select id from t where num in(1,2,3) -- 对于连续的数值，能用 between 就不要用 in 了：select id from t where num between 1 and 3</code></pre><ul><li>  6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</li><li>  7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</li></ul><pre><code>select id from t where num=@num-- 可以改为强制查询使用索引：select id from t with(index(索引名)) where num=@num</code></pre><ul><li>  8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li></ul><pre><code>select id from t where num/2=100-- 应改为:select id from t where num=100*2</code></pre><ul><li>  9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li></ul><pre><code>select id from t where substring(name,1,3)=’abc’-- name以abc开头的id应改为:select id from t where name like ‘abc%’</code></pre><ul><li>  10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li></ul><h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>数据库优化</h2><h3 id="为什么要优化"><a href="#为什么要优化" class="headerlink" title="为什么要优化"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>为什么要优化</h3><ul><li>  系统的吞吐量瓶颈往往出现在数据库的访问速度上</li><li>  随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li><li>  数据是存放在磁盘上的，读写速度无法和内存相比</li></ul><p>优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</p><h3 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>数据库结构优化</h3><p>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</p><p>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p><p><strong>将字段很多的表分解成多个表</strong></p><p>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</p><p>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p><p><strong>增加中间表</strong></p><p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p><p>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</p><p><strong>增加冗余字段</strong></p><p>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</p><p>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p><p><strong>注意：</strong></p><p><strong>冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</strong></p><h3 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h3><p>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</p><p>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</p><p>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</p><p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</p><h3 id="大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？"><a href="#大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？" class="headerlink" title="大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</h3><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><ol><li> <strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</li><li> <strong>读/写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li><li> <strong>缓存：</strong> 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li></ol><p>还有就是通过分库分表的方式进行优化，主要有垂直分表和水平分表</p><ol><li><p><strong>垂直分区：</strong></p><p> <strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p><p> <strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC82LzE2LzE2NDA4NDM1NGJhMmUwZmQ?x-oss-process=image/format,png" alt="img"></p><p> <strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p><p> <strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p><h4 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>垂直分表</h4><p> 把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy90dVNhS2M2U2ZQcjh0NFBaVVFJVUszVHl0aWF3T0VRa2dFZnBCTm4xZkNtdEVhMkRaNTlISFNSaWN2SEIzeU43Yk5LY1hkc3NWZGFNb25TOEFKanY5cFdBLzY0MA?x-oss-process=image/format,png" alt="img"></p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>适用场景</h5><ul><li><p>  1、如果一个表中某些列常用，另外一些列不常用</p></li><li><p>2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>缺点</h5></li><li><p>  有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差</p></li><li><p>  对于应用层来说，逻辑算法增加开发成本</p></li><li><p>  管理冗余列，查询所有数据需要join操作</p></li></ul></li><li><p><strong>水平分区：</strong></p><p> <strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p><p> 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC82LzE2LzE2NDA4NGI3ZTllNDIzZTM?x-oss-process=image/format,png" alt="数据库水平拆分"></p><p> 水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</p><p> 水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨界点Join性能较差，逻辑复杂。</p><p> 《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p><h4 id="水平分表："><a href="#水平分表：" class="headerlink" title="水平分表："></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>水平分表：</h4><p> 表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy90dVNhS2M2U2ZQcjh0NFBaVVFJVUszVHl0aWF3T0VRa2dkQVpyU1Y3M2liMWZkRENYS2M3QUd6Wmhid3FjS0ZVWkpGWThwMFZkVXRPM3JNYzZ2eDFBdzVBLzY0MA?x-oss-process=image/format,png" alt="img"></p><h5 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>适用场景</h5><ul><li><p>  1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。</p></li><li><p>2、需要把数据存放在多个介质上。</p><h5 id="水平切分的缺点"><a href="#水平切分的缺点" class="headerlink" title="水平切分的缺点"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>水平切分的缺点</h5></li><li><p>  1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作</p></li><li><p>  2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</p></li><li><p>*下面补充一下数据库分片的两种常见方案：**</p></li><li><p>  <strong>客户端代理：</strong> <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</p></li><li><p>  <strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</p></li></ul></li></ol><p><strong>分库分表后面临的问题</strong></p><ul><li><p>  <strong>事务支持</strong> 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p></li><li><p><strong>跨库join</strong></p><p>  只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品</p></li><li><p>  <strong>跨节点的count,order by,group by以及聚合函数问题</strong> 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p></li><li><p>  <strong>数据迁移，容量规划，扩容等问题</strong> 来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。</p></li><li><p>  <strong>ID问题</strong></p></li><li><p>  一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由. 一些常见的主键生成策略</p></li></ul><p><strong>UUID</strong> 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 <strong>Twitter的分布式自增ID算法Snowflake</strong> 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</p><ul><li><p>跨分片的排序分页</p><p>  般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p><p>  <img src="https://img-blog.csdnimg.cn/20200310170753848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h3 id="MySQL的复制原理以及流程"><a href="#MySQL的复制原理以及流程" class="headerlink" title="MySQL的复制原理以及流程"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>MySQL的复制原理以及流程</h3><p>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p><p><strong>主从复制的作用</strong></p><ol><li> 主数据库出现问题，可以切换到从数据库。</li><li> 可以进行数据库层面的读写分离。</li><li> 可以在从数据库上进行日常备份。</li></ol><p><strong>MySQL主从复制解决的问题</strong></p><ul><li>  数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li><li>  负载均衡：降低单个服务器的压力</li><li>  高可用和故障切换：帮助应用程序避免单点失败</li><li>  升级测试：可以用更高版本的MySQL作为从库</li></ul><p><strong>MySQL主从复制工作原理</strong></p><ul><li>  在主库上把数据更高记录到二进制日志</li><li>  从库将主库的日志复制到自己的中继日志</li><li>  从库读取中继日志的事件，将其重放到从库数据中</li></ul><p><strong>基本原理流程，3个线程以及之间的关联</strong></p><p><strong>主</strong>：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</p><p><strong>从</strong>：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；</p><p><strong>从</strong>：sql执行线程——执行relay log中的语句；</p><p><strong>复制过程</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzIxLzE2NWZiNjgzMjIyMDViMmU?x-oss-process=image/format,png" alt="img"></p><p>Binary log：主数据库的二进制日志</p><p>Relay log：从服务器的中继日志</p><p>第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</p><p>第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。</p><p>第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</p><h3 id="读写分离有哪些解决方案？"><a href="#读写分离有哪些解决方案？" class="headerlink" title="读写分离有哪些解决方案？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>读写分离有哪些解决方案？</h3><p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求<code>slave</code>不能写只能读（如果对<code>slave</code>执行写操作，那么<code>show slave status</code>将会呈现<code>Slave_SQL_Running=NO</code>，此时你需要按照前面提到的手动同步一下<code>slave</code>）。</p><p><strong>方案一</strong></p><p>使用mysql-proxy代理</p><p>优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用</p><p>缺点：降低性能， 不支持事务</p><p><strong>方案二</strong></p><p>使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。<br>如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的insert/update/delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下DataSourceTransactionManager， 将read-only的事务扔进读库， 其余的有读有写的扔进写库。</p><p><strong>方案三</strong></p><p>使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务.</p><p>缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。</p><h3 id="备份计划，mysqldump以及xtranbackup的实现原理"><a href="#备份计划，mysqldump以及xtranbackup的实现原理" class="headerlink" title="备份计划，mysqldump以及xtranbackup的实现原理"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>备份计划，mysqldump以及xtranbackup的实现原理</h3><p><strong>(1)备份计划</strong></p><p>视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。</p><p>100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。</p><p><strong>(2)备份恢复时间</strong></p><p>物理备份恢复快，逻辑备份恢复慢</p><p>这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考</p><p>20G的2分钟（mysqldump）</p><p>80G的30分钟(mysqldump)</p><p>111G的30分钟（mysqldump)</p><p>288G的3小时（xtra)</p><p>3T的4小时（xtra)</p><p>逻辑导入时间一般是备份时间的5倍以上</p><p><strong>(3)备份恢复失败如何处理</strong></p><p>首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。</p><p><strong>(4)mysqldump和xtrabackup实现原理</strong></p><p>mysqldump</p><p>mysqldump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个事务(START TRANSACTION /*!40100 WITH CONSISTENTSNAPSHOT */)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data=1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务</p><p>Xtrabackup:</p><p>xtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。最后完成 innodb 的备份后，会做一个 flush engine logs 的操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交</p><p>概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢最后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事</p><p>情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。</p><h3 id="数据表损坏的修复方式有哪些？"><a href="#数据表损坏的修复方式有哪些？" class="headerlink" title="数据表损坏的修复方式有哪些？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>数据表损坏的修复方式有哪些？</h3><p>使用 myisamchk 来修复，具体步骤：</p><ul><li>  1）修复前将mysql服务停止。</li><li>  2）打开命令行方式，然后进入到mysql的/bin目录。</li><li>  3）执行myisamchk –recover 数据库所在路径/*.MYI</li></ul><p>使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。 OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）</p><p>本文转自 <a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187">https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164574504116780274141388&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>top_positive~default-4-104778621.pc_search_result_positive&amp;utm_term=mysql&amp;spm=1018.2226.3001.4187</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;文章目录&quot;&gt;&lt;a href=&quot;#文章目录&quot; class=&quot;headerlink&quot; title=&quot;文章目录&quot;&gt;&lt;/a&gt;文章目录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;about:blank#_37&quot;&gt;数据库基础知识&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="数据库" scheme="https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
    <category term="MySQL面试" scheme="https://ysluckly.github.io/tags/MySQL%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Go Mock (gomock)简明教程</title>
    <link href="https://ysluckly.github.io/2022/02/16/go/"/>
    <id>https://ysluckly.github.io/2022/02/16/go/</id>
    <published>2022-02-16T13:59:10.000Z</published>
    <updated>2022-02-20T13:36:40.177Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114756.jpg" alt="gomock"></p><h2 id="1-gomock-简介"><a href="#1-gomock-简介" class="headerlink" title="1 gomock 简介"></a>1 gomock 简介</h2><p>上一篇文章 <a href="https://geektutu.com/post/quick-go-test.html">Go Test 单元测试简明教程</a> 介绍了 Go 语言中单元测试的常用方法，包括子测试(subtests)、表格驱动测试(table-driven tests)、帮助函数(helpers)、网络测试和基准测试(Benchmark)等。这篇文章介绍一种新的测试方法，mock/stub 测试，当待测试的函数/对象的依赖关系很复杂，并且有些依赖不能直接创建，例如数据库连接、文件I/O等。这种场景就非常适合使用 mock/stub 测试。简单来说，就是用 mock 对象模拟依赖项的行为。</p><blockquote><p>GoMock is a mocking framework for the Go programming language. It integrates well with Go’s built-in testing package, but can be used in other contexts too.</p></blockquote><p><a href="https://github.com/golang/mock">gomock</a> 是官方提供的 mock 框架，同时还提供了 mockgen 工具用来辅助生成测试代码。</p><p>使用如下命令即可安装：</p><pre><code class="bash">go get -u github.com/golang/mock/gomockgo get -u github.com/golang/mock/mockgen</code></pre><h2 id="2-一个简单的-Demo"><a href="#2-一个简单的-Demo" class="headerlink" title="2 一个简单的 Demo"></a>2 一个简单的 Demo</h2><pre><code class="go">// db.gotype DB interface &#123;    Get(key string) (int, error)&#125;func GetFromDB(db DB, key string) int &#123;    if value, err := db.Get(key); err == nil &#123;        return value    &#125;    return -1&#125;</code></pre><p>假设 <code>DB</code> 是代码中负责与数据库交互的部分(在这里用 map 模拟)，测试用例中不能创建真实的数据库连接。这个时候，如果我们需要测试 <code>GetFromDB</code> 这个函数内部的逻辑，就需要 mock 接口 <code>DB</code>。</p><p>第一步：使用 <code>mockgen</code> 生成 <code>db_mock.go</code>。一般传递三个参数。包含需要被mock的接口得到源文件<code>source</code>，生成的目标文件<code>destination</code>，包名<code>package</code>。</p><pre><code class="bash">$ mockgen -source=db.go -destination=db_mock.go -package=main</code></pre><p>第二步：新建 <code>db_test.go</code>，写测试用例。</p><pre><code class="go">func TestGetFromDB(t *testing.T) &#123;    ctrl := gomock.NewController(t)    defer ctrl.Finish() // 断言 DB.Get() 方法是否被调用    m := NewMockDB(ctrl)    m.EXPECT().Get(gomock.Eq(&quot;Tom&quot;)).Return(100, errors.New(&quot;not exist&quot;))    if v := GetFromDB(m, &quot;Tom&quot;); v != -1 &#123;        t.Fatal(&quot;expected -1, but got&quot;, v)    &#125;&#125;</code></pre><ul><li>这个测试用例有2个目的，一是使用 <code>ctrl.Finish()</code> 断言 <code>DB.Get()</code> 被是否被调用，如果没有被调用，后续的 mock 就失去了意义；</li><li>二是测试方法 <code>GetFromDB()</code> 的逻辑是否正确(如果 <code>DB.Get()</code> 返回 error，那么 <code>GetFromDB()</code> 返回 -1)。</li><li><code>NewMockDB()</code> 的定义在 <code>db_mock.go</code> 中，由 mockgen 自动生成。</li></ul><p>最终的代码结构如下：</p><pre><code class="bash">project/    |--db.go    |--db_mock.go // generated by mockgen    |--db_test.go</code></pre><p>执行测试：</p><pre><code class="bash">$ go test . -cover -v=== RUN   TestGetFromDB--- PASS: TestGetFromDB (0.00s)PASScoverage: 81.2% of statementsok      example 0.008s  coverage: 81.2% of statements</code></pre><h2 id="3-打桩-stubs"><a href="#3-打桩-stubs" class="headerlink" title="3 打桩(stubs)"></a>3 打桩(stubs)</h2><p>在上面的例子中，当 <code>Get()</code> 的参数为 Tom，则返回 error，这称之为<code>打桩(stub)</code>，有明确的参数和返回值是最简单打桩方式。除此之外，检测调用次数、调用顺序，动态设置返回值等方式也经常使用。</p><p>3.1 参数(Eq, Any, Not, Nil)</p><pre><code class="go">m.EXPECT().Get(gomock.Eq(&quot;Tom&quot;)).Return(0, errors.New(&quot;not exist&quot;))m.EXPECT().Get(gomock.Any()).Return(630, nil)m.EXPECT().Get(gomock.Not(&quot;Sam&quot;)).Return(0, nil) m.EXPECT().Get(gomock.Nil()).Return(0, errors.New(&quot;nil&quot;)) </code></pre><ul><li><code>Eq(value)</code> 表示与 value 等价的值。</li><li><code>Any()</code> 可以用来表示任意的入参。</li><li><code>Not(value)</code> 用来表示非 value 以外的值。</li><li><code>Nil()</code> 表示 None 值</li></ul><p>3.2 返回值(Return, DoAndReturn)</p><pre><code class="go">m.EXPECT().Get(gomock.Not(&quot;Sam&quot;)).Return(0, nil)m.EXPECT().Get(gomock.Any()).Do(func(key string) &#123;    t.Log(key)&#125;)m.EXPECT().Get(gomock.Any()).DoAndReturn(func(key string) (int, error) &#123;    if key == &quot;Sam&quot; &#123;        return 630, nil    &#125;    return 0, errors.New(&quot;not exist&quot;)&#125;)</code></pre><ul><li><code>Return</code> 返回确定的值</li><li><code>Do</code> Mock 方法被调用时，要执行的操作吗，忽略返回值。</li><li><code>DoAndReturn</code> 可以动态地控制返回值。</li></ul><p>3.3 调用次数(Times)</p><pre><code class="go">func TestGetFromDB(t *testing.T) &#123;    ctrl := gomock.NewController(t)    defer ctrl.Finish()    m := NewMockDB(ctrl)    m.EXPECT().Get(gomock.Not(&quot;Sam&quot;)).Return(0, nil).Times(2)    GetFromDB(m, &quot;ABC&quot;)    GetFromDB(m, &quot;DEF&quot;)&#125;</code></pre><ul><li><code>Times()</code> 断言 Mock 方法被调用的次数。</li><li><code>MaxTimes()</code> 最大次数。</li><li><code>MinTimes()</code> 最小次数。</li><li><code>AnyTimes()</code> 任意次数（包括 0 次）。</li></ul><p>3.4 调用顺序(InOrder)</p><pre><code class="go">func TestGetFromDB(t *testing.T) &#123;    ctrl := gomock.NewController(t)    defer ctrl.Finish() // 断言 DB.Get() 方法是否被调用    m := NewMockDB(ctrl)    o1 := m.EXPECT().Get(gomock.Eq(&quot;Tom&quot;)).Return(0, errors.New(&quot;not exist&quot;))    o2 := m.EXPECT().Get(gomock.Eq(&quot;Sam&quot;)).Return(630, nil)    gomock.InOrder(o1, o2)    GetFromDB(m, &quot;Tom&quot;)    GetFromDB(m, &quot;Sam&quot;)&#125;</code></pre><h2 id="4-如何编写可-mock-的代码"><a href="#4-如何编写可-mock-的代码" class="headerlink" title="4 如何编写可 mock 的代码"></a>4 如何编写可 mock 的代码</h2><p>写可测试的代码与写好测试用例是同等重要的，如何写可 mock 的代码呢？</p><ul><li>mock 作用的是接口，因此将依赖抽象为接口，而不是直接依赖具体的类。</li><li>不直接依赖的实例，而是使用依赖注入降低耦合性。</li></ul><blockquote><p>在软件工程中，依赖注入的意思为，给予调用方它所需要的事物。 “依赖”是指可被方法调用的事物。依赖注入形式下，调用方不再直接指使用“依赖”，取而代之是“注入” 。“注入”是指将“依赖”传递给调用方的过程。在“注入”之后，调用方才会调用该“依赖”。传递依赖给调用方，而不是让让调用方直接获得依赖，这个是该设计的根本需求。<br>– <a href="https://zh.wikipedia.org/zh-cn/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">依赖注入 - Wikipedia</a></p></blockquote><p>如果 <code>GetFromDB()</code> 方法长这个样子</p><pre><code class="go">func GetFromDB(key string) int &#123;    db := NewDB()    if value, err := db.Get(key); err == nil &#123;        return value    &#125;    return -1&#125;</code></pre><p>对 <code>DB</code> 接口的 mock 并不能作用于 <code>GetFromDB()</code> 内部，这样写是没办法进行测试的。那如果将接口 <code>db DB</code> 通过参数传递到 <code>GetFromDB()</code>，那么就可以轻而易举地传入 Mock 对象了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114756.jpg&quot; alt=&quot;gomock&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-gomock-简介&quot;&gt;&lt;a href=&quot;#1-go</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Go语言" scheme="https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
    <category term="单元测试" scheme="https://ysluckly.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    <category term="mock框架" scheme="https://ysluckly.github.io/tags/mock%E6%A1%86%E6%9E%B6/"/>
    
    <category term="stub" scheme="https://ysluckly.github.io/tags/stub/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言简明教程</title>
    <link href="https://ysluckly.github.io/2022/02/16/go/"/>
    <id>https://ysluckly.github.io/2022/02/16/go/</id>
    <published>2022-02-16T13:59:10.000Z</published>
    <updated>2022-02-20T13:35:38.378Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114701.jpg" alt="Golang中文教程"></p><blockquote><p>Go（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。 —— <a href="https://zh.wikipedia.org/wiki/Go">Go - wikipedia.org</a></p></blockquote><h2 id="1-Go-安装"><a href="#1-Go-安装" class="headerlink" title="1 Go 安装"></a>1 Go 安装</h2><p>最新版本下载地址<a href="https://golang.org/dl/">官方下载 golang.org</a>，当前是 1.13.6。如无法访问，可以在 <strong>studygolang.com/dl</strong> 下载</p><p>使用 Linux，可以用如下方式快速安装。</p><pre><code class="bash">$ wget https://studygolang.com/dl/golang/go1.13.6.linux-amd64.tar.gz$ tar -zxvf go1.13.6.linux-amd64.tar.gz$ sudo mv go /usr/local/$ go versiongo version go1.13.6 linux/amd64</code></pre><p>从 <code>Go 1.11</code> 版本开始，Go 提供了 <a href="https://github.com/golang/go/wiki/Modules">Go Modules</a> 的机制，推荐设置以下环境变量，第三方包的下载将通过国内镜像，避免出现官方网址被屏蔽的问题。</p><pre><code class="bash">$ go env -w GOPROXY=https://goproxy.cn,direct</code></pre><p>或在 <code>~/.profile</code> 中设置环境变量</p><pre><code class="bash">export GOPROXY=https://goproxy.cn</code></pre><h2 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2 Hello World"></a>2 Hello World</h2><p>新建一个文件 <code>main.go</code>，写入</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    fmt.Println(&quot;Hello World!&quot;)&#125;</code></pre><p>执行<code>go run main.go</code> 或 <code>go run .</code>，将会输出</p><pre><code class="bash">$ go run .Hello World!</code></pre><blockquote><p>如果强制启用了 Go Modules 机制，即环境变量中设置了 GO111MODULE=on，则需要先初始化模块 go mod init hello<br>否则会报错误：go: cannot find main module; see ‘go help modules’</p></blockquote><p>我们的第一个 Go 程序就完成了，接下来我们逐行来解读这个程序：</p><ul><li>package main：声明了 main.go 所在的包，Go 语言中使用包来组织代码。一般一个文件夹即一个包，包内可以暴露类型或方法供其他包使用。</li><li>import “fmt”：fmt 是 Go 语言的一个标准库/包，用来处理标准输入输出。</li><li>func main：main 函数是整个程序的入口，main 函数所在的包名也必须为 <code>main</code>。</li><li>fmt.Println(“Hello World!”)：调用 fmt 包的 Println 方法，打印出 “Hello World!”</li></ul><p>go run main.go，其实是 2 步：</p><ul><li>go build main.go：编译成二进制可执行程序</li><li>./main：执行该程序</li></ul><h2 id="3-变量与内置数据类型"><a href="#3-变量与内置数据类型" class="headerlink" title="3 变量与内置数据类型"></a>3 变量与内置数据类型</h2><h3 id="3-1-变量-Variable"><a href="#3-1-变量-Variable" class="headerlink" title="3.1 变量(Variable)"></a>3.1 变量(Variable)</h3><p>Go 语言是静态类型的，变量声明时必须明确变量的类型。Go 语言与其他语言显著不同的一个地方在于，Go 语言的类型在变量后面。比如 java 中，声明一个整体一般写成 <code>int a = 1</code>，在 Go 语言中，需要这么写：</p><pre><code class="go">var a int // 如果没有赋值，默认为0var a int = 1 // 声明时赋值var a = 1 // 声明时赋值</code></pre><p><code>var a = 1</code>，因为 1 是 int 类型的，所以赋值时，a 自动被确定为 int 类型，所以类型名可以省略不写，这种方式还有一种更简单的表达：</p><pre><code class="go">a := 1msg := &quot;Hello World!&quot;</code></pre><h3 id="3-2-简单类型"><a href="#3-2-简单类型" class="headerlink" title="3.2 简单类型"></a>3.2 简单类型</h3><p>空值：nil</p><p>整型类型： int(取决于操作系统), int8, int16, int32, int64, uint8, uint16, …</p><p>浮点数类型：float32, float64</p><p>字节类型：byte (等价于uint8)</p><p>字符串类型：string</p><p>布尔值类型：boolean，(true 或 false)</p><pre><code class="go">var a int8 = 10var c1 byte = &#39;a&#39;var b float32 = 12.2var msg = &quot;Hello World&quot;ok := false</code></pre><h3 id="3-3-字符串"><a href="#3-3-字符串" class="headerlink" title="3.3 字符串"></a>3.3 字符串</h3><p>在 Go 语言中，字符串使用 UTF8 编码，UTF8 的好处在于，如果基本是英文，每个字符占 1 byte，和 ASCII 编码是一样的，非常节省空间，如果是中文，一般占3字节。包含中文的字符串的处理方式与纯 ASCII 码构成的字符串有点区别。</p><p>我们看下面的例子：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;reflect&quot;)func main() &#123;    str1 := &quot;Golang&quot;    str2 := &quot;Go语言&quot;    fmt.Println(reflect.TypeOf(str2[2]).Kind()) // uint8    fmt.Println(str1[2], string(str1[2]))       // 108 l    fmt.Printf(&quot;%d %c\n&quot;, str2[2], str2[2])     // 232 è    fmt.Println(&quot;len(str2)：&quot;, len(str2))       // len(str2)： 8&#125;</code></pre><ul><li>reflect.TypeOf().Kind() 可以知道某个变量的类型，我们可以看到，字符串是以 byte 数组形式保存的，类型是 uint8，占1个 byte，打印时需要用 string 进行类型转换，否则打印的是编码值。</li><li>因为字符串是以 byte 数组的形式存储的，所以，<code>str2[2]</code> 的值并不等于<code>语</code>。str2 的长度 <code>len(str2)</code> 也不是 4，而是 8（ Go 占 2 byte，语言占 6 byte）。</li></ul><p>正确的处理方式是将 string 转为 rune 数组</p><pre><code class="go">str2 := &quot;Go语言&quot;runeArr := []rune(str2)fmt.Println(reflect.TypeOf(runeArr[2]).Kind()) // int32fmt.Println(runeArr[2], string(runeArr[2]))    // 35821 语fmt.Println(&quot;len(runeArr)：&quot;, len(runeArr))    // len(runeArr)： 4</code></pre><p>转换成 <code>[]rune</code> 类型后，字符串中的每个字符，无论占多少个字节都用 int32 来表示，因而可以正确处理中文。</p><h3 id="3-4-数组-array-与切片-slice"><a href="#3-4-数组-array-与切片-slice" class="headerlink" title="3.4 数组(array)与切片(slice)"></a>3.4 数组(array)与切片(slice)</h3><p>声明数组</p><pre><code class="go">var arr [5]int     // 一维var arr2 [5][5]int // 二维 </code></pre><p>声明时初始化</p><pre><code class="go">var arr = [5]int&#123;1, 2, 3, 4, 5&#125;// 或 arr := [5]int&#123;1, 2, 3, 4, 5&#125;</code></pre><p>使用 <code>[]</code> 索引/修改数组</p><pre><code class="go">arr := [5]int&#123;1, 2, 3, 4, 5&#125;for i := 0; i &lt; len(arr); i++ &#123;    arr[i] += 100&#125;fmt.Println(arr)  // [101 102 103 104 105]</code></pre><p>数组的长度不能改变，如果想拼接2个数组，或是获取子数组，需要使用切片。切片是数组的抽象。 切片使用数组作为底层结构。切片包含三个组件：容量，长度和指向底层数组的指针,切片可以随时进行扩展</p><p>声明切片：</p><pre><code class="go">slice1 := make([]float32, 0) // 长度为0的切片slice2 := make([]float32, 3, 5) // [0 0 0] 长度为3容量为5的切片fmt.Println(len(slice2), cap(slice2)) // 3 5</code></pre><p>使用切片：</p><pre><code class="go">// 添加元素，切片容量可以根据需要自动扩展slice2 = append(slice2, 1, 2, 3, 4) // [0, 0, 0, 1, 2, 3, 4]fmt.Println(len(slice2), cap(slice2)) // 7 12// 子切片 [start, end)sub1 := slice2[3:] // [1 2 3 4]sub2 := slice2[:3] // [0 0 0]sub3 := slice2[1:4] // [0 0 1]// 合并切片combined := append(sub1, sub2...) // [1, 2, 3, 4, 0, 0, 0]</code></pre><ul><li>声明切片时可以为切片设置容量大小，为切片预分配空间。在实际使用的过程中，如果容量不够，切片容量会自动扩展。</li><li><code>sub2...</code> 是切片解构的写法，将切片解构为 N 个独立的元素。</li></ul><h3 id="3-5-字典-键值对，map"><a href="#3-5-字典-键值对，map" class="headerlink" title="3.5 字典(键值对，map)"></a>3.5 字典(键值对，map)</h3><p>map 类似于 java 的 HashMap，Python的字典(dict)，是一种存储键值对(Key-Value)的数据解构。使用方式和其他语言几乎没有区别。</p><pre><code class="go">// 仅声明m1 := make(map[string]int)// 声明时初始化m2 := map[string]string&#123;    &quot;Sam&quot;: &quot;Male&quot;,    &quot;Alice&quot;: &quot;Female&quot;,&#125;// 赋值/修改m1[&quot;Tom&quot;] = 18</code></pre><h3 id="3-6-指针-pointer"><a href="#3-6-指针-pointer" class="headerlink" title="3.6 指针(pointer)"></a>3.6 指针(pointer)</h3><p>指针即某个值的地址，类型定义时使用符号<code>*</code>，对一个已经存在的变量，使用 <code>&amp;</code> 获取该变量的地址。</p><pre><code class="go">str := &quot;Golang&quot;var p *string = &amp;str // p 是指向 str 的指针*p = &quot;Hello&quot;fmt.Println(str) // Hello 修改了 p，str 的值也发生了改变</code></pre><p>一般来说，指针通常在函数传递参数，或者给某个类型定义新的方法时使用。Go 语言中，参数是按值传递的，如果不使用指针，函数内部将会拷贝一份参数的副本，对参数的修改并不会影响到外部变量的值。如果参数使用指针，对参数的传递将会影响到外部变量。</p><p>例如：</p><pre><code class="go">func add(num int) &#123;    num += 1&#125;func realAdd(num *int) &#123;    *num += 1&#125;func main() &#123;    num := 100    add(num)    fmt.Println(num)  // 100，num 没有变化    realAdd(&amp;num)    fmt.Println(num)  // 101，指针传递，num 被修改&#125;</code></pre><h2 id="4-流程控制-if-for-switch"><a href="#4-流程控制-if-for-switch" class="headerlink" title="4 流程控制(if, for, switch)"></a>4 流程控制(if, for, switch)</h2><h3 id="4-1-条件语句-if-else"><a href="#4-1-条件语句-if-else" class="headerlink" title="4.1 条件语句 if else"></a>4.1 条件语句 if else</h3><pre><code class="go">age := 18if age &lt; 18 &#123;    fmt.Printf(&quot;Kid&quot;)&#125; else &#123;    fmt.Printf(&quot;Adult&quot;)&#125;// 可以简写为：if age := 18; age &lt; 18 &#123;    fmt.Printf(&quot;Kid&quot;)&#125; else &#123;    fmt.Printf(&quot;Adult&quot;)&#125;</code></pre><h3 id="4-2-switch"><a href="#4-2-switch" class="headerlink" title="4.2 switch"></a>4.2 switch</h3><pre><code class="go">type Gender int8const (    MALE   Gender = 1    FEMALE Gender = 2)gender := MALEswitch gender &#123;case FEMALE:    fmt.Println(&quot;female&quot;)case MALE:    fmt.Println(&quot;male&quot;)default:    fmt.Println(&quot;unknown&quot;)&#125;// male</code></pre><ul><li>在这里，使用了<code>type</code> 关键字定义了一个新的类型 Gender。</li><li>使用 const 定义了 MALE 和 FEMALE 2 个常量，Go 语言中没有枚举(enum)的概念，一般可以用常量的方式来模拟枚举。</li><li>和其他语言不同的地方在于，Go 语言的 switch 不需要 break，匹配到某个 case，执行完该 case 定义的行为后，默认不会继续往下执行。如果需要继续往下执行，需要使用 fallthrough，例如：</li></ul><pre><code class="go">switch gender &#123;case FEMALE:    fmt.Println(&quot;female&quot;)    fallthroughcase MALE:    fmt.Println(&quot;male&quot;)    fallthroughdefault:    fmt.Println(&quot;unknown&quot;)&#125;// 输出结果// male// unknown</code></pre><h3 id="4-3-for-循环"><a href="#4-3-for-循环" class="headerlink" title="4.3 for 循环"></a>4.3 for 循环</h3><p>一个简单的累加的例子，break 和 continue 的用法与其他语言没有区别。</p><pre><code class="go">sum := 0for i := 0; i &lt; 10; i++ &#123;    if sum &gt; 50 &#123;        break    &#125;    sum += i&#125;</code></pre><p>对数组(arr)、切片(slice)、字典(map) 使用 for range 遍历：</p><pre><code class="go">nums := []int&#123;10, 20, 30, 40&#125;for i, num := range nums &#123;    fmt.Println(i, num)&#125;// 0 10// 1 20// 2 30// 3 40m2 := map[string]string&#123;    &quot;Sam&quot;:   &quot;Male&quot;,    &quot;Alice&quot;: &quot;Female&quot;,&#125;for key, value := range m2 &#123;    fmt.Println(key, value)&#125;// Sam Male// Alice Female</code></pre><h2 id="5-函数-functions"><a href="#5-函数-functions" class="headerlink" title="5 函数(functions)"></a>5 函数(functions)</h2><h3 id="5-1-参数与返回值"><a href="#5-1-参数与返回值" class="headerlink" title="5.1 参数与返回值"></a>5.1 参数与返回值</h3><p>一个典型的函数定义如下，使用关键字 <code>func</code>，参数可以有多个，返回值也支持有多个。特别地，<code>package main</code> 中的<code>func main()</code> 约定为可执行程序的入口。</p><pre><code class="go">func funcName(param1 Type1, param2 Type2, ...) (return1 Type3, ...) &#123;    // body&#125;</code></pre><p>例如，实现2个数的加法（一个返回值）和除法（多个返回值）：</p><pre><code class="go">func add(num1 int, num2 int) int &#123;    return num1 + num2&#125;func div(num1 int, num2 int) (int, int) &#123;    return num1 / num2, num1 % num2&#125;func main() &#123;    quo, rem := div(100, 17)    fmt.Println(quo, rem)     // 5 15    fmt.Println(add(100, 17)) // 117&#125;</code></pre><p>也可以给返回值命名，简化 return，例如 add 函数可以改写为</p><pre><code class="go">func add(num1 int, num2 int) (ans int) &#123;    ans = num1 + num2    return&#125;</code></pre><h3 id="5-2-错误处理-error-handling"><a href="#5-2-错误处理-error-handling" class="headerlink" title="5.2 错误处理(error handling)"></a>5.2 错误处理(error handling)</h3><p>如果函数实现过程中，如果出现不能处理的错误，可以返回给调用者处理。比如我们调用标准库函数<code>os.Open</code>读取文件，<code>os.Open</code> 有2个返回值，第一个是 <code>*File</code>，第二个是 <code>error</code>， 如果调用成功，error 的值是 nil，如果调用失败，例如文件不存在，我们可以通过 error 知道具体的错误信息。</p><pre><code class="go">import (    &quot;fmt&quot;    &quot;os&quot;)func main() &#123;    _, err := os.Open(&quot;filename.txt&quot;)    if err != nil &#123;        fmt.Println(err)    &#125;&#125;// open filename.txt: no such file or directory</code></pre><p>可以通过 <code>errorw.New</code> 返回自定义的错误</p><pre><code class="go">import (    &quot;errors&quot;    &quot;fmt&quot;)func hello(name string) error &#123;    if len(name) == 0 &#123;        return errors.New(&quot;error: name is null&quot;)    &#125;    fmt.Println(&quot;Hello,&quot;, name)    return nil&#125;func main() &#123;    if err := hello(&quot;&quot;); err != nil &#123;        fmt.Println(err)    &#125;&#125;// error: name is null</code></pre><p>error 往往是能预知的错误，但是也可能出现一些不可预知的错误，例如数组越界，这种错误可能会导致程序非正常退出，在 Go 语言中称之为 panic。</p><pre><code class="go">func get(index int) int &#123;    arr := [3]int&#123;2, 3, 4&#125;    return arr[index]&#125;func main() &#123;    fmt.Println(get(5))    fmt.Println(&quot;finished&quot;)&#125;</code></pre><pre><code class="bash">$ go run .panic: runtime error: index out of range [5] with length 3goroutine 1 [running]:exit status 2</code></pre><p>在 Python、Java 等语言中有 <code>try...catch</code> 机制，在 <code>try</code> 中捕获各种类型的异常，在 <code>catch</code> 中定义异常处理的行为。Go 语言也提供了类似的机制 <code>defer</code> 和 <code>recover</code>。</p><pre><code class="go">func get(index int) (ret int) &#123;    defer func() &#123;        if r := recover(); r != nil &#123;            fmt.Println(&quot;Some error happened!&quot;, r)            ret = -1        &#125;    &#125;()    arr := [3]int&#123;2, 3, 4&#125;    return arr[index]&#125;func main() &#123;    fmt.Println(get(5))    fmt.Println(&quot;finished&quot;)&#125;</code></pre><pre><code class="bash">$ go run .Some error happened! runtime error: index out of range [5] with length 3-1finished</code></pre><ul><li>在 get 函数中，使用 defer 定义了异常处理的函数，在协程退出前，会执行完 defer 挂载的任务。因此如果触发了 panic，控制权就交给了 defer。</li><li>在 defer 的处理逻辑中，使用 recover，使程序恢复正常，并且将返回值设置为 -1，在这里也可以不处理返回值，如果不处理返回值，返回值将被置为默认值 0。</li></ul><h2 id="6-结构体，方法和接口"><a href="#6-结构体，方法和接口" class="headerlink" title="6 结构体，方法和接口"></a>6 结构体，方法和接口</h2><h3 id="6-1-结构体-struct-和方法-methods"><a href="#6-1-结构体-struct-和方法-methods" class="headerlink" title="6.1 结构体(struct) 和方法(methods)"></a>6.1 结构体(struct) 和方法(methods)</h3><p>结构体类似于其他语言中的 class，可以在结构体中定义多个字段，为结构体实现方法，实例化等。接下来我们定义一个结构体 Student，并为 Student 添加 name，age 字段，并实现 <code>hello()</code> 方法。</p><pre><code class="go">type Student struct &#123;    name string    age  int&#125;func (stu *Student) hello(person string) string &#123;    return fmt.Sprintf(&quot;hello %s, I am %s&quot;, person, stu.name)&#125;func main() &#123;    stu := &amp;Student&#123;        name: &quot;Tom&quot;,    &#125;    msg := stu.hello(&quot;Jack&quot;)    fmt.Println(msg) // hello Jack, I am Tom&#125;</code></pre><ul><li>使用 <code>Student&#123;field: value, ...&#125;</code>的形式创建 Student 的实例，字段不需要每个都赋值，没有显性赋值的变量将被赋予默认值，例如 age 将被赋予默认值 0。</li><li>实现方法与实现函数的区别在于，<code>func</code> 和函数名<code>hello</code> 之间，加上该方法对应的实例名 <code>stu</code> 及其类型 <code>*Student</code>，可以通过实例名访问该实例的字段<code>name</code>和其他方法了。</li><li>调用方法通过 <code>实例名.方法名(参数)</code> 的方式。</li></ul><p>除此之外，还可以使用 <code>new</code> 实例化：</p><pre><code class="go">func main() &#123;    stu2 := new(Student)    fmt.Println(stu2.hello(&quot;Alice&quot;)) // hello Alice, I am  , name 被赋予默认值&quot;&quot;&#125;</code></pre><h3 id="6-2-接口-interfaces"><a href="#6-2-接口-interfaces" class="headerlink" title="6.2 接口(interfaces)"></a>6.2 接口(interfaces)</h3><p>一般而言，接口定义了一组方法的集合，接口不能被实例化，一个类型可以实现多个接口。</p><p>举一个简单的例子，定义一个接口 <code>Person</code>和对应的方法 <code>getName()</code> 和 <code>getAge()</code>：</p><pre><code class="go">type Person interface &#123;    getName() string&#125;type Student struct &#123;    name string    age  int&#125;func (stu *Student) getName() string &#123;    return stu.name&#125;type Worker struct &#123;    name   string    gender string&#125;func (w *Worker) getName() string &#123;    return w.name&#125;func main() &#123;    var p Person = &amp;Student&#123;        name: &quot;Tom&quot;,        age:  18,    &#125;    fmt.Println(p.getName()) // Tom&#125;</code></pre><ul><li>Go 语言中，并不需要显式地声明实现了哪一个接口，只需要直接实现该接口对应的方法即可。</li><li>实例化 <code>Student</code>后，强制类型转换为接口类型 Person。</li></ul><p>在上面的例子中，我们在 main 函数中尝试将 Student 实例类型转换为 Person，如果 Student 没有完全实现 Person 的方法，比如我们将 <code>(*Student).getName()</code> 删掉，编译时会出现如下报错信息。</p><pre><code class="bash"> *Student does not implement Person (missing getName method)</code></pre><p>但是删除 <code>(*Worker).getName()</code> 程序并不会报错，因为我们并没有在 main 函数中使用。这种情况下我们如何确保某个类型实现了某个接口的所有方法呢？一般可以使用下面的方法进行检测，如果实现不完整，编译期将会报错。</p><pre><code class="go">var _ Person = (*Student)(nil)var _ Person = (*Worker)(nil)</code></pre><ul><li>将空值 nil 转换为 *Student 类型，再转换为 Person 接口，如果转换失败，说明 Student 并没有实现 Person 接口的所有方法。</li><li>Worker 同上。</li></ul><p>实例可以强制类型转换为接口，接口也可以强制类型转换为实例。</p><pre><code class="go">func main() &#123;    var p Person = &amp;Student&#123;        name: &quot;Tom&quot;,        age:  18,    &#125;    stu := p.(*Student) // 接口转为实例    fmt.Println(stu.getAge())&#125;</code></pre><h3 id="6-3-空接口"><a href="#6-3-空接口" class="headerlink" title="6.3 空接口"></a>6.3 空接口</h3><p>如果定义了一个没有任何方法的空接口，那么这个接口可以表示任意类型。例如</p><pre><code class="go">func main() &#123;    m := make(map[string]interface&#123;&#125;)    m[&quot;name&quot;] = &quot;Tom&quot;    m[&quot;age&quot;] = 18    m[&quot;scores&quot;] = [3]int&#123;98, 99, 85&#125;    fmt.Println(m) // map[age:18 name:Tom scores:[98 99 85]]&#125;</code></pre><h2 id="7-并发编程-goroutine"><a href="#7-并发编程-goroutine" class="headerlink" title="7 并发编程(goroutine)"></a>7 并发编程(goroutine)</h2><h3 id="7-1-sync"><a href="#7-1-sync" class="headerlink" title="7.1 sync"></a>7.1 sync</h3><p>Go 语言提供了 sync 和 channel 两种方式支持协程(goroutine)的并发。</p><p>例如我们希望并发下载 N 个资源，多个并发协程之间不需要通信，那么就可以使用 sync.WaitGroup，等待所有并发协程执行结束。</p><pre><code class="go">import (    &quot;fmt&quot;    &quot;sync&quot;    &quot;time&quot;)var wg sync.WaitGroupfunc download(url string) &#123;    fmt.Println(&quot;start to download&quot;, url)    time.Sleep(time.Second) // 模拟耗时操作    wg.Done()&#125;func main() &#123;    for i := 0; i &lt; 3; i++ &#123;        wg.Add(1)        go download(&quot;a.com/&quot; + string(i+&#39;0&#39;))    &#125;    wg.Wait()    fmt.Println(&quot;Done!&quot;)&#125;</code></pre><ul><li>wg.Add(1)：为 wg 添加一个计数，wg.Done()，减去一个计数。</li><li>go download()：启动新的协程并发执行 download 函数。</li><li>wg.Wait()：等待所有的协程执行结束。</li></ul><pre><code class="bash">$  time go run .start to download a.com/2start to download a.com/0start to download a.com/1Done!real    0m1.563s</code></pre><p>可以看到串行需要 3s 的下载操作，并发后，只需要 1s。</p><h3 id="7-2-channel"><a href="#7-2-channel" class="headerlink" title="7.2 channel"></a>7.2 channel</h3><pre><code class="go">var ch = make(chan string, 10) // 创建大小为 10 的缓冲信道func download(url string) &#123;    fmt.Println(&quot;start to download&quot;, url)    time.Sleep(time.Second)    ch &lt;- url // 将 url 发送给信道&#125;func main() &#123;    for i := 0; i &lt; 3; i++ &#123;        go download(&quot;a.com/&quot; + string(i+&#39;0&#39;))    &#125;    for i := 0; i &lt; 3; i++ &#123;        msg := &lt;-ch // 等待信道返回消息。        fmt.Println(&quot;finish&quot;, msg)    &#125;    fmt.Println(&quot;Done!&quot;)&#125;</code></pre><p>使用 channel 信道，可以在协程之间传递消息。阻塞等待并发协程返回消息。</p><pre><code class="bash">$ time go run .start to download a.com/2start to download a.com/0start to download a.com/1finish a.com/2finish a.com/1finish a.com/0Done!real    0m1.528s</code></pre><h2 id="8-单元测试-unit-test"><a href="#8-单元测试-unit-test" class="headerlink" title="8 单元测试(unit test)"></a>8 单元测试(unit test)</h2><p>假设我们希望测试 package main 下 <code>calc.go</code> 中的函数，要只需要新建 <code>calc_test.go</code> 文件，在<code>calc_test.go</code>中新建测试用例即可。</p><pre><code class="go">// calc.gopackage mainfunc add(num1 int, num2 int) int &#123;    return num1 + num2&#125;</code></pre><pre><code class="go">// calc_test.gopackage mainimport &quot;testing&quot;func TestAdd(t *testing.T) &#123;    if ans := add(1, 2); ans != 3 &#123;        t.Error(&quot;add(1, 2) should be equal to 3&quot;)    &#125;&#125;</code></pre><p>运行 <code>go test</code>，将自动运行当前 package 下的所有测试用例，如果需要查看详细的信息，可以添加<code>-v</code>参数。</p><pre><code class="bash">$ go test -v=== RUN   TestAdd--- PASS: TestAdd (0.00s)PASSok      example 0.040s</code></pre><h2 id="9-包-Package-和模块-Modules"><a href="#9-包-Package-和模块-Modules" class="headerlink" title="9 包(Package)和模块(Modules)"></a>9 包(Package)和模块(Modules)</h2><h3 id="9-1-Package"><a href="#9-1-Package" class="headerlink" title="9.1 Package"></a>9.1 Package</h3><p>一般来说，一个文件夹可以作为 package，同一个 package 内部变量、类型、方法等定义可以相互看到。</p><p>比如我们新建一个文件 <code>calc.go</code>， <code>main.go</code> 平级，分别定义 add 和 main 方法。</p><pre><code class="go">// calc.gopackage mainfunc add(num1 int, num2 int) int &#123;    return num1 + num2&#125;</code></pre><pre><code class="go">// main.gopackage mainimport &quot;fmt&quot;func main() &#123;    fmt.Println(add(3, 5)) // 8&#125;</code></pre><p>运行 <code>go run main.go</code>，会报错，add 未定义：</p><pre><code class="bash">./main.go:6:14: undefined: add</code></pre><p>因为 <code>go run main.go</code> 仅编译 main.go 一个文件，所以命令需要换成 </p><pre><code class="bash">$ go run main.go calc.go8</code></pre><p>或 </p><pre><code class="bash">$ go run .8</code></pre><p>Go 语言也有 Public 和 Private 的概念，粒度是包。如果类型/接口/方法/函数/字段的首字母大写，则是 Public 的，对其他 package 可见，如果首字母小写，则是 Private 的，对其他 package 不可见。</p><h3 id="9-2-Modules"><a href="#9-2-Modules" class="headerlink" title="9.2 Modules"></a>9.2 Modules</h3><p><a href="https://github.com/golang/go/wiki/Modules">Go Modules</a> 是 Go 1.11 版本之后引入的，Go 1.11 之前使用 $GOPATH 机制。Go Modules 可以算作是较为完善的包管理工具。同时支持代理，国内也能享受高速的第三方包镜像服务。接下来简单介绍 <code>go mod</code> 的使用。Go Modules 在 1.13 版本仍是可选使用的，环境变量 GO111MODULE 的值默认为 AUTO，强制使用 Go Modules 进行依赖管理，可以将 GO111MODULE 设置为 ON。</p><p>在一个空文件夹下，初始化一个 Module</p><pre><code class="bash">$ go mod init examplego: creating new go.mod: module example</code></pre><p>此时，在当前文件夹下生成了<code>go.mod</code>，这个文件记录当前模块的模块名以及所有依赖包的版本。</p><p>接着，我们在当前目录下新建文件 <code>main.go</code>，添加如下代码：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;rsc.io/quote&quot;)func main() &#123;    fmt.Println(quote.Hello())  // Ahoy, world!&#125;</code></pre><p>运行 <code>go run .</code>，将会自动触发第三方包 <code>rsc.io/quote</code>的下载，具体的版本信息也记录在了<code>go.mod</code>中：</p><pre><code class="bash">module examplego 1.13require rsc.io/quote v3.1.0+incompatible</code></pre><p>我们在当前目录，添加一个子 package calc，代码目录如下：</p><pre><code class="bash">demo/   |--calc/      |--calc.go   |--main.go</code></pre><p>在 <code>calc.go</code> 中写入</p><pre><code class="go">package calcfunc Add(num1 int, num2 int) int &#123;    return num1 + num2&#125;</code></pre><p>在 package main 中如何使用 package cal 中的 Add 函数呢？<code>import 模块名/子目录名</code> 即可，修改后的 main 函数如下：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;example/calc&quot;    &quot;rsc.io/quote&quot;)func main() &#123;    fmt.Println(quote.Hello())    fmt.Println(calc.Add(10, 3))&#125;</code></pre><pre><code class="bash">$ go run .Ahoy, world!13</code></pre><h2 id="附-参考"><a href="#附-参考" class="headerlink" title="附 参考"></a>附 参考</h2><ul><li><a href="https://golang.org/">golang 官方文档 - golang.org</a></li><li><a href="https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md">goproxy.cn 文档 - github.com</a></li><li><a href="https://github.com/golang/go/wiki/Modules">Go Modules - github.com</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114701.jpg&quot; alt=&quot;Golang中文教程&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Go（又称Golang）是Go</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Go语言" scheme="https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Go语言程序设计" scheme="https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Go语言教程中文版" scheme="https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%E4%B8%AD%E6%96%87%E7%89%88/"/>
    
  </entry>
  
  <entry>
    <title>Go Mmap 文件内存映射简明教程</title>
    <link href="https://ysluckly.github.io/2022/02/11/go/"/>
    <id>https://ysluckly.github.io/2022/02/11/go/</id>
    <published>2022-02-11T13:59:10.000Z</published>
    <updated>2022-02-20T13:36:11.469Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114728.jpg" alt="golang mmap"></p><h2 id="1-mmap-简介"><a href="#1-mmap-简介" class="headerlink" title="1 mmap 简介"></a>1 mmap 简介</h2><blockquote><p>In computing, mmap is a POSIX-compliant Unix system call that maps files or devices into memory. It is a method of memory-mapped file I/O.<br>– <a href="https://en.wikipedia.org/wiki/Mmap">mmap - wikipedia.org</a></p></blockquote><p>简单理解，mmap 是一种将文件/设备映射到内存的方法，实现文件的磁盘地址和进程虚拟地址空间中的一段虚拟地址的一一映射关系。也就是说，可以在某个进程中通过操作这一段映射的内存，实现对文件的读写等操作。修改了这一段内存的内容，文件对应位置的内容也会同步修改，而读取这一段内存的内容，相当于读取文件对应位置的内容。</p><p>mmap 另一个非常重要的特性是：减少内存的拷贝次数。在 linux 系统中，文件的读写操作通常通过 read 和 write 这两个系统调用来实现，这个过程会产生频繁的内存拷贝。比如 read 函数就涉及了 2 次内存拷贝：</p><ul><li><ol><li>操作系统读取磁盘文件到页缓存；</li></ol></li><li><ol start="2"><li>从页缓存将数据拷贝到 read 传递的 buf 中(例如进程中创建的byte数组)。</li></ol></li></ul><p>mmap 只需要一次拷贝。即操作系统读取磁盘文件到页缓存，进程内部直接通过指针方式修改映射的内存。因此 mmap 特别适合读写频繁的场景，既减少了内存拷贝次数，提高效率，又简化了操作。KV数据库 <a href="https://github.com/etcd-io/bbolt">bbolt</a> 就使用了这个方法持久化数据。</p><h2 id="2-标准库-mmap"><a href="#2-标准库-mmap" class="headerlink" title="2 标准库 mmap"></a>2 标准库 mmap</h2><p>Go 语言标准库 <a href="https://godoc.org/golang.org/x/exp/mmap">golang.org/x/exp/mmap</a> 仅实现了 read 操作，后续能否支持 write 操作未知。使用场景非常有限。看一个简单的例子：</p><p>从第4个byte开始，读取 tmp.txt 2个byte的内容。</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;golang.org/x/exp/mmap&quot;)func main() &#123;    at, _ := mmap.Open(&quot;./tmp.txt&quot;)    buff := make([]byte, 2)    _, _ = at.ReadAt(buff, 4)    _ = at.Close()    fmt.Println(string(buff))&#125;</code></pre><pre><code class="bash">$ echo &quot;abcdefg&quot; &gt; tmp.txt$ go run .ef</code></pre><p>如果使用 <code>os.File</code> 操作，代码几乎是一样的，<code>os.File</code> 还支持写操作 <code>WriteAt</code>：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;os&quot;)func main() &#123;    f, _ := os.OpenFile(&quot;tmp.txt&quot;, os.O_CREATE|os.O_RDWR, 0644)    _, _ = f.WriteAt([]byte(&quot;abcdefg&quot;), 0)    buff := make([]byte, 2)    _, _ = f.ReadAt(buff, 4)    _ = f.Close()    fmt.Println(string(buff))&#125;</code></pre><h2 id="3-mmap-linux"><a href="#3-mmap-linux" class="headerlink" title="3 mmap(linux)"></a>3 mmap(linux)</h2><p>如果要支持 write 操作，那么就需要直接调用 mmap 的系统调用来实现了。Linux 和 Windows 都支持 mmap，但接口有所不同。对于 linux 系统，mmap 方法定义如下：</p><pre><code class="go">func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, err error)</code></pre><p>每个参数的含义分别是：</p><pre><code class="go">- fd：待映射的文件描述符。- offset：映射到内存区域的起始位置，0 表示由内核指定内存地址。- length：要映射的内存区域的大小。- prot：内存保护标志位，可以通过或运算符`|`组合    - PROT_EXEC  // 页内容可以被执行    - PROT_READ  // 页内容可以被读取    - PROT_WRITE // 页可以被写入    - PROT_NONE  // 页不可访问- flags：映射对象的类型，常用的是以下两类    - MAP_SHARED  // 共享映射，写入数据会复制回文件, 与映射该文件的其他进程共享。    - MAP_PRIVATE // 建立一个写入时拷贝的私有映射，写入数据不影响原文件。</code></pre><p>首先定义2个常量和数据类型Demo：</p><pre><code class="go">const defaultMaxFileSize = 1 &lt;&lt; 30        // 假设文件最大为 1Gconst defaultMemMapSize = 128 * (1 &lt;&lt; 20) // 假设映射的内存大小为 128Mtype Demo struct &#123;    file    *os.File    data    *[defaultMaxFileSize]byte    dataRef []byte&#125;func _assert(condition bool, msg string, v ...interface&#123;&#125;) &#123;    if !condition &#123;        panic(fmt.Sprintf(msg, v...))    &#125;&#125;</code></pre><ul><li>内存有换页机制，映射的物理内存可以远小于文件。</li><li>Demo结构体由3个字段构成，file 即文件描述符，data 是映射内存的起始地址，dataRef 用于后续取消映射。</li></ul><p>定义 mmap, grow, ummap 三个方法：</p><pre><code class="go">func (demo *Demo) mmap() &#123;    b, err := syscall.Mmap(int(demo.file.Fd()), 0, defaultMemMapSize, syscall.PROT_WRITE|syscall.PROT_READ, syscall.MAP_SHARED)    _assert(err == nil, &quot;failed to mmap&quot;, err)    demo.dataRef = b    demo.data = (*[defaultMaxFileSize]byte)(unsafe.Pointer(&amp;b[0]))&#125;func (demo *Demo) grow(size int64) &#123;    if info, _ := demo.file.Stat(); info.Size() &gt;= size &#123;        return    &#125;    _assert(demo.file.Truncate(size) == nil, &quot;failed to truncate&quot;)&#125;func (demo *Demo) munmap() &#123;    _assert(syscall.Munmap(demo.dataRef) == nil, &quot;failed to munmap&quot;)    demo.data = nil    demo.dataRef = nil&#125;</code></pre><ul><li>mmap 传入的内存保护标志位为 <code>syscall.PROT_WRITE|syscall.PROT_READ</code>，即可读可写，映射类型为 <code>syscall.MAP_SHARED</code>，即对内存的修改会同步到文件。</li><li><code>syscall.Mmap</code> 返回的是一个切片对象，需要从该切片中获取到内存的起始地址，并转换为可操作的 byte 数组，byte数组的长度为 <code>defaultMaxFileSize</code>。</li><li>grow 用于修改文件的大小，Linux 不允许操作超过文件大小之外的内存地址。例如文件大小为 4K，可访问的地址是<code>data[0~4095]</code>，如果访问 <code>data[10000]</code> 会报错。</li><li>munmap 用于取消映射。</li></ul><p>在文件中写入 <code>hello, geektutu!</code></p><pre><code class="go">func main() &#123;    _ = os.Remove(&quot;tmp.txt&quot;)    f, _ := os.OpenFile(&quot;tmp.txt&quot;, os.O_CREATE|os.O_RDWR, 0644)    demo := &amp;Demo&#123;file: f&#125;    demo.grow(1)    demo.mmap()    defer demo.munmap()    msg := &quot;hello geektutu!&quot;    demo.grow(int64(len(msg) * 2))    for i, v := range msg &#123;        demo.data[2*i] = byte(v)        demo.data[2*i+1] = byte(&#39; &#39;)    &#125;&#125;</code></pre><ul><li>在调用 <code>mmap</code> 之前，调用了 <code>grow(1)</code>，因为在 <code>mmap</code> 中使用 <code>&amp;b[0]</code> 获取到映射内存的起始地址，所以文件大小至少为 1 byte。</li><li>接下来，便是通过直接操作 <code>demo.data</code>，修改文件内容了。</li></ul><p>运行：</p><pre><code class="bash">$ go run .$ cat tmp.txth e l l o   g e e k t u t u !</code></pre><h2 id="4-mmap-Windows"><a href="#4-mmap-Windows" class="headerlink" title="4 mmap(Windows)"></a>4 mmap(Windows)</h2><p>相对于 Linux，Windows 上 mmap 的使用要复杂一些。</p><pre><code class="go">func (demo *Demo) mmap() &#123;    h, err := syscall.CreateFileMapping(syscall.Handle(demo.file.Fd()), nil, syscall.PAGE_READWRITE, 0, defaultMemMapSize, nil)    _assert(h != 0, &quot;failed to map&quot;, err)    addr, err := syscall.MapViewOfFile(h, syscall.FILE_MAP_WRITE, 0, 0, uintptr(defaultMemMapSize))    _assert(addr != 0, &quot;MapViewOfFile failed&quot;, err)    err = syscall.CloseHandle(syscall.Handle(h));    _assert(err == nil, &quot;CloseHandle failed&quot;)    // Convert to a byte array.    demo.data = (*[defaultMaxFileSize]byte)(unsafe.Pointer(addr))&#125;func (demo *Demo) munmap() &#123;    addr := (uintptr)(unsafe.Pointer(&amp;demo.data[0]))    _assert(syscall.UnmapViewOfFile(addr) == nil, &quot;failed to munmap&quot;)&#125;</code></pre><ul><li>需要 <code>CreateFileMapping</code> 和 <code>MapViewOfFile</code> 两步才能完成内存映射。<code>MapViewOfFile</code> 返回映射成功的内存地址，因此可以直接将该地址转换成 byte 数组。</li><li>Windows 对文件的大小没有要求，直接操作内存<code>data</code>，文件大小会自动发生改变。</li></ul><p>使用时无需关注文件的大小。</p><pre><code class="go">func main() &#123;    _ = os.Remove(&quot;tmp.txt&quot;)    f, _ := os.OpenFile(&quot;tmp.txt&quot;, os.O_CREATE|os.O_RDWR, 0644)    demo := &amp;Demo&#123;file: f&#125;    demo.mmap()    defer demo.munmap()    msg := &quot;hello geektutu!&quot;    for i, v := range msg &#123;        demo.data[2*i] = byte(v)        demo.data[2*i+1] = byte(&#39; &#39;)    &#125;&#125;</code></pre><pre><code class="go">$ go run .$ cat .\tmp.txth e l l o   g e e k t u t u !</code></pre><h2 id="附-参考"><a href="#附-参考" class="headerlink" title="附 参考"></a>附 参考</h2><ul><li><a href="https://github.com/edsrzf/mmap-go">edsrzf/mmap-go - github.com</a></li><li><a href="https://golang.org/pkg/syscall/">golang 官方文档 syscall - golang.org</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114728.jpg&quot; alt=&quot;golang mmap&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-mmap-简介&quot;&gt;&lt;a href=&quot;#1</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="golang" scheme="https://ysluckly.github.io/tags/golang/"/>
    
    <category term="mmap" scheme="https://ysluckly.github.io/tags/mmap/"/>
    
    <category term="memory mapping" scheme="https://ysluckly.github.io/tags/memory-mapping/"/>
    
    <category term="windows" scheme="https://ysluckly.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>休闲娱乐-小游戏</title>
    <link href="https://ysluckly.github.io/2022/02/02/gamesh/"/>
    <id>https://ysluckly.github.io/2022/02/02/gamesh/</id>
    <published>2022-02-01T17:00:10.000Z</published>
    <updated>2022-02-20T13:54:25.410Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>休闲小游戏是小游戏的一种。一般都是在看技术博客累的时候玩的，后来发展成网页游戏。并成为网络游戏集，并加以利用加入网络等元素，可以和网友进行比拼，使得休闲小游戏得以发展。</p></blockquote><h4 id="①、2048-小游戏-点击进入…"><a href="#①、2048-小游戏-点击进入…" class="headerlink" title="①、2048-小游戏 | 点击进入…"></a>①、2048-小游戏 | <a href="https://ysluckly.github.io/games/2048/index.html">点击进入…</a></h4><h4 id="②、五子棋-小游戏-点击进入…"><a href="#②、五子棋-小游戏-点击进入…" class="headerlink" title="②、五子棋- 小游戏 | 点击进入…"></a>②、五子棋- 小游戏 | <a href="https://ysluckly.github.io/games/gobang/index.html">点击进入…</a></h4><h4 id="③、圈小猫-小游戏-点击进入…"><a href="#③、圈小猫-小游戏-点击进入…" class="headerlink" title="③、圈小猫-小游戏 | 点击进入…"></a>③、圈小猫-小游戏 | <a href="https://ysluckly.github.io/games/cat/index.html">点击进入…</a></h4><h4 id="④、3D元素周期表-小游戏-点击进入…"><a href="#④、3D元素周期表-小游戏-点击进入…" class="headerlink" title="④、3D元素周期表-小游戏 | 点击进入…"></a>④、3D元素周期表-小游戏 | <a href="https://ysluckly.github.io/games/element/index.html">点击进入…</a></h4><h4 id="⑤、弹钢琴-小游戏-点击进入…"><a href="#⑤、弹钢琴-小游戏-点击进入…" class="headerlink" title="⑤、弹钢琴-小游戏 | 点击进入…"></a>⑤、弹钢琴-小游戏 | <a href="https://ysluckly.github.io/games/piano/index.html">点击进入…</a></h4><h4 id="⑥、吃豆人-小游戏-点击进入…"><a href="#⑥、吃豆人-小游戏-点击进入…" class="headerlink" title="⑥、吃豆人-小游戏 | 点击进入…"></a>⑥、吃豆人-小游戏 | <a href="https://ysluckly.github.io/games/PacMan/index.html">点击进入…</a></h4>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;休闲小游戏是小游戏的一种。一般都是在看技术博客累的时候玩的，后来发展成网页游戏。并成为网络游戏集，并加以利用加入网络等元素，可以和网友进行比拼，使得休闲小游戏得以发展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;①、2048-小游戏-点击</summary>
      
    
    
    
    <category term="工具" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="game" scheme="https://ysluckly.github.io/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 有这一篇就够（呕心狂敲37k字，只为博君一点赞！！！）</title>
    <link href="https://ysluckly.github.io/2022/01/31/mysql/"/>
    <id>https://ysluckly.github.io/2022/01/31/mysql/</id>
    <published>2022-01-31T07:29:32.000Z</published>
    <updated>2022-02-25T15:57:17.872Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li>  <a href="about:blank#_5">前言</a></li><li>  <a href="about:blank#SQL_9">一、SQL简述</a></li><li><ul><li><a href="about:blank#1SQL_10">1.SQL的概述</a><ul><li>  <a href="about:blank#2SQL_12">2.SQL的优点</a></li><li>  <a href="about:blank#3SQL_16">3.SQL的分类</a></li></ul></li></ul></li><li>  <a href="about:blank#_25">二、数据库的三大范式</a></li><li>  <a href="about:blank#_29">三、数据库的数据类型</a></li><li><ul><li><a href="about:blank#1_31">1.整数类型</a><ul><li>  <a href="about:blank#2_40">2.浮点数类型和定点数类型</a></li><li>  <a href="about:blank#3_49">3.字符串类型</a></li><li>  <a href="about:blank#4_60">4.字符串类型</a></li><li>  <a href="about:blank#5_68">5.日期与时间类型</a></li><li><ul><li><a href="about:blank#51_YEAR_77">5.1 YEAR类型</a><ul><li>  <a href="about:blank#52_TIME_83">5.2 TIME类型</a></li><li>  <a href="about:blank#53_DATETIME_88">5.3 DATETIME类型</a></li><li>  <a href="about:blank#54_TIMESTAMP_94">5.4 TIMESTAMP类型</a></li></ul></li></ul></li><li>  <a href="about:blank#6_99">6.二进制类型</a></li></ul></li></ul></li><li>  <a href="about:blank#_107">四、数据库、数据表的基本操作</a></li><li><ul><li><a href="about:blank#1_108">1.数据库的基本操作</a><ul><li>  <a href="about:blank#2_157">2.数据表的基本操作</a></li><li><ul><li><a href="about:blank#21__169">2.1 创建数据表</a><ul><li>  <a href="about:blank#22__181">2.2 查看数据表</a></li><li>  <a href="about:blank#23__200">2.3 修改数据表</a></li><li>  <a href="about:blank#24__233">2.4 删除数据表</a></li></ul></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#_247">五、数据表的约束</a></li><li><ul><li><a href="about:blank#1_257">1.主键约束</a><ul><li>  <a href="about:blank#2_284">2.非空约束</a></li><li>  <a href="about:blank#3_299">3.默认值约束</a></li><li>  <a href="about:blank#5_315">5.唯一性约束</a></li><li>  <a href="about:blank#6_330">6.外键约束</a></li><li><ul><li><a href="about:blank#61__360">6.1 数据一致性概念</a><ul><li>  <a href="about:blank#62__362">6.2 删除外键</a></li><li>  <a href="about:blank#63__375">6.3 关于外键约束需要注意的细节</a></li></ul></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#_379">六、数据表插入数据</a></li><li><ul><li><a href="about:blank#1__389">1. 为表中所有字段插入数据</a><ul><li>  <a href="about:blank#2__401">2. 为表中指定字段插入数据</a></li><li>  <a href="about:blank#3__408">3. 同时插入多条记录</a></li></ul></li></ul></li><li>  <a href="about:blank#_421">七、更新数据</a></li><li><ul><li><a href="about:blank#1_UPDATE_423">1. UPDATE基本语法</a><ul><li>  <a href="about:blank#2_UPDATE_428">2. UPDATE更新部分数据</a></li><li>  <a href="about:blank#3_UPDATE_435">3. UPDATE更新全部数据</a></li></ul></li></ul></li><li>  <a href="about:blank#_442">八、删除数据</a></li><li><ul><li><a href="about:blank#1_DELETE_457">1. DELETE基本语法</a><ul><li>  <a href="about:blank#2_DELETE_462">2. DELETE删除部分数据</a></li><li>  <a href="about:blank#3_DELETE_469">3. DELETE删除全部数据</a></li><li>  <a href="about:blank#4_TRUNCATEDETELE_476">4. TRUNCATE和DETELE的区别</a></li></ul></li></ul></li><li>  <a href="about:blank#MySQL_481">九、MySQL数据表简单查询</a></li><li><ul><li><a href="about:blank#1_482">1.简单查询概述</a><ul><li>  <a href="about:blank#2_512">2.查询所有字段（方法不唯一只是举例）</a></li><li>  <a href="about:blank#3sidsname_519">3.查询指定字段（sid、sname）</a></li><li>  <a href="about:blank#4_526">4.常数的查询</a></li><li>  <a href="about:blank#5_535">5.从查询结果中过滤重复数据</a></li><li>  <a href="about:blank#6_545">6.算术运算符（举例加运算符）</a></li></ul></li></ul></li><li>  <a href="about:blank#_554">十、函数</a></li><li><ul><li><a href="about:blank#1_583">1.聚合函数</a><ul><li><ul><li><a href="about:blank#11count_588">1.1、count（）</a><ul><li>  <a href="about:blank#12max_598">1.2、max（）</a></li><li>  <a href="about:blank#13min_609">1.3、min（）</a></li><li>  <a href="about:blank#14sum_620">1.4、sum（）</a></li><li>  <a href="about:blank#15avg_630">1.5、avg（）</a></li></ul></li></ul></li><li>  <a href="about:blank#2_640">2.其他常用函数</a></li><li><ul><li><a href="about:blank#21_642">2.1、时间函数</a><ul><li>  <a href="about:blank#22_660">2.2、字符串函数</a></li><li>  <a href="about:blank#23_670">2.3、数学函数</a></li></ul></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#_680">十一、条件查询</a></li><li><ul><li><a href="about:blank#1_712">1.使用关系运算符查询</a><ul><li>  <a href="about:blank#2IN_731">2.使用IN关键字查询</a></li><li>  <a href="about:blank#3BETWEEN_AND_748">3.使用BETWEEN AND关键字查询</a></li><li>  <a href="about:blank#4_764">4.使用空值查询</a></li><li>  <a href="about:blank#5AND_774">5.使用AND关键字查询</a></li><li>  <a href="about:blank#6OR_783">6.使用OR关键字查询</a></li><li>  <a href="about:blank#7LIKE_792">7.使用LIKE关键字查询</a></li><li><ul><li><a href="about:blank#71__794">7.1 普通字符串</a><ul><li>  <a href="about:blank#72__802">7.2 含有%通配的字符串</a></li><li>  <a href="about:blank#73___825">7.3 含有_通配的字符串</a></li></ul></li></ul></li><li>  <a href="about:blank#8LIMIT_842">8.使用LIMIT限制查询结果的数量</a></li><li>  <a href="about:blank#9GROUP_BY_851">9.使用GROUP BY进行分组查询</a></li><li><ul><li><a href="about:blank#91_GROUP_BY_880">9.1 GROUP BY和聚合函数一起使用</a><ul><li>  <a href="about:blank#92_GROUP_BYHAVING_896">9.2 GROUP BY和聚合函数以及HAVING一起使用</a></li></ul></li></ul></li><li>  <a href="about:blank#10ORDER_BY_904">10.使用ORDER BY对查询结果排序</a></li></ul></li></ul></li><li>  <a href="about:blank#_928">十二、别名设置</a></li><li><ul><li><a href="about:blank#1_931">1.为表取别名</a><ul><li>  <a href="about:blank#2_942">2.为字段取别名</a></li></ul></li></ul></li><li>  <a href="about:blank#_954">十三、表的关联关系</a></li><li><ul><li><a href="about:blank#1_993">1.关联查询</a><ul><li>  <a href="about:blank#2_1000">2.关于关联关系的删除数据</a></li></ul></li></ul></li><li>  <a href="about:blank#_1009">十四、多表连接查询</a></li><li><ul><li><a href="about:blank#1_1010">1.交叉连接查询</a><ul><li>  <a href="about:blank#2_1018">2.内连接查询</a></li><li>  <a href="about:blank#3_1067">3.外连接查询</a></li><li><ul><li><a href="about:blank#31__1117">3.1 左（外）连接查询</a><ul><li>  <a href="about:blank#32__1129">3.2 右（外）连接查询</a></li></ul></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#_1142">十五、子查询</a></li><li><ul><li><a href="about:blank#1_1181">1.带比较运算符的子查询</a><ul><li>  <a href="about:blank#2EXISTS_1195">2.带EXISTS关键字的子查询</a></li><li>  <a href="about:blank#3ANY_1203">3.带ANY关键字的子查询</a></li><li>  <a href="about:blank#4ALL_1213">4.带ALL关键字的子查询</a></li></ul></li></ul></li><li>  <a href="about:blank#_1224">总结</a></li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>前言</h1><p>知识无底，学海无涯，到今天进入MySQL的学习4天了，知识点虽然简单，但是比较多，所以写一篇博客将MySQL的基础写出来，方便自己以后查找，还有就是分享给大家。</p><h1 id="一、SQL简述"><a href="#一、SQL简述" class="headerlink" title="一、SQL简述"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>一、SQL简述</h1><h2 id="1-SQL的概述"><a href="#1-SQL的概述" class="headerlink" title="1.SQL的概述"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.SQL的概述</h2><p>Structure Query Language(结构化查询语言)简称SQL，它被美国国家标准局(ANSI)确定为关系型数据库语言的美国标准，后被国际化标准组织(ISO)采纳为关系数据库语言的国际标准。数据库管理系统可以通过SQL管理数据库；定义和操作数据，维护数据的完整性和安全性。</p><h2 id="2-SQL的优点"><a href="#2-SQL的优点" class="headerlink" title="2.SQL的优点"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.SQL的优点</h2><p>1、简单易学，具有很强的操作性<br>2、绝大多数重要的数据库管理系统均支持SQL<br>3、高度非过程化；用SQL操作数据库时大部分的工作由DBMS自动完成</p><h2 id="3-SQL的分类"><a href="#3-SQL的分类" class="headerlink" title="3.SQL的分类"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3.SQL的分类</h2><p>1、DDL(Data Definition Language) 数据定义语言，用来操作数据库、表、列等； 常用语句：CREATE、 ALTER、DROP<br>2、DML(Data Manipulation Language) 数据操作语言，用来操作数据库中表里的数据；常用语句：INSERT、 UPDATE、 DELETE<br>3、DCL(Data Control Language) 数据控制语言，用来操作访问权限和安全级别； 常用语句：GRANT、DENY<br>4、DQL(Data Query Language) 数据查询语言，用来查询数据 常用语句：SELECT</p><h1 id="二、数据库的三大范式"><a href="#二、数据库的三大范式" class="headerlink" title="二、数据库的三大范式"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>二、数据库的三大范式</h1><p>1、第一范式(1NF)是指数据库表的每一列都是不可分割的基本数据线；也就是说：每列的值具有原子性，不可再分割。<br>2、第二范式(2NF)是在第一范式(1NF)的基础上建立起来得，满足第二范式(2NF)必须先满足第一范式(1NF)。如果表是单主键，那么主键以外的列必须完全依赖于主键；如果表是复合主键，那么主键以外的列必须完全依赖于主键，不能仅依赖主键的一部分。<br>3、第三范式(3NF)是在第二范式的基础上建立起来的，即满足第三范式必须要先满足第二范式。第三范式(3NF)要求：表中的非主键列必须和主键直接相关而不能间接相关；也就是说：非主键列之间不能相关依赖。</p><h1 id="三、数据库的数据类型"><a href="#三、数据库的数据类型" class="headerlink" title="三、数据库的数据类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>三、数据库的数据类型</h1><p>使用MySQL数据库存储数据时，不同的数据类型决定了 MySQL存储数据方式的不同。为此，MySQL数据库提供了多种数据类型，其中包括整数类型、浮点数类型、定点 数类型、日期和时间类型、字符串类型、二进制…等等数据类型。</p><h2 id="1-整数类型"><a href="#1-整数类型" class="headerlink" title="1.整数类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.整数类型</h2><p>根据数值取值范围的不同MySQL 中的整数类型可分为5种，分别是TINYINT、SMALUNT、MEDIUMINT、INT和 BIGINT。下图列举了 MySQL不同整数类型所对应的字节大小和取值范围而最常用的为INT类型的，</p><table><thead><tr><th>数据类型</th><th>字节数</th><th>无符号数的取值范围</th><th>有符号数的取值范围</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>0~255</td><td>-128~127</td></tr><tr><td>SMALLINT</td><td>2</td><td>0~65535</td><td>-32768~32768</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>0~16777215</td><td>-8388608~8388608</td></tr><tr><td>INT</td><td>4</td><td>0~4294967295</td><td>-2147483648~ 2147483648</td></tr><tr><td>BIGINT</td><td>8</td><td>0~18446744073709551615</td><td>-9223372036854775808~9223372036854775808</td></tr></tbody></table><h2 id="2-浮点数类型和定点数类型"><a href="#2-浮点数类型和定点数类型" class="headerlink" title="2.浮点数类型和定点数类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.浮点数类型和定点数类型</h2><p>在MySQL数据库中使用浮点数和定点数来存储小数。浮点数的类型有两种：单精度浮点数类型（FLOAT)和双精度浮点数类型（DOUBLE)。而定点数类型只有一种即DECIMAL类型。下图列举了 MySQL中浮点数和定点数类型所对应的字节大小及其取值范围：</p><table><thead><tr><th>数据类型</th><th>字节数</th><th>有符号的取值范围</th><th>无符号的取值范围</th></tr></thead><tbody><tr><td>FLOAT</td><td>4</td><td>-3.402823466E+38~-1.175494351E-38</td><td>0和1.175494351E-38~3.402823466E+38</td></tr><tr><td>DOUBLE</td><td>8</td><td>-1.7976931348623157E+308~2.2250738585072014E-308</td><td>0和2.2250738585072014E-308~1.7976931348623157E+308</td></tr><tr><td>DECIMAL（M,D）</td><td>M+2</td><td>-1.7976931348623157E+308~2.2250738585072014E-308</td><td>0和2.2250738585072014E-308~1.7976931348623157E+308</td></tr></tbody></table><p>从上图中可以看出：DECIMAL类型的取值范围与DOUBLE类型相同。但是，请注意：DECIMAL类型的有效取值范围是由M和D决定的。其中，M表示的是数据的长 度，D表示的是小数点后的长度。比如，将数据类型为DECIMAL(6,2)的数据6.5243 插人数据库后显示的结果为6.52</p><h2 id="3-字符串类型"><a href="#3-字符串类型" class="headerlink" title="3.字符串类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3.字符串类型</h2><p>在MySQL中常用CHAR 和 VARCHAR 表示字符串。两者不同的是：VARCHAR存储可变长度的字符串。<br><strong>当数据为CHAR(M)类型时，不管插入值的长度是实际是多少它所占用的存储空间都是M个字节；而VARCHAR(M)所对应的数据所占用的字节数为实际长度加1</strong></p><table><thead><tr><th>插入值</th><th>CHAR(3)</th><th>存储需求</th><th>VARCHAR(3)</th><th>存储需求</th></tr></thead><tbody><tr><td>‘’</td><td>‘’</td><td>3个字节</td><td>‘’</td><td>1个字节</td></tr><tr><td>‘a’</td><td>‘a’</td><td>3个字节</td><td>‘a’</td><td>2个字节</td></tr><tr><td>‘ab’</td><td>‘ab’</td><td>3个字节</td><td>‘ab’</td><td>3个字节</td></tr><tr><td>‘abc’</td><td>‘ab’</td><td>3个字节</td><td>‘abc’</td><td>4个字节</td></tr><tr><td>‘abcd’</td><td>‘ab’</td><td>3个字节</td><td>‘abc’</td><td>4字节</td></tr></tbody></table><h2 id="4-字符串类型"><a href="#4-字符串类型" class="headerlink" title="4.字符串类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>4.字符串类型</h2><p>文本类型用于表示大文本数据，例如，文章内容、评论、详情等，它的类型分为如下4种：</p><table><thead><tr><th>数据类型</th><th>储存范围</th></tr></thead><tbody><tr><td>TINYTEXT</td><td>0~255字节</td></tr><tr><td>TEXT</td><td>0~65535字节</td></tr><tr><td>MEDIUMTEXT</td><td>0~16777215字节</td></tr><tr><td>LONGTEXT</td><td>0~4294967295字节</td></tr></tbody></table><h2 id="5-日期与时间类型"><a href="#5-日期与时间类型" class="headerlink" title="5.日期与时间类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>5.日期与时间类型</h2><p>MySQL提供的表示日期和时间的数据类型分别是 ：YEAR、DATE、TIME、DATETIME 和 TIMESTAMP。下图列举了日期和时间数据类型所对应的字节数、取值范围、日期格式以及零值：</p><table><thead><tr><th>数据类型</th><th>字节数</th><th>取值范围</th><th>日期格式</th><th>零值</th></tr></thead><tbody><tr><td>YEAR</td><td>1</td><td>1901~2155</td><td>YYYY</td><td>0000</td></tr><tr><td>DATE</td><td>4</td><td>1000-01-01~9999-12-31</td><td>YYYY-MM-DD</td><td>0000-00-00</td></tr><tr><td>TIME</td><td>3</td><td>-838：59：59~ 838：59：59</td><td>HH:MM:SS</td><td>00:00:00</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00~9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>0000-00-00 00:00:00</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:01~2038-01-19 03:14:07</td><td>YYYY-MM-DD HH:MM:SS</td><td>0000-00-00 00:00:00</td></tr></tbody></table><h3 id="5-1-YEAR类型"><a href="#5-1-YEAR类型" class="headerlink" title="5.1 YEAR类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>5.1 YEAR类型</h3><p>YEAR类型用于表示年份，在MySQL中，可以使用以下三种格式指定YEAR类型 的值。<br>1、使用4位字符串或数字表示，范围为’1901’—‘2155’或1901—2155。例如，输人 ‘2019’或2019插人到数据库中的值均为2019。<br>2、使用两位字符串表示，范围为’00’—‘99’。其中，‘00’—‘69’范围的值会被转换为 2000—2069范围的YEAR值，‘70’—‘99’范围的值会被转换为1970—1999范围的YEAR 值。例如，输人’19’插人到数据库中的值为2019。<br>3、使用两位数字表示，范围为1—99。其中，1—69范围的值会被转换为2001— 2069范围的YEAR值，70—99范围的值会被转换为1970—1999范围的YEAR值。例 如，输人19插入到数据库中的值为2019。<br><strong>请注意：当使用YEAR类型时，一定要区分’0’和0。因为字符串格式的’0’表示的YEAR值是2000而数字格式的0表示的YEAR值是0000。</strong></p><h3 id="5-2-TIME类型"><a href="#5-2-TIME类型" class="headerlink" title="5.2 TIME类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>5.2 TIME类型</h3><p>TIME类型用于表示时间值，它的显示形式一般为HH:MM:SS，其中，HH表示小时， MM表示分,SS表示秒。在MySQL中，可以使用以下3种格式指定TIME类型的值。<br>1、以’D HH:MM:SS’字符串格式表示。其中，D表示日可取0—34之间的值, 插人数据时，小时的值等于(DX24+HH)。例如，输入’2 11:30:50’插人数据库中的日期为59:30:50。<br>2、以’HHMMSS’字符串格式或者HHMMSS数字格式表示。 例如，输人’115454’或115454,插入数据库中的日期为11:54:54<br>3、使用CURRENT_TIME或NOW()输人当前系统时间。</p><h3 id="5-3-DATETIME类型"><a href="#5-3-DATETIME类型" class="headerlink" title="5.3 DATETIME类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>5.3 DATETIME类型</h3><p>DATETIME类型用于表示日期和时间，它的显示形式为’YYYY-MM-DD HH: MM:SS’，其中，YYYY表示年，MM表示月，DD表示日，HH表示小时，MM表示分，SS 表示秒。在MySQL中，可以使用以下4种格式指定DATETIME类型的值。<br>以’YYYY-MM-DD HH:MM:SS’或者’YYYYMMDDHHMMSS’字符串格式表示的日期和时间，取值范围为’1000-01-01 00:00:00’—‘9999-12-3 23:59:59’。例如，输人’2019-01-22 09:01:23’或 ‘20140122_0_90123’插人数据库中的 DATETIME 值都为 2019-01-22 09:01:23。<br>1、以’YY-MM-DD HH:MM:SS’或者’YYMMDDHHMMSS’字符串格式表示的日期和时间，其中YY表示年，取值范围为’00’—‘99’。与DATE类型中的YY相同，‘00’— ‘69’范围的值会被转换为2000—2069范围的值，‘70’—‘99’范围的值会被转换为1970—1999范围的值。<br>2、以YYYYMMDDHHMMSS或者YYMMDDHHMMSS数字格式表示的日期 和时间。例如，插入20190122090123或者190122090123,插人数据库中的DATETIME值都 为 2019-01-22 09:01:23。<br>3、使用NOW来输人当前系统的日期和时间。</p><h3 id="5-4-TIMESTAMP类型"><a href="#5-4-TIMESTAMP类型" class="headerlink" title="5.4 TIMESTAMP类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>5.4 TIMESTAMP类型</h3><p>TIMESTAMP类型用于表示日期和时间，它的显示形式与DATETIME相同但取值范围比DATETIME小。在此，介绍几种TIMESTAMP类型与DATATIME类型不同的形式：<br>1、使用CURRENT_TIMESTAMP输人系统当前日期和时间。<br>2、输人NULL时系统会输人系统当前日期和时间。<br>3、无任何输人时系统会输入系统当前日期和时间。</p><h2 id="6-二进制类型"><a href="#6-二进制类型" class="headerlink" title="6.二进制类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>6.二进制类型</h2><p>在MySQL中常用BLOB存储二进制类型的数据，例如：图片、PDF文档等。BLOB类型分为如下四种：</p><table><thead><tr><th>数据类型</th><th>储存范围</th></tr></thead><tbody><tr><td>TINYBLOB</td><td>0~255字节</td></tr><tr><td>BLOB</td><td>0~65535字节</td></tr><tr><td>MEDIUMBLOB</td><td>0~16777215字节</td></tr><tr><td>LONGBLOB</td><td>0~4294967295字节</td></tr></tbody></table><h1 id="四、数据库、数据表的基本操作"><a href="#四、数据库、数据表的基本操作" class="headerlink" title="四、数据库、数据表的基本操作"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>四、数据库、数据表的基本操作</h1><h2 id="1-数据库的基本操作"><a href="#1-数据库的基本操作" class="headerlink" title="1.数据库的基本操作"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.数据库的基本操作</h2><p>MySQL安装完成后，要想将数据存储到数据库的表中，首先要创建一个数据库。创 建数据库就是在数据库系统中划分一块空间存储数据，语法如下：</p><pre><code>create database 数据库名称;</code></pre><p>创建一个叫db1的数据库MySQL命令：</p><pre><code>-- 创建一个叫db1的数据库show create database db1;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/2021030312520741.png" alt="在这里插入图片描述"><br>创建数据库后查看该数据库基本信息MySQL命令：</p><pre><code>show create database db1;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303125330974.png" alt="在这里插入图片描述"><br>删除数据库MySQL命令：</p><pre><code>drop database db1;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303125647454.png" alt="在这里插入图片描述"><br>查询出MySQL中所有的数据库MySQL命令：</p><pre><code>show databases;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303125940965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>将数据库的字符集修改为gbk MySQL命令：</p><pre><code>alter database db1 character set gbk;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303130330527.png" alt="在这里插入图片描述"><br>切换数据库 MySQL命令：</p><pre><code>use db1;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303130451230.png" alt="在这里插入图片描述"><br>查看当前使用的数据库 MySQL命令：</p><pre><code>select database();</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303130616683.png" alt="在这里插入图片描述"></p><h2 id="2-数据表的基本操作"><a href="#2-数据表的基本操作" class="headerlink" title="2.数据表的基本操作"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.数据表的基本操作</h2><p>数据库创建成功后可在该数据库中创建数据表(简称为表)存储数据。请注意：在操作数据表之前应使用“USE 数据库名;”指定操作是在哪个数据库中进行先关操作，否则会抛出“No database selected”错误。<br>语法如下：</p><pre><code> create table 表名(         字段1 字段类型,         字段2 字段类型,         …         字段n 字段类型);</code></pre><h3 id="2-1-创建数据表"><a href="#2-1-创建数据表" class="headerlink" title="2.1 创建数据表"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.1 创建数据表</h3><p>示例：创建学生表 MySQL命令：</p><pre><code> create table student( id int, name varchar(20), gender varchar(10), birthday date );</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303140044367.png" alt="在这里插入图片描述"></p><h3 id="2-2-查看数据表"><a href="#2-2-查看数据表" class="headerlink" title="2.2 查看数据表"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.2 查看数据表</h3><p>示例：查看当前数据库中所有表 MySQL命令：</p><pre><code>show tables;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303144745383.png" alt="在这里插入图片描述"><br>示例：查表的基本信息 MySQL命令：</p><pre><code>show create table student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303144940575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>示例：查看表的字段信息 MySQL命令：</p><pre><code>desc student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303145223522.png" alt="在这里插入图片描述"></p><h3 id="2-3-修改数据表"><a href="#2-3-修改数据表" class="headerlink" title="2.3 修改数据表"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.3 修改数据表</h3><p>有时，希望对表中的某些信息进行修改，例如：修改表名、修改字段名、修改字段 数据类型…等等。在MySQL中使用alter table修改数据表.<br>示例：修改表名 MySQL命令：</p><pre><code>alter table student rename to stu;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303145645914.png" alt="在这里插入图片描述"><br>示例：修改字段名 MySQL命令：</p><pre><code>alter table stu change name sname varchar(10);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303150127793.png" alt="在这里插入图片描述"><br>示例：修改字段数据类型 MySQL命令：</p><pre><code>alter table stu modify sname int;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303150426652.png" alt="在这里插入图片描述"><br>示例：增加字段 MySQL命令：</p><pre><code>alter table stu add address varchar(50);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303150757176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>示例：删除字段 MySQL命令：</p><pre><code>alter table stu drop address;</code></pre><p>运行效果展示：</p><p><img src="https://img-blog.csdnimg.cn/20210303151816445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-4-删除数据表"><a href="#2-4-删除数据表" class="headerlink" title="2.4 删除数据表"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.4 删除数据表</h3><p>语法：</p><pre><code>drop table 表名;</code></pre><p>示例：删除数据表 MySQL命令：</p><pre><code>drop table stu;</code></pre><p>运行效果展示：</p><p><img src="https://img-blog.csdnimg.cn/20210303152039101.png" alt="在这里插入图片描述"></p><h1 id="五、数据表的约束"><a href="#五、数据表的约束" class="headerlink" title="五、数据表的约束"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>五、数据表的约束</h1><p>为防止错误的数据被插入到数据表，MySQL中定义了一些维护数据库完整性的规则；这些规则常称为表的约束。常见约束如下：</p><table><thead><tr><th>约束条件</th><th>说明</th></tr></thead><tbody><tr><td>PRIMARY KEY</td><td>主键约束用于唯一标识对应的记录</td></tr><tr><td>FOREIGN KEY</td><td>外键约束</td></tr><tr><td>NOT NULL</td><td>非空约束</td></tr><tr><td>UNIQUE</td><td>唯一性约束</td></tr><tr><td>DEFAULT</td><td>默认值约束，用于设置字段的默认值</td></tr></tbody></table><p>以上五种约束条件针对表中字段进行限制从而保证数据表中数据的正确性和唯一性。换句话说，表的约束实际上就是表中数据的限制条件。</p><h2 id="1-主键约束"><a href="#1-主键约束" class="headerlink" title="1.主键约束"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.主键约束</h2><p>主键约束即primary key用于唯一的标识表中的每一行。被标识为主键的数据在表中是唯一的且其值不能为空。这点类似于我们每个人都有一个身份证号，并且这个身份证号是唯一的。<br>主键约束基本语法：</p><pre><code>字段名 数据类型 primary key;</code></pre><p><strong>设置主键约束(primary key)的第一种方式</strong><br>示例：MySQL命令：</p><pre><code>create table student(id int primary key,name varchar(20));</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303161028430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>设置主键约束(primary key)的第二·种方式</strong><br>示例：MySQL命令：</p><pre><code>create table student01(id intname varchar(20),primary key(id));</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303173104926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-非空约束"><a href="#2-非空约束" class="headerlink" title="2.非空约束"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.非空约束</h2><p>非空约束即 NOT NULL指的是字段的值不能为空，基本的语法格式如下所示：</p><pre><code>字段名 数据类型 NOT NULL;</code></pre><p>示例：MySQL命令：</p><pre><code>create table student02(id intname varchar(20) not null);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/2021030317340097.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-默认值约束"><a href="#3-默认值约束" class="headerlink" title="3.默认值约束"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3.默认值约束</h2><p>默认值约束即DEFAULT用于给数据表中的字段指定默认值，即当在表中插入一条新记录时若未给该字段赋值，那么，数据库系统会自动为这个字段插人默认值；其基本的语法格式如下所示：</p><pre><code>字段名 数据类型 DEFAULT 默认值；</code></pre><p>示例：MySQL命令：</p><pre><code>create table student03(id int,name varchar(20),gender varchar(10) default &#39;male&#39;);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303173835546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5-唯一性约束"><a href="#5-唯一性约束" class="headerlink" title="5.唯一性约束"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>5.唯一性约束</h2><p>唯一性约束即UNIQUE用于保证数据表中字段的唯一性，即表中字段的值不能重复出现，其基本的语法格式如下所示：</p><pre><code>字段名 数据类型 UNIQUE;</code></pre><p>示例：MySQL命令：</p><pre><code>create table student04(id int,name varchar(20) unique);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303174216204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="6-外键约束"><a href="#6-外键约束" class="headerlink" title="6.外键约束"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>6.外键约束</h2><p>外键约束即FOREIGN KEY常用于多张表之间的约束。基本语法如下：</p><pre><code>-- 在创建数据表时语法如下：CONSTRAINT 外键名 FOREIGN KEY (从表外键字段) REFERENCES 主表 (主键字段)-- 将创建数据表创号后语法如下：ALTER TABLE 从表名 ADD CONSTRAINT 外键名 FOREIGN KEY (从表外键字段) REFERENCES 主表 (主键字段);</code></pre><p>示例：创建一个学生表 MySQL命令：</p><pre><code>create table student05(id int primary key,name varchar(20));</code></pre><p>示例：创建一个班级表 MySQL命令：</p><pre><code>create table class(classid int primary key,studentid int);</code></pre><p>示例：学生表作为主表，班级表作为副表设置外键， MySQL命令：</p><pre><code>alter table class add constraint fk_class_studentid foreign key(studentid) references student05(id);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303180124470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="6-1-数据一致性概念"><a href="#6-1-数据一致性概念" class="headerlink" title="6.1 数据一致性概念"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>6.1 数据一致性概念</h3><p>大家知道：建立外键是为了保证数据的完整和统一性。但是，如果主表中的数据被删除或修改从表中对应的数据该怎么办呢？很明显，从表中对应的数据也应该被删除，否则数据库中会存在很多无意义的垃圾数据。</p><h3 id="6-2-删除外键"><a href="#6-2-删除外键" class="headerlink" title="6.2 删除外键"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>6.2 删除外键</h3><p>语法如下：</p><pre><code>alter table 从表名 drop foreign key 外键名；</code></pre><p>示例：删除外键 MySQL命令：</p><pre><code>alter table class drop foreign key fk_class_studentid;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303180554954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>外键的那个字段不在了证明删除成功了</p><h3 id="6-3-关于外键约束需要注意的细节"><a href="#6-3-关于外键约束需要注意的细节" class="headerlink" title="6.3 关于外键约束需要注意的细节"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>6.3 关于外键约束需要注意的细节</h3><p>1、从表里的外键通常为主表的主键<br>2、从表里外键的数据类型必须与主表中主键的数据类型一致<br>3、主表发生变化时应注意主表与从表的数据一致性问题</p><h1 id="六、数据表插入数据"><a href="#六、数据表插入数据" class="headerlink" title="六、数据表插入数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>六、数据表插入数据</h1><p>在MySQL通过INSERT语句向数据表中插入数据。在此，我们先准备一张学生表，代码如下：</p><pre><code> create table student( id int, name varchar(30), age int, gender varchar(30) );</code></pre><h2 id="1-为表中所有字段插入数据"><a href="#1-为表中所有字段插入数据" class="headerlink" title="1. 为表中所有字段插入数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1. 为表中所有字段插入数据</h2><p>每个字段与其值是严格一一对应的。也就是说：每个值、值的顺序、值的类型必须与对应的字段相匹配。但是，各字段也无须与其在表中定义的顺序一致，它们只要与 VALUES中值的顺序一致即可。<br>语法如下：</p><pre><code>INSERT INTO 表名（字段名1,字段名2,...) VALUES (值 1,值 2,...);</code></pre><p>示例：向学生表中插入一条学生信息 MySQL命令：</p><pre><code>insert into student (id,name,age,gender) values (1,&#39;bob&#39;,16,&#39;male&#39;);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/2021030318190944.png" alt="在这里插入图片描述"></p><h2 id="2-为表中指定字段插入数据"><a href="#2-为表中指定字段插入数据" class="headerlink" title="2. 为表中指定字段插入数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2. 为表中指定字段插入数据</h2><p>语法如下：</p><pre><code>INSERT INTO 表名（字段名1,字段名2,...) VALUES (值 1,值 2,...);</code></pre><p>插入数据的方法基本和为表中所有字段插入数据，一样，只是需要插入的字段由你自己指定</p><h2 id="3-同时插入多条记录"><a href="#3-同时插入多条记录" class="headerlink" title="3. 同时插入多条记录"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3. 同时插入多条记录</h2><p>语法如下：</p><pre><code>INSERT INTO 表名 [(字段名1,字段名2,...)]VALUES (值 1,值 2,…),(值 1,值 2,…),...;</code></pre><p>在该方式中：(字段名1,字段名2,…)是可选的，它用于指定插人的字段名；(值 1,值 2,…),(值 1,值 2,…)表示要插人的记录，该记录可有多条并且每条记录之间用逗号隔开。<br>示例：向学生表中插入多条学生信息 MySQL命令：</p><pre><code>insert into student (id,name,age,gender) values (2,&#39;lucy&#39;,17,&#39;female&#39;),(3,&#39;jack&#39;,19,&#39;male&#39;),(4,&#39;tom&#39;,18,&#39;male&#39;);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303182837401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="七、更新数据"><a href="#七、更新数据" class="headerlink" title="七、更新数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>七、更新数据</h1><p>在MySQL通过UPDATE语句更新数据表中的数据。在此，我们将就用六中的student学生表</p><h2 id="1-UPDATE基本语法"><a href="#1-UPDATE基本语法" class="headerlink" title="1. UPDATE基本语法"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1. UPDATE基本语法</h2><pre><code>UPDATE 表名 SET 字段名1=值1[,字段名2 =值2,…] [WHERE 条件表达式];</code></pre><p>在该语法中：字段名1、字段名2…用于指定要更新的字段名称；值1、值 2…用于表示字段的新数据；WHERE 条件表达式 是可选的，它用于指定更新数据需要满足的条件</p><h2 id="2-UPDATE更新部分数据"><a href="#2-UPDATE更新部分数据" class="headerlink" title="2. UPDATE更新部分数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2. UPDATE更新部分数据</h2><p>示例：将name为tom的记录的age设置为20并将其gender设置为female MySQL命令：</p><pre><code>update student set age=20,gender=&#39;female&#39; where name=&#39;tom&#39;;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/2021030318372031.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-UPDATE更新全部数据"><a href="#3-UPDATE更新全部数据" class="headerlink" title="3. UPDATE更新全部数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3. UPDATE更新全部数据</h2><p>示例：将所有记录的age设置为18 MySQL命令：</p><pre><code>update student set age=18;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/2021030318401177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="八、删除数据"><a href="#八、删除数据" class="headerlink" title="八、删除数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>八、删除数据</h1><p>在MySQL通过DELETE语句删除数据表中的数据。在此，我们先准备一张数据表，代码如下：</p><pre><code>-- 创建学生表 create table student( id int, name varchar(30), age int, gender varchar(30) ); -- 插入数据 insert into student (id,name,age,gender) values (2,&#39;lucy&#39;,17,&#39;female&#39;),(3,&#39;jack&#39;,19,&#39;male&#39;),(4,&#39;tom&#39;,18,&#39;male&#39;),(5,&#39;sal&#39;,19,&#39;female&#39;),(6,&#39;sun&#39;,20,&#39;male&#39;),(7,&#39;sad&#39;,13,&#39;female&#39;),(8,&#39;sam&#39;,14,&#39;male&#39;);</code></pre><h2 id="1-DELETE基本语法"><a href="#1-DELETE基本语法" class="headerlink" title="1. DELETE基本语法"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1. DELETE基本语法</h2><p>在该语法中：表名用于指定要执行删除操作的表；[WHERE 条件表达式]为可选参数用于指定删除的条件。</p><pre><code>DELETE FROM 表名 [WHERE 条件表达式];</code></pre><h2 id="2-DELETE删除部分数据"><a href="#2-DELETE删除部分数据" class="headerlink" title="2. DELETE删除部分数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2. DELETE删除部分数据</h2><p>示例：删除age等于14的所有记录 MySQL命令：</p><pre><code>delete from student where age=14;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303185050926.png" alt="在这里插入图片描述"></p><h2 id="3-DELETE删除全部数据"><a href="#3-DELETE删除全部数据" class="headerlink" title="3. DELETE删除全部数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3. DELETE删除全部数据</h2><p>示例：删除student表中的所有记录 MySQL命令：</p><pre><code>delete from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303185424760.png" alt="在这里插入图片描述"></p><h2 id="4-TRUNCATE和DETELE的区别"><a href="#4-TRUNCATE和DETELE的区别" class="headerlink" title="4. TRUNCATE和DETELE的区别"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>4. TRUNCATE和DETELE的区别</h2><p>TRUNCATE和DETELE都能实现删除表中的所有数据的功能，但两者也是有区别的：<br>1、DELETE语句后可跟WHERE子句，可通过指定WHERE子句中的条件表达式只删除满足条件的部分记录；但是，TRUNCATE语句只能用于删除表中的所有记录。<br>2、使用TRUNCATE语句删除表中的数据后，再次向表中添加记录时自动增加字段的默认初始值重新由1开始；使用DELETE语句删除表中所有记录后，再次向表中添加记录时自动增加字段的值为删除时该字段的最大值加1<br>3、DELETE语句是DML语句，TRUNCATE语句通常被认为是DDL语句</p><h1 id="九、MySQL数据表简单查询"><a href="#九、MySQL数据表简单查询" class="headerlink" title="九、MySQL数据表简单查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>九、MySQL数据表简单查询</h1><h2 id="1-简单查询概述"><a href="#1-简单查询概述" class="headerlink" title="1.简单查询概述"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.简单查询概述</h2><p>简单查询即不含where的select语句。在此，我们讲解简单查询中最常用的两种查询：查询所有字段和查询指定字段。<br>在此，先准备测试数据，代码如下：</p><pre><code>-- 创建数据库DROP DATABASE IF EXISTS mydb;CREATE DATABASE mydb;USE mydb;-- 创建student表CREATE TABLE student (    sid CHAR(6),    sname VARCHAR(50),    age INT,    gender VARCHAR(50) DEFAULT &#39;male&#39;);-- 向student表插入数据INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1001&#39;, &#39;lili&#39;, 14, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1002&#39;, &#39;wang&#39;, 15, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1003&#39;, &#39;tywd&#39;, 16, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1004&#39;, &#39;hfgs&#39;, 17, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1005&#39;, &#39;qwer&#39;, 18, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1006&#39;, &#39;zxsd&#39;, 19, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1007&#39;, &#39;hjop&#39;, 16, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1008&#39;, &#39;tyop&#39;, 15, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1009&#39;, &#39;nhmk&#39;, 13, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1010&#39;, &#39;xdfv&#39;, 17, &#39;female&#39;);</code></pre><h2 id="2-查询所有字段（方法不唯一只是举例）"><a href="#2-查询所有字段（方法不唯一只是举例）" class="headerlink" title="2.查询所有字段（方法不唯一只是举例）"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.查询所有字段（方法不唯一只是举例）</h2><p>查询所有字段 MySQL命令：</p><pre><code>select * from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302183927761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-查询指定字段（sid、sname）"><a href="#3-查询指定字段（sid、sname）" class="headerlink" title="3.查询指定字段（sid、sname）"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3.查询指定字段（sid、sname）</h2><p>查询指定字段（sid、sname） MySQL命令：</p><pre><code>select sid,sname from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302184506628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-常数的查询"><a href="#4-常数的查询" class="headerlink" title="4.常数的查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>4.常数的查询</h2><p>在SELECT中除了书写列名，还可以书写常数。可以用于标记<br>常数的查询日期标记 MySQL命令：</p><pre><code>select sid,sname,&#39;2021-03-02&#39; from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302185049215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5-从查询结果中过滤重复数据"><a href="#5-从查询结果中过滤重复数据" class="headerlink" title="5.从查询结果中过滤重复数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>5.从查询结果中过滤重复数据</h2><p>在使用DISTINCT 时需要注意：<br><strong>在SELECT查询语句中DISTINCT关键字只能用在第一个所查列名之前。</strong><br>MySQL命令：</p><pre><code>select distinct gender from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302185517964.png" alt="在这里插入图片描述"></p><h2 id="6-算术运算符（举例加运算符）"><a href="#6-算术运算符（举例加运算符）" class="headerlink" title="6.算术运算符（举例加运算符）"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>6.算术运算符（举例加运算符）</h2><p>在SELECT查询语句中还可以使用加减乘除运算符。<br>查询学生10年后的年龄 MySQL命令：</p><pre><code> select sname,age+10 from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302185922370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="十、函数"><a href="#十、函数" class="headerlink" title="十、函数"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>十、函数</h1><p>在此，先准备测试数据，代码如下：</p><pre><code>-- 创建数据库DROP DATABASE IF EXISTS mydb;CREATE DATABASE mydb;USE mydb;-- 创建student表CREATE TABLE student (    sid CHAR(6),    sname VARCHAR(50),    age INT,    gender VARCHAR(50) DEFAULT &#39;male&#39;);-- 向student表插入数据INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1001&#39;, &#39;lili&#39;, 14, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1002&#39;, &#39;wang&#39;, 15, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1003&#39;, &#39;tywd&#39;, 16, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1004&#39;, &#39;hfgs&#39;, 17, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1005&#39;, &#39;qwer&#39;, 18, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1006&#39;, &#39;zxsd&#39;, 19, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1007&#39;, &#39;hjop&#39;, 16, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1008&#39;, &#39;tyop&#39;, 15, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1009&#39;, &#39;nhmk&#39;, 13, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1010&#39;, &#39;xdfv&#39;, 17, &#39;female&#39;);</code></pre><h2 id="1-聚合函数"><a href="#1-聚合函数" class="headerlink" title="1.聚合函数"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.聚合函数</h2><p>在开发中，我们常常有类似的需求：统计某个字段的最大值、最小值、 平均值等等。为此，MySQL中提供了聚合函数来实现这些功能。所谓聚合，就是将多行汇总成一行；其实，所有的聚合函数均如此——输入多行，输出一行。聚合函数具有自动滤空的功能，若某一个值为NULL，那么会自动将其过滤使其不参与运算。<br><strong>聚合函数使用规则：</strong><br>只有SELECT子句和HAVING子句、ORDER BY子句中能够使用聚合函数。例如，在WHERE子句中使用聚合函数是错误的。<br>接下来，我们学习常用聚合函数。</p><h3 id="1-1、count（）"><a href="#1-1、count（）" class="headerlink" title="1.1、count（）"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.1、count（）</h3><p>统计表中数据的行数或者统计指定列其值不为NULL的数据个数<br><em>查询有多少该表中有多少人</em><br>MySQL命令：</p><pre><code>select count(*) from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302190940321.png" alt="在这里插入图片描述"></p><h3 id="1-2、max（）"><a href="#1-2、max（）" class="headerlink" title="1.2、max（）"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.2、max（）</h3><p>计算指定列的最大值，如果指定列是字符串类型则使用字符串排序运算</p><p><em>查询该学生表中年纪最大的学生</em><br>MySQL命令：</p><pre><code>select max(age) from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210304164639342.png" alt="在这里插入图片描述"></p><h3 id="1-3、min（）"><a href="#1-3、min（）" class="headerlink" title="1.3、min（）"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.3、min（）</h3><p>计算指定列的最小值，如果指定列是字符串类型则使用字符串排序运算</p><p>查询该学生表中年纪最小的学生 MySQL命令：</p><pre><code>select sname,min(age) from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302191531189.png" alt="在这里插入图片描述"></p><h3 id="1-4、sum（）"><a href="#1-4、sum（）" class="headerlink" title="1.4、sum（）"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.4、sum（）</h3><p>计算指定列的数值和，如果指定列类型不是数值类型则计算结果为0<br>查询该学生表中年纪的总和 MySQL命令：</p><pre><code>select sum(age) from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302192155981.png" alt="在这里插入图片描述"></p><h3 id="1-5、avg（）"><a href="#1-5、avg（）" class="headerlink" title="1.5、avg（）"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.5、avg（）</h3><p>计算指定列的平均值，如果指定列类型不是数值类型则计算结果为</p><p>查询该学生表中年纪的平均数 MySQL命令：</p><pre><code>select avg(age) from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302192048399.png" alt="在这里插入图片描述"></p><h2 id="2-其他常用函数"><a href="#2-其他常用函数" class="headerlink" title="2.其他常用函数"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.其他常用函数</h2><p>这里我就不一一举例了，基本混个眼熟，以后用到再细说</p><h3 id="2-1、时间函数"><a href="#2-1、时间函数" class="headerlink" title="2.1、时间函数"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.1、时间函数</h3><pre><code>SELECT NOW();SELECT DAY (NOW());SELECT DATE (NOW());SELECT TIME (NOW());SELECT YEAR (NOW());SELECT MONTH (NOW());SELECT CURRENT_DATE();SELECT CURRENT_TIME();SELECT CURRENT_TIMESTAMP();SELECT ADDTIME(&#39;14:23:12&#39;,&#39;01:02:01&#39;);SELECT DATE_ADD(NOW(),INTERVAL 1 DAY);SELECT DATE_ADD(NOW(),INTERVAL 1 MONTH);SELECT DATE_SUB(NOW(),INTERVAL 1 DAY);SELECT DATE_SUB(NOW(),INTERVAL 1 MONTH);SELECT DATEDIFF(&#39;2019-07-22&#39;,&#39;2019-05-05&#39;);</code></pre><h3 id="2-2、字符串函数"><a href="#2-2、字符串函数" class="headerlink" title="2.2、字符串函数"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.2、字符串函数</h3><pre><code>--连接函数SELECT CONCAT ()--SELECT INSTR ();--统计长度SELECT LENGTH();</code></pre><h3 id="2-3、数学函数"><a href="#2-3、数学函数" class="headerlink" title="2.3、数学函数"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.3、数学函数</h3><pre><code>-- 绝对值SELECT ABS(-136);-- 向下取整SELECT FLOOR(3.14);-- 向上取整SELECT CEILING(3.14);</code></pre><h1 id="十一、条件查询"><a href="#十一、条件查询" class="headerlink" title="十一、条件查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>十一、条件查询</h1><p>数据库中存有大量数据，我们可根据需求获取指定的数据。此时，我们可在查询语句中通过WHERE子句指定查询条件对查询结果进行过滤。<br>在开始学习条件查询之前，我们先准备测试数据，代码如下：</p><pre><code>-- 创建数据库DROP DATABASE IF EXISTS mydb;CREATE DATABASE mydb;USE mydb;-- 创建student表CREATE TABLE student (    sid CHAR(6),    sname VARCHAR(50),    age INT,    gender VARCHAR(50) DEFAULT &#39;male&#39;);-- 向student表插入数据INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1001&#39;, &#39;lili&#39;, 14, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1002&#39;, &#39;wang&#39;, 15, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1003&#39;, &#39;tywd&#39;, 16, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1004&#39;, &#39;hfgs&#39;, 17, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1005&#39;, &#39;qwer&#39;, 18, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1006&#39;, &#39;zxsd&#39;, 19, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1007&#39;, &#39;hjop&#39;, 16, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1008&#39;, &#39;tyop&#39;, 15, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1009&#39;, &#39;nhmk&#39;, 13, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1010&#39;, &#39;xdfv&#39;, 17, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1012&#39;, &#39;lili&#39;, 14, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1013&#39;, &#39;wang&#39;, 15, &#39;female&#39;);</code></pre><h2 id="1-使用关系运算符查询"><a href="#1-使用关系运算符查询" class="headerlink" title="1.使用关系运算符查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.使用关系运算符查询</h2><p>在WHERE中可使用关系运算符进行条件查询，常用的关系运算符如下所示：</p><table><thead><tr><th>关系运算符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr></tbody></table><p>查询年龄等于或大于17的学生的信息 MySQL命令：</p><pre><code>select * from student where age&gt;=17;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302194156529.png" alt="在这里插入图片描述"></p><h2 id="2-使用IN关键字查询"><a href="#2-使用IN关键字查询" class="headerlink" title="2.使用IN关键字查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.使用IN关键字查询</h2><p>IN关键字用于判断某个字段的值是否在指定集合中。如果字段的值恰好在指定的集合中，则将字段所在的记录将査询出来。</p><p>查询sid为S_1002和S_1003的学生信息 MySQL命令：</p><pre><code>select * from student where sid in (&#39;S_1002&#39;,&#39;S_1003&#39;);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302195114401.png" alt="在这里插入图片描述"><br>查询sid为S_1001以外的学生的信息 MySQL命令：</p><pre><code>select * from student where sid not in (&#39;S_1001&#39;);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302195321878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-使用BETWEEN-AND关键字查询"><a href="#3-使用BETWEEN-AND关键字查询" class="headerlink" title="3.使用BETWEEN AND关键字查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3.使用BETWEEN AND关键字查询</h2><p>BETWEEN AND用于判断某个字段的值是否在指定的范围之内。如果字段的值在指定范围内，则将所在的记录将查询出来<br>查询15到18岁的学生信息 MySQL命令：</p><pre><code>select * from student where age between 15 and 18;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/2021030219575915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查询不是15到18岁的学生信息 MySQL命令：</p><pre><code>select * from student where age not between 15 and 18;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302195913168.png" alt="在这里插入图片描述"></p><h2 id="4-使用空值查询"><a href="#4-使用空值查询" class="headerlink" title="4.使用空值查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>4.使用空值查询</h2><p>在MySQL中，使用 IS NULL关键字判断字段的值是否为空值。请注意：空值NULL不同于0，也不同于空字符串<br><strong>由于student表没有空值就不演示查询空值的了</strong><br>查询sname不为空值的学生信息 MySQL命令：</p><pre><code>select * from student where sname is not null;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302201810965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5-使用AND关键字查询"><a href="#5-使用AND关键字查询" class="headerlink" title="5.使用AND关键字查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>5.使用AND关键字查询</h2><p>在MySQL中可使用AND关键字可以连接两个或者多个查询条件。<br>查询年纪大于15且性别为male的学生信息 MySQL命令：</p><pre><code>select * from student where age&gt;15 and gender=&#39;male&#39;;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302202328945.png" alt="在这里插入图片描述"></p><h2 id="6-使用OR关键字查询"><a href="#6-使用OR关键字查询" class="headerlink" title="6.使用OR关键字查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>6.使用OR关键字查询</h2><p>在使用SELECT语句查询数据时可使用OR关键字连接多个査询条件。在使用OR关键字时，只要记录满足其中任意一个条件就会被查询出来<br>查询年纪大于15或者性别为male的学生信息 MySQL命令：</p><pre><code>select * from student where age&gt;15 or gender=&#39;male&#39;;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302202642783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="7-使用LIKE关键字查询"><a href="#7-使用LIKE关键字查询" class="headerlink" title="7.使用LIKE关键字查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>7.使用LIKE关键字查询</h2><p>MySQL中可使用LIKE关键字可以判断两个字符串是否相匹配</p><h3 id="7-1-普通字符串"><a href="#7-1-普通字符串" class="headerlink" title="7.1 普通字符串"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>7.1 普通字符串</h3><p>查询sname中与wang匹配的学生信息 MySQL命令：</p><pre><code>select * from student where sname like &#39;wang&#39;;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/202103022030077.png" alt="在这里插入图片描述"></p><h3 id="7-2-含有-通配的字符串"><a href="#7-2-含有-通配的字符串" class="headerlink" title="7.2 含有%通配的字符串"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>7.2 含有%通配的字符串</h3><p>%用于匹配任意长度的字符串。例如，字符串“a%”匹配以字符a开始任意长度的字符串<br>查询学生姓名以li开始的记录 MySQL命令：</p><pre><code>select * from student where sname like &#39;li%&#39;;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302203419987.png" alt="在这里插入图片描述"><br>查询学生姓名以g结尾的记录 MySQL命令：</p><pre><code>select * from student where sname like &#39;%g&#39;;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302203654189.png" alt="在这里插入图片描述"><br>查询学生姓名包含s的记录 MySQL命令：</p><pre><code>select * from student where sname like &#39;%s%&#39;;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210302203828429.png" alt="在这里插入图片描述"></p><h3 id="7-3-含有-通配的字符串"><a href="#7-3-含有-通配的字符串" class="headerlink" title="7.3 含有_通配的字符串"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>7.3 含有_通配的字符串</h3><p>下划线通配符只匹配单个字符，如果要匹配多个字符，需要连续使用多个下划线通配符。例如，字符串“ab_”匹配以字符串“ab”开始长度为3的字符串，如abc、abp等等；字符串“a__d”匹配在字符“a”和“d”之间包含两个字符的字符串，如”abcd”、”atud”等等。<br>查询学生姓名以zx开头且长度为4的记录 MySQL命令：</p><pre><code>select * from student where sname like &#39;zx__&#39;;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210302204051494.png" alt="在这里插入图片描述"></p><p>查询学生姓名以g结尾且长度为4的记录 MySQL命令：</p><pre><code>select * from student where sname like &#39;___g&#39;;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210302204240798.png" alt="在这里插入图片描述"></p><h2 id="8-使用LIMIT限制查询结果的数量"><a href="#8-使用LIMIT限制查询结果的数量" class="headerlink" title="8.使用LIMIT限制查询结果的数量"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>8.使用LIMIT限制查询结果的数量</h2><p>当执行查询数据时可能会返回很多条记录，而用户需要的数据可能只是其中的一条或者几条<br>查询学生表中年纪最小的3位同学 MySQL命令：</p><pre><code>select * from student order by age asc limit 3;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210302204847986.png" alt="在这里插入图片描述"></p><h2 id="9-使用GROUP-BY进行分组查询"><a href="#9-使用GROUP-BY进行分组查询" class="headerlink" title="9.使用GROUP BY进行分组查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>9.使用GROUP BY进行分组查询</h2><p>GROUP BY 子句可像切蛋糕一样将表中的数据进行分组，再进行查询等操作。换言之，可通俗地理解为：通过GROUP BY将原来的表拆分成了几张小表。<br>接下来，我们通过一个例子开始学习GROUP BY，代码如下</p><pre><code>-- 创建数据库DROP DATABASE IF EXISTS mydb;CREATE DATABASE mydb;USE mydb;-- 创建员工表CREATE TABLE employee (    id int,    name varchar(50),    salary int,    departmentnumber int);-- 向员工表中插入数据INSERT INTO employee values(1,&#39;tome&#39;,2000,1001); INSERT INTO employee values(2,&#39;lucy&#39;,9000,1002); INSERT INTO employee values(3,&#39;joke&#39;,5000,1003); INSERT INTO employee values(4,&#39;wang&#39;,3000,1004); INSERT INTO employee values(5,&#39;chen&#39;,3000,1001); INSERT INTO employee values(6,&#39;yukt&#39;,7000,1002); INSERT INTO employee values(7,&#39;rett&#39;,6000,1003); INSERT INTO employee values(8,&#39;mujk&#39;,4000,1004); INSERT INTO employee values(9,&#39;poik&#39;,3000,1001);</code></pre><h3 id="9-1-GROUP-BY和聚合函数一起使用"><a href="#9-1-GROUP-BY和聚合函数一起使用" class="headerlink" title="9.1 GROUP BY和聚合函数一起使用"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>9.1 GROUP BY和聚合函数一起使用</h3><p>统计各部门员工个数 MySQL命令：</p><pre><code>select count(*), departmentnumber from employee group by departmentnumber;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/2021030220555769.png" alt="在这里插入图片描述"><br>统计部门编号大于1001的各部门员工个数 MySQL命令：</p><pre><code>select count(*), departmentnumber from employee where departmentnumber&gt;1001 group by departmentnumber;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210302210134682.png" alt="在这里插入图片描述"></p><h3 id="9-2-GROUP-BY和聚合函数以及HAVING一起使用"><a href="#9-2-GROUP-BY和聚合函数以及HAVING一起使用" class="headerlink" title="9.2 GROUP BY和聚合函数以及HAVING一起使用"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>9.2 GROUP BY和聚合函数以及HAVING一起使用</h3><p>统计工资总和大于8000的部门 MySQL命令：</p><pre><code>select sum(salary),departmentnumber from employee group by departmentnumber having sum(salary)&gt;8000;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210302210627962.png" alt="在这里插入图片描述"></p><h2 id="10-使用ORDER-BY对查询结果排序"><a href="#10-使用ORDER-BY对查询结果排序" class="headerlink" title="10.使用ORDER BY对查询结果排序"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>10.使用ORDER BY对查询结果排序</h2><p>从表中査询出来的数据可能是无序的或者其排列顺序不是我们期望的。为此，我们可以使用ORDER BY对查询结果进行排序<br>其语法格式如下所示：</p><pre><code>SELECT 字段名1,字段名2,…FROM 表名ORDER BY 字段名1 [ASC 丨 DESC],字段名2 [ASC | DESC];</code></pre><p>在该语法中：字段名1、字段名2是查询结果排序的依据；参数 ASC表示按照升序排序，DESC表示按照降序排序；默认情况下，按照ASC方式排序。通常情况下，ORDER BY子句位于整个SELECT语句的末尾。<br>查询所有学生并按照年纪大小升序排列 MySQL命令：</p><pre><code>select * from student order by age asc;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/2021030221134859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查询所有学生并按照年纪大小降序排列 MySQL命令：</p><pre><code>select * from student order by age desc;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210302211454223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="十二、别名设置"><a href="#十二、别名设置" class="headerlink" title="十二、别名设置"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>十二、别名设置</h1><p>在査询数据时可为表和字段取別名，该别名代替表和字段的原名参与查询操作。<br><strong>操作的表事先已准备</strong></p><h2 id="1-为表取别名"><a href="#1-为表取别名" class="headerlink" title="1.为表取别名"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.为表取别名</h2><p>在查询操作时，假若表名很长使用起来就不太方便，此时可为表取一个別名，用该别名来代替表的名称。语法格式如下所示：</p><pre><code>SELECT * FROM 表名 [AS] 表的别名 WHERE .... ;</code></pre><p>将student改为stu查询整表 MySQL命令：</p><pre><code>select * from student as stu;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210303192155711.png" alt="在这里插入图片描述"></p><h2 id="2-为字段取别名"><a href="#2-为字段取别名" class="headerlink" title="2.为字段取别名"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.为字段取别名</h2><p>在查询操作时，假若字段名很长使用起来就不太方便，此时可该字段取一个別名，用该别名来代替字段的名称。语法格式如下所示：</p><pre><code>SELECT 字段名1 [AS] 别名1 , 字段名2 [AS] 别名2 , ... FROM 表名 WHERE ... ;</code></pre><p>将student中的name取别名为“姓名” 查询整表 MySQL命令：</p><pre><code>select name as &#39;姓名&#39;,id from student;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/2021030319253113.png" alt="在这里插入图片描述"></p><h1 id="十三、表的关联关系"><a href="#十三、表的关联关系" class="headerlink" title="十三、表的关联关系"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>十三、表的关联关系</h1><p>在实际开发中数据表之间存在着各种关联关系。在此，介绍MySQL中数据表的三种关联关系。<br><strong>多对一</strong><br>多对一(亦称为一对多)是数据表中最常见的一种关系。例如：员工与部门之间的关系，一个部门可以有多个员工；而一个员工不能属于多个部门只属于某个部门。在多对一的表关系 中，应将外键建在多的一方否则会造成数据的冗余。<br><strong>多对多</strong><br>多对多是数据表中常见的一种关系。例如：学生与老师之间的关系，一个学生可以有多个老师而且一个老师有多个学生。通常情况下，为了实现这种关系需要定义一张中间表(亦称为连接表)该表会存在两个外键分别参照老师表和学生表。<br><strong>一对一</strong><br>在开发过程中，一对一的关联关系在数据库中并不常见；因为以这种方式存储的信息通常会放在同一张表中。<br>接下来，我们来学习在一对多的关联关系中如果添加和删除数据。先准备一些测试数据，代码如下：</p><pre><code>DROP TABLE IF EXISTS student;DROP TABLE IF EXISTS class;-- 创建班级表CREATE TABLE class(    cid int(4) NOT NULL PRIMARY KEY,    cname varchar(30) );-- 创建学生表CREATE TABLE student(    sid int(8) NOT NULL PRIMARY KEY,    sname varchar(30),    classid int(8) NOT NULL);-- 为学生表添加外键约束ALTER TABLE student ADD CONSTRAINT fk_student_classid FOREIGN KEY(classid) REFERENCES class(cid);-- 向班级表插入数据INSERT INTO class(cid,cname)VALUES(1,&#39;Java&#39;);INSERT INTO class(cid,cname)VALUES(2,&#39;Python&#39;);-- 向学生表插入数据INSERT INTO student(sid,sname,classid)VALUES(1,&#39;tome&#39;,1);INSERT INTO student(sid,sname,classid)VALUES(2,&#39;lucy&#39;,1);INSERT INTO student(sid,sname,classid)VALUES(3,&#39;lili&#39;,2);INSERT INTO student(sid,sname,classid)VALUES(4,&#39;domi&#39;,2);</code></pre><h2 id="1-关联查询"><a href="#1-关联查询" class="headerlink" title="1.关联查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.关联查询</h2><p>查询Java班的所有学生 MySQL命令：</p><pre><code>select * from student where classid=(select cid from class where cname=&#39;Java&#39;);</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/2021030319330865.png" alt="在这里插入图片描述"></p><h2 id="2-关于关联关系的删除数据"><a href="#2-关于关联关系的删除数据" class="headerlink" title="2.关于关联关系的删除数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.关于关联关系的删除数据</h2><p>请从班级表中删除Java班级。在此，请注意：班级表和学生表之间存在关联关系；要删除Java班级，应该先删除学生表中与该班相关联的学生。否则，假若先删除Java班那么学生表中的cid就失去了关联<br>删除Java班 MySQL命令：</p><pre><code>delete from student where classid=(select cid from class where cname=&#39;Java&#39;);delete from class where cname=&#39;Java&#39;;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/2021030319415767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="十四、多表连接查询"><a href="#十四、多表连接查询" class="headerlink" title="十四、多表连接查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>十四、多表连接查询</h1><h2 id="1-交叉连接查询"><a href="#1-交叉连接查询" class="headerlink" title="1.交叉连接查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.交叉连接查询</h2><p>交叉连接返回的结果是被连接的两个表中所有数据行的笛卡儿积；比如：集合A={a,b}，集合B={0,1,2}，则集合A和B的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)}。所以，交叉连接也被称为笛卡尔连接，其语法格式如下：</p><pre><code>SELECT * FROM 表1 CROSS JOIN 表2;</code></pre><p>在该语法中：CROSS JOIN用于连接两个要查询的表，通过该语句可以查询两个表中所有的数据组合。<br><strong>由于这个交叉连接查询在实际运用中没有任何意义，所以只做为了解即可</strong></p><h2 id="2-内连接查询"><a href="#2-内连接查询" class="headerlink" title="2.内连接查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.内连接查询</h2><p>内连接(Inner Join)又称简单连接或自然连接，是一种非常常见的连接查询。内连接使用比较运算符对两个表中的数据进行比较并列出与连接条件匹配的数据行，组合成新的 记录。也就是说在内连接查询中只有满足条件的记录才能出现在查询结果中。其语法格式如下：</p><pre><code>SELECT 查询字段1,查询字段2, ... FROM 表1 [INNER] JOIN 表2 ON 表1.关系字段=表2.关系字段</code></pre><p>在该语法中：INNER JOIN用于连接两个表，ON来指定连接条件；其中INNER可以省略。</p><p>准备数据，代码如下：</p><pre><code>-- 若存在数据库mydb则删除DROP DATABASE IF EXISTS mydb;-- 创建数据库mydbCREATE DATABASE mydb;-- 选择数据库mydbUSE mydb;-- 创建部门表CREATE TABLE department(  did int (4) NOT NULL PRIMARY KEY,   dname varchar(20));-- 创建员工表CREATE TABLE employee (  eid int (4) NOT NULL PRIMARY KEY,   ename varchar (20),   eage int (2),   departmentid int (4) NOT NULL);-- 向部门表插入数据INSERT INTO department VALUES(1001,&#39;财务部&#39;);INSERT INTO department VALUES(1002,&#39;技术部&#39;);INSERT INTO department VALUES(1003,&#39;行政部&#39;);INSERT INTO department VALUES(1004,&#39;生活部&#39;);-- 向员工表插入数据INSERT INTO employee VALUES(1,&#39;张三&#39;,19,1003);INSERT INTO employee VALUES(2,&#39;李四&#39;,18,1002);INSERT INTO employee VALUES(3,&#39;王五&#39;,20,1001);INSERT INTO employee VALUES(4,&#39;赵六&#39;,20,1004);</code></pre><p>查询员工姓名及其所属部门名称 MySQL命令：</p><pre><code>select employee.ename,department.dname from department inner join employee on department.did=employee.departmentid;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/2021030320040897.png" alt="在这里插入图片描述"></p><h2 id="3-外连接查询"><a href="#3-外连接查询" class="headerlink" title="3.外连接查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3.外连接查询</h2><p>在使用内连接查询时我们发现：返回的结果只包含符合查询条件和连接条件的数据。但是，有时还需要在返回查询结果中不仅包含符合条件的数据，而且还包括左表、右表或两个表中的所有数据，此时我们就需要使用外连接查询。外连接又分为左(外)连接和右(外)连接。其语法格式如下：</p><pre><code>SELECT 查询字段1,查询字段2, ... FROM 表1 LEFT | RIGHT [OUTER] JOIN 表2 ON 表1.关系字段=表2.关系字段 WHERE 条件</code></pre><p>由此可见，外连接的语法格式和内连接非常相似，只不过使用的是LEFT [OUTER] JOIN、RIGHT [OUTER] JOIN关键字。其中，关键字左边的表被称为左表，关键字右边的表被称为右表；OUTER可以省略。<br>在使用左(外)连接和右(外)连接查询时，查询结果是不一致的，具体如下：<br><strong>1、LEFT [OUTER] JOIN 左(外)连接：返回包括左表中的所有记录和右表中符合连接条件的记录。<br>2、RIGHT [OUTER] JOIN 右(外)连接：返回包括右表中的所有记录和左表中符合连接条件的记录。</strong></p><p>先准备数据，代码如下：</p><pre><code>-- 若存在数据库mydb则删除DROP DATABASE IF EXISTS mydb;-- 创建数据库mydbCREATE DATABASE mydb;-- 选择数据库mydbUSE mydb;-- 创建班级表CREATE TABLE class(  cid int (4) NOT NULL PRIMARY KEY,   cname varchar(20));-- 创建学生表CREATE TABLE student (  sid int (4) NOT NULL PRIMARY KEY,   sname varchar (20),   sage int (2),   classid int (4) NOT NULL);-- 向班级表插入数据INSERT INTO class VALUES(1001,&#39;Java&#39;);INSERT INTO class VALUES(1002,&#39;C++&#39;);INSERT INTO class VALUES(1003,&#39;Python&#39;);INSERT INTO class VALUES(1004,&#39;PHP&#39;);-- 向学生表插入数据INSERT INTO student VALUES(1,&#39;张三&#39;,20,1001);INSERT INTO student VALUES(2,&#39;李四&#39;,21,1002);INSERT INTO student VALUES(3,&#39;王五&#39;,24,1002);INSERT INTO student VALUES(4,&#39;赵六&#39;,23,1003);INSERT INTO student VALUES(5,&#39;Jack&#39;,22,1009);</code></pre><p><em>准备这组数据有一定的特点，为的是让大家直观的看出左连接与右连接的不同之处<br>1、班级编号为1004的PHP班级没有学生<br>2、学号为5的学生王跃跃班级编号为1009，该班级编号并不在班级表中</em></p><h3 id="3-1-左（外）连接查询"><a href="#3-1-左（外）连接查询" class="headerlink" title="3.1 左（外）连接查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3.1 左（外）连接查询</h3><p>左(外)连接的结果包括LEFT JOIN子句中指定的左表的所有记录，以及所有满足连接条件的记录。如果左表的某条记录在右表中不存在则在右表中显示为空。<br>查询每个班的班级ID、班级名称及该班的所有学生的名字 MySQL命令：</p><pre><code>select class.cid,class.cname,student.sname from class left outer join student on class.cid=student.classid;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210303201647123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>展示结果分析：<br>1、分别找出Java班、C++班、Python班的学生<br>2、右表的王跃跃不满足查询条件故其没有出现在查询结果中<br>3、虽然左表的PHP班没有学生，但是任然显示了PHP的信息；但是，它对应的学生名字为NULL</p><h3 id="3-2-右（外）连接查询"><a href="#3-2-右（外）连接查询" class="headerlink" title="3.2 右（外）连接查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3.2 右（外）连接查询</h3><p>右(外)连接的结果包括RIGHT JOIN子句中指定的右表的所有记录，以及所有满足连接条件的记录。如果右表的某条记录在左表中没有匹配，则左表将返回空值。<br>查询每个班的班级ID、班级名称及该班的所有学生的名字 MySQL命令：</p><pre><code>select class.cid,class.cname,student.sname from class right outer join student on class.cid=student.classid;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210303202037216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>展示结果分析：<br>1、分别找出Java班、C++班、Python班的学生<br>2、左表的PHP班不满足查询条件故其没有出现在查询结果中<br>3、虽然右表的jack没有对应班级，但是任然显示王跃跃的信息；但是，它对应的班级以及班级编号均为NULL</p><h1 id="十五、子查询"><a href="#十五、子查询" class="headerlink" title="十五、子查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>十五、子查询</h1><p>子查询是指一个查询语句嵌套在另一个查询语句内部的查询；该查询语句可以嵌套在一个 SELECT、SELECT…INTO、INSERT…INTO等语句中。在执行查询时，首先会执行子查询中的语句，再将返回的结果作为外层查询的过滤条件。在子査询中通常可以使用比较运算符和IN、EXISTS、ANY、ALL等关键字。</p><p>准备数据，代码如下：</p><pre><code>DROP TABLE IF EXISTS student;DROP TABLE IF EXISTS class;-- 创建班级表CREATE TABLE class(  cid int (4) NOT NULL PRIMARY KEY,   cname varchar(20));-- 创建学生表CREATE TABLE student (  sid int (4) NOT NULL PRIMARY KEY,   sname varchar (20),   sage int (2),   classid int (4) NOT NULL);-- 向班级表插入数据INSERT INTO class VALUES(1001,&#39;Java&#39;);INSERT INTO class VALUES(1002,&#39;C++&#39;);INSERT INTO class VALUES(1003,&#39;Python&#39;);INSERT INTO class VALUES(1004,&#39;PHP&#39;);INSERT INTO class VALUES(1005,&#39;Android&#39;);-- 向学生表插入数据INSERT INTO student VALUES(1,&#39;张三&#39;,20,1001);INSERT INTO student VALUES(2,&#39;李四&#39;,21,1002);INSERT INTO student VALUES(3,&#39;王五&#39;,24,1003);INSERT INTO student VALUES(4,&#39;赵六&#39;,23,1004);INSERT INTO student VALUES(5,&#39;小明&#39;,21,1001);INSERT INTO student VALUES(6,&#39;小红&#39;,26,1001);INSERT INTO student VALUES(7,&#39;小亮&#39;,27,1002);</code></pre><h2 id="1-带比较运算符的子查询"><a href="#1-带比较运算符的子查询" class="headerlink" title="1.带比较运算符的子查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.带比较运算符的子查询</h2><p>比较运算符前面我们提到过得，就是&gt;、&lt;、=、&gt;=、&lt;=、!=等<br>查询张三同学所在班级的信息 MySQL命令：</p><pre><code>select * from class where cid=(select classid from student where sname=&#39;张三&#39;);</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/2021030320275492.png" alt="在这里插入图片描述"><br>查询比张三同学所在班级编号还大的班级的信息 MySQL命令：</p><pre><code>select * from class where cid&gt;(select classid from student where sname=&#39;张三&#39;);</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210303203231622.png" alt="在这里插入图片描述"></p><h2 id="2-带EXISTS关键字的子查询"><a href="#2-带EXISTS关键字的子查询" class="headerlink" title="2.带EXISTS关键字的子查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.带EXISTS关键字的子查询</h2><p>EXISTS关键字后面的参数可以是任意一个子查询， 它不产生任何数据只返回TRUE或FALSE。当返回值为TRUE时外层查询才会 执行<br>假如王五同学在学生表中则从班级表查询所有班级信息 MySQL命令：</p><pre><code>select * from class where exists (select * from student where sname=&#39;王五&#39;);</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210303203707252.png" alt="在这里插入图片描述"></p><h2 id="3-带ANY关键字的子查询"><a href="#3-带ANY关键字的子查询" class="headerlink" title="3.带ANY关键字的子查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3.带ANY关键字的子查询</h2><p>ANY关键字表示满足其中任意一个条件就返回一个结果作为外层查询条件。</p><p>查询比任一学生所属班级号还大的班级编号 MySQL命令：</p><pre><code>select * from class where cid &gt; any (select classid from student);</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210303204057530.png" alt="在这里插入图片描述"></p><h2 id="4-带ALL关键字的子查询"><a href="#4-带ALL关键字的子查询" class="headerlink" title="4.带ALL关键字的子查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>4.带ALL关键字的子查询</h2><p>ALL关键字与ANY有点类似，只不过带ALL关键字的子査询返回的结果需同时满足所有内层査询条件。</p><p>查询比所有学生所属班级号还大的班级编号 MySQL命令：</p><pre><code>select * from class where cid &gt; all (select classid from student);</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210303204447489.png" alt="在这里插入图片描述"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>总结</h1><p><strong>重要</strong>（从关键字分析）：<br><strong>查询语句的书写顺序和执行顺序</strong><br>select ===&gt; from ===&gt; where ===&gt; group by ===&gt; having ===&gt; order by ===&gt; limit<br><strong>查询语句的执行顺序</strong><br>from ===&gt; where ===&gt; group by ===&gt; having ===&gt; select ===&gt; order by ===&gt; limi</p><p>基于复习，乐于分享 所以有了这篇文章！！！<br><img src="https://img-blog.csdnimg.cn/20210303204835945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>本文转自 <a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164574504116780274141388&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>top_positive~default-1-114287877.pc_search_result_positive&amp;utm_term=mysql&amp;spm=1018.2226.3001.4187</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;文章目录&quot;&gt;&lt;a href=&quot;#文章目录&quot; class=&quot;headerlink&quot; title=&quot;文章目录&quot;&gt;&lt;/a&gt;文章目录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;  &lt;a href=&quot;about:blank#_5&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;  &lt;a href=&quot;ab</summary>
      
    
    
    
    <category term="数据库" scheme="https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
    <category term="MySQL总结" scheme="https://ysluckly.github.io/tags/MySQL%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Go WebAssembly (Wasm) 简明教程</title>
    <link href="https://ysluckly.github.io/2022/01/17/go/"/>
    <id>https://ysluckly.github.io/2022/01/17/go/</id>
    <published>2022-01-17T13:59:10.000Z</published>
    <updated>2022-02-20T13:38:38.925Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919113247.jpg" alt="Golang WebAssembly"></p><h2 id="1-WebAssembly-简介"><a href="#1-WebAssembly-简介" class="headerlink" title="1 WebAssembly 简介"></a>1 WebAssembly 简介</h2><blockquote><p>WebAssembly是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如C / C ++等语言提供一个编译目标，以便它们可以在Web上运行。它也被设计为可以与JavaScript共存，允许两者一起工作。  —— <a href="https://developer.mozilla.org/zh-CN/docs/WebAssembly">MDN web docs - mozilla.org</a></p></blockquote><p>从 MDN 的介绍中，我们可以得出几个结论：</p><ul><li>1）WebAssembly 是一种二进制编码格式，而不是一门新的语言。</li><li><ol start="2"><li>WebAssembly 不是为了取代 JavaScript，而是一种补充（至少现阶段是这样），结合 WebAssembly 的性能优势，很大可能集中在对性能要求高（例如游戏，AI），或是对交互体验要求高（例如移动端）的场景。</li></ol></li><li>3）C/C++ 等语言可以编译 WebAssembly 的目标文件，也就是说，其他语言可以通过编译器支持，而写出能够在浏览器前端运行的代码。</li></ul><p>Go 语言在 1.11 版本(2018年8月) 加入了对 WebAssembly (Wasm) 的原生支持，使用 Go 语言开发 WebAssembly 相关的应用变得更加地简单。Go 语言的内建支持是 Go 语言进军前端的一个重要的里程碑。在这之前，如果想使用 Go 语言开发前端，需要使用 <a href="https://github.com/gopherjs/gopherjs">GopherJS</a>，GopherJS 是一个编译器，可以将 Go 语言转换成可以在浏览器中运行的 JavaScript 代码。新版本的 Go 则直接将 Go 代码编译为 wasm 二进制文件，而不再需要转为 JavaScript 代码。更巧的是，实现 GopherJS 和在 Go 语言中内建支持 WebAssembly 的是同一拨人。</p><p>Go 语言实现的函数可以直接导出供 JavaScript 代码调用，同时，Go 语言内置了 <a href="https://github.com/golang/go/tree/master/src/syscall/js">syscall/js</a> 包，可以在 Go 语言中直接调用 JavaScript 函数，包括对 DOM 树的操作。</p><h2 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2 Hello World"></a>2 Hello World</h2><p>如果对 Go 语言不熟悉，推荐 <a href="https://geektutu.com/post/quick-golang.html">Go 语言简明教程</a>，一篇文章快速入门。</p><p>接下来，我们使用 Go 语言实现一个最简单的程序，在网页上弹出 <code>Hello World</code>。</p><p>第一步，新建文件 main.go，使用 js.Global().get(‘alert’) 获取全局的 alert 对象，通过 Invoke 方法调用。等价于在 js 中调用 <code>window.alert(&quot;Hello World&quot;)</code>。</p><pre><code class="go">// main.gopackage mainimport &quot;syscall/js&quot;func main() &#123;    alert := js.Global().Get(&quot;alert&quot;)    alert.Invoke(&quot;Hello World!&quot;)&#125;</code></pre><p>第二步，将 main.go 编译为 static/main.wasm</p><blockquote><p>如果启用了 <code>GO MODULES</code>，则需要使用 go mod init 初始化模块，或设置 GO111MODULE=auto。</p></blockquote><pre><code class="bash">$ GOOS=js GOARCH=wasm go build -o static/main.wasm</code></pre><p>第三步，拷贝 wasm_exec.js (JavaScript 支持文件，加载 wasm 文件时需要) 到 static 文件夹</p><pre><code class="bash">$ cp &quot;$(go env GOROOT)/misc/wasm/wasm_exec.js&quot; static</code></pre><p>第四步，创建 index.html，引用 <code>static/main.wasm</code> 和 <code>static/wasm_exec.js</code>。</p><pre><code class="html">&lt;html&gt;&lt;script src=&quot;static/wasm_exec.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    const go = new Go();    WebAssembly.instantiateStreaming(fetch(&quot;static/main.wasm&quot;), go.importObject)        .then((result) =&gt; go.run(result.instance));&lt;/script&gt;&lt;/html&gt;</code></pre><p>第五步，使用 goexec 启动 Web 服务</p><blockquote><p>如果没有安装 goexec，可用 <code>go get -u github.com/shurcooL/goexec</code> 安装，需要将 $GOBIN 或 $GOPATH/bin 加入环境变量</p></blockquote><p>当前的目录结构如下：</p><pre><code class="bash">demo/   |--static/      |--wasm_exec.js      |--main.wasm   |--main.go   |--index.html</code></pre><pre><code class="bash">$ goexec &#39;http.ListenAndServe(`:9999`, http.FileServer(http.Dir(`.`)))&#39;</code></pre><p>浏览器访问 localhost:9999，则会有一个弹出窗口，上面写着 *Hello World!*。</p><p><img src="quick-go-wasm/hello_world.png" alt="go wasm hello world demo"></p><p>为了避免每次编译都需要输入繁琐的命令，可将这个过程写在 <code>Makefile</code> 中</p><pre><code class="makefile">all: static/main.wasm static/wasm_exec.js    goexec &#39;http.ListenAndServe(`:9999`, http.FileServer(http.Dir(`.`)))&#39;static/wasm_exec.js:    cp &quot;$(shell go env GOROOT)/misc/wasm/wasm_exec.js&quot; staticstatic/main.wasm : main.go    GO111MODULE=auto GOOS=js GOARCH=wasm go build -o static/main.wasm .</code></pre><p>这样一个敲一下 make 就够了，代码已经上传到 <a href="https://github.com/geektutu/7days-golang/tree/master/demo-wasm">7days-golang - github.com</a>。</p><h2 id="3-注册函数-Register-Functions"><a href="#3-注册函数-Register-Functions" class="headerlink" title="3 注册函数(Register Functions)"></a>3 注册函数(Register Functions)</h2><p>在 Go 语言中调用 JavaScript 函数是一方面，另一方面，如果仅仅是使用 WebAssembly 替代性能要求高的模块，那么就需要注册函数，以便其他 JavaScript 代码调用。</p><p>假设我们需要注册一个计算斐波那契数列的函数，可以这么实现。</p><pre><code class="go">// main.gopackage mainimport &quot;syscall/js&quot;func fib(i int) int &#123;    if i == 0 || i == 1 &#123;        return 1    &#125;    return fib(i-1) + fib(i-2)&#125;func fibFunc(this js.Value, args []js.Value) interface&#123;&#125; &#123;    return js.ValueOf(fib(args[0].Int()))&#125;func main() &#123;    done := make(chan int, 0)    js.Global().Set(&quot;fibFunc&quot;, js.FuncOf(fibFunc))    &lt;-done&#125;</code></pre><ul><li>fib 是一个普通的 Go 函数，通过递归计算第 i 个斐波那契数，接收一个 int 入参，返回值也是 int。</li><li>定义了 fibFunc 函数，为 fib 函数套了一个壳，从 args[0] 获取入参，计算结果用 js.ValueOf 包装，并返回。</li><li>使用 js.Global().Set() 方法，将注册函数 fibFunc 到全局，以便在浏览器中能够调用。</li></ul><p><code>js.Value</code> 可以将 Js 的值转换为 Go 的值，比如 args[0].Int()，则是转换为 Go 语言中的整型。<code>js.ValueOf</code>，则用来将 Go 的值，转换为 Js 的值。另外，注册函数的时候，使用 js.FuncOf 将函数转换为 <code>Func</code> 类型，只有 Func 类型的函数，才能在 JavaScript 中调用。可以认为这是 Go 与 JavaScript 之间的接口/约定。</p><p><code>js.Func()</code> 接受一个函数类型作为其参数，该函数的定义必须是：</p><pre><code class="go">func(this Value, args []Value) interface&#123;&#125;// this 即 JavaScript 中的 this// args 是在 JavaScript 中调用该函数的参数列表。// 返回值需用 js.ValueOf 映射成 JavaScript 的值</code></pre><p>在 main 函数中，创建了信道(chan) done，阻塞主协程(goroutine)。fibFunc 如果在 JavaScript 中被调用，会开启一个新的子协程执行。</p><blockquote><p>A wrapped function triggered during a call from Go to JavaScript gets executed on the same goroutine. A wrapped function triggered by JavaScript’s event loop gets executed on an extra goroutine.  —— <a href="https://golang.org/pkg/syscall/js/#FuncOf">FuncOf - golang.org</a></p></blockquote><p>接下来，修改之前的 index.html，在其中添加一个输入框(num)，一个按钮(btn) 和一个文本框(ans，用来显示计算结果)，并给按钮添加了一个点击事件，调用 fibFunc，并将计算结果显示在文本框(ans)中。</p><pre><code class="html">&lt;html&gt;...&lt;body&gt;    &lt;input id=&quot;num&quot; type=&quot;number&quot; /&gt;    &lt;button id=&quot;btn&quot; onclick=&quot;ans.innerHTML=fibFunc(num.value * 1)&quot;&gt;Click&lt;/button&gt;    &lt;p id=&quot;ans&quot;&gt;1&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>使用之前的命令重新编译 main.go，并在 9999 端口启动 Web 服务，如果我们已经将命令写在 Makefile 中了，只需要运行 <code>make</code> 即可。</p><p>接下来访问 localhost:9999，可以看到如下效果。输入一个数字，点击<code>Click</code>，计算结果显示在输入框下方。</p><p><img src="quick-go-wasm/register_functions.png" alt="register functions demo"></p><h2 id="4-操作-DOM"><a href="#4-操作-DOM" class="headerlink" title="4 操作 DOM"></a>4 操作 DOM</h2><p>在上一个例子中，仅仅是注册了全局函数 fibFunc，事件注册，调用，对 DOM 元素的操作都是在 HTML<br>中通过原生的 JavaScript 函数实现的。这些事情，能不能全部在 Go 语言中完成呢？答案可以。</p><p>首先修改 index.html，删除事件注册部分和 对 DOM 元素的操作部分。</p><pre><code class="html">&lt;html&gt;...&lt;body&gt;    &lt;input id=&quot;num&quot; type=&quot;number&quot; /&gt;    &lt;button id=&quot;btn&quot;&gt;Click&lt;/button&gt;    &lt;p id=&quot;ans&quot;&gt;1&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>修改 main.go：</p><pre><code class="go">package mainimport (    &quot;strconv&quot;    &quot;syscall/js&quot;)func fib(i int) int &#123;    if i == 0 || i == 1 &#123;        return 1    &#125;    return fib(i-1) + fib(i-2)&#125;var (    document = js.Global().Get(&quot;document&quot;)    numEle   = document.Call(&quot;getElementById&quot;, &quot;num&quot;)    ansEle   = document.Call(&quot;getElementById&quot;, &quot;ans&quot;)    btnEle   = js.Global().Get(&quot;btn&quot;))func fibFunc(this js.Value, args []js.Value) interface&#123;&#125; &#123;    v := numEle.Get(&quot;value&quot;)    if num, err := strconv.Atoi(v.String()); err == nil &#123;        ansEle.Set(&quot;innerHTML&quot;, js.ValueOf(fib(num)))    &#125;    return nil&#125;func main() &#123;    done := make(chan int, 0)    btnEle.Call(&quot;addEventListener&quot;, &quot;click&quot;, js.FuncOf(fibFunc))    &lt;-done&#125;</code></pre><ul><li>通过 <code>js.Global().Get(&quot;btn&quot;)</code> 或 <code>document.Call(&quot;getElementById&quot;, &quot;num&quot;)</code> 两种方式获取到 DOM 元素。</li><li>btnEle 调用 <code>addEventListener</code> 为 btn 绑定点击事件 fibFunc。</li><li>在 fibFunc 中使用 <code>numEle.Get(&quot;value&quot;)</code> 获取到 numEle 的值（字符串），转为整型并调用 fib 计算出结果。</li><li>ansEle 调用 <code>Set(&quot;innerHTML&quot;, ...)</code> 渲染计算结果。</li></ul><p>重新编译 main.go，访问 localhost:9999，效果与之前是一致的。</p><h2 id="5-回调函数-Callback-Functions"><a href="#5-回调函数-Callback-Functions" class="headerlink" title="5 回调函数(Callback Functions)"></a>5 回调函数(Callback Functions)</h2><p>在 JavaScript 中，异步+回调是非常常见的，比如请求一个 Restful API，注册一个回调函数，待数据获取到，再执行回调函数的逻辑，这个期间程序可以继续做其他的事情。Go 语言可以通过协程实现异步。</p><p>假设 fib 的计算非常耗时，那么可以启动注册一个回调函数，待 fib 计算完成后，再把计算结果显示出来。</p><p>我们先修改 main.go，使得 fibFunc 支持传入回调函数。</p><pre><code class="go">package mainimport (    &quot;syscall/js&quot;    &quot;time&quot;)func fib(i int) int &#123;    if i == 0 || i == 1 &#123;        return 1    &#125;    return fib(i-1) + fib(i-2)&#125;func fibFunc(this js.Value, args []js.Value) interface&#123;&#125; &#123;    callback := args[len(args)-1]    go func() &#123;        time.Sleep(3 * time.Second)        v := fib(args[0].Int())        callback.Invoke(v)    &#125;()    js.Global().Get(&quot;ans&quot;).Set(&quot;innerHTML&quot;, &quot;Waiting 3s...&quot;)    return nil&#125;func main() &#123;    done := make(chan int, 0)    js.Global().Set(&quot;fibFunc&quot;, js.FuncOf(fibFunc))    &lt;-done&#125;</code></pre><ul><li>假设调用 fibFunc 时，回调函数作为最后一个参数，那么通过 args[len(args)-1] 便可以获取到该函数。这与其他类型参数的传递并无区别。</li><li>使用 <code>go func()</code> 启动子协程，调用 fib 计算结果，计算结束后，调用回调函数 <code>callback</code>，并将计算结果传递给回调函数，使用 time.Sleep() 模拟 3s 的耗时操作。</li><li>计算结果出来前，先在界面上显示 <code>Waiting 3s...</code></li></ul><p>接下来我们修改 index.html，为按钮添加点击事件，调用 fibFunc</p><pre><code class="html">&lt;html&gt;...&lt;body&gt;    &lt;input id=&quot;num&quot; type=&quot;number&quot; /&gt;    &lt;button id=&quot;btn&quot; onclick=&quot;fibFunc(num.value * 1, (v)=&gt; ans.innerHTML=v)&quot;&gt;Click&lt;/button&gt;    &lt;p id=&quot;ans&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>为 btn 注册了点击事件，第一个参数是待计算的数字，从 num 输入框获取。</li><li>第二个参数是一个回调函数，将参数 v 显示在 ans 文本框中。</li></ul><p>接下来，重新编译 main.go，访问 localhost:9999，随便输入一个数字，点击 Click。页面会先显示 <code>Waiting 3s...</code>，3s过后显示计算结果。</p><p><img src="quick-go-wasm/callback.png" alt="go wasm callback demo"></p><h2 id="6-进一步的尝试"><a href="#6-进一步的尝试" class="headerlink" title="6 进一步的尝试"></a>6 进一步的尝试</h2><h3 id="6-1-工具框架"><a href="#6-1-工具框架" class="headerlink" title="6.1 工具框架"></a>6.1 工具框架</h3><ul><li>WebAssembly 的二进制分析工具 <a href="https://wasdk.github.io/wasmcodeexplorer/">WebAssembly Code Explorer</a></li><li>使用NodeJs 或浏览器测试 Go Wasm 代码 <a href="https://github.com/golang/go/wiki/WebAssembly#executing-webassembly-with-nodejs">Github Wiki</a></li><li>借鉴 Vue 实现的 Golang WebAssembly 前端框架 <a href="https://www.vugu.org/doc/start">Vugu</a>，完全使用 Go，不用写任何的 JavaScript 代码。</li></ul><h3 id="6-2-Demo-项目"><a href="#6-2-Demo-项目" class="headerlink" title="6.2 Demo/项目"></a>6.2 Demo/项目</h3><ul><li>使用 Go Assembly 前端渲染的一些<a href="https://stdiopt.github.io/gowasm-experiments/">例子</a></li><li><a href="https://github.com/dave/jsgo">jsgo</a> 这个项目汇聚一些小而精的项目，包括 <a href="https://jsgo.io/hajimehoshi/ebiten/examples/2048">2048</a>，<a href="https://jsgo.io/hajimehoshi/ebiten/examples/blocks">俄罗斯方块</a>等游戏，还有证明 Go 可以完整开发前端项目的 <a href="https://jsgo.io/dave/todomvc">TodoMVC</a></li></ul><h3 id="6-3-相关文档"><a href="#6-3-相关文档" class="headerlink" title="6.3 相关文档"></a>6.3 相关文档</h3><ul><li><a href="https://golang.org/pkg/syscall/js">syscall/js 官方文档 - golang.org</a></li><li><a href="https://github.com/golang/go/wiki/WebAssembly">Go WebAssembly 官方文档 - github.com</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919113247.jpg&quot; alt=&quot;Golang WebAssembly&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-WebAssembly-简</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Go WebAssembly" scheme="https://ysluckly.github.io/tags/Go-WebAssembly/"/>
    
    <category term="wasm" scheme="https://ysluckly.github.io/tags/wasm/"/>
    
    <category term="gopherjs" scheme="https://ysluckly.github.io/tags/gopherjs/"/>
    
  </entry>
  
  <entry>
    <title>Go RPC &amp; TLS 鉴权简明教程</title>
    <link href="https://ysluckly.github.io/2022/01/16/go/"/>
    <id>https://ysluckly.github.io/2022/01/16/go/</id>
    <published>2022-01-16T13:59:10.000Z</published>
    <updated>2022-02-20T13:37:43.335Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了 Go 语言远程过程调用(Remote Procedure Call, RPC)的使用方式，示例基于 Golang 标准库 net/rpc，同时介绍了如何基于 TLS/SSL 实现服务器端和客户端的单向鉴权、双向鉴权。</p><h2 id="1-RPC-简介"><a href="#1-RPC-简介" class="headerlink" title="1 RPC 简介"></a>1 RPC 简介</h2><blockquote><p>远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。RPC是一种服务器-客户端（Client/Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。<br>– <a href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8">远程过程调用 - Wikipedia.org</a></p></blockquote><p>划重点：<strong>程序员就像调用本地程序一样，无需关注细节</strong></p><p>RPC 协议假定某种传输协议(TCP, UDP)存在，为通信程序之间携带信息数据。使用 RPC 协议，无需关注底层网络技术协议，调用远程方法就像在调用本地方法一样。</p><p>RPC 流程：</p><p><img src="quick-go-rpc/rpc-procedure.jpg" alt="RPC PROCEDURE"></p><p>RPC 模型是一个典型的客户端-服务器模型(Client-Server, CS)，相比于调用本地的接口，RPC 还需要知道的是服务器端的地址信息。本地调用，好比两个人面对面说话，而 RPC 好比打电话，需要知道对方的电话号码，但是并不需要关心语音是怎么编码，如何传输，又如何解码的。</p><p>接下来我们将展示如何将一个简单的本地调用的程序一步步地改造一个 RPC 服务。</p><p>示例使用 Go 语言，RPC 使用 Golang 提供的<code>net/rpc</code> 标准库</p><h2 id="2-一个简单的计算二次方的程序"><a href="#2-一个简单的计算二次方的程序" class="headerlink" title="2 一个简单的计算二次方的程序"></a>2 一个简单的计算二次方的程序</h2><p>不考虑 RPC 调用，仅考虑本地调用的场景，程序实现如下：</p><pre><code class="go">// main.gopackage mainimport &quot;log&quot;type Result struct &#123;    Num, Ans int&#125;type Cal intfunc (cal *Cal) Square(num int) *Result &#123;    return &amp;Result&#123;        Num: num,        Ans: num * num,    &#125;&#125;func main() &#123;    cal := new(Cal)    result := cal.Square(12)    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)&#125;</code></pre><p>在这个20行的程序中，我们做了以下几件事：</p><ul><li><code>Cal</code> 结构体，提供了 Square 方法，用于计算传入参数 num 的 二次方。</li><li><code>Result</code> 结构体，包含 Num 和 Ans 两个字段，Ans 是计算后的值，Num 是待计算的值。</li><li><code>main</code> 函数，测试我们实现的 Square 方法。</li></ul><p>运行 main.go，将会输出</p><pre><code class="go">$ go run main.go2020/01/13 20:27:08 12^2 = 144</code></pre><h2 id="3-RPC-需要满足什么条件"><a href="#3-RPC-需要满足什么条件" class="headerlink" title="3 RPC 需要满足什么条件"></a>3 RPC 需要满足什么条件</h2><p>虽然说，远程过程调用并不需要我们关心如何编解码，如何通信，但是最基本的，如果一个方法需要支持远程过程调用，需要满足一定的约束和规范。不同 RPC 框架的约束和规范是不同的，如果使用 Golang 的标准库 <code>net/rpc</code>，方法需要长这个样子：</p><pre><code class="go">func (t *T) MethodName(argType T1, replyType *T2) error</code></pre><p>即需要满足以下 5 个条件：</p><ul><li><ol><li>方法类型（T）是导出的（首字母大写） </li></ol></li><li><ol start="2"><li>方法名（MethodName）是导出的</li></ol></li><li><ol start="3"><li>方法有2个参数(argType T1, replyType *T2)，均为导出/内置类型</li></ol></li><li><ol start="4"><li>方法的第2个参数一个指针(replyType *T2)</li></ol></li><li><ol start="5"><li>方法的返回值类型是 error</li></ol></li></ul><p><code>net/rpc</code> 对参数个数的限制比较严格，仅能有2个，第一个参数是调用者提供的请求参数，第二个参数是返回给调用者的响应参数，也就是说，服务端需要将计算结果写在第二个参数中。如果调用过程中发生错误，会返回 error 给调用者。</p><p>接下来，我们改造下 Square 函数，以满足上述 5 个条件。</p><pre><code class="go">func (cal *Cal) Square(num int, result *Result) error &#123;    result.Num = num    result.Ans = num * num    return nil&#125;func main() &#123;    cal := new(Cal)    var result Result    cal.Square(11, &amp;result)    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)&#125;</code></pre><ul><li>Cal 和 Square 均为导出类型，满足条件 1) 和 2) </li><li>2 个参数，<code>num int</code> 为内置类型，<code>result *Result</code> 为导出类型，满足条件 3)</li><li>第2个参数 <code>result *Result</code> 是一个指针，满足条件 4) </li><li>返回值类型是 error，满足条件 5)</li></ul><p>至此，方法 Cal.Square 满足了 RPC 调用的5个条件。</p><h2 id="4-RPC-服务与调用"><a href="#4-RPC-服务与调用" class="headerlink" title="4 RPC 服务与调用"></a>4 RPC 服务与调用</h2><h3 id="4-1-基于HTTP，启动-RPC-服务"><a href="#4-1-基于HTTP，启动-RPC-服务" class="headerlink" title="4.1 基于HTTP，启动 RPC 服务"></a>4.1 基于HTTP，启动 RPC 服务</h3><p>RPC 是一个典型的客户端-服务器(Client-Server, CS) 架构模型，很显然，需要将 Cal.Square 方法放在服务端。服务端需要提供一个套接字服务，处理客户端发送的请求。通常可以基于 HTTP 协议，监听一个端口，等待 HTTP 请求。</p><p>接下来我们新建一个文件夹 server，将 Cal.Square 方法移动到 server/main.go 中，并在 main 函数中启动 RPC 服务。</p><pre><code class="go">// server/main.gopackage mainimport (    &quot;log&quot;    &quot;net&quot;    &quot;net/http&quot;    &quot;net/rpc&quot;)type Result struct &#123;    Num, Ans int&#125;type Cal intfunc (cal *Cal) Square(num int, result *Result) error &#123;    result.Num = num    result.Ans = num * num    return nil&#125;func main() &#123;    rpc.Register(new(Cal))    rpc.HandleHTTP()    log.Printf(&quot;Serving RPC server on port %d&quot;, 1234)    if err := http.ListenAndServe(&quot;:1234&quot;, nil); err != nil &#123;        log.Fatal(&quot;Error serving: &quot;, err)    &#125;&#125;</code></pre><ul><li>使用 <code>rpc.Register</code>，发布 Cal 中满足 RPC 注册条件的方法（Cal.Square）</li><li>使用 <code>rpc.HandleHTTP</code> 注册用于处理 RPC 消息的 HTTP Handler</li><li>使用 <code>http.ListenAndServe</code> 监听 1234 端口，等待 RPC 请求。</li></ul><p>我们在 server 目录下，执行</p><pre><code class="bash">$ go run main.go2020/01/13 20:59:22 Serving RPC server on port 1234</code></pre><p>此时，RPC 服务已经启动，等待客户端的调用。</p><h3 id="4-2-实现客户端"><a href="#4-2-实现客户端" class="headerlink" title="4.2 实现客户端"></a>4.2 实现客户端</h3><p>我们在 client 目录中新建文件 client/main.go，创建 HTTP 客户端，调用 Cal.Square 方法。</p><pre><code class="go">// client/main.gopackage mainimport (    &quot;log&quot;    &quot;net/rpc&quot;)type Result struct &#123;    Num, Ans int&#125;func main() &#123;    client, _ := rpc.DialHTTP(&quot;tcp&quot;, &quot;localhost:1234&quot;)    var result Result    if err := client.Call(&quot;Cal.Square&quot;, 12, &amp;result); err != nil &#123;        log.Fatal(&quot;Failed to call Cal.Square. &quot;, err)    &#125;    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)&#125;</code></pre><p>在客户端的实现中，因为要用到 Result 类型，简单起见，我们拷贝了 <code>Result</code> 的定义。</p><ul><li>使用 <code>rpc.DialHTTP</code> 创建了 HTTP 客户端 client，并且创建了与 localhost:1234 的链接，1234 恰好是 RPC 服务监听的端口。</li><li>使用 <code>rpc.Call</code> 调用远程方法，第1个参数是方法名 Cal.Square，后两个参数与 Cal.Square 的定义的参数相对应。</li></ul><p>我们在 client 目录下，执行</p><pre><code class="bash">2020/01/13 21:17:45 12^2 = 144</code></pre><p>如果能够返回计算的结果，说明调用成功。</p><h3 id="4-3-异步调用"><a href="#4-3-异步调用" class="headerlink" title="4.3 异步调用"></a>4.3 异步调用</h3><p><code>client.Call</code> 是同步调用的方式，会阻塞当前的程序，直到结果返回。如果有异步调用的需求，可以考虑使用<code>client.Go</code>，如下</p><pre><code class="go">func main() &#123;    client, _ := rpc.DialHTTP(&quot;tcp&quot;, &quot;localhost:1234&quot;)    var result Result    asyncCall := client.Go(&quot;Cal.Square&quot;, 12, &amp;result, nil)    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)    &lt;-asyncCall.Done    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)&#125;</code></pre><p>执行结果如下：</p><pre><code>2020/01/13 21:34:26 0^2 = 02020/01/13 21:34:26 12^2 = 144</code></pre><p>因为 <code>client.Go</code> 是异步调用，因此第一次打印 result，result 没有被赋值。而通过调用 <code>&lt;-asyncCall.Done</code>，阻塞当前程序直到 RPC 调用结束，因此第二次打印 result 时，能够看到正确的赋值。</p><h2 id="5-证书鉴权-TLS-SSL"><a href="#5-证书鉴权-TLS-SSL" class="headerlink" title="5 证书鉴权(TLS/SSL)"></a>5 证书鉴权(TLS/SSL)</h2><h3 id="5-1-客户端对服务器端鉴权"><a href="#5-1-客户端对服务器端鉴权" class="headerlink" title="5.1 客户端对服务器端鉴权"></a>5.1 客户端对服务器端鉴权</h3><p>HTTP 协议默认是不加密的，我们可以使用证书来保证通信过程的安全。</p><p>生成私钥和自签名的证书，并将  server.key 权限设置为只读，保证私钥的安全。</p><pre><code class="bash"># 生成私钥openssl genrsa -out server.key 2048# 生成证书openssl req -new -x509 -key server.key -out server.crt -days 3650# 只读权限chmod 400 server.key</code></pre><p>执行完，当前文件夹下多出了 server.crt 和 server.key 2 个文件。</p><p>服务器端可以使用生成的 server.crt 和 server.key 文件启动 TLS 的端口监听。</p><pre><code class="go">// server/main.goimport (    &quot;crypto/tls&quot;    &quot;log&quot;    &quot;net/rpc&quot;)func main() &#123;    rpc.Register(new(Cal))    cert, _ := tls.LoadX509KeyPair(&quot;server.crt&quot;, &quot;server.key&quot;)    config := &amp;tls.Config&#123;        Certificates: []tls.Certificate&#123;cert&#125;,    &#125;    listener, _ := tls.Listen(&quot;tcp&quot;, &quot;:1234&quot;, config)    log.Printf(&quot;Serving RPC server on port %d&quot;, 1234)    for &#123;        conn, _ := listener.Accept()        defer conn.Close()        go rpc.ServeConn(conn)    &#125;&#125;</code></pre><p>客户端也需要做相应的修改，使用 <code>tls.Dial</code> 代替 <code>rpc.DialHTTP</code> 连接服务端，如果客户端不需要对服务端鉴权，那么可以设置 <code>InsecureSkipVerify:true</code>，即可跳过对服务端的鉴权，例如：</p><pre><code class="go">// client/main.goimport (    &quot;crypto/tls&quot;    &quot;log&quot;    &quot;net/rpc&quot;)func main() &#123;    config := &amp;tls.Config&#123;        InsecureSkipVerify: true,    &#125;    conn, _ := tls.Dial(&quot;tcp&quot;, &quot;localhost:1234&quot;, config)    defer conn.Close()    client := rpc.NewClient(conn)    var result Result    if err := client.Call(&quot;Cal.Square&quot;, 12, &amp;result); err != nil &#123;        log.Fatal(&quot;Failed to call Cal.Square. &quot;, err)    &#125;    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)&#125;</code></pre><p>如果需要对服务器端鉴权，那么需要将服务端的证书添加到信任证书池中，如下：</p><pre><code class="go">// client/main.gofunc main() &#123;    certPool := x509.NewCertPool()    certBytes, err := ioutil.ReadFile(&quot;../server/server.crt&quot;)    if err != nil &#123;        log.Fatal(&quot;Failed to read server.crt&quot;)    &#125;    certPool.AppendCertsFromPEM(certBytes)    config := &amp;tls.Config&#123;        RootCAs: certPool,    &#125;    conn, _ := tls.Dial(&quot;tcp&quot;, &quot;localhost:1234&quot;, config)    defer conn.Close()    client := rpc.NewClient(conn)    var result Result    if err := client.Call(&quot;Cal.Square&quot;, 12, &amp;result); err != nil &#123;        log.Fatal(&quot;Failed to call Cal.Square. &quot;, err)    &#125;    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)&#125;</code></pre><h3 id="5-2-服务器端对客户端的鉴权"><a href="#5-2-服务器端对客户端的鉴权" class="headerlink" title="5.2 服务器端对客户端的鉴权"></a>5.2 服务器端对客户端的鉴权</h3><p>服务器端对客户端的鉴权是类似的，核心在于 <code>tls.Config</code> 的配置：</p><ul><li>把对方的证书添加到自己的信任证书池 <code>RootCAs</code>(客户端配置)，<code>ClientCAs</code>(服务器端配置) 中。</li><li>创建链接时，配置自己的证书 <code>Certificates</code>。</li></ul><p>客户端的 config 作如下修改：</p><pre><code class="go">// client/main.gocert, _ := tls.LoadX509KeyPair(&quot;client.crt&quot;, &quot;client.key&quot;)certPool := x509.NewCertPool()certBytes, _ := ioutil.ReadFile(&quot;../server/server.crt&quot;)certPool.AppendCertsFromPEM(certBytes)config := &amp;tls.Config&#123;    Certificates: []tls.Certificate&#123;cert&#125;,    RootCAs: certPool,&#125;</code></pre><p>服务器端的 config 作如下修改：</p><pre><code class="go">// server/main.gocert, _ := tls.LoadX509KeyPair(&quot;server.crt&quot;, &quot;server.key&quot;)certPool := x509.NewCertPool()certBytes, _ := ioutil.ReadFile(&quot;../client/client.crt&quot;)certPool.AppendCertsFromPEM(certBytes)config := &amp;tls.Config&#123;    Certificates: []tls.Certificate&#123;cert&#125;,    ClientAuth:   tls.RequireAndVerifyClientCert,    ClientCAs:    certPool,&#125;</code></pre><h2 id="附：参考"><a href="#附：参考" class="headerlink" title="附：参考"></a>附：参考</h2><ol><li><a href="https://golang.org/pkg/net/rpc/">Golang net/rpc 官方文档 - golang.org</a></li><li><a href="https://github.com/denji/golang-tls">Golang TLS 配置 - github.com</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文介绍了 Go 语言远程过程调用(Remote Procedure Call, RPC)的使用方式，示例基于 Golang 标准库 net/rpc，同时介绍了如何基于 TLS/SSL 实现服务器端和客户端的单向鉴权、双向鉴权。&lt;/p&gt;
&lt;h2 id=&quot;1-RPC-简介&quot;&gt;</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="TLS" scheme="https://ysluckly.github.io/tags/TLS/"/>
    
    <category term="Golang" scheme="https://ysluckly.github.io/tags/Golang/"/>
    
    <category term="RPC" scheme="https://ysluckly.github.io/tags/RPC/"/>
    
    <category term="证书" scheme="https://ysluckly.github.io/tags/%E8%AF%81%E4%B9%A6/"/>
    
    <category term="鉴权" scheme="https://ysluckly.github.io/tags/%E9%89%B4%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Go Test 单元测试简明教程</title>
    <link href="https://ysluckly.github.io/2022/01/16/go/"/>
    <id>https://ysluckly.github.io/2022/01/16/go/</id>
    <published>2022-01-16T13:59:10.000Z</published>
    <updated>2022-02-20T13:38:12.755Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919113329.jpg" alt="golang test"></p><h2 id="1-如何写好单元测试"><a href="#1-如何写好单元测试" class="headerlink" title="1 如何写好单元测试"></a>1 如何写好单元测试</h2><p>单元测试(Unit Tests, UT) 是一个优秀项目不可或缺的一部分，特别是在一些频繁变动和多人合作开发的项目中尤为重要。你或多或少都会有因为自己的提交，导致应用挂掉或服务宕机的经历。如果这个时候你的修改导致测试用例失败，你再重新审视自己的修改，发现之前的修改还有一些特殊场景没有包含，恭喜你减少了一次上库失误。也会有这样的情况，项目很大，启动环境很复杂，你优化了一个函数的性能，或是添加了某个新的特性，如果部署在正式环境上之后再进行测试，成本太高。对于这种场景，几个小小的测试用例或许就能够覆盖大部分的测试场景。而且在开发过程中，效率最高的莫过于所见即所得了，单元测试也能够帮助你做到这一点，试想一下，假如你一口气写完一千行代码，debug 的过程也不会轻松，如果在这个过程中，对于一些逻辑较为复杂的函数，同时添加一些测试用例，即时确保正确性，最后集成的时候，会是另外一番体验。</p><p>如何写好单元测试呢？</p><p>首先，学会写测试用例。比如如何测试单个函数/方法；比如如何做基准测试；比如如何写出简洁精炼的测试代码；再比如遇到数据库访问等的方法调用时，如何 <code>mock</code>。</p><p>然后，写可测试的代码。<code>高内聚，低耦合</code>是软件工程的原则，同样，对测试而言，函数/方法写法不同，测试难度也是不一样的。职责单一，参数类型简单，与其他函数耦合度低的函数往往更容易测试。我们经常会说，“这种代码没法测试”，这种时候，就得思考函数的写法可不可以改得更好一些。为了代码可测试而重构是值得的。</p><p>接下来将介绍如何使用 Go 语言的标准库 <code>testing</code> 进行单元测试。</p><h2 id="2-一个简单例子"><a href="#2-一个简单例子" class="headerlink" title="2 一个简单例子"></a>2 一个简单例子</h2><p>Go 语言推荐测试文件和源代码文件放在一块，测试文件以 <code>_test.go</code> 结尾。比如，当前 package 有 <code>calc.go</code> 一个文件，我们想测试 <code>calc.go</code> 中的 <code>Add</code> 和 <code>Mul</code> 函数，那么应该新建 <code>calc_test.go</code> 作为测试文件。</p><pre><code class="bash">example/   |--calc.go   |--calc_test.go</code></pre><p>假如 <code>calc.go</code> 的代码如下：</p><pre><code class="go">package mainfunc Add(a int, b int) int &#123;    return a + b&#125;func Mul(a int, b int) int &#123;    return a * b&#125;</code></pre><p>那么 <code>calc_test.go</code> 中的测试用例可以这么写：</p><pre><code class="go">package mainimport &quot;testing&quot;func TestAdd(t *testing.T) &#123;    if ans := Add(1, 2); ans != 3 &#123;        t.Errorf(&quot;1 + 2 expected be 3, but %d got&quot;, ans)    &#125;    if ans := Add(-10, -20); ans != -30 &#123;        t.Errorf(&quot;-10 + -20 expected be -30, but %d got&quot;, ans)    &#125;&#125;</code></pre><ul><li>测试用例名称一般命名为 <code>Test</code> 加上待测试的方法名。</li><li>测试用的参数有且只有一个，在这里是 <code>t *testing.T</code>。</li><li>基准测试(benchmark)的参数是 <code>*testing.B</code>，TestMain 的参数是 <code>*testing.M</code> 类型。</li></ul><p>运行 <code>go test</code>，该 package 下所有的测试用例都会被执行。</p><pre><code class="bash">$ go testok      example 0.009s</code></pre><p>或 <code>go test -v</code>，<code>-v</code> 参数会显示每个用例的测试结果，另外 <code>-cover</code> 参数可以查看覆盖率。</p><pre><code class="bash">$ go test -v=== RUN   TestAdd--- PASS: TestAdd (0.00s)=== RUN   TestMul--- PASS: TestMul (0.00s)PASSok      example 0.007s</code></pre><p>如果只想运行其中的一个用例，例如 <code>TestAdd</code>，可以用 <code>-run</code> 参数指定，该参数支持通配符 <code>*</code>，和部分正则表达式，例如 <code>^</code>、<code>$</code>。</p><pre><code class="bash">$ go test -run TestAdd -v=== RUN   TestAdd--- PASS: TestAdd (0.00s)PASSok      example 0.007s</code></pre><h2 id="3-子测试-Subtests"><a href="#3-子测试-Subtests" class="headerlink" title="3 子测试(Subtests)"></a>3 子测试(Subtests)</h2><p>子测试是 Go 语言内置支持的，可以在某个测试用例中，根据测试场景使用 <code>t.Run</code>创建不同的子测试用例：</p><pre><code class="go">// calc_test.gofunc TestMul(t *testing.T) &#123;    t.Run(&quot;pos&quot;, func(t *testing.T) &#123;        if Mul(2, 3) != 6 &#123;            t.Fatal(&quot;fail&quot;)        &#125;    &#125;)    t.Run(&quot;neg&quot;, func(t *testing.T) &#123;        if Mul(2, -3) != -6 &#123;            t.Fatal(&quot;fail&quot;)        &#125;    &#125;)&#125;</code></pre><ul><li>之前的例子测试失败时使用 <code>t.Error/t.Errorf</code>，这个例子中使用 <code>t.Fatal/t.Fatalf</code>，区别在于前者遇错不停，还会继续执行其他的测试用例，后者遇错即停。</li></ul><p>运行某个测试用例的子测试：</p><pre><code class="bash">$ go test -run TestMul/pos -v=== RUN   TestMul=== RUN   TestMul/pos--- PASS: TestMul (0.00s)    --- PASS: TestMul/pos (0.00s)PASSok      example 0.008s</code></pre><p>对于多个子测试的场景，更推荐如下的写法(table-driven tests)：</p><pre><code class="go">//  calc_test.gofunc TestMul(t *testing.T) &#123;    cases := []struct &#123;        Name           string        A, B, Expected int    &#125;&#123;        &#123;&quot;pos&quot;, 2, 3, 6&#125;,        &#123;&quot;neg&quot;, 2, -3, -6&#125;,        &#123;&quot;zero&quot;, 2, 0, 0&#125;,    &#125;    for _, c := range cases &#123;        t.Run(c.Name, func(t *testing.T) &#123;            if ans := Mul(c.A, c.B); ans != c.Expected &#123;                t.Fatalf(&quot;%d * %d expected %d, but %d got&quot;,                    c.A, c.B, c.Expected, ans)            &#125;        &#125;)    &#125;&#125;</code></pre><p>所有用例的数据组织在切片 <code>cases</code> 中，看起来就像一张表，借助循环创建子测试。这样写的好处有：</p><ul><li>新增用例非常简单，只需给 cases 新增一条测试数据即可。</li><li>测试代码可读性好，直观地能够看到每个子测试的参数和期待的返回值。</li><li>用例失败时，报错信息的格式比较统一，测试报告易于阅读。</li></ul><p>如果数据量较大，或是一些二进制数据，推荐使用相对路径从文件中读取。</p><h2 id="4-帮助函数-helpers"><a href="#4-帮助函数-helpers" class="headerlink" title="4 帮助函数(helpers)"></a>4 帮助函数(helpers)</h2><p>对一些重复的逻辑，抽取出来作为公共的帮助函数(helpers)，可以增加测试代码的可读性和可维护性。 借助帮助函数，可以让测试用例的主逻辑看起来更清晰。</p><p>例如，我们可以将创建子测试的逻辑抽取出来：</p><pre><code class="go">// calc_test.gopackage mainimport &quot;testing&quot;type calcCase struct&#123; A, B, Expected int &#125;func createMulTestCase(t *testing.T, c *calcCase) &#123;    // t.Helper()    if ans := Mul(c.A, c.B); ans != c.Expected &#123;        t.Fatalf(&quot;%d * %d expected %d, but %d got&quot;,            c.A, c.B, c.Expected, ans)    &#125;&#125;func TestMul(t *testing.T) &#123;    createMulTestCase(t, &amp;calcCase&#123;2, 3, 6&#125;)    createMulTestCase(t, &amp;calcCase&#123;2, -3, -6&#125;)    createMulTestCase(t, &amp;calcCase&#123;2, 0, 1&#125;) // wrong case&#125;</code></pre><p>在这里，我们故意创建了一个错误的测试用例，运行 <code>go test</code>，用例失败，会报告错误发生的文件和行号信息：</p><pre><code class="bash">$ go test--- FAIL: TestMul (0.00s)    calc_test.go:11: 2 * 0 expected 1, but 0 gotFAILexit status 1FAIL    example 0.007s</code></pre><p>可以看到，错误发生在第11行，也就是帮助函数 <code>createMulTestCase</code> 内部。18, 19, 20行都调用了该方法，我们第一时间并不能够确定是哪一行发生了错误。有些帮助函数还可能在不同的函数中被调用，报错信息都在同一处，不方便问题定位。因此，Go 语言在 1.9 版本中引入了 <code>t.Helper()</code>，用于标注该函数是帮助函数，报错时将输出帮助函数调用者的信息，而不是帮助函数的内部信息。</p><p>修改 <code>createMulTestCase</code>，调用 <code>t.Helper()</code></p><pre><code class="go">func createMulTestCase(c *calcCase, t *testing.T) &#123;    t.Helper()    t.Run(c.Name, func(t *testing.T) &#123;        if ans := Mul(c.A, c.B); ans != c.Expected &#123;            t.Fatalf(&quot;%d * %d expected %d, but %d got&quot;,                c.A, c.B, c.Expected, ans)        &#125;    &#125;)&#125;</code></pre><p>运行 <code>go test</code>，报错信息如下，可以非常清晰地知道，错误发生在第 20 行。</p><pre><code class="bash">$ go test--- FAIL: TestMul (0.00s)    calc_test.go:20: 2 * 0 expected 1, but 0 gotFAILexit status 1FAIL    example 0.006s</code></pre><p>关于 <code>helper</code> 函数的 2 个建议：</p><ul><li>不要返回错误， 帮助函数内部直接使用 <code>t.Error</code> 或 <code>t.Fatal</code> 即可，在用例主逻辑中不会因为太多的错误处理代码，影响可读性。</li><li>调用 <code>t.Helper()</code> 让报错信息更准确，有助于定位。</li></ul><h2 id="5-setup-和-teardown"><a href="#5-setup-和-teardown" class="headerlink" title="5 setup 和 teardown"></a>5 setup 和 teardown</h2><p>如果在同一个测试文件中，每一个测试用例运行前后的逻辑是相同的，一般会写在 setup 和 teardown 函数中。例如执行前需要实例化待测试的对象，如果这个对象比较复杂，很适合将这一部分逻辑提取出来；执行后，可能会做一些资源回收类的工作，例如关闭网络连接，释放文件等。标准库 <code>testing</code> 提供了这样的机制：</p><pre><code class="go">func setup() &#123;    fmt.Println(&quot;Before all tests&quot;)&#125;func teardown() &#123;    fmt.Println(&quot;After all tests&quot;)&#125;func Test1(t *testing.T) &#123;    fmt.Println(&quot;I&#39;m test1&quot;)&#125;func Test2(t *testing.T) &#123;    fmt.Println(&quot;I&#39;m test2&quot;)&#125;func TestMain(m *testing.M) &#123;    setup()    code := m.Run()    teardown()    os.Exit(code)&#125;</code></pre><ul><li>在这个测试文件中，包含有2个测试用例，<code>Test1</code> 和 <code>Test2</code>。</li><li>如果测试文件中包含函数 <code>TestMain</code>，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。</li><li>调用 <code>m.Run()</code> 触发所有测试用例的执行，并使用 <code>os.Exit()</code> 处理返回的状态码，如果不为0，说明有用例失败。</li><li>因此可以在调用 <code>m.Run()</code> 前后做一些额外的准备(setup)和回收(teardown)工作。</li></ul><p>执行 <code>go test</code>，将会输出</p><pre><code class="bash">$ go testBefore all testsI&#39;m test1I&#39;m test2PASSAfter all testsok      example 0.006s</code></pre><h2 id="6-网络测试-Network"><a href="#6-网络测试-Network" class="headerlink" title="6 网络测试(Network)"></a>6 网络测试(Network)</h2><h3 id="6-1-TCP-HTTP"><a href="#6-1-TCP-HTTP" class="headerlink" title="6.1 TCP/HTTP"></a>6.1 TCP/HTTP</h3><p>假设需要测试某个 API 接口的 handler 能够正常工作，例如 helloHandler </p><pre><code class="go">func helloHandler(w http.ResponseWriter, r *http.Request) &#123;    w.Write([]byte(&quot;hello world&quot;))&#125;</code></pre><p>那我们可以创建真实的网络连接进行测试：</p><pre><code class="go">// test codeimport (    &quot;io/ioutil&quot;    &quot;net&quot;    &quot;net/http&quot;    &quot;testing&quot;)func handleError(t *testing.T, err error) &#123;    t.Helper()    if err != nil &#123;        t.Fatal(&quot;failed&quot;, err)    &#125;&#125;func TestConn(t *testing.T) &#123;    ln, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:0&quot;)    handleError(t, err)    defer ln.Close()    http.HandleFunc(&quot;/hello&quot;, helloHandler)    go http.Serve(ln, nil)    resp, err := http.Get(&quot;http://&quot; + ln.Addr().String() + &quot;/hello&quot;)    handleError(t, err)    defer resp.Body.Close()    body, err := ioutil.ReadAll(resp.Body)    handleError(t, err)    if string(body) != &quot;hello world&quot; &#123;        t.Fatal(&quot;expected hello world, but got&quot;, string(body))    &#125;&#125;</code></pre><ul><li><code>net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:0&quot;)</code>：监听一个未被占用的端口，并返回 Listener。</li><li>调用 <code>http.Serve(ln, nil)</code> 启动 http 服务。</li><li>使用 <code>http.Get</code> 发起一个 Get 请求，检查返回值是否正确。</li><li>尽量不对 <code>http</code> 和 <code>net</code> 库使用 mock，这样可以覆盖较为真实的场景。</li></ul><h3 id="6-2-httptest"><a href="#6-2-httptest" class="headerlink" title="6.2 httptest"></a>6.2 httptest</h3><p>针对 http 开发的场景，使用标准库 <code>net/http/httptest</code> 进行测试更为高效。</p><p>上述的测试用例改写如下：</p><pre><code class="go">// test codeimport (    &quot;io/ioutil&quot;    &quot;net/http&quot;    &quot;net/http/httptest&quot;    &quot;testing&quot;)func TestConn(t *testing.T) &#123;    req := httptest.NewRequest(&quot;GET&quot;, &quot;http://example.com/foo&quot;, nil)    w := httptest.NewRecorder()    helloHandler(w, req)    bytes, _ := ioutil.ReadAll(w.Result().Body)    if string(bytes) != &quot;hello world&quot; &#123;        t.Fatal(&quot;expected hello world, but got&quot;, string(bytes))    &#125;&#125;</code></pre><p>使用 httptest 模拟请求对象(req)和响应对象(w)，达到了相同的目的。</p><h2 id="7-Benchmark-基准测试"><a href="#7-Benchmark-基准测试" class="headerlink" title="7 Benchmark 基准测试"></a>7 Benchmark 基准测试</h2><p>基准测试用例的定义如下：</p><pre><code class="go">func BenchmarkName(b *testing.B)&#123;    // ...&#125;</code></pre><ul><li>函数名必须以 <code>Benchmark</code> 开头，后面一般跟待测试的函数名</li><li>参数为 <code>b *testing.B</code>。</li><li>执行基准测试时，需要添加 <code>-bench</code> 参数。</li></ul><p>例如：</p><pre><code class="go">func BenchmarkHello(b *testing.B) &#123;    for i := 0; i &lt; b.N; i++ &#123;        fmt.Sprintf(&quot;hello&quot;)    &#125;&#125;</code></pre><pre><code class="bash">$ go test -benchmem -bench ....BenchmarkHello-16   15991854   71.6 ns/op   5 B/op   1 allocs/op...</code></pre><p>基准测试报告每一列值对应的含义如下：</p><pre><code class="go">type BenchmarkResult struct &#123;    N         int           // 迭代次数    T         time.Duration // 基准测试花费的时间    Bytes     int64         // 一次迭代处理的字节数    MemAllocs uint64        // 总的分配内存的次数    MemBytes  uint64        // 总的分配内存的字节数&#125;</code></pre><p>如果在运行前基准测试需要一些耗时的配置，则可以使用 <code>b.ResetTimer()</code> 先重置定时器，例如：</p><pre><code class="go">func BenchmarkHello(b *testing.B) &#123;    ... // 耗时操作    b.ResetTimer()    for i := 0; i &lt; b.N; i++ &#123;        fmt.Sprintf(&quot;hello&quot;)    &#125;&#125;</code></pre><p>使用 <code>RunParallel</code> 测试并发性能</p><pre><code class="go">func BenchmarkParallel(b *testing.B) &#123;    templ := template.Must(template.New(&quot;test&quot;).Parse(&quot;Hello, &#123;&#123;.&#125;&#125;!&quot;))    b.RunParallel(func(pb *testing.PB) &#123;        var buf bytes.Buffer        for pb.Next() &#123;            // 所有 goroutine 一起，循环一共执行 b.N 次            buf.Reset()            templ.Execute(&amp;buf, &quot;World&quot;)        &#125;    &#125;)&#125;</code></pre><pre><code class="bash">$ go test -benchmem -bench ....BenchmarkParallel-16   3325430     375 ns/op   272 B/op   8 allocs/op...</code></pre><h2 id="附-参考"><a href="#附-参考" class="headerlink" title="附 参考"></a>附 参考</h2><ul><li><a href="https://geektutu.com/post/quick-gomock.html">Go Mock (gomock) 简明教程</a></li><li><a href="https://golang.org/pkg/testing/">testing - golang.org</a></li><li><a href="https://about.sourcegraph.com/go/advanced-testing-in-go">Advanced Testing in Go - sourcegraph.com</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919113329.jpg&quot; alt=&quot;golang test&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-如何写好单元测试&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="golang test" scheme="https://ysluckly.github.io/tags/golang-test/"/>
    
    <category term="unit tests" scheme="https://ysluckly.github.io/tags/unit-tests/"/>
    
    <category term="golang testing" scheme="https://ysluckly.github.io/tags/golang-testing/"/>
    
  </entry>
  
  <entry>
    <title>Go Protobuf 简明教程</title>
    <link href="https://ysluckly.github.io/2022/01/16/go/"/>
    <id>https://ysluckly.github.io/2022/01/16/go/</id>
    <published>2022-01-16T13:59:10.000Z</published>
    <updated>2022-02-20T13:37:12.952Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114831.jpg" alt="Golang Protocol Buffers"></p><h2 id="1-Protocol-Buffers-简介"><a href="#1-Protocol-Buffers-简介" class="headerlink" title="1 Protocol Buffers 简介"></a>1 Protocol Buffers 简介</h2><p>protobuf 即 Protocol Buffers，是一种轻便高效的结构化数据存储格式，与语言、平台无关，可扩展可序列化。protobuf 性能和效率大幅度优于 JSON、XML 等其他的结构化数据格式。protobuf 是以二进制方式存储的，占用空间小，但也带来了可读性差的缺点。protobuf 在通信协议和数据存储等领域应用广泛。例如著名的分布式缓存工具 <a href="https://memcached.org/">Memcached</a> 的 Go 语言版本<a href="https://github.com/golang/groupcache">groupcache</a> 就使用了 protobuf 作为其 RPC 数据格式。</p><p>Protobuf 在 <code>.proto</code> 定义需要处理的结构化数据，可以通过 <code>protoc</code> 工具，将 <code>.proto</code> 文件转换为 C、C++、Golang、Java、Python 等多种语言的代码，兼容性好，易于使用。</p><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h2><h3 id="2-1-protoc"><a href="#2-1-protoc" class="headerlink" title="2.1 protoc"></a>2.1 protoc</h3><p>从 <a href="https://github.com/protocolbuffers/protobuf/releases">Protobuf Releases</a> 下载最先版本的发布包安装。如果是 Ubuntu，可以按照如下步骤操作（以3.11.2为例）。</p><pre><code class="bash"># 下载安装包$ wget https://github.com/protocolbuffers/protobuf/releases/download/v3.11.2/protoc-3.11.2-linux-x86_64.zip# 解压到 /usr/local 目录下$ sudo 7z x protoc-3.11.2-linux-x86_64.zip -o/usr/local</code></pre><p>如果不想安装在 /usr/local 目录下，可以解压到其他的其他，并把解压路径下的 bin 目录 加入到环境变量即可。</p><p>如果能正常显示版本，则表示安装成功。</p><pre><code class="bash">$ protoc --versionlibprotoc 3.11.2</code></pre><h3 id="2-2-protoc-gen-go"><a href="#2-2-protoc-gen-go" class="headerlink" title="2.2 protoc-gen-go"></a>2.2 protoc-gen-go</h3><p>我们需要在 Golang 中使用 protobuf，还需要安装 protoc-gen-go，这个工具用来将 <code>.proto</code> 文件转换为 Golang 代码。</p><pre><code class="bash">go get -u github.com/golang/protobuf/protoc-gen-go</code></pre><p>protoc-gen-go 将自动安装到 <code>$GOPATH/bin</code> 目录下，也需要将这个目录加入到环境变量中。</p><h2 id="3-定义消息类型"><a href="#3-定义消息类型" class="headerlink" title="3 定义消息类型"></a>3 定义消息类型</h2><p>接下来，我们创建一个非常简单的示例，<code>student.proto</code></p><pre><code class="go">syntax = &quot;proto3&quot;;package main;// this is a commentmessage Student &#123;  string name = 1;  bool male = 2;  repeated int32 scores = 3;&#125;</code></pre><p>在当前目录下执行：</p><pre><code class="bash">$ protoc --go_out=. *.proto$ lsstudent.pb.go  student.proto</code></pre><p>即是，将该目录下的所有的 .proto 文件转换为 Go 代码，我们可以看到该目录下多出了一个 Go 文件 <em>student.pb.go</em>。这个文件内部定义了一个结构体 Student，以及相关的方法：</p><pre><code class="go">type Student struct &#123;    Name string `protobuf:&quot;bytes,1,opt,name=name,proto3&quot; json:&quot;name,omitempty&quot;`    Male bool `protobuf:&quot;varint,2,opt,name=male,proto3&quot; json:&quot;male,omitempty&quot;`    Scores []int32 `protobuf:&quot;varint,3,rep,packed,name=scores,proto3&quot; json:&quot;scores,omitempty&quot;`    ...&#125;</code></pre><p>逐行解读<code>student.proto</code></p><ul><li>protobuf 有2个版本，默认版本是 proto2，如果需要 proto3，则需要在非空非注释第一行使用 <code>syntax = &quot;proto3&quot;</code> 标明版本。</li><li><code>package</code>，即包名声明符是可选的，用来防止不同的消息类型有命名冲突。</li><li>消息类型 使用 <code>message</code> 关键字定义，Student 是类型名，name, male, scores 是该类型的 3 个字段，类型分别为 string, bool 和 []int32。字段可以是标量类型，也可以是合成类型。</li><li>每个字段的修饰符默认是 singular，一般省略不写，<code>repeated</code> 表示字段可重复，即用来表示 Go 语言中的数组类型。</li><li>每个字符 <code>=</code>后面的数字称为标识符，每个字段都需要提供一个唯一的标识符。标识符用来在消息的二进制格式中识别各个字段，一旦使用就不能够再改变，标识符的取值范围为 [1, 2^29 - 1] 。</li><li>.proto 文件可以写注释，单行注释 <code>//</code>，多行注释 <code>/* ... */</code></li><li>一个 .proto 文件中可以写多个消息类型，即对应多个结构体(struct)。</li></ul><p>接下来，就可以在项目代码中直接使用了，以下是一个非常简单的例子，即证明被序列化的和反序列化后的实例，包含相同的数据。</p><pre><code class="go">package mainimport (    &quot;log&quot;    &quot;github.com/golang/protobuf/proto&quot;)func main() &#123;    test := &amp;Student&#123;        Name: &quot;geektutu&quot;,        Male:  true,        Scores: []int32&#123;98, 85, 88&#125;,    &#125;    data, err := proto.Marshal(test)    if err != nil &#123;        log.Fatal(&quot;marshaling error: &quot;, err)    &#125;    newTest := &amp;Student&#123;&#125;    err = proto.Unmarshal(data, newTest)    if err != nil &#123;        log.Fatal(&quot;unmarshaling error: &quot;, err)    &#125;    // Now test and newTest contain the same data.    if test.GetName() != newTest.GetName() &#123;        log.Fatalf(&quot;data mismatch %q != %q&quot;, test.GetName(), newTest.GetName())    &#125;&#125;</code></pre><ul><li>保留字段(Reserved Field)</li></ul><p>更新消息类型时，可能会将某些字段/标识符删除。这些被删掉的字段/标识符可能被重新使用，如果加载老版本的数据时，可能会造成数据冲突，在升级时，可以将这些字段/标识符保留(reserved)，这样就不会被重新使用了，protoc 会检查。</p><pre><code class="go">message Foo &#123;  reserved 2, 15, 9 to 11;  reserved &quot;foo&quot;, &quot;bar&quot;;&#125;</code></pre><h2 id="4-字段类型"><a href="#4-字段类型" class="headerlink" title="4 字段类型"></a>4 字段类型</h2><h3 id="4-1-标量类型-Scalar"><a href="#4-1-标量类型-Scalar" class="headerlink" title="4.1 标量类型(Scalar)"></a>4.1 标量类型(Scalar)</h3><table><thead><tr><th>proto类型</th><th>go类型</th><th>备注</th><th>proto类型</th><th>go类型</th><th>备注</th></tr></thead><tbody><tr><td>double</td><td>float64</td><td></td><td>float</td><td>float32</td><td></td></tr><tr><td>int32</td><td>int32</td><td></td><td>int64</td><td>int64</td><td></td></tr><tr><td>uint32</td><td>uint32</td><td></td><td>uint64</td><td>uint64</td><td></td></tr><tr><td>sint32</td><td>int32</td><td>适合负数</td><td>sint64</td><td>int64</td><td>适合负数</td></tr><tr><td>fixed32</td><td>uint32</td><td>固长编码，适合大于2^28的值</td><td>fixed64</td><td>uint64</td><td>固长编码，适合大于2^56的值</td></tr><tr><td>sfixed32</td><td>int32</td><td>固长编码</td><td>sfixed64</td><td>int64</td><td>固长编码</td></tr><tr><td>bool</td><td>bool</td><td></td><td>string</td><td>string</td><td>UTF8 编码，长度不超过 2^32</td></tr><tr><td>bytes</td><td>[]byte</td><td>任意字节序列，长度不超过 2^32</td><td></td><td></td><td></td></tr></tbody></table><p>标量类型如果没有被赋值，则不会被序列化，解析时，会赋予默认值。</p><ul><li>strings：空字符串</li><li>bytes：空序列</li><li>bools：false</li><li>数值类型：0</li></ul><h3 id="4-2-枚举-Enumerations"><a href="#4-2-枚举-Enumerations" class="headerlink" title="4.2 枚举(Enumerations)"></a>4.2 枚举(Enumerations)</h3><p>枚举类型适用于提供一组预定义的值，选择其中一个。例如我们将性别定义为枚举类型。</p><pre><code class="go">message Student &#123;  string name = 1;  enum Gender &#123;    FEMALE = 0;    MALE = 1;  &#125;  Gender gender = 2;  repeated int32 scores = 3;&#125;</code></pre><ul><li>枚举类型的第一个选项的标识符必须是0，这也是枚举类型的默认值。</li><li>别名（Alias），允许为不同的枚举值赋予相同的标识符，称之为别名，需要打开<code>allow_alias</code>选项。</li></ul><pre><code class="go">message EnumAllowAlias &#123;  enum Status &#123;    option allow_alias = true;    UNKOWN = 0;    STARTED = 1;    RUNNING = 1;  &#125;&#125;</code></pre><h3 id="4-3-使用其他消息类型"><a href="#4-3-使用其他消息类型" class="headerlink" title="4.3 使用其他消息类型"></a>4.3 使用其他消息类型</h3><p><code>Result</code>是另一个消息类型，在 SearchReponse 作为一个消息字段类型使用。</p><pre><code class="go">message SearchResponse &#123;  repeated Result results = 1; &#125;message Result &#123;  string url = 1;  string title = 2;  repeated string snippets = 3;&#125;</code></pre><p>嵌套写也是支持的：</p><pre><code class="go">message SearchResponse &#123;  message Result &#123;    string url = 1;    string title = 2;    repeated string snippets = 3;  &#125;  repeated Result results = 1;&#125;</code></pre><p>如果定义在其他文件中，可以导入其他消息类型来使用：</p><pre><code class="go">import &quot;myproject/other_protos.proto&quot;;</code></pre><h3 id="4-4-任意类型-Any"><a href="#4-4-任意类型-Any" class="headerlink" title="4.4 任意类型(Any)"></a>4.4 任意类型(Any)</h3><p>Any 可以表示不在 .proto 中定义任意的内置类型。</p><pre><code class="go">import &quot;google/protobuf/any.proto&quot;;message ErrorStatus &#123;  string message = 1;  repeated google.protobuf.Any details = 2;&#125;</code></pre><h3 id="4-5-oneof"><a href="#4-5-oneof" class="headerlink" title="4.5 oneof"></a>4.5 oneof</h3><pre><code class="go">message SampleMessage &#123;  oneof test_oneof &#123;    string name = 4;    SubMessage sub_message = 9;  &#125;&#125;</code></pre><h3 id="4-6-map"><a href="#4-6-map" class="headerlink" title="4.6 map"></a>4.6 map</h3><pre><code class="go">message MapRequest &#123;  map&lt;string, int32&gt; points = 1;&#125;</code></pre><h2 id="5-定义服务-Services"><a href="#5-定义服务-Services" class="headerlink" title="5 定义服务(Services)"></a>5 定义服务(Services)</h2><p>如果消息类型是用来远程通信的(Remote Procedure Call, RPC)，可以在 .proto 文件中定义 RPC 服务接口。例如我们定义了一个名为 SearchService 的 RPC 服务，提供了 <code>Search</code> 接口，入参是 <code>SearchRequest</code> 类型，返回类型是 <code>SearchResponse</code></p><pre><code class="go">service SearchService &#123;  rpc Search (SearchRequest) returns (SearchResponse);&#125;</code></pre><p>官方仓库也提供了一个<a href="https://github.com/protocolbuffers/protobuf/blob/master/docs/third_party.md">插件列表</a>，帮助开发基于 Protocol Buffer 的 RPC 服务。</p><h2 id="6-protoc-其他参数"><a href="#6-protoc-其他参数" class="headerlink" title="6 protoc 其他参数"></a>6 protoc 其他参数</h2><p>命令行使用方法</p><pre><code class="bash">protoc --proto_path=IMPORT_PATH --&lt;lang&gt;_out=DST_DIR path/to/file.proto</code></pre><ul><li><code>--proto_path=IMPORT_PATH</code>：可以在 .proto 文件中 import 其他的 .proto 文件，proto_path 即用来指定其他 .proto 文件的查找目录。如果没有引入其他的 .proto 文件，该参数可以省略。</li><li><code>--&lt;lang&gt;_out=DST_DIR</code>：指定生成代码的目标文件夹，例如 –go_out=. 即生成 GO 代码在当前文件夹，另外支持 cpp/java/python/ruby/objc/csharp/php 等语言</li></ul><h2 id="7-推荐风格"><a href="#7-推荐风格" class="headerlink" title="7 推荐风格"></a>7 推荐风格</h2><ul><li><p>文件(Files)</p><ul><li>文件名使用小写下划线的命名风格，例如 lower_snake_case.proto</li><li>每行不超过 80 字符</li><li>使用 2 个空格缩进</li></ul></li><li><p>包(Packages)</p><ul><li>包名应该和目录结构对应，例如文件在<code>my/package/</code>目录下，包名应为 <code>my.package</code></li></ul></li><li><p>消息和字段(Messages &amp; Fields)</p><ul><li>消息名使用首字母大写驼峰风格(CamelCase)，例如<code>message StudentRequest &#123; ... &#125;</code></li><li>字段名使用小写下划线的风格，例如 <code>string status_code = 1</code></li><li>枚举类型，枚举名使用首字母大写驼峰风格，例如 <code>enum FooBar</code>，枚举值使用全大写下划线隔开的风格(CAPITALS_WITH_UNDERSCORES )，例如 FOO_DEFAULT=1</li></ul></li><li><p>服务(Services) </p><ul><li>RPC 服务名和方法名，均使用首字母大写驼峰风格，例如<code>service FooService&#123; rpc GetSomething() &#125;</code></li></ul></li></ul><h2 id="附：参考"><a href="#附：参考" class="headerlink" title="附：参考"></a>附：参考</h2><ol><li><a href="https://github.com/protocolbuffers/protobuf">protobuf 代码仓库 - github.com</a></li><li><a href="https://github.com/golang/protobuf">golang protobuf 代码仓库 - github.com</a></li><li><a href="https://en.wikipedia.org/wiki/Remote_procedure_call">Remote procedure call 远程过程调用 - wikipedia.org</a></li><li><a href="https://github.com/golang/groupcache">Groupcache Go语言版 memcached - github.com</a></li><li><a href="https://developers.google.com/protocol-buffers/docs/proto3">Language Guide (proto3) 官方指南 - google.com</a></li><li><a href="https://developers.google.com/protocol-buffers/docs/style">Proto Style Guide 代码风格指南 - google.com</a></li><li><a href="https://github.com/protocolbuffers/protobuf/blob/master/docs/third_party.md">Protocol Buffer 插件列表 - github.com</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114831.jpg&quot; alt=&quot;Golang Protocol Buffers&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-Protocol</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Golang" scheme="https://ysluckly.github.io/tags/Golang/"/>
    
    <category term="RPC" scheme="https://ysluckly.github.io/tags/RPC/"/>
    
    <category term="Protocol Buffers" scheme="https://ysluckly.github.io/tags/Protocol-Buffers/"/>
    
    <category term="Protobuf" scheme="https://ysluckly.github.io/tags/Protobuf/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 基础教程</title>
    <link href="https://ysluckly.github.io/2021/12/31/mysql/"/>
    <id>https://ysluckly.github.io/2021/12/31/mysql/</id>
    <published>2021-12-31T14:00:42.000Z</published>
    <updated>2022-02-20T13:42:53.249Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210914230736.jpg" alt="linux"></p><table border="0" align="left"><tbody><tr><td align="left" valign="top"><p>mysql资源</p><p>　　<a href="http://dev.mysql.com/doc/refman/5.1/zh/index.html">mysql5.1中文参考手册</a></p><p>mysql管理</p><p>　　<a id="homepage1_HomePageDays_DaysList_DayItem_0_DayList_0_TitleUrl_0" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/02/2751113.html">基于linux使用mysql二进制包安装mysql5.5</a></p><p>　　<a id="homepage1_HomePageDays_DaysList_DayItem_0_DayList_0_TitleUrl_5" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/02/2751222.html">mysql client命令行选项</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/02/2751395.html">mysqld服务器系统变量和状态变量</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/02/2751408.html">mysql SQL服务器模式</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/02/2751721.html">mysql 账户管理</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/02/2751780.html">mysql日志文件</a></p><p>　　</p><p>　　<a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html">mysql列类型</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/02/2751840.html">mysql数据库操作</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/03/2752082.html">mysql创建和删除表</a><a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/03/2752082.html"><br></a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/04/2754254.html">mysql修改表</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/04/2754379.html">mysql索引操作</a></p><p>　　<a id="cb_post_title_url" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/04/2754128.html">mysql索引详解</a></p><p>&nbsp;</p><p>　　<a id="cb_post_title_url" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/05/2754757.html">mysql select操作</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/05/2754938.html">mysql insert操作</a></p><p>　　<a id="cb_post_title_url" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/05/2755683.html">mysql load操作</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/06/2756392.html">mysql update操作</a></p><p>　　<a id="cb_post_title_url" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/06/2756420.html">mysql 删除操作</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/06/2757972.html">mysql join操作</a></p><p>　　<a href="http://dev.mysql.com/doc/refman/5.1/zh/sql-syntax.html#subqueries">mysql子查询</a></p><p>　　<a href="http://dev.mysql.com/doc/refman/5.1/zh/functions.html#cast-functions">mysql函数</a></p><p>&nbsp;</p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/07/2758014.html">mysql show操作</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/07/2758021.html">mysql flush操作</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/07/2758025.html">mysql kill操作</a></p><p>　　<a href="http://dev.mysql.com/doc/refman/5.1/zh/client-side-scripts.html#mysqlcheck">mysql表维护操作</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/13/2768485.html">mysql导入导出</a></p><p>　　<a id="homepage1_HomePageDays_DaysList_DayItem_0_DayList_0_TitleUrl_0" href="http://www.cnblogs.com/ggjucheng/p/3349256.html">分析MySQL慢日志</a></p><p>mysql使用</p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3352291.html">MySQL类型转换</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3352280.html">MySQL：日期函数、时间函数总结</a></p><p>&nbsp;　　</p></td><td align="left" valign="top"><p>mysql调优</p><p>　　<a id="cb_post_title_url" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765237.html">MySQL执行计划解读</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/15/2772058.html">MySQL Profiling 的使用</a></p><p>&nbsp;　 &nbsp;<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/07/2758058.html">mysql常见sql优化</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/15/2771535.html">mysql日志设置优化</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765336.html">MySQL缓存参数优化</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765347.html">MySQL表结构优化</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765428.html">MySQL 索引优化</a>&nbsp;</p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765465.html">MySQL SQL优化</a></p><p>　　<a id="cb_post_title_url" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765469.html">MySQ 存储引擎选择</a></p><p>&nbsp;　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/15/2771877.html">MySQL硬件瓶颈分析</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/15/2771856.html">硬件环境对系统性能的影响</a></p><p>&nbsp;</p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765479.html">MySQL内存使用-全局共享</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765484.html">MySQL内存使用-线程独享</a></p><p>　　<a id="cb_post_title_url" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/14/2770445.html">mysql数据库锁定机制</a></p><p>　　<a id="homepage1_HomePageDays_DaysList_DayItem_0_DayList_0_TitleUrl_0" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/15/2772148.html">Join的实现原理及优化思路</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/18/2776449.html">mysql ORDER BY,GROUP BY 和DISTINCT原理</a></p><p>　　<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html#more-100">MySQL索引背后的数据结构及算法原理</a></p><p>mysql架构</p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/13/2768856.html">mysql主要应用场景</a></p><p>　　<a id="cb_post_title_url" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/13/2768863.html">MySQL Server系统架构</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/13/2768879.html">MySQL Replication 常用架构</a></p><p>　　<a id="cb_post_title_url" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/13/2768959.html">可扩展性设计之数据切分</a></p><p>　　<a id="homepage1_HomePageDays_DaysList_DayItem_0_DayList_0_TitleUrl_2" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/15/2771686.html">可扩展性设计之Cache与Search的利用</a></p><p>&nbsp;　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3349107.html">MySQL key/value存储方案</a></p></td><td align="left" valign="top"><p>db</p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3349104.html">互联网 DBA 需要做那些事</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3349113.html">列式数据库</a></p><p>nosql</p><p>　　<a href="http://sebug.net/paper/databases/nosql/Nosql.html">NoSQL数据库笔谈</a></p><p>　　<a href="http://www.programmer.com.cn/9260/">如何“打败”CAP定理</a></p><p>　　<a href="http://djt.qq.com/article/view/234">NoSQL 在腾讯应用实践</a></p><p>memcached</p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3349237.html">memcached简介</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3349240.html">memcached应用场景</a></p><p>&nbsp;　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3349233.html">Linux下memcached的安装和启动</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3349247.html">在Java中使用Memcached</a></p><p>&nbsp;</p><p>redis文档</p><p>　　<a href="http://redis.io/documentation">redis官方文档</a></p><p>　　<a href="http://www.redis.cn/">redis中文官方文档</a></p><p>　　<a href="http://redis.readthedocs.org/en/latest/" rel="bookmark">Redis命令参考中文版翻译</a></p><p>redis入门资料</p><p>　　<a href="http://files.cnblogs.com/ggjucheng/Redis%E4%B8%AD%E6%96%87%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C.pdf">redis中文入门手册</a></p><p>　　<a href="http://vdisk.weibo.com/s/rNPx2">redis深入浅出</a></p><p>redis应用</p><p>　　<a href="http://blog.nosqlfan.com/html/2235.html?ref=rediszt">Redis作者谈Redis应用场景</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3348273.html">Redis容量及使用规划</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3348277.html">Redis几个认识误区(转)</a></p><p>　<a href="http://www.cnblogs.com/ggjucheng/p/3348268.html">　浅谈Redis数据库的键值设计</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3348271.html">案例:用Redis来存储关注关系(php版)</a></p></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210914230736.jpg&quot; alt=&quot;linux&quot;&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbod</summary>
      
    
    
    
    <category term="数据库" scheme="https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
    <category term="mysql" scheme="https://ysluckly.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Go Gin 简明教程</title>
    <link href="https://ysluckly.github.io/2021/12/26/go/"/>
    <id>https://ysluckly.github.io/2021/12/26/go/</id>
    <published>2021-12-26T13:59:10.000Z</published>
    <updated>2022-02-20T13:34:56.295Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114636.jpg" alt="Gin"></p><p>关键字：<strong>Gin教程</strong> <strong>Gin中文文档</strong> <strong>Go语言Web框架</strong> <strong>Go环境搭建</strong></p><h2 id="Gin-简介"><a href="#Gin-简介" class="headerlink" title="Gin 简介"></a>Gin 简介</h2><blockquote><p>Gin is a HTTP web framework written in Go (Golang). It features a Martini-like API with much better performance – up to 40 times faster. If you need smashing performance, get yourself some Gin. </p></blockquote><p>Gin 是使用 Go/golang 语言实现的 HTTP Web 框架。接口简洁，性能极高。截止 <em>1.4.0</em> 版本，包含测试代码，仅14K，其中测试代码 9K 左右，也就是说框架源码仅 5K 左右。</p><pre><code class="bash">$ find . -name &quot;*_test.go&quot; | xargs cat | wc -l8657$ find . -name &quot;*.go&quot; | xargs cat | wc -l14115</code></pre><h4 id="Gin-特性"><a href="#Gin-特性" class="headerlink" title="Gin 特性"></a>Gin 特性</h4><ul><li><p><strong>快速</strong>：路由不使用反射，基于Radix树，内存占用少。</p></li><li><p><strong>中间件</strong>：HTTP请求，可先经过一系列中间件处理，例如：Logger，Authorization，GZIP等。这个特性和 NodeJs 的 <code>Koa</code> 框架很像。中间件机制也极大地提高了框架的可扩展性。</p></li><li><p><strong>异常处理</strong>：服务始终可用，不会宕机。Gin 可以捕获 panic，并恢复。而且有极为便利的机制处理HTTP请求过程中发生的错误。</p></li><li><p><strong>JSON</strong>：Gin可以解析并验证请求的JSON。这个特性对<code>Restful API</code>的开发尤其有用。</p></li><li><p><strong>路由分组</strong>：例如将需要授权和不需要授权的API分组，不同版本的API分组。而且分组可嵌套，且性能不受影响。</p></li><li><p><strong>渲染内置</strong>：原生支持JSON，XML和HTML的渲染。</p></li></ul><h2 id="安装Go-amp-Gin"><a href="#安装Go-amp-Gin" class="headerlink" title="安装Go &amp; Gin"></a>安装Go &amp; Gin</h2><blockquote><p>初学者建议先阅读 <a href="https://geektutu.com/post/quick-golang.html">Go 语言简明教程</a>。<br>一篇文章介绍了 Go 基本类型，结构体，单元测试，并发编程，依赖管理等内容。Go 1.13 以上版本的安装推荐该教程的方式。</p></blockquote><ul><li>安装 Go (Ubuntu)</li></ul><pre><code class="bash">$ sudo apt-get install golang-go$ go version# go version go1.6.2 linux/amd64</code></pre><p>Ubuntu自带版本太老了，安装新版可以使用如下命令。</p><pre><code>$ sudo add-apt-repository ppa:gophers/archive$ sudo apt-get update$ sudo apt-get install golang-1.11-go</code></pre><p>默认安装在/usr/lib/go-1.11，需要将<code>/usr/lib/go-1.11/bin</code>手动加入环境变量。在 .bashrc 中添加下面的配置，并 <code>source ~/.bashrc</code></p><pre><code class="bash">export PATH=$PATH:/usr/lib/go-1.11/bin</code></pre><p>参考：<a href="https://github.com/golang/go/wiki/Ubuntu">Golang Ubuntu - Github</a></p><ul><li>安装 Go (Mac)</li></ul><pre><code class="bash">$ brew install go$ go version# go version go1.12.5 darwin/amd64</code></pre><ul><li>设置环境变量</li></ul><p>在 ~/.bashrc 中添加 GOPATH 变量</p><pre><code class="bash">export GOPATH=~/goexport PATH=$PATH:$GOPATH/bin</code></pre><p>添加完后，<code>source ~/.bashrc</code></p><ul><li>安装一些辅助的工具库</li></ul><p>由于网络原因，不能够直接访问 golang.org，但相关的库已经镜像到 <a href="https://github.com/golang">Golang - Github</a></p><p>例如，直接安装 go-outline 时会报网络错误，因为<code>golang.org/x/tools</code>是<code>go-outline</code>的依赖库。</p><pre><code class="bash">$ go get -u -v github.com/ramya-rao-a/go-outlinegithub.com/ramya-rao-a/go-outline (download)Fetching https://golang.org/x/tools/go/buildutil?go-get=1https fetch failed: Get https://golang.org/x/tools/go/buildutil?go-get=1: dial tcp 216.239.37.1:443: i/o timeout</code></pre><p>因此，可以先从 Github 手动安装好，再安装 <code>go-outline</code> 和 <code>goreturns</code>。</p><pre><code class="bash">git clone https://github.com/golang/tools.git $GOPATH/src/golang.org/x/toolsgo get -v github.com/ramya-rao-a/go-outlinego get -v github.com/sqs/goreturnsgo get -v github.com/rogpeppe/godef</code></pre><p>Go语言有大量的辅助工具，如果你使用<code>VSCode</code>，将会提示你将必要的工具，例如静态检查、自动补全等工具依次安装完毕。</p><ul><li>安装 Gin</li></ul><pre><code class="bash">go get -u -v github.com/gin-gonic/gin</code></pre><p><code>-v</code>：打印出被构建的代码包的名字<br><code>-u</code>：已存在相关的代码包，强行更新代码包及其依赖包</p><h2 id="第一个Gin程序"><a href="#第一个Gin程序" class="headerlink" title="第一个Gin程序"></a>第一个Gin程序</h2><p>在一个空文件夹里新建文件<code>main.go</code>。</p><pre><code class="go">// geektutu.com// main.gopackage mainimport &quot;github.com/gin-gonic/gin&quot;func main() &#123;    r := gin.Default()    r.GET(&quot;/&quot;, func(c *gin.Context) &#123;        c.String(200, &quot;Hello, Geektutu&quot;)    &#125;)    r.Run() // listen and serve on 0.0.0.0:8080&#125;</code></pre><ol><li>首先，我们使用了<code>gin.Default()</code>生成了一个实例，这个实例即 WSGI 应用程序。</li><li>接下来，我们使用<code>r.Get(&quot;/&quot;, ...)</code>声明了一个路由，告诉 Gin 什么样的URL 能触发传入的函数，这个函数返回我们想要显示在用户浏览器中的信息。</li><li>最后用 <code>r.Run()</code>函数来让应用运行在本地服务器上，默认监听端口是 _8080_，可以传入参数设置端口，例如<code>r.Run(&quot;:9999&quot;)</code>即运行在 _9999_端口。</li></ol><ul><li>运行</li></ul><pre><code class="bash">$ go run main.go[GIN-debug] GET    /                         --&gt; main.main.func1 (3 handlers)[GIN-debug] Environment variable PORT is undefined. Using port :8080 by default[GIN-debug] Listening and serving HTTP on :8080</code></pre><ul><li>浏览器访问 <code>http://localhost:8080</code></li></ul><p><img src="quick-go-gin/hello_gin.jpg" alt="Hello Gin"></p><h2 id="路由-Route"><a href="#路由-Route" class="headerlink" title="路由(Route)"></a>路由(Route)</h2><p>路由方法有 <strong>GET, POST, PUT, PATCH, DELETE</strong> 和 <strong>OPTIONS</strong>，还有<strong>Any</strong>，可匹配以上任意类型的请求。</p><h4 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h4><pre><code class="go">// 无参数r.GET(&quot;/&quot;, func(c *gin.Context) &#123;    c.String(http.StatusOK, &quot;Who are you?&quot;)&#125;)</code></pre><pre><code class="bash">$ curl http://localhost:9999/Who are you?</code></pre><p><code>curl</code>参数可参考<code>https://man.linuxde.net/curl</code></p><h4 id="解析路径参数"><a href="#解析路径参数" class="headerlink" title="解析路径参数"></a>解析路径参数</h4><p>有时候我们需要动态的路由，如 <code>/user/:name</code>，通过调用不同的 url 来传入不同的 name。<code>/user/:name/*role</code>，<code>*</code> 代表可选。</p><pre><code class="go">// 匹配 /user/geektutur.GET(&quot;/user/:name&quot;, func(c *gin.Context) &#123;    name := c.Param(&quot;name&quot;)    c.String(http.StatusOK, &quot;Hello %s&quot;, name)&#125;)</code></pre><pre><code class="bash">$ curl http://localhost:9999/user/geektutuHello geektutu</code></pre><h4 id="获取Query参数"><a href="#获取Query参数" class="headerlink" title="获取Query参数"></a>获取Query参数</h4><pre><code class="go">// 匹配users?name=xxx&amp;role=xxx，role可选r.GET(&quot;/users&quot;, func(c *gin.Context) &#123;    name := c.Query(&quot;name&quot;)    role := c.DefaultQuery(&quot;role&quot;, &quot;teacher&quot;)    c.String(http.StatusOK, &quot;%s is a %s&quot;, name, role)&#125;)</code></pre><pre><code class="bash">$ curl &quot;http://localhost:9999/users?name=Tom&amp;role=student&quot;Tom is a student</code></pre><h4 id="获取POST参数"><a href="#获取POST参数" class="headerlink" title="获取POST参数"></a>获取POST参数</h4><pre><code class="go">// POSTr.POST(&quot;/form&quot;, func(c *gin.Context) &#123;    username := c.PostForm(&quot;username&quot;)    password := c.DefaultPostForm(&quot;password&quot;, &quot;000000&quot;) // 可设置默认值    c.JSON(http.StatusOK, gin.H&#123;        &quot;username&quot;: username,        &quot;password&quot;: password,    &#125;)&#125;)</code></pre><pre><code class="bash">$ curl http://localhost:9999/form  -X POST -d &#39;username=geektutu&amp;password=1234&#39;&#123;&quot;password&quot;:&quot;1234&quot;,&quot;username&quot;:&quot;geektutu&quot;&#125;</code></pre><h4 id="Query和POST混合参数"><a href="#Query和POST混合参数" class="headerlink" title="Query和POST混合参数"></a>Query和POST混合参数</h4><pre><code class="go">// GET 和 POST 混合r.POST(&quot;/posts&quot;, func(c *gin.Context) &#123;    id := c.Query(&quot;id&quot;)    page := c.DefaultQuery(&quot;page&quot;, &quot;0&quot;)    username := c.PostForm(&quot;username&quot;)    password := c.DefaultPostForm(&quot;username&quot;, &quot;000000&quot;) // 可设置默认值    c.JSON(http.StatusOK, gin.H&#123;        &quot;id&quot;:       id,        &quot;page&quot;:     page,        &quot;username&quot;: username,        &quot;password&quot;: password,    &#125;)&#125;)</code></pre><pre><code class="bash">$ curl &quot;http://localhost:9999/posts?id=9876&amp;page=7&quot;  -X POST -d &#39;username=geektutu&amp;password=1234&#39;&#123;&quot;id&quot;:&quot;9876&quot;,&quot;page&quot;:&quot;7&quot;,&quot;password&quot;:&quot;1234&quot;,&quot;username&quot;:&quot;geektutu&quot;&#125;</code></pre><h4 id="Map参数-字典参数"><a href="#Map参数-字典参数" class="headerlink" title="Map参数(字典参数)"></a>Map参数(字典参数)</h4><pre><code class="go">r.POST(&quot;/post&quot;, func(c *gin.Context) &#123;    ids := c.QueryMap(&quot;ids&quot;)    names := c.PostFormMap(&quot;names&quot;)    c.JSON(http.StatusOK, gin.H&#123;        &quot;ids&quot;:   ids,        &quot;names&quot;: names,    &#125;)&#125;)</code></pre><pre><code class="bash">$ curl -g &quot;http://localhost:9999/post?ids[Jack]=001&amp;ids[Tom]=002&quot; -X POST -d &#39;names[a]=Sam&amp;names[b]=David&#39;&#123;&quot;ids&quot;:&#123;&quot;Jack&quot;:&quot;001&quot;,&quot;Tom&quot;:&quot;002&quot;&#125;,&quot;names&quot;:&#123;&quot;a&quot;:&quot;Sam&quot;,&quot;b&quot;:&quot;David&quot;&#125;&#125;</code></pre><h4 id="重定向-Redirect"><a href="#重定向-Redirect" class="headerlink" title="重定向(Redirect)"></a>重定向(Redirect)</h4><pre><code class="go">r.GET(&quot;/redirect&quot;, func(c *gin.Context) &#123;    c.Redirect(http.StatusMovedPermanently, &quot;/index&quot;)&#125;)r.GET(&quot;/goindex&quot;, func(c *gin.Context) &#123;    c.Request.URL.Path = &quot;/&quot;    r.HandleContext(c)&#125;)</code></pre><pre><code class="bash">$ curl -i http://localhost:9999/redirectHTTP/1.1 301 Moved PermanentlyContent-Type: text/html; charset=utf-8Location: /Date: Thu, 08 Aug 2019 17:22:14 GMTContent-Length: 36&lt;a href=&quot;/&quot;&gt;Moved Permanently&lt;/a&gt;.$ curl &quot;http://localhost:9999/goindex&quot;Who are you?</code></pre><h4 id="分组路由-Grouping-Routes"><a href="#分组路由-Grouping-Routes" class="headerlink" title="分组路由(Grouping Routes)"></a>分组路由(Grouping Routes)</h4><p>如果有一组路由，前缀都是<code>/api/v1</code>开头，是否每个路由都需要加上<code>/api/v1</code>这个前缀呢？答案是不需要，分组路由可以解决这个问题。利用分组路由还可以更好地实现权限控制，例如将需要登录鉴权的路由放到同一分组中去，简化权限控制。</p><pre><code class="go">// group routes 分组路由defaultHandler := func(c *gin.Context) &#123;    c.JSON(http.StatusOK, gin.H&#123;        &quot;path&quot;: c.FullPath(),    &#125;)&#125;// group: v1v1 := r.Group(&quot;/v1&quot;)&#123;    v1.GET(&quot;/posts&quot;, defaultHandler)    v1.GET(&quot;/series&quot;, defaultHandler)&#125;// group: v2v2 := r.Group(&quot;/v2&quot;)&#123;    v2.GET(&quot;/posts&quot;, defaultHandler)    v2.GET(&quot;/series&quot;, defaultHandler)&#125;</code></pre><pre><code class="bash">$ curl http://localhost:9999/v1/posts&#123;&quot;path&quot;:&quot;/v1/posts&quot;&#125;$ curl http://localhost:9999/v2/posts&#123;&quot;path&quot;:&quot;/v2/posts&quot;&#125;</code></pre><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><h4 id="单个文件"><a href="#单个文件" class="headerlink" title="单个文件"></a>单个文件</h4><pre><code class="go">r.POST(&quot;/upload1&quot;, func(c *gin.Context) &#123;    file, _ := c.FormFile(&quot;file&quot;)    // c.SaveUploadedFile(file, dst)    c.String(http.StatusOK, &quot;%s uploaded!&quot;, file.Filename)&#125;)</code></pre><h4 id="多个文件"><a href="#多个文件" class="headerlink" title="多个文件"></a>多个文件</h4><pre><code class="go">r.POST(&quot;/upload2&quot;, func(c *gin.Context) &#123;    // Multipart form    form, _ := c.MultipartForm()    files := form.File[&quot;upload[]&quot;]    for _, file := range files &#123;        log.Println(file.Filename)        // c.SaveUploadedFile(file, dst)    &#125;    c.String(http.StatusOK, &quot;%d files uploaded!&quot;, len(files))&#125;)</code></pre><h2 id="HTML模板-Template"><a href="#HTML模板-Template" class="headerlink" title="HTML模板(Template)"></a>HTML模板(Template)</h2><pre><code class="go">type student struct &#123;    Name string    Age  int8&#125;r.LoadHTMLGlob(&quot;templates/*&quot;)stu1 := &amp;student&#123;Name: &quot;Geektutu&quot;, Age: 20&#125;stu2 := &amp;student&#123;Name: &quot;Jack&quot;, Age: 22&#125;r.GET(&quot;/arr&quot;, func(c *gin.Context) &#123;    c.HTML(http.StatusOK, &quot;arr.tmpl&quot;, gin.H&#123;        &quot;title&quot;:  &quot;Gin&quot;,        &quot;stuArr&quot;: [2]*student&#123;stu1, stu2&#125;,    &#125;)&#125;)</code></pre><pre><code class="html">&lt;!-- templates/arr.tmpl --&gt;&lt;html&gt;&lt;body&gt;    &lt;p&gt;hello, &#123;&#123;.title&#125;&#125;&lt;/p&gt;    &#123;&#123;range $index, $ele := .stuArr &#125;&#125;    &lt;p&gt;&#123;&#123; $index &#125;&#125;: &#123;&#123; $ele.Name &#125;&#125; is &#123;&#123; $ele.Age &#125;&#125; years old&lt;/p&gt;    &#123;&#123; end &#125;&#125;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="shell">$ curl http://localhost:9999/arr&lt;html&gt;&lt;body&gt;    &lt;p&gt;hello, Gin&lt;/p&gt;    &lt;p&gt;0: Geektutu is 20 years old&lt;/p&gt;    &lt;p&gt;1: Jack is 22 years old&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>Gin默认使用模板Go语言标准库的模板<code>text/template</code>和<code>html/template</code>，语法与标准库一致，支持各种复杂场景的渲染。</li><li>参考官方文档<a href="https://golang.org/pkg/text/template/">text/template</a>，<a href="https://golang.org/pkg/html/template/">html/template</a></li></ul><h2 id="中间件-Middleware"><a href="#中间件-Middleware" class="headerlink" title="中间件(Middleware)"></a>中间件(Middleware)</h2><pre><code class="go">// 作用于全局r.Use(gin.Logger())r.Use(gin.Recovery())// 作用于单个路由r.GET(&quot;/benchmark&quot;, MyBenchLogger(), benchEndpoint)// 作用于某个组authorized := r.Group(&quot;/&quot;)authorized.Use(AuthRequired())&#123;    authorized.POST(&quot;/login&quot;, loginEndpoint)    authorized.POST(&quot;/submit&quot;, submitEndpoint)&#125;</code></pre><p>如何自定义中间件呢？</p><pre><code class="go">func Logger() gin.HandlerFunc &#123;    return func(c *gin.Context) &#123;        t := time.Now()        // 给Context实例设置一个值        c.Set(&quot;geektutu&quot;, &quot;1111&quot;)        // 请求前        c.Next()        // 请求后        latency := time.Since(t)        log.Print(latency)    &#125;&#125;</code></pre><h2 id="热加载调试-Hot-Reload"><a href="#热加载调试-Hot-Reload" class="headerlink" title="热加载调试 Hot Reload"></a>热加载调试 Hot Reload</h2><p>Python 的 <code>Flask</code>框架，有 <em>debug</em> 模式，启动时传入 <em>debug=True</em> 就可以热加载(Hot Reload, Live Reload)了。即更改源码，保存后，自动触发更新，浏览器上刷新即可。免去了杀进程、重新启动之苦。</p><p>Gin 原生不支持，但有很多额外的库可以支持。例如</p><ul><li>github.com/codegangsta/gin</li><li>github.com/pilu/fresh</li></ul><p>这次，我们采用 <em>github.com/pilu/fresh</em> 。</p><pre><code class="bash">go get -v -u github.com/pilu/fresh</code></pre><p>安装好后，只需要将<code>go run main.go</code>命令换成<code>fresh</code>即可。每次更改源文件，代码将自动重新编译(Auto Compile)。</p><p>参考 <a href="https://github.com/gravityblast/fresh">github.com/pilu/fresh - Github</a></p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="https://github.com/gin-gonic/gin">Golang Gin - Github</a></li><li><a href="https://gin-gonic.com/">Gin Web Framework - 英文官方网站</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114636.jpg&quot; alt=&quot;Gin&quot;&gt;&lt;/p&gt;
&lt;p&gt;关键字：&lt;strong&gt;Gin教程&lt;/strong&gt; &lt;strong&gt;</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Gin" scheme="https://ysluckly.github.io/tags/Gin/"/>
    
  </entry>
  
  <entry>
    <title>Go Context 并发编程简明教程</title>
    <link href="https://ysluckly.github.io/2021/12/25/go/"/>
    <id>https://ysluckly.github.io/2021/12/25/go/</id>
    <published>2021-12-25T13:59:10.000Z</published>
    <updated>2022-02-20T13:33:13.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为什么需要-Context"><a href="#1-为什么需要-Context" class="headerlink" title="1 为什么需要 Context"></a>1 为什么需要 Context</h2><p>WaitGroup 和信道(channel)是常见的 2 种并发控制的方式。</p><p>如果并发启动了多个子协程，需要等待所有的子协程完成任务，WaitGroup 非常适合于这类场景，例如下面的例子：</p><pre><code class="go">var wg sync.WaitGroupfunc doTask(n int) &#123;    time.Sleep(time.Duration(n))    fmt.Printf(&quot;Task %d Done\n&quot;, n)    wg.Done()&#125;func main() &#123;    for i := 0; i &lt; 3; i++ &#123;        wg.Add(1)        go doTask(i + 1)    &#125;    wg.Wait()    fmt.Println(&quot;All Task Done&quot;)&#125;</code></pre><p><code>wg.Wait()</code> 会等待所有的子协程任务全部完成，所有子协程结束后，才会执行 <code>wg.Wait()</code> 后面的代码。</p><pre><code class="bash">Task 3 DoneTask 1 DoneTask 2 DoneAll Task Done</code></pre><p>WaitGroup 只是傻傻地等待子协程结束，但是并不能主动通知子协程退出。假如开启了一个定时轮询的子协程，有没有什么办法，通知该子协程退出呢？这种场景下，可以使用 <code>select+chan</code> 的机制。</p><pre><code class="go">var stop chan boolfunc reqTask(name string) &#123;    for &#123;        select &#123;        case &lt;-stop:            fmt.Println(&quot;stop&quot;, name)            return        default:            fmt.Println(name, &quot;send request&quot;)            time.Sleep(1 * time.Second)        &#125;    &#125;&#125;func main() &#123;    stop = make(chan bool)    go reqTask(&quot;worker1&quot;)    time.Sleep(3 * time.Second)    stop &lt;- true    time.Sleep(3 * time.Second)&#125;</code></pre><p>子协程使用 for 循环定时轮询，如果 <code>stop</code> 信道有值，则退出，否则继续轮询。</p><pre><code class="bash">worker1 send requestworker1 send requestworker1 send requeststop worker1</code></pre><p>更复杂的场景如何做并发控制呢？比如子协程中开启了新的子协程，或者需要同时控制多个子协程。这种场景下，<code>select+chan</code>的方式就显得力不从心了。</p><p>Go 语言提供了 Context 标准库可以解决这类场景的问题，Context 的作用和它的名字很像，上下文，即子协程的下上文。Context 有两个主要的功能：</p><ul><li>通知子协程退出（正常退出，超时退出等）；</li><li>传递必要的参数。</li></ul><h2 id="2-context-WithCancel"><a href="#2-context-WithCancel" class="headerlink" title="2 context.WithCancel"></a>2 context.WithCancel</h2><p><code>context.WithCancel()</code> 创建可取消的 Context 对象，即可以主动通知子协程退出。</p><h3 id="2-1-控制单个协程"><a href="#2-1-控制单个协程" class="headerlink" title="2.1 控制单个协程"></a>2.1 控制单个协程</h3><p>使用 Context 改写上述的例子，效果与 <code>select+chan</code> 相同。</p><pre><code class="go">func reqTask(ctx context.Context, name string) &#123;    for &#123;        select &#123;        case &lt;-ctx.Done():            fmt.Println(&quot;stop&quot;, name)            return        default:            fmt.Println(name, &quot;send request&quot;)            time.Sleep(1 * time.Second)        &#125;    &#125;&#125;func main() &#123;    ctx, cancel := context.WithCancel(context.Background())    go reqTask(ctx, &quot;worker1&quot;)    time.Sleep(3 * time.Second)    cancel()    time.Sleep(3 * time.Second)&#125;</code></pre><ul><li><code>context.Backgroud()</code> 创建根 Context，通常在 main 函数、初始化和测试代码中创建，作为顶层 Context。</li><li><code>context.WithCancel(parent)</code> 创建可取消的子 Context，同时返回函数 <code>cancel</code>。</li><li>在子协程中，使用 select 调用 <code>&lt;-ctx.Done()</code> 判断是否需要退出。</li><li>主协程中，调用 <code>cancel()</code> 函数通知子协程退出。</li></ul><h3 id="2-2-控制多个协程"><a href="#2-2-控制多个协程" class="headerlink" title="2.2 控制多个协程"></a>2.2 控制多个协程</h3><pre><code class="go">func main() &#123;    ctx, cancel := context.WithCancel(context.Background())    go reqTask(ctx, &quot;worker1&quot;)    go reqTask(ctx, &quot;worker2&quot;)    time.Sleep(3 * time.Second)    cancel()    time.Sleep(3 * time.Second)&#125;</code></pre><p>为每个子协程传递相同的上下文 <code>ctx</code> 即可，调用 <code>cancel()</code> 函数后该 Context 控制的所有子协程都会退出。</p><pre><code class="bash">worker1 send requestworker2 send requestworker1 send requestworker2 send requestworker1 send requestworker2 send requeststop worker1stop worker2</code></pre><h2 id="3-context-WithValue"><a href="#3-context-WithValue" class="headerlink" title="3 context.WithValue"></a>3 context.WithValue</h2><p>如果需要往子协程中传递参数，可以使用 <code>context.WithValue()</code>。</p><pre><code class="go">type Options struct&#123; Interval time.Duration &#125;func reqTask(ctx context.Context, name string) &#123;    for &#123;        select &#123;        case &lt;-ctx.Done():            fmt.Println(&quot;stop&quot;, name)            return        default:            fmt.Println(name, &quot;send request&quot;)            op := ctx.Value(&quot;options&quot;).(*Options)            time.Sleep(op.Interval * time.Second)        &#125;    &#125;&#125;func main() &#123;    ctx, cancel := context.WithCancel(context.Background())    vCtx := context.WithValue(ctx, &quot;options&quot;, &amp;Options&#123;1&#125;)    go reqTask(vCtx, &quot;worker1&quot;)    go reqTask(vCtx, &quot;worker2&quot;)    time.Sleep(3 * time.Second)    cancel()    time.Sleep(3 * time.Second)&#125;</code></pre><ul><li><code>context.WithValue()</code> 创建了一个基于 <code>ctx</code> 的子 Context，并携带了值 <code>options</code>。</li><li>在子协程中，使用 <code>ctx.Value(&quot;options&quot;)</code> 获取到传递的值，读取/修改该值。</li></ul><h2 id="4-context-WithTimeout"><a href="#4-context-WithTimeout" class="headerlink" title="4 context.WithTimeout"></a>4 context.WithTimeout</h2><p>如果需要控制子协程的执行时间，可以使用 <code>context.WithTimeout</code> 创建具有超时通知机制的 Context 对象。</p><pre><code>func main() &#123;    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)    go reqTask(ctx, &quot;worker1&quot;)    go reqTask(ctx, &quot;worker2&quot;)    time.Sleep(3 * time.Second)    fmt.Println(&quot;before cancel&quot;)    cancel()    time.Sleep(3 * time.Second)&#125;</code></pre><p><code>WithTimeout()</code>的使用与 <code>WithCancel()</code> 类似，多了一个参数，用于设置超时时间。执行结果如下：</p><pre><code class="bash">worker2 send requestworker1 send requestworker1 send requestworker2 send requeststop worker2stop worker1before cancel</code></pre><p>因为超时时间设置为 2s，但是 main 函数中，3s 后才会调用 <code>cancel()</code>，因此，在调用 <code>cancel()</code> 函数前，子协程因为超时已经退出了。</p><h2 id="5-context-WithDeadline"><a href="#5-context-WithDeadline" class="headerlink" title="5 context.WithDeadline"></a>5 context.WithDeadline</h2><p>超时退出可以控制子协程的最长执行时间，那 <code>context.WithDeadline()</code> 则可以控制子协程的最迟退出时间。</p><pre><code class="go">func reqTask(ctx context.Context, name string) &#123;    for &#123;        select &#123;        case &lt;-ctx.Done():            fmt.Println(&quot;stop&quot;, name, ctx.Err())            return        default:            fmt.Println(name, &quot;send request&quot;)            time.Sleep(1 * time.Second)        &#125;    &#125;&#125;func main() &#123;    ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(1*time.Second))    go reqTask(ctx, &quot;worker1&quot;)    go reqTask(ctx, &quot;worker2&quot;)    time.Sleep(3 * time.Second)    fmt.Println(&quot;before cancel&quot;)    cancel()    time.Sleep(3 * time.Second)&#125;</code></pre><ul><li><code>WithDeadline</code> 用于设置截止时间。在这个例子中，将截止时间设置为1s后，<code>cancel()</code> 函数在 3s 后调用，因此子协程将在调用 <code>cancel()</code> 函数前结束。</li><li>在子协程中，可以通过 <code>ctx.Err()</code> 获取到子协程退出的错误原因。</li></ul><p>运行结果如下：</p><pre><code class="bash">worker2 send requestworker1 send requeststop worker2 context deadline exceededstop worker1 context deadline exceededbefore cancel</code></pre><p>可以看到，子协程 <code>worker1</code> 和 <code>worker2</code> 均是因为截止时间到了而退出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-为什么需要-Context&quot;&gt;&lt;a href=&quot;#1-为什么需要-Context&quot; class=&quot;headerlink&quot; title=&quot;1 为什么需要 Context&quot;&gt;&lt;/a&gt;1 为什么需要 Context&lt;/h2&gt;&lt;p&gt;WaitGroup 和信道(chan</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="并发编程" scheme="https://ysluckly.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="上下文" scheme="https://ysluckly.github.io/tags/%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
    <category term="信道" scheme="https://ysluckly.github.io/tags/%E4%BF%A1%E9%81%93/"/>
    
    <category term="超时退出" scheme="https://ysluckly.github.io/tags/%E8%B6%85%E6%97%B6%E9%80%80%E5%87%BA/"/>
    
    <category term="golang" scheme="https://ysluckly.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go2 新特性简明教程</title>
    <link href="https://ysluckly.github.io/2021/12/24/go/"/>
    <id>https://ysluckly.github.io/2021/12/24/go/</id>
    <published>2021-12-24T13:59:10.000Z</published>
    <updated>2022-02-20T13:32:23.306Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114535.jpg" alt="quick-go2"></p><p>图片引用自<code>udemy.com</code></p><h2 id="Go-的演进"><a href="#Go-的演进" class="headerlink" title="Go 的演进"></a>Go 的演进</h2><p>Go语言/golang 诞生于2007年，经过12年的发展，Go逐渐成为了云计算领域新一代的开发语言。Go语言在牺牲很少性能的情况下，语法简洁，功能强大。我是Python的重度用户，在学习Go时，却有一种在学习Python的感觉。并非语法相似，而是Go语言作为一门编译型语言，竟然能够像Python一样，少量的代码就能够完成尽可能多的事情。Go语言仿佛是C和Python的结合体。</p><p>Go是如何火起来的呢？我觉得有几个主要的原因，除了语言本身性能好，语法简单，易上手外。Go语言原生支持<code>Goroutine</code>和<code>Channel</code>，极大地降低了并发和异步编程的复杂度。对于服务端编程，并发和异步尤其重要，相比之下，C++，Java等语言的并发和异步控制逻辑过于复杂。另外，杀手级应用<code>Docker</code>的出现起到了很大的推动作用。</p><p>Go语言也有很多令人诟病的地方，例如包管理机制，Go直到v1.6才默认开启了vendor机制，vendor机制非常简陋，简单说就是在项目目录下增加一个vendor文件夹，里面放第三方依赖。vendor机制是没有版本概念的，而且不能解决vendor目录嵌套的问题以及同名包函数冲突问题。后来社区涌现了大量的包管理工具，仅官方推荐的包管理工具就有15种之多，应用比较广泛的，如dep、govendor。直到v1.11，官方增加了Go modules机制，才算较为完整地解决了包管理的问题。</p><p>Go2 可以说是Go语言一个非常重要的里程碑，Go1 目前虽然已经到了1.12版本，事实上每一个版本很少涉及语法层面的变化，而且每个版本都是向前兼容的。较大的改动如下：</p><ul><li>Go1.2 切片操作</li></ul><pre><code class="go">var a = make([]int, 10)var b = a[i:j:k]</code></pre><ul><li>Go1.4 for语言加强</li></ul><pre><code class="go">// &lt;= 1.3for i, v := range x &#123;    // ...&#125;for i := range x &#123;    // ...&#125;// 1.4 新增var times [5][0]intfor i := 0; i &lt; len(times); i++ &#123;    // ...&#125;for _ = range times &#123;    // ...&#125;</code></pre><ul><li>Go1.9 类型别名</li></ul><pre><code class="go">type T1 = T2</code></pre><h2 id="Go-2-设计草案"><a href="#Go-2-设计草案" class="headerlink" title="Go 2 设计草案"></a>Go 2 设计草案</h2><p>为了进一步完善Go语言，提供更好的体验。Go语言社区目前发布了三类重要的设计草案，分别是<code>错误处理(Error handling)</code>、<code>错误值(Error values)</code>、<code>泛型(Generics)</code>，这几个草案代表了社区重点关注的完善方向，但并不代表最终的实现。</p><h3 id="错误处理-Error-Handling"><a href="#错误处理-Error-Handling" class="headerlink" title="错误处理(Error Handling)"></a>错误处理(Error Handling)</h3><p>Go1 的错误处理机制非常简单，通过返回值的方式，强迫调用者对错误进行处理，这种设计导致会在代码中写大量的<code>if</code>判断。例如：</p><pre><code class="go">func CopyFile(src, dst string) &#123;    r := os.Open(src)    defer r.Close()    w := os.Create(dst)    io.Copy(w, r)    w.Close()&#125;</code></pre><p>IO操作容易引发错误，文件打开失败，创建失败，拷贝失败等都会产生错误。如果要对这个函数进行完整的错误处理，代码将变成这样：</p><pre><code class="go">func CopyFile(src, dst string) error &#123;    r, err := os.Open(src)    if err != nil &#123;        return err    &#125;    defer r.Close()    w, err := os.Create(dst)    if err != nil &#123;        return err    &#125;    defer w.Close()    if _, err := io.Copy(w, r); err != nil &#123;        return err    &#125;    if err := w.Close(); err != nil &#123;        return err    &#125;&#125;</code></pre><p>看似逻辑清晰，但不够优雅，充斥了大量重复的逻辑。这是Go错误处理机制的缺陷。同时，因为错误处理机制的繁琐，很多开发者在开发应用时，很少去检查并处理错误，程序的健壮性得不到保证。</p><p>为了解决这个问题，Go2 发布了一个设计草案供社区讨论，Go2将会完善错误处理机制，错误处理的语法将会简洁很多。</p><p>这个提案引入了<code>handle err</code>和<code>check</code>关键字，上面的函数可以简化成：</p><pre><code class="go">func CopyFile(src, dst string) error &#123;    handle err &#123;        return fmt.Errorf(&quot;copy %s %s: %v&quot;, src, dst, err)    &#125;    r := check os.Open(src)    defer r.Close()    w := check os.Create(dst)    check io.Copy(w, r)    check w.Close()&#125;</code></pre><p>为什么不使用被Java、Python等语言采用的<code>try</code>关键字呢？比如写成：</p><pre><code class="go">data := try parseHexdump(string(hex))</code></pre><p>上面的写法看似和谐，但<code>try</code>关键字直接应用在 error values 时，可读性就没那么好了：</p><pre><code class="go">data, err := parseHexdump(string(hex))if err == ErrBadHex &#123;    ... special handling ...&#125;try err</code></pre><p>很明显，在这种场景下，<code>check err</code>显然比<code>try err</code>更有意义。</p><h3 id="错误值-Error-values"><a href="#错误值-Error-values" class="headerlink" title="错误值(Error values)"></a>错误值(Error values)</h3><p>同样由于错误处理机制设计得较为简陋，Go语言对<code>Error values</code>支持有限。任何值，只要实现了<code>error</code>接口，都是错误类型。由于缺少细粒度的设计，在各种库当中，判断是否产生错误以及产生了哪类错误的方式多种多样，例如<code>io.EOF</code>，<code>os.IsNotExist</code>，<code>err.Error()</code>等，。另外，Go语言目前没有机制追溯到完整的错误链条。例如，</p><pre><code class="go">func funcB() error &#123;    if v, err := funcA(); if err != nil &#123;        return fmt.Errorf(&quot;connect to db: %v&quot;, err)    &#125;&#125;func funcC() error &#123;    v, err := funcB()    if err != nil &#123;        return fmt.Errorf(&quot;write users database: %v&quot;, err)    &#125;&#125;</code></pre><p><code>funcC</code>返回的错误信息是：</p><pre><code class="bash">write users database: connect to db: open /etc/xx.conf: permission denied</code></pre><p>每一层，用额外的字符串对错误进行封装，是目前最常用的方法，除了通过字符串解析，很难还原出完整的错误链条。</p><p>为了解决Error values缺少标准的问题，有2个提案，分别针对<code>Error inspection</code>和<code>Error formatting</code>。</p><ul><li>针对 Error inspection ，为error定义了一个可选的接口<code>Unwrap</code>，用来返回错误链上的下一个错误。</li></ul><pre><code class="go">package errorstype Wrapper interface &#123;    Unwrap() error&#125;</code></pre><p>例如，</p><pre><code class="go">// WriteError 实现 Unwrap 接口func (e *WriteError) Unwrap() error &#123; return e.Err &#125;</code></pre><ul><li>针对 Error format，定义了一个可选的接口<code>Format</code>，用来返回错误信息。</li></ul><pre><code class="go">package errorstype Formatter interface &#123;    Format(p Printer) (next error)&#125;</code></pre><p>例如，</p><pre><code class="go">func (e *WriteError) Format(p errors.Printer) (next error) &#123;    p.Printf(&quot;write %s database&quot;, e.Database)    if p.Detail() &#123;        p.Printf(&quot;more detail here&quot;)    &#125;    return e.Err&#125;</code></pre><h3 id="泛型-Generics"><a href="#泛型-Generics" class="headerlink" title="泛型(Generics)"></a>泛型(Generics)</h3><p>Go语言当前可使用<code>inferface&#123;&#125;</code>，允许函数参数和返回值是任何类型的值。但这过于灵活，很多时候需要在获取参数后使用类型断言，进而决定下一步的处理。对比C++/Java的标准容器，Go语言在泛型方面有很大不足，因此针对泛型的提案即希望弥补这方面的不足。提案希望能够支持以下功能：</p><pre><code class="go">type List(type T) []T// 返回map的键func Keys(type K, V)(m map[K]V) []K// 去重过滤func Uniq(&lt;-chan T) &lt;-chan T// 合并func Merge(chans ...&lt;-chan T) &lt;-chan T// 使用自定义排序函数排序func SortSlice(data []T, less func(x, y T) bool)</code></pre><p>例如，我们需要返回一个map对象中所有的键，而希望这个键的类型可以是任意类型。</p><pre><code class="go">var ints List(int)keysA := Keys(int, string)(map[int]string&#123;1:&quot;one&quot;, 2: &quot;two&quot;&#125;)keysB := Keys(string, string)(map[string]string&#123;&quot;name&quot;:&quot;geektutu&quot;, &quot;age&quot;: &quot;twenty&quot;&#125;)// [1, 2]</code></pre><blockquote><p>参考：<a href="https://github.com/golang/go/wiki/Go2">Go2 wiki - Github</a></p></blockquote><h2 id="Go-2-新特性"><a href="#Go-2-新特性" class="headerlink" title="Go 2 新特性"></a>Go 2 新特性</h2><p>Go2还未正式发布，发布后更新</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114535.jpg&quot; alt=&quot;quick-go2&quot;&gt;&lt;/p&gt;
&lt;p&gt;图片引用自&lt;code&gt;udemy.com&lt;/code&gt;&lt;/</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Go语言" scheme="https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
    <category term="GO2" scheme="https://ysluckly.github.io/tags/GO2/"/>
    
    <category term="泛型" scheme="https://ysluckly.github.io/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 基础教程</title>
    <link href="https://ysluckly.github.io/2021/12/17/tcp/ip/"/>
    <id>https://ysluckly.github.io/2021/12/17/tcp/ip/</id>
    <published>2021-12-17T14:00:42.000Z</published>
    <updated>2022-02-20T13:42:14.489Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210914230121.jpg" alt="linux"></p><p>　　基础</p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/11/01/2750217.html">TCP Implementation in Linux: A Brief Tutorial</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/02/02/2335495.html">基于tcpdump实例讲解TCP/IP协议</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/p/3348492.html">tcp-ip-状态详解</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/15/2323070.html">纳格算法</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/15/2323081.html">TCP延迟确认</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/02/03/2337046.html">糊涂窗口综合症</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/02/02/2335994.html">TCP慢启动算法</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/02/03/2337420.html">拥塞避免算法</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/02/05/2339217.html">TCP的超时与重传</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/02/05/2339228.html">快速重传与快速恢复算法</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/02/05/2339212.html">TCP的坚持定时器</a></p><p>　　编程</p><p>　　　　TCP客户端和服务端入门</p><p>　　　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/17/2324584.html">Linux/Unix服务端和客户端Socket编程入门实例</a></p><p>　　　　IO复用</p><p>　　　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/17/2324859.html">Linux/Unix IO多路复用之select网络编程</a></p><p>　　　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/17/2324968.html">Linux/Unix IO多路复用之poll网络编程</a></p><p>　　　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/17/2324974.html">Linux IO多路复用之epoll网络编程</a></p><p>　　　　套接字选项</p><p>　　　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/02/17/2355874.html">Socket选项概览</a></p><p>　　　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/15/2323068.html">网络编程中Nagle算法和Delayed ACK的测试</a></p><p>　　　　原始套接字</p><p>　　　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/02/17/2355564.html">C++ Ping源码</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210914230121.jpg&quot; alt=&quot;linux&quot;&gt;&lt;/p&gt;
&lt;p&gt;　　基础&lt;/p&gt;
&lt;p&gt;　　　　&lt;a href=&quot;http://w</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="网络编程" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="tcp/ip" scheme="https://ysluckly.github.io/tags/tcp-ip/"/>
    
  </entry>
  
  <entry>
    <title>Redis 2021最新 超详解 教程（狂神笔记+个人总结+代码+截图）</title>
    <link href="https://ysluckly.github.io/2021/12/08/redis/"/>
    <id>https://ysluckly.github.io/2021/12/08/redis/</id>
    <published>2021-12-08T02:44:30.000Z</published>
    <updated>2022-02-25T15:04:20.560Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li>  <a href="about:blank#NoSQL__1">一.NoSQL 简介</a></li><li><ul><li><a href="about:blank#1_3">1.数据库演化</a><ul><li>  <a href="about:blank#2NoSQL_21">2.为什么使用NoSQL</a></li><li>  <a href="about:blank#3NoSQL_28">3.NoSQL特点</a></li><li>  <a href="about:blank#4NoSQL_49">4.NoSQL分类</a></li><li>  <a href="about:blank#5_59">5.电商的数据存储</a></li><li><ul><li><ul><li><a href="about:blank#_60">商品的基本信息</a><ul><li>  <a href="about:blank#_64">商品的描述、评论（文字较多）</a></li><li>  <a href="about:blank#_67">图片</a></li><li>  <a href="about:blank#_78">商品关键字（搜索）</a></li><li>  <a href="about:blank#_83">商品热门信息</a></li><li>  <a href="about:blank#_86">商品的交易，外部支付接口</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#Redis__91">二、Redis 简介</a></li><li><ul><li><a href="about:blank#1_93">1.简介</a><ul><li>  <a href="about:blank#2Redis_101">2.为什么需要Redis</a></li><li>  <a href="about:blank#3Redis_107">3.Redis帮我们解决什么</a></li><li>  <a href="about:blank#4_119">4.学习途径</a></li><li>  <a href="about:blank#5_126">5.下载</a></li></ul></li></ul></li><li>  <a href="about:blank#Redis__129">三、Redis 安装</a></li><li><ul><li><a href="about:blank#1windows_130">1.windows环境</a><ul><li><ul><li><ul><li><a href="about:blank#_139">启动服务端</a><ul><li>  <a href="about:blank#_144">启动客户端</a></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#2Linux_158">2.Linux安装</a></li><li><ul><li><ul><li><a href="about:blank#_160">下载</a><ul><li>  <a href="about:blank#_175">环境</a></li><li>  <a href="about:blank#_186">安装</a></li><li>  <a href="about:blank#_198">配置文件</a></li><li>  <a href="about:blank#_208">启动</a></li><li>  <a href="about:blank#_241">关闭</a></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#3_249">3.测试性能</a></li><li><ul><li><ul><li>  <a href="about:blank#_265">分析结果</a></li></ul></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#Redis__272">四、Redis 基础知识</a></li><li><ul><li><ul><li><ul><li><a href="about:blank#_275">基础指令</a><pre><code>*   [Redis单线程](about:blank#Redis_290)</code></pre></li></ul></li><li>  <a href="about:blank#1_295">1.五大数据类型</a></li><li><ul><li><ul><li><a href="about:blank#RedisKey_299">Redis-Key</a><ul><li>  <a href="about:blank#String_328">String(字符串)</a></li><li>  <a href="about:blank#List_392">List（列表）</a></li><li>  <a href="about:blank#Set_471">Set（集合）</a></li><li>  <a href="about:blank#HashHashMap_533">Hash（HashMap集合、散列表、链表数组）</a></li><li>  <a href="about:blank#Zset_601">Zset（有序集合）</a></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#2_643">2.三种特殊数据类型</a></li><li><ul><li><ul><li><a href="about:blank#geospatial_644">geospatial</a><ul><li>  <a href="about:blank#Hyperloglogs_701">Hyperloglogs</a></li><li>  <a href="about:blank#Bitmaps_728">Bitmaps</a></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#3Redis__747">3.Redis 事务</a></li><li>  <a href="about:blank#4Redis_785">4.Redis实现乐观锁</a></li></ul></li></ul></li><li>  <a href="about:blank#Java__Redis_811">五、Java 操作 Redis</a></li><li><ul><li><a href="about:blank#1Jedis_API_812">1.Jedis 官方原生API</a><ul><li><ul><li><ul><li><a href="about:blank#_813">概念</a><ul><li>  <a href="about:blank#_816">项目、依赖</a></li><li>  <a href="about:blank#_832">连接、测试</a></li><li>  <a href="about:blank#API_852">常用API</a></li><li><ul><li><a href="about:blank#Key_855">Key操作</a><ul><li>  <a href="about:blank#String_881">String类型</a></li><li>  <a href="about:blank#List_923">List集合</a></li><li>  <a href="about:blank#Set_960">Set集合</a></li></ul></li></ul></li><li>  <a href="about:blank#Hash_999">Hash</a></li><li>  <a href="about:blank#Jedis__1033">Jedis 事务</a></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#2SpringBoot__Redis_1072">2.SpringBoot 整合 Redis</a></li><li><ul><li><ul><li><a href="about:blank#_1075">项目准备</a><ul><li>  <a href="about:blank#Redis_1096">Redis测试</a></li><li>  <a href="about:blank#_1103">序列化问题</a></li><li>  <a href="about:blank#_1172">自己写工具类</a></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#Redis__1395">六、Redis 高级</a></li><li><ul><li><a href="about:blank#1redisconf__1396">1.redis.conf 配置文件</a><ul><li>  <a href="about:blank#2Redis__1546">2.Redis 持久化</a></li><li><ul><li><ul><li><a href="about:blank#RDBRedis_DataBase_1547">RDB（Redis DataBase）</a><ul><li>  <a href="about:blank#AOFAppend_Only_File_1586">AOF（Append Only File）</a></li><li>  <a href="about:blank#Redis__1652">Redis 持久化总结</a></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#3Redis__1672">3.Redis 发布订阅</a></li><li>  <a href="about:blank#4Redis__1699">4.Redis 主从复制</a></li><li><ul><li><ul><li><a href="about:blank#_1701">概念</a><ul><li>  <a href="about:blank#_1717">配置</a></li><li>  <a href="about:blank#_1749">启动</a></li><li>  <a href="about:blank#_1789">主从链路</a></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#5_1803">5.哨兵模式（重点）</a></li><li><ul><li><ul><li><a href="about:blank#_1804">概念</a><ul><li>  <a href="about:blank#_1811">模型</a></li><li>  <a href="about:blank#_1818">配置</a></li><li>  <a href="about:blank#_1838">测试</a></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#6Redis__1864">6.Redis 缓存穿透、击穿、雪崩（面试重点）</a></li><li><ul><li><a href="about:blank#_1865">缓存穿透</a><ul><li><ul><li><a href="about:blank#_1866">概念</a><ul><li>  <a href="about:blank#_1874">布隆过滤器</a></li><li>  <a href="about:blank#_1879">缓存空对象</a></li></ul></li></ul></li><li>  <a href="about:blank#_1886">缓存击穿</a></li><li><ul><li><a href="about:blank#_1887">概念</a><ul><li>  <a href="about:blank#_1894">设置热点数据永不过期</a></li><li>  <a href="about:blank#_1896">加互斥锁</a></li></ul></li></ul></li><li>  <a href="about:blank#_1899">缓存雪崩</a></li><li><ul><li><a href="about:blank#_1900">概念</a><ul><li>  <a href="about:blank#Redis_1907">Redis高可用</a></li><li>  <a href="about:blank#_1911">限流降级</a></li><li>  <a href="about:blank#_1914">数据预热</a></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h1 id="一-NoSQL-简介"><a href="#一-NoSQL-简介" class="headerlink" title="一.NoSQL 简介"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>一.NoSQL 简介</h1><h2 id="1-数据库演化"><a href="#1-数据库演化" class="headerlink" title="1.数据库演化"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>1.数据库演化</h2><p>早期网站访问量不大，单个数据够用，多数为静态网页，服务器没有太大压力，网站瓶颈主要在</p><ul><li>  数据量过大，一台机器放不下</li><li>  数据索引（B+Tree）内存也放不下</li><li>  访问量读写混合，一个服务器承受不了</li></ul><p>为了解决以上问题，开始使用 Memcached（缓存）+MySQL+垂直拆分（读写分离）</p><ul><li>  开始没有MyCat中间件，为了确保多个数据库服务器数据同步，所以数据库采用了读写分离的方式</li><li>  网站的主要消耗在读操作，所以经常使用的数据使用缓存来保证查询效率</li></ul><p>进一步优化结构，采用 分库分表+水平拆分+MySQL集群</p><ul><li>  核心问题在解决数据库的 读、写</li></ul><p>数据量进一步增长，需要保存较大的文件，如博客、图片等，MySQL开始力不从心，效率低下，到了近期技术需要进一步提升，由转恩的数据库来处理。比如，一个几亿条数据的表，需要加一个列，很难想象。</p><h2 id="2-为什么使用NoSQL"><a href="#2-为什么使用NoSQL" class="headerlink" title="2.为什么使用NoSQL"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>2.为什么使用NoSQL</h2><p>用户个人信息、社交网络、地理位置、用户自己产生的数据、用户日志等数据量巨大，这些类型数据存储不需要固定的格式，也就是行列，不需要操作就可以横向扩展，</p><p>需要新型的专门数据库出里，随之出现了NoSQL</p><p>NoSQL=Not Only SQL</p><h2 id="3-NoSQL特点"><a href="#3-NoSQL特点" class="headerlink" title="3.NoSQL特点"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>3.NoSQL特点</h2><ul><li>  方便扩展，数据之间没有关系，方便扩展</li><li>  大数据量高性能，读写速度快，是细粒度缓存</li><li>  数据类型多样，不需要事先设计数据库，随取随用，数据量庞大的表很不好设计</li></ul><p>传统的关系型数据库RDBMS</p><ul><li>  结构化组织</li><li>  语言SQL</li><li>  数据和关系都存在单独的表中</li><li>  操作，数据定义语言</li><li>  严格的一致性</li><li>  基础的事务</li></ul><p>NoSQL</p><ul><li>  存储不仅仅是数据</li><li>  没有固定的查询语言</li><li>  键值对存储，列存储，文档存储，图形数据库（社交关系）</li><li>  最终一致性（最终一致即可）</li><li>  CAP定理和BASE</li><li>  高性能，高可用，高可扩展</li></ul><h2 id="4-NoSQL分类"><a href="#4-NoSQL分类" class="headerlink" title="4.NoSQL分类"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>4.NoSQL分类</h2><ul><li>  泛指非关系型数据库，为了和关系型数据库做区分，Redis就是一款NoSQL</li><li>主流分为四大类：<br>  1.Key-Value型：Redis Tair memecache<br>  2.文档型：ElasticSearch Solr MongoDB（非关系型数据库中最像关系型数据库的）<br>  3.面向列：Hbase Cassandra<br>  4.图形化：Neo4j，不是存图片，而是存关系图形化的</li></ul><p>简单的理解：关系型数据库以外的都是非关系型数据库，因为它不采用表结构</p><h2 id="5-电商的数据存储"><a href="#5-电商的数据存储" class="headerlink" title="5.电商的数据存储"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>5.电商的数据存储</h2><h4 id="商品的基本信息"><a href="#商品的基本信息" class="headerlink" title="商品的基本信息"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>商品的基本信息</h4><p>名称、价格、商家等信息，<br>采用关系型数据库，MySQL、Oracle</p><h4 id="商品的描述、评论（文字较多）"><a href="#商品的描述、评论（文字较多）" class="headerlink" title="商品的描述、评论（文字较多）"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>商品的描述、评论（文字较多）</h4><p>文档型数据库，如MongoDB</p><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>图片</h4><p>分布式文件系统，FastDFS</p><p>淘宝自研技术，TFS</p><p>Google：GFS</p><p>Hadoop：HDFS</p><p>阿里云：OSS</p><h4 id="商品关键字（搜索）"><a href="#商品关键字（搜索）" class="headerlink" title="商品关键字（搜索）"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>商品关键字（搜索）</h4><p>早期搜索引擎：solr elasticsearch</p><p>淘宝使用：ISearch</p><h4 id="商品热门信息"><a href="#商品热门信息" class="headerlink" title="商品热门信息"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>商品热门信息</h4><p>内存数据库：Redis，Tair，Memache</p><h4 id="商品的交易，外部支付接口"><a href="#商品的交易，外部支付接口" class="headerlink" title="商品的交易，外部支付接口"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>商品的交易，外部支付接口</h4><p>第三方应用如银行</p><h1 id="二、Redis-简介"><a href="#二、Redis-简介" class="headerlink" title="二、Redis 简介"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>二、Redis 简介</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>1.简介</h2><ul><li>  Redis全称Remote Dictionary Server，即远程字典服务，由C语言编写，所以不需要安装Java环境，是一款基于K-V的NoSQL，使用起来就像map一样，免费，开源，也叫结构化数据库</li><li>  一个意大利人需要开发一款LLOOGG统计页面，因为MySQL性能不好，所以自己研发一款非关系型数据库，并命名为Redis</li><li>  基于内存存储数据，读写速度快，性能达到110000次/s读数据，81000次/s写数据，但是内存存储不持久，所以Redis提供了持久化机制</li><li>  Redis还提供了主从、哨兵以及集群的搭建方式，可以更方便的横向扩展以及垂直扩展</li><li>  新浪有全世界最大的Redis集群，数据量大的服务器基本都需要Redis，他是后台开发人员的必备技能之一</li></ul><p><img src="https://img-blog.csdnimg.cn/20210224221406169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-为什么需要Redis"><a href="#2-为什么需要Redis" class="headerlink" title="2.为什么需要Redis"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>2.为什么需要Redis</h2><ul><li>  由于用户量增大，请求数量增大，数据压力过大，服务器集群能承受住，数据库无法承受</li><li>  多台服务器之间存在数据不同步，比如，上次登录的服务器有session，这次登录的服务器没有session</li><li>  多台服务器之间的锁已经不具备互斥性，各论各的</li></ul><p><img src="https://img-blog.csdnimg.cn/20210224222336861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-Redis帮我们解决什么"><a href="#3-Redis帮我们解决什么" class="headerlink" title="3.Redis帮我们解决什么"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>3.Redis帮我们解决什么</h2><ul><li>  针对热点数据添加缓存，存到Redis中，Redis基于内存存储、读取数据，读写效率非常高</li><li>  将之前存储在session中的共享数据统一存放Redis中</li><li>  Redis基于接收用户请求的是单线程的</li><li>  可以实现持久化</li><li>  可以发布订阅，实现消息队列功能</li><li>  可以地图信息分析</li><li>  支持计时器、计数器，比如支持浏览量</li><li>  提供多种语言API</li></ul><p>特性：多样的数据类型、持久化、集群、事务</p><h2 id="4-学习途径"><a href="#4-学习途径" class="headerlink" title="4.学习途径"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>4.学习途径</h2><p>官网：<a href="https://redis.io/">https://redis.io/</a></p><p>中文网：<a href="http://www.redis.cn/">http://www.redis.cn/</a>、</p><p>论坛</p><h2 id="5-下载"><a href="#5-下载" class="headerlink" title="5.下载"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>5.下载</h2><p>windows版本在Github上下载，很久没有更新，Redis官方推荐使用Linux版本</p><h1 id="三、Redis-安装"><a href="#三、Redis-安装" class="headerlink" title="三、Redis 安装"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>三、Redis 安装</h1><h2 id="1-windows环境"><a href="#1-windows环境" class="headerlink" title="1.windows环境"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>1.windows环境</h2><p>github下载，放在指定的目录下，直接解压文件，Redis很小，只有几兆</p><p><img src="https://img-blog.csdnimg.cn/20210225021457461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>  redis-server.exe：启动服务端</li><li>  redis-cli.exe：启动客户端</li><li>  redis-check-aof.pdb：检查持久化文件是否正确</li><li>  redis-benchmark.exe：测试性能</li></ul><h4 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>启动服务端</h4><p>双击redis-server，启动服务端，Redis默认端口号6379，</p><p>如果启动服务端发现闪退，可能是重复启动导致的，进入任务管理器关闭旧的即可<br><img src="https://img-blog.csdnimg.cn/20210225021828299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>启动客户端</h4><p>双击redis-cli，默认连接6379端口，使用ping测试是否连接正常</p><p><img src="https://img-blog.csdnimg.cn/20210225022256890.png" alt="在这里插入图片描述"><br>测试存储，设置一个k-v，并获取值，如，</p><p><code>set name jack</code> <code>get name</code><br><img src="https://img-blog.csdnimg.cn/20210225022505432.png" alt="在这里插入图片描述"></p><p>window下使用很简单，但是Redis推荐我们使用Linux环境使用！官方已经不维护了，只是微软在维护而已<br><img src="https://img-blog.csdnimg.cn/20210225023024858.png" alt="在这里插入图片描述"><br>windows环境下也可以使用RedisDesktopManager来作为客户端界面，<br><img src="https://img-blog.csdnimg.cn/20210225023751945.png" alt="在这里插入图片描述"></p><h2 id="2-Linux安装"><a href="#2-Linux安装" class="headerlink" title="2.Linux安装"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>2.Linux安装</h2><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>下载</h4><p>官网下载：<a href="https://redis.io/download">https://redis.io/download</a></p><p><img src="https://img-blog.csdnimg.cn/20210225020646116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用VMware启动Linux，MobaXterm连接Linux<br><img src="https://img-blog.csdnimg.cn/20210227194417362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>将Redis压缩包上传到Linux中，进入到上传目录，<br><img src="https://img-blog.csdnimg.cn/20210227201454642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解压Redis压缩包，将程序移动到opt目录下（推荐放在此处），</p><pre><code>tar -zxvf redis-6.2.0.tar.gzmv redis-6.2.0 /opt</code></pre><p><img src="https://img-blog.csdnimg.cn/20210227202246352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>环境</h4><p>Redis运行需要C++环境，安装C++，查看C++版本状态</p><pre><code>yum install gcc-c++gcc-v</code></pre><p><img src="https://img-blog.csdnimg.cn/20210227202800303.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210227202959592.png" alt="在这里插入图片描述"></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>安装</h4><p>进入Redis解压缩的目录，执行<code>make</code>命令，开始安装Redis（需要一段时间），<code>make insall</code>确认一下</p><pre><code>cd redis-6.2.0/makemake install</code></pre><p><img src="https://img-blog.csdnimg.cn/20210227203941294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>Redis默认安装目录在/usr/local/bin中，这里的目录就相当于windows中解压缩后进入的目录<br><img src="https://img-blog.csdnimg.cn/20210227204408472.png" alt="在这里插入图片描述"></p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>配置文件</h4><p>在当前目录下新建一个配置文件目录，将Redis解压文件中的redis.con配置文件复制到其中</p><p>以后使用这个复制的配置文件启动Redis</p><pre><code>mkdir rconfigcp /opt/redis-6.2.0/redis.conf rconfig/</code></pre><p><img src="https://img-blog.csdnimg.cn/20210227205540270.png" alt="在这里插入图片描述"></p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>启动</h4><p>Redis默认不是后台启动，将其修改为后台启动，编辑配置文件，</p><p>vim命令不好使的，需要在线安装vim，自行百度搜方法</p><pre><code>vim redis.conf</code></pre><p>i开始插入编辑，这里修改为yes表示可以后台启动，esc退出编辑，:wq退出配置文件<br><img src="https://img-blog.csdnimg.cn/20210227210644962.png" alt="在这里插入图片描述"><br>回到bin目录，通过配置文件启动Redis服务端</p><pre><code>redis-server rconfig/redis.conf</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228005744640.png" alt="在这里插入图片描述"><br>启动客户端，连接服务</p><pre><code>redis-cli -p 6379</code></pre><p><img src="https://img-blog.csdnimg.cn/2021022800583916.png" alt="在这里插入图片描述"><br>测试连接，测试存储<br><img src="https://img-blog.csdnimg.cn/2021022801001890.png" alt="在这里插入图片描述"><br>查看Redis进程命令</p><pre><code>ps -ef|grep redis</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228010402722.png" alt="在这里插入图片描述"></p><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>关闭</h4><p>在客户端连接中，使用命令shutdown关闭服务端，退出客户端即可</p><pre><code>shutdownexit</code></pre><p><img src="https://img-blog.csdnimg.cn/2021022801084370.png" alt="在这里插入图片描述"></p><h2 id="3-测试性能"><a href="#3-测试性能" class="headerlink" title="3.测试性能"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>3.测试性能</h2><p>bin目录下的redis-benchmark，官方自带<br><img src="https://img-blog.csdnimg.cn/20210228011305997.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210228012055113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>如，测试100个并发，100000个并发请求</p><p>确保客户端连接服务，再开启一个新的连接窗口，进入到bin目录<br><img src="https://img-blog.csdnimg.cn/20210228013227928.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210228013241659.png" alt="在这里插入图片描述"><br>新窗口bin目录中执行测试命令</p><pre><code>redis-benchmark -h localhost -p 6379 -c 100 -n 100000</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228013528355.png" alt="在这里插入图片描述"></p><h4 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>分析结果</h4><p><img src="https://img-blog.csdnimg.cn/20210228013802942.png" alt="在这里插入图片描述"><br>写入测试，100000个请求，0.84秒完成，100个并发，每次写入3字节，保持1个连接<br><img src="https://img-blog.csdnimg.cn/20210228014606488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">完成多少百分比的请求量所消耗的时间<br><img src="https://img-blog.csdnimg.cn/20210228014653463.png" alt="在这里插入图片描述"><br>计算结果，每秒处理119189.52个请求</p><h1 id="四、Redis-基础知识"><a href="#四、Redis-基础知识" class="headerlink" title="四、Redis 基础知识"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>四、Redis 基础知识</h1><p>Redis默认16个数据库，默认使用的是第一个数据库，select *指令可以切换，配置文件中可以查看到，<br><img src="https://img-blog.csdnimg.cn/20210228105429182.png" alt="在这里插入图片描述"></p><h4 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>基础指令</h4><p>以下指令在客户端连接状态下使用</p><pre><code>#切换数据库select num(0-15)#查看数据库大小dbsize#查看数据库所有的keykeys *#清空当前数据库flushdb#清除所有数据库flushall</code></pre><h4 id="Redis单线程"><a href="#Redis单线程" class="headerlink" title="Redis单线程"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>Redis单线程</h4><p>Redis速度很快，基于内存操作，性能瓶颈不在CPU，而是内存和网络带宽，我们使用Redis用单线程即可</p><p>多线程的CPU上下文切换比较耗时，所有对于Redis来说，单线程效率最高</p><h2 id="1-五大数据类型"><a href="#1-五大数据类型" class="headerlink" title="1.五大数据类型"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>1.五大数据类型</h2><p><img src="https://img-blog.csdnimg.cn/20210228111913810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>提示：五大基本数据类型的操作使用需要熟练掌握，因为Java操作Redis的API都是基于Redis原生操作来定义的</p><h4 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>Redis-Key</h4><p>key泛指键，value泛指值，以实际为准</p><p>查看所有key</p><pre><code>keys *</code></pre><p>判断某一个key是否存在</p><pre><code>exist key</code></pre><p>将数据移动到指定的数据库中</p><pre><code>move key num(数据库编号)</code></pre><p>设置某一条数据的过期时间,t的单位是秒</p><pre><code>expire key t</code></pre><p>查看某条数据的剩余生命时长，-2表示没了</p><pre><code>ttl key</code></pre><p>查看key的类型</p><pre><code>type key</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228113706853.png" alt="在这里插入图片描述"></p><h4 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>String(字符串)</h4><p>赋值、取值、追加、长度</p><pre><code>set key valueget key#向key对应的值后面追加value，如果当前key不存在，则相当于set key valueappend key value#查看key对应的值的长度strlen key</code></pre><p><img src="https://img-blog.csdnimg.cn/2021022812271536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>自增减、步长</p><pre><code>#给key的值+1，常用于计数，如网页浏览量incr key#将key的值-1decr key#增减时设置增减步长incrby key numdecrby key num</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228123303531.png" alt="在这里插入图片描述"><br>截取</p><pre><code>#截取字符串，从num1-num2，0到-1表示查看全部字符串getrange key num1 num2</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228123829808.png" alt="在这里插入图片描述"><br>替换</p><pre><code>#替换字符串，从offset处开始setrange key offset value</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228125513484.png" alt="在这里插入图片描述"><br>判断，分布式锁中经常使用</p><pre><code>#如果key存在，则设置过期时间和key的值setex key seconds value#如果key不存在，则创建新的key和value，如果这个key存在，那么也不会设置成功，值也不会覆盖</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228130538126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>批量处理，原子性</p><pre><code>#批量设置键值对k1-v1,k2-v2,k3-v3mset k1 v1 k2 2 k3 v3#批量获取值mget k1 k2 k3#批量设置，如果不存在，则设置k-v，只要其中有一个是存在的，则整体设置不成功，体现出原子性msetnx k1 v1 k2 v2 k3 v3</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228131739908.png" alt="在这里插入图片描述"><br>利用Redis批量设置，可以这样保存json格式的对象</p><p><code>对象名:对象id:属性名</code> 作为Redis的key，<code>属性值</code> 作为Redis的value<br><img src="https://img-blog.csdnimg.cn/20210228133435181.png" alt="在这里插入图片描述"><br>先get再set，不存在则返回nil并设置新的值，如果存在则返回旧的值并设置新的值</p><pre><code>#先get再set，返回的是get的值，值会被覆盖getset key value</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228134048991.png" alt="在这里插入图片描述"></p><ul><li>  总结：Redis String类型可以用作计数器、统计多单位数量、浏览量、对象缓存等</li></ul><h4 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>List（列表）</h4><p>基本数据类型，列表</p><p>Redis中，可以将list当做栈、队列、阻塞队列来使用，所有的list命令都用l开头</p><p>很多命令都是左右对称可以使用的，我们主要以左侧举例，右侧镜像可以自行测试</p><p>从头部（左侧）操作，赋值、取值，先进后出</p><pre><code>#向key列表赋值,按照入栈顺序listpush key element#从key列表取值,按照出栈顺序,0到-1表示所有lrange key start stop</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228155559422.png" alt="在这里插入图片描述"><br>从尾部（右侧）操作</p><pre><code>lrange list start stop</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228160212850.png" alt="在这里插入图片描述"><br>当做数组使用，使用下标</p><pre><code>#从数组key中取值，下标为indexlindex key index</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228165927868.png" alt="在这里插入图片描述"><br>获取队列长度，</p><p><img src="https://img-blog.csdnimg.cn/20210228170317329.png" alt="在这里插入图片描述"><br>同一个队列中可以有重复的值</p><p>移除队列中指定的值，如果这个值在队列中只有一个，移除个数就是1，如果有多个，可以指定移除多个这样的值</p><pre><code>#移除队列中的值，可以指定移除个数lrem list count element</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228171011510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>截取指定区间的元素，通过下标，永久性修改了队列</p><pre><code>ltrim list start stop</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228171515114.png" alt="在这里插入图片描述"><br>组合命令，可以实现上述功能组合后的效果</p><p>移除列表最后一个元素，或者说从右侧弹出一个元素，放到新的队列中，返回值就是弹出的那个元素</p><pre><code>#移除最后（右侧）的元素，放在新的队列中，左侧入栈rpoplpush source destination</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228172816696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>判断队列是否存在，如果存在则，如果不存在则</p><pre><code>#判断是否存在队列exists key#如果队列存在，则将指定索引出的值进行更新，如果队列不存在，则没有效果，如果队列存在索引不存在，也报错lset list index element</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228173640861.png" alt="在这里插入图片描述"><br>在指定的元素（值，不是索引）处插入一个值，指定在前面插入，或在后面插入</p><pre><code>linsert key before|after pivot element</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228175002623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>总结：</p><ul><li>  list实际上是一个链表，before node after，left，right 都可以插入值</li><li>  如果key不存在，则创建新链表</li><li>  如果key存在，则新增内容</li><li>  如果移除所有值，成为空链表，代表不存在，</li><li>  对于链表而言，在两端的值操作值效率最高，对中间的值操作效率略低</li><li>  消息排队，lpush rpop 表示左进右出，相当于消息队列，lpush lpop 表示左进左出，相当于栈</li></ul><h4 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>Set（集合）</h4><p>因为无序，所以存储的值不可重复，命令以s开头</p><p>添加集合元素，查看集合元素，判断某个元素是否存在</p><pre><code>#向名为key的集合添加元素membersadd key member#显示集合key中所有元素smembers key#判断集合key中是否存在元素membersismember key member</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228231620407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>获取集合中元素个数</p><pre><code>#获取集合key中元素的个数scard key</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228231842939.png" alt="在这里插入图片描述"><br>移除集合中的指定元素</p><pre><code>#移除集合key中的指定元素membersrem key member</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228232107163.png" alt="在这里插入图片描述"><br>随机取出指定个数的元素</p><pre><code>#随机从集合key中抽选指定个数的元素，没有指定个数就是默认1srandmember key [count]</code></pre><p><img src="https://img-blog.csdnimg.cn/20210228232444495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>删除元素</p><pre><code>#随机移除指定个数的元素，没有指定个数就是默认1spop key [count]</code></pre><p><img src="https://img-blog.csdnimg.cn/2021030100094893.png" alt="在这里插入图片描述"><br>将集合中元素移动到另一个集合中</p><pre><code>#将集合key中的元素member移动到新的集合destination中smove key destination member</code></pre><p><img src="https://img-blog.csdnimg.cn/20210301001459698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>两个集合之间的运算，应用在比如，共同通讯好友，共同关注上</p><pre><code>#集合key1中减去集合key2与集合key1的交集，得到的剩余部分，如果key2没有指定得到的还是完整的key1sdiff key1 [key2]#集合key1与集合key2做交集，如果key2没有指定，则得到完整的key1sinter key1 [key2]#集合key1与集合key2做并集，如果key2没有指定，则得到完整的key1sunion key1 [key2]</code></pre><p><img src="https://img-blog.csdnimg.cn/20210301003547678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="Hash（HashMap集合、散列表、链表数组）"><a href="#Hash（HashMap集合、散列表、链表数组）" class="headerlink" title="Hash（HashMap集合、散列表、链表数组）"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>Hash（HashMap集合、散列表、链表数组）</h4><p>与String类型类似，只不过每个元素变成了一个键值对</p><p>Hash类型的命令以h开头</p><p>赋值、取值、键不可重复，如果键相同则新值覆盖旧值</p><pre><code>#向集合key中存入键值对，键为field，值为valuehset key field value#向集合key中存入多个键值对，field1-value1，field2-value2...hmset key field1 value1 field2 value2#根据键获取集合key中的多个值hmget key field1 field2#获取集合Key中的所有的键值对hgetall key</code></pre><p><img src="https://img-blog.csdnimg.cn/20210301013802722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>删除</p><pre><code>#根据键field删除集合key中的指定键值对hdel key field</code></pre><p><img src="https://img-blog.csdnimg.cn/20210301014452182.png" alt="在这里插入图片描述"><br>长度</p><pre><code>#查看集合key的长度，元素个数hlen key</code></pre><p><img src="https://img-blog.csdnimg.cn/20210301014730540.png" alt="在这里插入图片描述"><br>判断</p><pre><code>#根据键field判断集合key中是否存在该键值对hexists key field</code></pre><p><img src="https://img-blog.csdnimg.cn/20210301015007760.png" alt="在这里插入图片描述"><br>只获取键，只获取值</p><pre><code>#只获取集合Key中的键hkeys key#只获取集合key中的值hvals key</code></pre><p><img src="https://img-blog.csdnimg.cn/20210301015140756.png" alt="在这里插入图片描述"><br>自增长</p><pre><code>#设置集合key中的键值对中的值增长，并指定步长incrementhincrby key field increment</code></pre><p><img src="https://img-blog.csdnimg.cn/20210301015703336.png" alt="在这里插入图片描述"><br>判断元素如果存在，如果不存在</p><pre><code>#判断指定的键是否存在，如果不存在，则指定值，如果存在，则设置不成功hsetnx key field value</code></pre><p>存储对象，可变更数据，对象信息的保存，前面String类型也可以存对象，但是推荐使用Hash类型存储对象</p><p>如，将<code>对象名:对象id</code>作为集合，<code>属性名</code>作为键，<code>属性值</code>作为值，可以同时给集合添加多个属性名、属性值</p><p><code>对象名:id</code> 只是一种规范，自己也可设置其他规范</p><p><img src="https://img-blog.csdnimg.cn/20210301021004601.png" alt="在这里插入图片描述"></p><h4 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>Zset（有序集合）</h4><p>还是集合，在Set类型基础上，增加一个值score，值可以用来实现排序，命令以z开头</p><p>赋值、</p><pre><code>#集合key添加元素member，元素的值为scorezadd key score member#添加多个元素zadd key score1 member1 score2 member2#获取范围内的值，0到-1为全部的值，这里的范围编号和score不同，注意区分zrange key start stop#降序zrevrange key start stop</code></pre><p><img src="https://img-blog.csdnimg.cn/20210301124718100.png" alt="在这里插入图片描述"><br>排序</p><pre><code>#根据score的大小，展示范围内的元素，-inf +inf 表示正无穷、负无穷，这个范围代表集合中的所有元素#m默认升序，withscores表示结果中包含scores值zrangebyscore key min max [witscores] [limit offset count]</code></pre><p><img src="https://img-blog.csdnimg.cn/2021030123414820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>移除，</p><pre><code>#移除集合key中的元素memberzrem key member</code></pre><p><img src="https://img-blog.csdnimg.cn/20210301234752678.png" alt="在这里插入图片描述"></p><p>统计</p><pre><code>#统计集合key总的元素个数zcard key#根据score的区间范围，统计元素个数，范围含头含尾zcount key min max</code></pre><p><img src="https://img-blog.csdnimg.cn/20210302000007626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用场景：需要set排序，如成绩表，薪资表，需要使用权重判断，排行榜等</p><h2 id="2-三种特殊数据类型"><a href="#2-三种特殊数据类型" class="headerlink" title="2.三种特殊数据类型"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>2.三种特殊数据类型</h2><h4 id="geospatial"><a href="#geospatial" class="headerlink" title="geospatial"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>geospatial</h4><p>定位、附近人、地理位置推算距离，</p><p><a href="http://www.redis.cn/commands/geoadd.html">http://www.redis.cn/commands/geoadd.html</a></p><p>添加地理位置，南北极无法直接添加，通常会下载城市数据直接导入</p><p>地理数据与实际地图吻合不可乱写，否则会计算错误</p><ul><li>  有效的经度从-180度到180度。</li><li>  有效的纬度从-85.05112878度到85.05112878度。</li><li>  当坐标位置超出上述指定范围时，该命令将会返回一个错误。</li></ul><pre><code>#向集合key中添加元素member的经度longitude、纬度latitude，可以一次添加多个位置geoadd key longitude latitude member#获取地理位置geopos key member</code></pre><p><img src="https://img-blog.csdnimg.cn/20210302205357684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>定位之间距离</p><ul><li>  m 表示单位为米。</li><li>  km 表示单位为千米。</li><li>  mi 表示单位为英里。</li><li>  ft 表示单位为英尺</li></ul><pre><code>#返回两个位置之间的距离geodist key member1 member2 [m|km|mi|ft]</code></pre><p><img src="https://img-blog.csdnimg.cn/20210302210009587.png" alt="在这里插入图片描述"><br>获取半径内的元素</p><pre><code>#以给定经纬度longitude latitude为中心，找出半径radius内的元素，#可以选择是否返回元素到中心的距离、经纬度、限制查询的个数georadius key longitude latitude radius [m|km|mi|ft] [withdist] [withcoord] [count count]</code></pre><p><img src="https://img-blog.csdnimg.cn/20210302210544374.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210302211205350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>根据已有的元素，筛选范围内其他元素</p><pre><code>#给定一个元素，查找半径内的其他元素#可以选择是否返回查找的元素到中心的距离、经纬度、限制查询的个数georadiusbymember key member radius [m|km|mi|ft] [withdist] [withcoord] [count count]</code></pre><p><img src="https://img-blog.csdnimg.cn/20210302211930785.png" alt="在这里插入图片描述"><br>返回元素的Hash，该命令将返回11个字符的Geohash字符串，不常用</p><pre><code>geohash key member1 member2</code></pre><p><img src="https://img-blog.csdnimg.cn/20210302212339269.png" alt="在这里插入图片描述"><br>geo底层实现原理还是zset，所以可也以使用zset命令来操作地理位置，如查看全部元素、移除元素<br><img src="https://img-blog.csdnimg.cn/20210302212637269.png" alt="在这里插入图片描述"></p><h4 id="Hyperloglogs"><a href="#Hyperloglogs" class="headerlink" title="Hyperloglogs"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>Hyperloglogs</h4><p>基数：指一个集合中不重复的元素的个数</p><p>Redis HyperLogLog 是用来做基数统计的算法</p><p>用途：同一个人访问多次，可以算作一个访问人。</p><p>传统的方式使用set集合，统计id，如果用户数据量很大就会比较麻烦，消耗资源，</p><p>而Redis HyperLogLog 底层数据结构就是去重统计基数，占用内存非常小，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数，但是有0.81%的错误率，统计UV时可以忽略不计</p><p>新增，统计</p><pre><code>#添加元素pfadd key member [member]#统计集合元素个数pfcount key#统计多个集合总的元素个数，也会自动去重pfcount key [key]</code></pre><p>合并，去重</p><pre><code>#合并多个集合，自动去重复元素,合并之后的集合替换掉destkey,sourcekey不变pfmerge destkey sourcekey [sourcekey]</code></pre><p><img src="https://img-blog.csdnimg.cn/20210303001343713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>Bitmaps</h4><p>在开发中，可能会遇到这种情况：需要统计用户的某些信息，如活跃或不活跃，登录或者不登录；又如需要记录用户一年的打卡情况，打卡了是1， 没有打卡是0，如果使用普通的 key/value存储，则要记录365条记录，如果用户量很大，需要的空间也会很大，所以 Redis　提供了 Bitmap 位图这中数据结构，Bitmap 就是通过操作二进制位来进行记录，即为 0 和 1；如果要记录 365 天的打卡情况，使用 Bitmap 表示的形式大概如下：0101000111000111…，这样有什么好处呢？当然就是节约内存了，365 天相当于 365 bit，又 1 字节 = 8 bit , 所以相当于使用 46 个字节即可</p><p>通俗理解：</p><ul><li>  当我们使用标记存储两种状态时，如果用一个变量存一个标记太浪费资源，现在将所有标记统一放在一条二进制数据上，每一位都用0或1对应一个标记，大大节约空间</li></ul><p>bitmap位图这种数据结构，使用二进制操作数据，</p><p>新增、查看、统计</p><pre><code>#向key中存入数据，offet相当于下标，记录位置，从0开始，value只能是0和1，对应我们所需的状态setbit key offet value#查看指定位置的状态getbit key offet#统计二进制数据上1的个数，可以加范围,start 和 end 参数的设置和 GETRANGE 命令类似,都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，以此类推bitcount key [start end]</code></pre><p><img src="https://img-blog.csdnimg.cn/2021030301071769.png" alt="在这里插入图片描述"></p><h2 id="3-Redis-事务"><a href="#3-Redis-事务" class="headerlink" title="3.Redis 事务"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>3.Redis 事务</h2><p>事物的本质是一组命令一块执行，事务执行是，里面的命令按照顺序执行，一次性，顺序性，排他性</p><p>Redis事务没有隔离级别的概念，因为所有命令在事务中没有直接执行，只有发起命令的时候才会执行exec</p><p>Redis单条命令保证原子性，但Redis整个事务不保证原子性，原因见下面</p><ul><li>  开启事务 <code>multi</code></li><li>  命令入队</li><li>  执行事务 <code>exec</code></li></ul><p><img src="https://img-blog.csdnimg.cn/20210304012443637.png" alt="在这里插入图片描述"></p><ul><li>  放弃事务 <code>discard</code></li></ul><p><img src="https://img-blog.csdnimg.cn/20210304012736780.png" alt="在这里插入图片描述"></p><ul><li>  编译异常</li></ul><p>开启事务后，当出现代码异常，直至提交事务，这段期间的命令都不会执行，</p><p>这种情况在Java中比较少见，因为Java操作Redis基本不会出现代码异常</p><p><img src="https://img-blog.csdnimg.cn/202103040133126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>  运行异常</li></ul><p>开启事务后，执行命令，提交事务，如果运行期间出现问题，除了异常命令，其他命令正常执行</p><p>所以说，Redis单条命名保证原子性，但整个Redis事务无法保证原子性<br><img src="https://img-blog.csdnimg.cn/20210304014936500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>结论：</p><ul><li><p>  Redis单条命令保证原子性，因为Redis是单线程</p></li><li><p>  Redis整个事务不保证原子性，因为开启事务时并没有执行命令，而是提交之后统一执行</p></li><li><p>  这与MySQL截然不同，注意区分</p></li></ul><h2 id="4-Redis实现乐观锁"><a href="#4-Redis实现乐观锁" class="headerlink" title="4.Redis实现乐观锁"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>4.Redis实现乐观锁</h2><p>悲观锁：一开始就认为会出现问题，所以什么时候都加锁</p><p>乐观锁：认为不会出现问题，只有在需要的时候才会判断是否有必要加锁</p><p>Redis使用监视命令 <code>watch</code> ，配合Redis事务一起使用</p><p>正常执行成功时</p><p><img src="https://img-blog.csdnimg.cn/20210304021520768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>模拟多线程问题</p><p>第一个线程，监视数据，开启事务，但没有提交<br><img src="https://img-blog.csdnimg.cn/20210304022124624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开新窗口，新客户端同样连接6379，模拟多线程操作，修改被监视的数据</p><p><img src="https://img-blog.csdnimg.cn/2021030402250357.png" alt="在这里插入图片描述"><br>然后第一个线程提交事务，发现被监视的元素被篡改，返回nil表示当前线程的整个事务提交失败</p><p>数据按照另一个线程修改为准</p><p><img src="https://img-blog.csdnimg.cn/20210304022854646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Redis的这种监视事务的机制，相当于实现了Redis乐观锁</p><p>当监视出现事务执行失败后，先取消监视<code>unwatch key</code> ，再去重新开始监视，开启事务</p><h1 id="五、Java-操作-Redis"><a href="#五、Java-操作-Redis" class="headerlink" title="五、Java 操作 Redis"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>五、Java 操作 Redis</h1><h2 id="1-Jedis-官方原生API"><a href="#1-Jedis-官方原生API" class="headerlink" title="1.Jedis 官方原生API"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>1.Jedis 官方原生API</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>概念</h4><p>Redis官方推荐的Java开发工具，实际中可能不常用，但是与Redis原生API关联非常紧密，一定要熟练掌握</p><h4 id="项目、依赖"><a href="#项目、依赖" class="headerlink" title="项目、依赖"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>项目、依赖</h4><p>在maven项目中导入Jedis依赖，maven镜像搜索坐标，地址：<a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p><p>导入<code>jedis</code> <code>fastjson</code> 依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;redis.clients&lt;/groupId&gt;    &lt;artifactId&gt;jedis&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.70&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="连接、测试"><a href="#连接、测试" class="headerlink" title="连接、测试"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>连接、测试</h4><p>开启redis服务端，默认端口号6379<br><img src="https://img-blog.csdnimg.cn/20210304233102804.png" alt="在这里插入图片描述"><br>创建Jedis对象，添加连接参数，测试连接</p><p>注意：如果是连接Linux中的Redis，先将redis.conf配置文件中的IP绑定注释掉，保护模式关闭，Jedis才能正产连接<br><img src="https://img-blog.csdnimg.cn/2021030500495939.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210305005029527.png" alt="在这里插入图片描述"></p><pre><code>public class demo1 &#123;    public static void main(String[] args) &#123;        //创建对象,连接        Jedis jedis = new Jedis(&quot;192.168.126.130&quot;, 6379);        //连接测试        System.out.println(jedis.ping());    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/20210305005330943.png" alt="在这里插入图片描述"></p><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>常用API</h4><p>Jedis的所有命令都是基于Redis原生命令，在这里命令变成了方法</p><h5 id="Key操作"><a href="#Key操作" class="headerlink" title="Key操作"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>Key操作</h5><pre><code>public class demo2 &#123;    public static void main(String[] args) &#123;        Jedis jedis = new Jedis(&quot;192.168.126.130&quot;, 6379);        System.out.println(&quot;清空当前数据库: &quot;+jedis.flushDB());        System.out.println(&quot;判断: &quot;+jedis.exists(&quot;k1&quot;));        System.out.println(&quot;添加: &quot;+jedis.set(&quot;k1&quot;, &quot;v1&quot;));        System.out.println(&quot;添加: &quot;+jedis.set(&quot;k2&quot;, &quot;v2&quot;));        Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;);        System.out.println(&quot;列出所有key: &quot;+keys);        System.out.println(&quot;删除: &quot;+jedis.del(&quot;k1&quot;));        System.out.println(&quot;判断: &quot;+jedis.exists(&quot;k1&quot;));        System.out.println(&quot;查看键对应的值的类型: &quot;+jedis.type(&quot;k2&quot;));        System.out.println(&quot;随机返回一个key: &quot;+jedis.randomKey());        System.out.println(&quot;重命名key: &quot;+jedis.rename(&quot;k2&quot;, &quot;k3&quot;));        System.out.println(&quot;获取元素: &quot;+jedis.get(&quot;k3&quot;));        System.out.println(&quot;根据索引查询: &quot;+jedis.select(0));        System.out.println(&quot;清空当前数据库: &quot;+jedis.flushDB());        System.out.println(&quot;数据库key数量: &quot;+jedis.dbSize());        System.out.println(&quot;清空所有数据库的key: &quot;+jedis.flushAll());    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/20210305013335673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>String类型</h5><pre><code>public class demo3 &#123;    public static void main(String[] args) &#123;        Jedis jedis = new Jedis(&quot;192.168.126.130&quot;, 6379);        System.out.println(&quot;添加元素&quot;);        System.out.println(jedis.set(&quot;k1&quot;, &quot;v1&quot;));        System.out.println(jedis.set(&quot;k2&quot;, &quot;v2&quot;));        System.out.println(jedis.set(&quot;k3&quot;, &quot;v3&quot;));        System.out.println(&quot;删除: &quot;+jedis.del(&quot;k2&quot;));        System.out.println(&quot;取值: &quot;+jedis.get(&quot;k2&quot;));        System.out.println(&quot;修改值: &quot;+jedis.set(&quot;k1&quot;, &quot;v11&quot;));        System.out.println(&quot;取值: &quot;+jedis.get(&quot;k1&quot;));        System.out.println(&quot;追加值: &quot;+jedis.append(&quot;k3&quot;, &quot;end&quot;));        System.out.println(&quot;取值: &quot;+jedis.get(&quot;k3&quot;));        System.out.println(&quot;添加多个元素: &quot;+jedis.mset(&quot;k4&quot;,&quot;v4&quot;,&quot;k5&quot;,&quot;v5&quot;));        System.out.println(&quot;获取多个值: &quot;+jedis.mget(&quot;k4&quot;,&quot;k5&quot;,&quot;k6&quot;));        System.out.println(&quot;删除多个元素: &quot;+jedis.del(&quot;k4&quot;,&quot;k5&quot;));        System.out.println(&quot;获取多个值: &quot;+jedis.mget(&quot;k3&quot;,&quot;k4&quot;,&quot;k5&quot;));        System.out.println(&quot;清空: &quot;+jedis.flushDB());        System.out.println(&quot;新增键值对,防止被覆盖&quot;);        System.out.println(&quot;第一次赋值: &quot;+jedis.setnx(&quot;k1&quot;, &quot;v1&quot;));        System.out.println(&quot;第一次赋值: &quot;+jedis.setnx(&quot;k2&quot;, &quot;v2&quot;));        System.out.println(&quot;覆盖原值: &quot;+jedis.setnx(&quot;k2&quot;, &quot;v2new&quot;));        System.out.println(&quot;取值: &quot;+jedis.get(&quot;k1&quot;));        System.out.println(&quot;取值: &quot;+jedis.get(&quot;k2&quot;));        System.out.println(&quot;添加元素设置生命周期: &quot;+jedis.setex(&quot;k3&quot;, 2, &quot;v3&quot;));        System.out.println(&quot;取值: &quot;+jedis.get(&quot;k3&quot;));        try &#123;            TimeUnit.SECONDS.sleep(3);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;过期后取值: &quot;+jedis.get(&quot;k3&quot;));        System.out.println(&quot;获取原值,并更新: &quot;+jedis.getSet(&quot;k2&quot;, &quot;v2abc&quot;));        System.out.println(&quot;获取新的值: &quot;+jedis.get(&quot;k2&quot;));        System.out.println(&quot;截取部分字符串: &quot;+jedis.getrange(&quot;k2&quot;, 2, 4));    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/2021030502204145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>List集合</h5><pre><code>public class demo4 &#123;    public static void main(String[] args) &#123;        Jedis jedis = new Jedis(&quot;192.168.126.130&quot;, 6379);        System.out.println(&quot;清空数据: &quot;+jedis.flushDB());        System.out.println(&quot;新增元素&quot;);        System.out.println(jedis.lpush(&quot;list&quot;, &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;));        System.out.println(jedis.lpush(&quot;list&quot;, &quot;d&quot;));        System.out.println(jedis.lpush(&quot;list&quot;, &quot;e&quot;));        System.out.println(jedis.lpush(&quot;list&quot;, &quot;f&quot;));        System.out.println(&quot;查看所有: &quot;+jedis.lrange(&quot;list&quot;, 0, -1));        System.out.println(&quot;查看区间数据: &quot;+jedis.lrange(&quot;list&quot;, 0, 3));        System.out.println(&quot;删除列表中指定的值,第二参数为删除的个数(有重复时),后进先出原则,相当于出栈&quot;);        System.out.println(&quot;删除指定值的元素: &quot;+jedis.lrem(&quot;list&quot;, 2, &quot;d&quot;));        System.out.println(&quot;查看所有: &quot;+jedis.lrange(&quot;list&quot;, 0, -1));        System.out.println(&quot;删除区间以外的元素: &quot;+jedis.ltrim(&quot;list&quot;, 0, 3));        System.out.println(&quot;查看所有: &quot;+jedis.lrange(&quot;list&quot;, 0, -1));        System.out.println(&quot;左侧弹出: &quot;+jedis.lpop(&quot;list&quot;));        System.out.println(&quot;查看所有: &quot;+jedis.lrange(&quot;list&quot;, 0, -1));        System.out.println(&quot;右侧新增: &quot;+jedis.rpush(&quot;list&quot;, &quot;g&quot;));        System.out.println(&quot;查看所有: &quot;+jedis.lrange(&quot;list&quot;, 0, -1));        System.out.println(&quot;右侧弹出: &quot;+jedis.rpop(&quot;list&quot;));        System.out.println(&quot;查看所有: &quot;+jedis.lrange(&quot;list&quot;, 0, -1));        System.out.println(&quot;修改指定下标元素: &quot;+jedis.lset(&quot;list&quot;, 1, &quot;new&quot;));        System.out.println(&quot;查看所有: &quot;+jedis.lrange(&quot;list&quot;, 0, -1));        System.out.println(&quot;队列长度: &quot;+jedis.llen(&quot;list&quot;));        System.out.println(&quot;获取指定下标元素: &quot;+jedis.lindex(&quot;list&quot;, 2));        System.out.println(&quot;新增元素: &quot;+jedis.lpush(&quot;list1&quot;, &quot;4&quot;,&quot;2&quot;,&quot;0&quot;,&quot;6&quot;,&quot;5&quot;,&quot;8&quot;));        System.out.println(&quot;查看所有: &quot;+jedis.lrange(&quot;list1&quot;, 0, -1));        System.out.println(&quot;排序: &quot;+jedis.sort(&quot;list1&quot;));        System.out.println(&quot;查看所有: &quot;+jedis.lrange(&quot;list1&quot;, 0, -1));    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/20210305082531908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>Set集合</h5><pre><code>public class demo5 &#123;    public static void main(String[] args) &#123;        Jedis jedis = new Jedis(&quot;192.168.126.130&quot;,6379);        jedis.flushDB();        System.out.println(&quot;新增元素,不可重复&quot;);        System.out.println(jedis.sadd(&quot;set1&quot;, &quot;s0&quot;,&quot;s1&quot;,&quot;s2&quot;,&quot;s3&quot;,&quot;s4&quot;,&quot;s5&quot;,&quot;s7&quot;,&quot;s8&quot;));        System.out.println(jedis.sadd(&quot;set1&quot;, &quot;s6&quot;));        System.out.println(jedis.sadd(&quot;set1&quot;, &quot;s6&quot;));        System.out.println(&quot;列出所有元素: &quot;+jedis.smembers(&quot;set1&quot;));        System.out.println(&quot;删除一个元素: &quot;+jedis.srem(&quot;set1&quot;, &quot;s0&quot;));        System.out.println(&quot;列出所有元素: &quot;+jedis.smembers(&quot;set1&quot;));        System.out.println(&quot;删除元素: &quot;+jedis.srem(&quot;set1&quot;, &quot;s6&quot;,&quot;s7&quot;));        System.out.println(&quot;随机移除一个元素: &quot;+jedis.spop(&quot;set1&quot;));        System.out.println(&quot;随机移除一个元素: &quot;+jedis.spop(&quot;set1&quot;));        System.out.println(&quot;列出所有元素: &quot;+jedis.smembers(&quot;set1&quot;));        System.out.println(&quot;查看元素个数: &quot;+jedis.scard(&quot;set1&quot;));        System.out.println(&quot;判断是否存在某个元素: &quot;+jedis.sismember(&quot;set1&quot;, &quot;s3&quot;));        System.out.println(&quot;判断某个元素是否存在: &quot;+jedis.sismember(&quot;set1&quot;, &quot;s1&quot;));        System.out.println(jedis.sismember(&quot;set1&quot;, &quot;s5&quot;));        System.out.println(&quot;================&quot;);        System.out.println(&quot;新增: &quot;+jedis.sadd(&quot;set2&quot;, &quot;s0&quot;,&quot;s1&quot;,&quot;s2&quot;,&quot;s4&quot;,&quot;s5&quot;,&quot;s7&quot;,&quot;s8&quot;));        System.out.println(&quot;新增: &quot;+jedis.sadd(&quot;set3&quot;, &quot;s0&quot;,&quot;s1&quot;,&quot;s2&quot;,&quot;s4&quot;,&quot;s8&quot;));        System.out.println(&quot;set2中删除,并存到另一集合上 : &quot;+jedis.smove(&quot;set2&quot;, &quot;set3&quot;, &quot;s1&quot;));        System.out.println(&quot;set2中删除,并存到另一集合上 : &quot;+jedis.smove(&quot;set2&quot;, &quot;set3&quot;, &quot;s1&quot;));        System.out.println(&quot;删除元素并放在新集合中 :&quot;+jedis.smove(&quot;set2&quot;, &quot;set3&quot;, &quot;s2&quot;));        System.out.println(&quot;列出所有元素: &quot;+jedis.smembers(&quot;set2&quot;));        System.out.println(&quot;列出所有元素: &quot;+jedis.smembers(&quot;set3&quot;));        System.out.println(&quot;交集: &quot;+jedis.sinter(&quot;set2&quot;,&quot;set3&quot;));        System.out.println(&quot;并集: &quot;+jedis.sunion(&quot;set2&quot;,&quot;set3&quot;));        System.out.println(&quot;差集: &quot;+jedis.sdiff(&quot;set2&quot;,&quot;set3&quot;));        System.out.println(&quot;交集保存到集合中: &quot;+jedis.sinterstore(&quot;set4&quot;, &quot;set2&quot;,&quot;set3&quot;));        System.out.println(&quot;列出所有元素: &quot;+jedis.smembers(&quot;set4&quot;));    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/20210306025020740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>Hash</h4><pre><code>public class demo6 &#123;    public static void main(String[] args) &#123;        Jedis jedis = new Jedis(&quot;192.168.126.130&quot;,6379);        System.out.println(&quot;清空当前数据库&quot;);        jedis.flushDB();        Map&lt;String,String&gt; map = new HashMap();        map.put(&quot;k1&quot;, &quot;v1&quot;);        map.put(&quot;k2&quot;, &quot;v2&quot;);        map.put(&quot;k3&quot;, &quot;v3&quot;);        map.put(&quot;k4&quot;, &quot;v4&quot;);        System.out.println(&quot;添加map集合&quot;);        jedis.hmset(&quot;hash&quot;, map);        System.out.println(&quot;添加元素: &quot;+jedis.hset(&quot;hash&quot;, &quot;k5&quot;,&quot;v5&quot;));        System.out.println(&quot;所有键值对: &quot;+jedis.hgetAll(&quot;hash&quot;));        System.out.println(&quot;所有键: &quot;+jedis.hkeys(&quot;hash&quot;));        System.out.println(&quot;所有值: &quot;+jedis.hvals(&quot;hash&quot;));        System.out.println(&quot;给一个键保存整数,如果该键不存在则添加: &quot;+jedis.hincrBy(&quot;hash&quot;, &quot;k6&quot;, 6));        System.out.println(&quot;所有键值对: &quot;+jedis.hgetAll(&quot;hash&quot;));        System.out.println(&quot;添加或修改: &quot;+jedis.hincrBy(&quot;hash&quot;, &quot;k6&quot;, 60));        System.out.println(&quot;所有键值对: &quot;+jedis.hgetAll(&quot;hash&quot;));        System.out.println(&quot;删除一个或多个元素: &quot;+jedis.hdel(&quot;hash&quot;, &quot;k2&quot;));        System.out.println(&quot;所有元素: &quot;+jedis.hgetAll(&quot;hash&quot;));        System.out.println(&quot;元素个数: &quot;+jedis.hlen(&quot;hash&quot;));        System.out.println(&quot;判断元素是否存在: &quot;+jedis.hexists(&quot;hash&quot;, &quot;k2&quot;));        System.out.println(&quot;判断元素是否存在: &quot;+jedis.hexists(&quot;hash&quot;, &quot;k3&quot;));        System.out.println(&quot;根据键获取值: &quot;+jedis.hmget(&quot;hash&quot;, &quot;k3&quot;));        System.out.println(&quot;根据键获取值: &quot;+jedis.hmget(&quot;hash&quot;, &quot;k3&quot;,&quot;k4&quot;));    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/20210306112928417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="Jedis-事务"><a href="#Jedis-事务" class="headerlink" title="Jedis 事务"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>Jedis 事务</h4><p>使用 multi 方法</p><pre><code>public class demo7 &#123;    public static void main(String[] args) &#123;        Jedis jedis = new Jedis(&quot;192.168.126.130&quot;,6379);        JSONObject jsonObject = new JSONObject();        jsonObject.put(&quot;hello&quot;, &quot;world&quot;);        jsonObject.put(&quot;hi&quot;, &quot;Java&quot;);        jedis.flushDB();        System.out.println(&quot;开启事务&quot;);        Transaction multi = jedis.multi();        String result = jsonObject.toJSONString();        try &#123;            multi.set(&quot;k1&quot;, result);            multi.set(&quot;k2&quot;, result);            // 模拟异常            // int i = 1/0;            multi.exec();//提交事务        &#125; catch (Exception e) &#123;            multi.discard();//回滚事务            e.printStackTrace();        &#125; finally &#123;            System.out.println(jedis.get(&quot;k1&quot;));            System.out.println(jedis.get(&quot;k2&quot;));            jedis.close();//关闭连接        &#125;    &#125;&#125;</code></pre><p>成功<br><img src="https://img-blog.csdnimg.cn/20210306123716792.png" alt="在这里插入图片描述"></p><p>失败<br><img src="https://img-blog.csdnimg.cn/2021030612365489.png" alt="在这里插入图片描述"><br>如果使用watch方法，可以监控，在try catch中进行判断监控结果，根据情况抛异常</p><h2 id="2-SpringBoot-整合-Redis"><a href="#2-SpringBoot-整合-Redis" class="headerlink" title="2.SpringBoot 整合 Redis"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>2.SpringBoot 整合 Redis</h2><p>SpringData 用来操作各种数据库的整合</p><h4 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>项目准备</h4><p>新建springboot项目模块，勾选Redis依赖，其他根据需要</p><p><img src="https://img-blog.csdnimg.cn/20210306160037843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>删除模块里的这些文件，暂时不需要<br><img src="https://img-blog.csdnimg.cn/20210306160335372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>pom文件依赖</p><p>java web, redis, fastjson</p><p>注意：</p><ul><li>  有些版本springboot连接redis使用jedis，有些使用lettuce</li><li>  jedis采用直连，多个线程下不安全，使用连接池可以解决</li><li>  采用netty，实例可以在多个线程中共享，没有现成安全情况，像NIO模式，性能高一些</li><li>  使用连接池尽量选用lecttuce的，功能更强大，支持的类更多</li></ul><p>主配置文件</p><p>Redis地址，端口号</p><h4 id="Redis测试"><a href="#Redis测试" class="headerlink" title="Redis测试"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>Redis测试</h4><p>先通过redistemplate对象调出所需的Redis操作对象，再进一步调用数据库方法API<br><img src="https://img-blog.csdnimg.cn/20210306174429835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021030617450852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>进入Redistemplate源码，可以看到所有的操作API</p><h4 id="序列化问题"><a href="#序列化问题" class="headerlink" title="序列化问题"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>序列化问题</h4><p>对象存入Redis之前需要序列化，否则可能出现中文乱码</p><p>使用jdk自带序列化方案</p><pre><code>@Component@AllArgsConstructor@NoArgsConstructor@Datapublic class User implements Serializable &#123;    private Integer age;    private String name;&#125;</code></pre><p>测试存入Redis</p><pre><code>@Test    void test1() throws Exception&#123;        User user = new User(18,&quot;螺蛳粉&quot;);        String jsonUser = new ObjectMapper().writeValueAsString(user);//对象转json字符串        redisTemplate.opsForValue().set(&quot;user&quot;, jsonUser);//存入set集合        Object user1 = redisTemplate.opsForValue().get(&quot;user&quot;);        System.out.println(user1);    &#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/20210306175409780.png" alt="在这里插入图片描述"><br>自己配置序列化方案，准备配置类，自己配置bean对象，公司常用这个模板</p><pre><code>@Configurationpublic class RedisConfig &#123;    //手动修改redisTemplate,常见的固定模板    @Bean    public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123;        // 连接        RedisTemplate&lt;String,Object&gt; template = new RedisTemplate&lt;&gt;();        template.setConnectionFactory(redisConnectionFactory);        // 创建json的序列化配置        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);        ObjectMapper om = new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        // 创建string的序配置        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();        // key采用string序列化配置        template.setKeySerializer(stringRedisSerializer);        // value采用jackson序列化配置        template.setValueSerializer(jackson2JsonRedisSerializer);        // hash key采用string序列化配置        template.setHashKeySerializer(stringRedisSerializer);        // hash value采用value序列化方案        template.setHashValueSerializer(jackson2JsonRedisSerializer);        template.afterPropertiesSet();        return template;    &#125;&#125;</code></pre><p>注入RedisTemplate时选择我们配置的Bean对象<br><img src="https://img-blog.csdnimg.cn/20210306182828197.png" alt="在这里插入图片描述"><br>运行测试，查看Redis数据库，<br><img src="https://img-blog.csdnimg.cn/20210306183437724.png" alt="在这里插入图片描述"><br>这样使用我们自己定义的Redis序列化配置，更好用，如果不配置默认使用jdk自带序列化方案，可能会出现中文乱码或者转义斜杠等问题</p><h4 id="自己写工具类"><a href="#自己写工具类" class="headerlink" title="自己写工具类"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>自己写工具类</h4><ul><li>  实际生产中通常不直接使用RedisTemplate原生API，而是自己准备RedisUtils工具类，需要使用时直接注入属性，调用方法</li></ul><p>如，</p><pre><code>@Componentpublic class RedisUtil &#123;    @Autowired    private RedisTemplate&lt;String, Object&gt; redisTemplate;    // 设置失效时间    public boolean expire(String key, long time) &#123;        try &#123;            if (time&gt;0) &#123;                redisTemplate.expire(key, time, TimeUnit.SECONDS);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    // 获取过期时间    public long getExpire(String key) &#123;        return redisTemplate.getExpire(key, TimeUnit.SECONDS);    &#125;    // 判断key是否存在    public boolean hasKey(String key) &#123;        try &#123;            return redisTemplate.hasKey(key);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    // 删除缓存    public void del(String... key) &#123;        if (key != null &amp;&amp; key.length&gt;0) &#123;            if (key.length == 1) &#123;                redisTemplate.delete(key[0]);            &#125; else &#123;                redisTemplate.delete(String.valueOf(CollectionUtils.arrayToList(key)));            &#125;        &#125;    &#125;    // 添加值    public boolean set(String key, Object value) &#123;        try &#123;            redisTemplate.opsForValue().set(key, value);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    // 取值    public Object get(String key, Object value) &#123;        return key == null ? null : redisTemplate.opsForValue().get(key);    &#125;    // 存入普通缓存设置时间    public boolean set(String key, Object value, long time) &#123;        try &#123;            if (time &gt; 0) &#123;                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);            &#125; else &#123;                set(key, value);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    // 设置递增    public long incr(String key, long delta) &#123;        if (delta &lt; 0) &#123;            throw new RuntimeException();        &#125;        return redisTemplate.opsForValue().increment(key, delta);    &#125;    // 设置递减    public long decr(String key, long delta) &#123;        if (delta &lt; 0) &#123;            throw new RuntimeException();        &#125;        return redisTemplate.opsForValue().increment(key, -delta);    &#125;    // Hash get    public Object hget(String key, String item) &#123;        return redisTemplate.opsForHash().get(key, item);    &#125;    // Hash get 获取对应的所有值    public Map&lt;Object,Object&gt; hmget(String key) &#123;        return redisTemplate.opsForHash().entries(key);    &#125;    // Hash set    public boolean hmset(String key, Map&lt;String, Object&gt; map) &#123;        try &#123;            redisTemplate.opsForHash().putAll(key, map);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    // Hash set 并设置时间    public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) &#123;        try &#123;            redisTemplate.opsForHash().putAll(key, map);            if (time &gt; 0) &#123;                expire(key, time);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    // 存入数据，如果不存在则新增    public boolean hset(String key, String item, Object value) &#123;        try &#123;            redisTemplate.opsForHash().put(key, item, value);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    // 存入数据，设置时间，如果不存在则新增    public boolean hset(String key, String item, Object value, long time) &#123;        try &#123;            redisTemplate.opsForHash().put(key, item, value);            if (time &gt; 0) &#123;                expire(key, time);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    // 删除    public void hdel(String key, Object... item)&#123;        redisTemplate.opsForHash().delete(key, item);    &#125;    // 判断是否有该值    public boolean hHasKey(String key, String item) &#123;        return redisTemplate.opsForHash().hasKey(key, item);    &#125;    // 存入值，如果不存在则新增，并设置时间    public double hincr(String key, String item, double by) &#123;        return redisTemplate.opsForHash().increment(key, item, by);    &#125;    // 设置递减    public double hdecr(String key, String item, double by) &#123;        return redisTemplate.opsForHash().increment(key, item, -by);    &#125;    // set 获取值    public Set&lt;Object&gt; sGet(String key) &#123;        try &#123;            return redisTemplate.opsForSet().members(key);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return null;        &#125;    &#125;    // 查询是否存在    public boolean sHasKey(String key, Object value) &#123;        try &#123;            return redisTemplate.opsForSet().isMember(key, value);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    // 存入值    public long sSet(String key, Object... values) &#123;        try &#123;            return redisTemplate.opsForSet().add(key, values);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;    // 存入职，并设置时间    public long sSet(String key, long time, Object... values) &#123;        try &#123;            long count = redisTemplate.opsForSet().add(key, values);            if (time &gt; 0) &#123;                expire(key, time);            &#125;            return count;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;    // 获取值的数量    public long sGetSetSize(String key) &#123;        try &#123;            return redisTemplate.opsForSet().size(key);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;    // 移除值    public long setRemove(String key, Object... values) &#123;        try &#123;            long count = redisTemplate.opsForSet().remove(key, values);            return count;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;    // list相关API&#125;</code></pre><h1 id="六、Redis-高级"><a href="#六、Redis-高级" class="headerlink" title="六、Redis 高级"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>六、Redis 高级</h1><h2 id="1-redis-conf-配置文件"><a href="#1-redis-conf-配置文件" class="headerlink" title="1.redis.conf 配置文件"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>1.redis.conf 配置文件</h2><p>redis.conf 配置了Redis的详细参数，Redis启动需要使用配置文件</p><p><img src="https://img-blog.csdnimg.cn/20210307003118853.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210307003243280.png" alt="在这里插入图片描述"><br>进入 redis.conf 编辑状态，分析配置参数，<code>vim redis.conf</code></p><p>规定单位，单位书写对大小写不敏感<br><img src="https://img-blog.csdnimg.cn/20210307004804175.png" alt="在这里插入图片描述"><br>可以包含其他配置文件，将多个配置文件组合起来<br><img src="https://img-blog.csdnimg.cn/20210307004953591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>NETWORK 网络配置，重点<br><img src="https://img-blog.csdnimg.cn/20210307005337748.png" alt="在这里插入图片描述"><br>绑定IP，只能使用指定的IP地址链接</p><pre><code>bind 127.0.0.1</code></pre><p>保护模式 yes/no，保护模式下只能本机连接</p><pre><code>protected-mode no</code></pre><p>连接端口号</p><pre><code>port 6379</code></pre><p>GENERAL 通用配置，<br><img src="https://img-blog.csdnimg.cn/20210307005941839.png" alt="在这里插入图片描述"><br>是否后台运行 yes/no</p><pre><code>daemonize yes</code></pre><p>管理守护进程的，一般不用动</p><pre><code># supervised auto</code></pre><p>如果选择后台运行，则指定一个pid进程文件</p><pre><code>pidfile /var/run/redis_6379.pid</code></pre><p>日志级别，注释里有详解极少各个级别的用途</p><pre><code>loglevel notice</code></pre><p>生成日志的位置，空则使用默认</p><pre><code>logfile &quot;&quot;</code></pre><p>默认数据库数量 16</p><pre><code>databases 16</code></pre><p>是否显示启动logo</p><pre><code>always-show-logo no</code></pre><p>SNAPSHOTTING 快照<br><img src="https://img-blog.csdnimg.cn/20210307010917727.png" alt="在这里插入图片描述"><br>持久化策略，如，这里表示，</p><pre><code>save 900 1  #900秒内，至少有一个key发生修改，则进行持久化操作save 300 10  #300秒内，至少有10个key发生修改，则进行持久化save 60 10000  #60秒内，至少有10000个key发生修改，则进行持久化</code></pre><p>持久化出现错误，是否继续工作</p><pre><code>stop-writes-on-bgsave-error yes</code></pre><p>是否压缩rdb文件，会消耗一定cpu资源</p><pre><code>rdbcompression yes</code></pre><p>保存rdb文件时，是否进行校验</p><pre><code>rdbchecksum yes</code></pre><p>持久化文件存放目录，默认在当前文件目录</p><pre><code>dir ./</code></pre><p>REPLICATION 主从复制，后面详解<br><img src="https://img-blog.csdnimg.cn/20210307012052543.png" alt="在这里插入图片描述"><br>SECURITY 安全<br><img src="https://img-blog.csdnimg.cn/20210307013639671.png" alt="在这里插入图片描述"></p><p>设置密码，默认没有</p><pre><code># requirepass foobared</code></pre><p>在Redis客户单，执行命令可以操作当前密码，</p><p>如果设置密码后发现操作无权限，只需要在客户端验证密码即可 <code>auth 密码</code><br><img src="https://img-blog.csdnimg.cn/20210307013916195.png" alt="在这里插入图片描述"><br>CLIENTS 客户端设置<br><img src="https://img-blog.csdnimg.cn/20210307014345958.png" alt="在这里插入图片描述"><br>最大客户端连接数，默认10000</p><pre><code># maxclients 10000</code></pre><p>MEMORY MANAGEMENT 内存设置<br><img src="https://img-blog.csdnimg.cn/20210307014518363.png" alt="在这里插入图片描述"><br>Redis最大内存</p><pre><code># maxmemory &lt;bytes&gt;</code></pre><p>内存达到上限的处理策略</p><ul><li>  volatile-lru：只对设置了过期时间的key进行LRU（默认值）</li><li>  allkeys-lru ： 删除lru算法的key</li><li>  volatile-random：随机删除即将过期key</li><li>  allkeys-random：随机删除</li><li>  volatile-ttl ： 删除即将过期的</li><li>  noeviction ： 永不过期，返回错误</li></ul><pre><code># maxmemory-policy noeviction</code></pre><p>APPEND ONLY MODE aof的持久化配置，后面详解<br><img src="https://img-blog.csdnimg.cn/20210307015248537.png" alt="在这里插入图片描述"><br>默认不开启aof，而是使用了 rdb</p><pre><code>appendonly no</code></pre><p>持久化文件名</p><pre><code>appendfilename &quot;appendonly.aof&quot;</code></pre><p>同步的频率，always每次修改都同步，比较消耗性能，everysec每秒一次，也可能有数据丢失，no不同步</p><pre><code># appendfsync alwaysappendfsync everysec# appendfsync no</code></pre><h2 id="2-Redis-持久化"><a href="#2-Redis-持久化" class="headerlink" title="2.Redis 持久化"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>2.Redis 持久化</h2><h4 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>RDB（Redis DataBase）</h4><p><img src="https://img-blog.csdnimg.cn/20210307110418783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>根据配置文件的持久化参数，定期将内存数据写入磁盘，即定期拍快照，恢复时将快照读到内存中</p><p>Redis持久化使用一个单独的子进程fork，主进程不进行任何IO操作，确保了Redis的高性能，因此RDB模式效率更高，对于数据完整性不是很敏感的情况下大多使用RDB持久化策略。</p><p>唯一的缺点就是在拍快照的间隙如果出现宕机，可能会有数据丢失</p><p>rdb保存文件，默认名dump.rdb，与redis.conf在同一个目录</p><p>生产环境下，我们会定期备份RDB文件<br><img src="https://img-blog.csdnimg.cn/20210307112712801.png" alt="在这里插入图片描述"></p><p>配置RDB持久化策略<br><img src="https://img-blog.csdnimg.cn/20210307111928682.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210307112551210.png" alt="在这里插入图片描述"></p><p>触发机制</p><ul><li>  save规则满足条件下，可以触发</li><li>  执行flushdb，可以触发</li><li>  退出redis，可以触发</li></ul><p>恢复数据</p><ul><li>  只需将rdb文件放在redis启动目录下，redis启动时可以自动识别读取</li><li>  查看启动目录，在客户端执行<code>config get dir</code></li></ul><p><img src="https://img-blog.csdnimg.cn/20210307113049730.png" alt="在这里插入图片描述"><br>优点</p><ul><li>  适合大规模数据恢复</li><li>  对数据完整性要求不高</li></ul><p>缺点</p><ul><li>  持久化操作有时间间隔，如果redis以外宕机，最后一次操作修改的数据会丢失</li><li>  fork进程运行时，会占用一定内存空间</li></ul><h4 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>AOF（Append Only File）</h4><p><img src="https://img-blog.csdnimg.cn/20210307113918696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>直译，追加文件，将所有命令记录下来，恢复时将里面的命令全部执行一遍，所以Redis重启就会将该持久化记录里面的指令从到位执行一遍，比较麻烦</p><p>配置文件<br><img src="https://img-blog.csdnimg.cn/20210307114409406.png" alt="在这里插入图片描述"><br>默认不开启，手动开启，需要设置</p><pre><code>appendonly yes</code></pre><p>默认声明文件名</p><pre><code>appendfilename &quot;appendonly.aof&quot;</code></pre><p>追加记录的频率</p><pre><code># appendfsync alwaysappendfsync everysec# appendfsync no</code></pre><p>其他配置一般使用默认，有需要可以查询</p><p>修改配置文件，开启AOF，重启Redis服务端，即可生效，持久化文件默认保存在Redis启动目录下，</p><p>执行一段Redis数据命令，查看文件目录，打开持久化文件<br><img src="https://img-blog.csdnimg.cn/20210307115606870.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210307115645383.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210307115742985.png" alt="在这里插入图片描述"><br>如果我们修改了这个日志文件，会影响数据的恢复，可以使用 自动检测修复aof文件，</p><p>执行命令</p><pre><code>redis-check-aof --fix appendonly.aof</code></pre><p><img src="https://img-blog.csdnimg.cn/20210307120055395.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210307120338798.png" alt="在这里插入图片描述"><br>重写规则，当aof文件超过配置参数的大小（这里是64mb），Redis就会开启一个新的进程，重写一个新的aof文件</p><p>aof配置中默认文件无限追加，会导致文件越来越大</p><pre><code>no-appendfsync-on-rewrite no</code></pre><p>如果配置重写，可以指定文件多大触发重写新的aof</p><pre><code>auto-aof-rewrite-min-size 64mb</code></pre><p>优点</p><ul><li>  每次修改都记录，确保文件完整性，注意需要将持久化策略改为always</li></ul><p>缺点</p><ul><li>  持久化文件远大于RDB文件，修复速度也更慢</li><li>  开启AOF持久化策略下，Redis运行效率也会比RDB模式慢</li></ul><p>使用策略</p><ul><li>  实际生产中会开启主从复制，rdb策略放在从机上，用来起到备份作用</li></ul><h4 id="Redis-持久化总结"><a href="#Redis-持久化总结" class="headerlink" title="Redis 持久化总结"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>Redis 持久化总结</h4><p>1.RDB持久化方式能够在指定的时间间隔内对数据进行快照存储</p><p>2.AOF持久化方式记录每次对服务器写的操作，当服务器重启时会重新执行这些命令来恢复原始数据，AOF命令以Redis协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，避免AOF文件体积过大</p><p>3.如果只是使用Redis作为服务器运行的缓存，其实也可以不必使用持久化</p><p>4.同时开启两种持久化方式</p><ul><li>  Redis重启会优先载入AOF文件来恢复原始数据，因为保存的数据更完整</li><li>  RDB的数据不实时，但是也推荐开启。因RDB更适合用于备份数据库，AOF不断变化不好备份，RDB重启速度快，没有AOF潜在的bug</li></ul><p>5.性能建议</p><ul><li>  RDB文件通常作为后备，建议只在Slave上持久化RDB文件，而且只需要15分钟备份一次就够了，只保留save 900 1这条规则</li><li>  如果开启AOF，好处是在最糟糕的情况下，也只会丢失不超过2秒的数据，启动脚本也简单；但是产生了一个持续的IO，还有，在rewrite重写过程中，将新的数据写入新文件不可避免会造成阻塞，所以只要硬盘允许，尽量减小重写频率，默认是64mb，可以设置到5g以上，超过原大小100%触发重写也可以适当提升数值</li><li>  如果不使用AOF，只靠Master-Slave Replication 时间高可用性也可以，性能节省一大笔IO，减少rewrite带来的波动，代价是，如果主机从机同时宕机，会丢失十几分钟的数据，启动脚本也会比较主机从机中的RDB文件，选择比较新的</li></ul><h2 id="3-Redis-发布订阅"><a href="#3-Redis-发布订阅" class="headerlink" title="3.Redis 发布订阅"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>3.Redis 发布订阅</h2><p>Redis发布订阅是一种消息通信模式，发送者发送消息，订阅者接收消息</p><p>Redis客户端可以接收任意数量的频道</p><p>要素：消息发送者、频道、消息接收者<br><img src="https://img-blog.csdnimg.cn/20210307142152833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210307142740291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210307142804968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>命令描述<br><img src="https://img-blog.csdnimg.cn/20210307142837128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>测试使用</p><p>订阅频道，c1<br><img src="https://img-blog.csdnimg.cn/20210307143057972.png" alt="在这里插入图片描述"><br>开启一个新的窗口，连接服务端，发送消息<br><img src="https://img-blog.csdnimg.cn/2021030714331911.png" alt="在这里插入图片描述"><br>接收端会实时接收消息，并显示<br><img src="https://img-blog.csdnimg.cn/20210307143423921.png" alt="在这里插入图片描述"><br>总结</p><ul><li>  发布者向频道发送消息</li><li>  接收者订阅频道，实施接收频道消息</li><li>  redis-server底层维护一个字典，字典的键就是每个频道，字典的值是一个链表，链表中保存了所有订阅这个频道的客户端，当字典的一个键上发布消息后，值对应的所有客户端都会接收消息，最明显的用法就是具有实时性，如，即时聊天，群聊、关注等，</li><li>  进一步复杂的场景一般使用消息中间件 MQ</li></ul><h2 id="4-Redis-主从复制"><a href="#4-Redis-主从复制" class="headerlink" title="4.Redis 主从复制"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>4.Redis 主从复制</h2><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>概念</h4><p>默认情况下，每台Redis服务器都一个主节点</p><p>通常主节点用来读操作，从机用来写操作，</p><p>主从复制作用：</p><ul><li>  数据冗余，实现了数据双击热备，是持久化之外的一种冗余方式</li><li>  故障恢复，主节点出现问题，从节节点可以提供服务，快速恢复</li><li>  负载均衡，多个从节点可以实现负载均衡，分担访问压力，提高Redis服务器的并发量</li><li>  高可用，主从复制是哨兵模式、Redis集群实施的前提</li></ul><p>结构上，Redis服务器可能发生故障，一台服务器不够用，且访问压力大；</p><p>容量上，单台服务器内存容量有限，也不应当将所有内存用作Redis存储，通常，单台Redis最大使用内存不应超过20G</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>配置</h4><p>只需要配置从机，主机默认就是，不需要单独配置</p><p>以默认方式启动Redis服务，连接客户端，查看主从复制信息</p><p><img src="https://img-blog.csdnimg.cn/20210307155329765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可得知当前服务身份为主机，从机连接数为0，</p><p>Redis集群的搭建至少需要三台服务器</p><p>Redis的启动需要配置文件，因此我们准备多个不同的配置文件，分别根据各个配置文件启动，就可以得到多个Redis服务器</p><p>准备四个连接窗口，一个观察，三个模拟三台Redis服务器<br><img src="https://img-blog.csdnimg.cn/20210307155918610.png" alt="在这里插入图片描述"><br>拷贝redis.conf配置文件，<br><img src="https://img-blog.csdnimg.cn/20210307160908496.png" alt="在这里插入图片描述"></p><p>分别进入各个配置文件，修改配置信息，这里以redis79.conf为例</p><p>端口号<br><img src="https://img-blog.csdnimg.cn/20210307161159489.png" alt="在这里插入图片描述"><br>后台运行</p><p><img src="https://img-blog.csdnimg.cn/20210307161249965.png" alt="在这里插入图片描述"><br>pid<br><img src="https://img-blog.csdnimg.cn/20210307161319910.png" alt="在这里插入图片描述"><br>日志<br><img src="https://img-blog.csdnimg.cn/20210307161420452.png" alt="在这里插入图片描述"><br>rdb<br><img src="https://img-blog.csdnimg.cn/20210307161526155.png" alt="在这里插入图片描述"><br>保存退出，80，81根据各自端口号修改</p><h4 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>启动</h4><p>修改完配置文件，分别用6379，6380，6381配置文件启动Redis服务端<br><img src="https://img-blog.csdnimg.cn/20210307162417666.png" alt="在这里插入图片描述"><br>当前状态每台服务器都是主节点</p><p>三个窗口分别连接6379，6380，6381客户端，查看连接信息<br><img src="https://img-blog.csdnimg.cn/2021030716274531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210307162829685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210307162907587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通常，从机不用改，只需配置从机，指定从机的主机即可</p><p>给从机指定主机，从机客户端中使用命令,80,81都执行</p><pre><code>slaveof 127.0.0.1 6379</code></pre><p><img src="https://img-blog.csdnimg.cn/20210307163228774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查看主机信息，多了两个从机<br><img src="https://img-blog.csdnimg.cn/20210307163424457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以上方式通过命令搭建主从，这是暂时的，实际生产中应该通过配置文件搭建主从，这是永久操作，开机即按照主从信息启动</p><p><img src="https://img-blog.csdnimg.cn/20210307163845885.png" alt="在这里插入图片描述"><br>注意事项</p><ul><li>  主机可以写，从机不能写只能读，写了也会报错</li><li>  主从复制状态下，主机中的所有信息和数据，都会自动被从机保存</li></ul><p>测试</p><ul><li>  主机宕机，主从关系没有变化，从机依旧无法写，主机恢复，主从关系不变，从机依旧无法写</li><li>  从机宕机，重启后变回主机，如果重新指定成刚才的从机，依旧可以获取主机所有数据，包括宕机期间主机的操作</li></ul><p>复制原理</p><ul><li>  slave启动成功连接到master后会发送一个sync同步命令</li><li>  master接到命令，启动后台存盘进程，同时收集所有接收到的修改数据的命令，后台进程执行完毕后，master将传送整个数据文件给slave，并完成一次完全同步</li><li>  全量复制：slave在接收到数据库文件数据后，将其存盘并加载到内存中</li><li>  增量复制：master继续将新的所有手机到的修改命令一次传给slave，完成同步</li><li>  只要是重新连接master，一次完全同步（全量复制）就会自动执行，从机恢复所有数据</li></ul><h4 id="主从链路"><a href="#主从链路" class="headerlink" title="主从链路"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>主从链路</h4><p>79做主机，80做79的从机，81做80的从机</p><p>此时的80依旧是从机，但是81依旧可以获取全部数据<br><img src="https://img-blog.csdnimg.cn/20210307173038456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这个模型下，如果79宕机，可以指定其中一个从机成为主机，进入一个从机客户端，执行命令，这个从机就会成为主机</p><pre><code>slaveof no one</code></pre><p>然后，其他从机再指定这个新的主机</p><p>最初的主机重新启动，也失去之前那些从机了</p><h2 id="5-哨兵模式（重点）"><a href="#5-哨兵模式（重点）" class="headerlink" title="5.哨兵模式（重点）"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>5.哨兵模式（重点）</h2><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>概念</h4><p>之前的主从切换，当主机宕机后，需要手动将一台服务器切换为主机，费事费力，服务器也会有一段时间不可用，</p><p>Redis从2.8开始出现哨兵模式，Redis提供了哨兵命令，哨兵是一个独立的进程，会独立运行，哨兵通过发送命令，等待Redis服务器响应，从而监控多个Redis实例</p><p>后台监控主机是否故障，如果宕机，将根据投票自动将从机切换为主机</p><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>模型</h4><p>基本模型<br><img src="https://img-blog.csdnimg.cn/20210307174247512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为了确保哨兵也高可用，可以使用多哨兵模式<br><img src="https://img-blog.csdnimg.cn/20210307174421898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果主机宕机，哨兵1先发现，系统不会马上进行切换，只是哨兵1主观认为，这个现象叫做主观下线。如果后续其他哨兵也发现主机不可用，且数量达到一定值时，哨兵之间就会进行投票，投票结果由一个哨兵发起，进行故障转移操作，切换成功后，通过发布订阅模式，通知各个哨兵把监控的从机切换为主机，者叫客观下线。</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>配置</h4><p>当前主从状态，79主机，80，81从机</p><p>在配置文件的目录中，新建哨兵配置文件<code>sentinel.conf</code></p><p>sentinel monitor不能变，sen1是名字自己取，127.0.0.1 6379 是监控的主机，1表示如果主机宕机，哨兵会进行投票</p><p>这是最基本的配置，完成后，保存退出</p><pre><code>sentinel monitor sen1 127.0.0.1 6379 1</code></pre><p><img src="https://img-blog.csdnimg.cn/20210307175632457.png" alt="在这里插入图片描述"></p><p>启动哨兵</p><p><img src="https://img-blog.csdnimg.cn/20210307175828421.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021030717593749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>哨兵启动，根据配置文件，当前监控的6379成为主机，还有两个从机6380，6381</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>测试</h4><p>打开新窗口，模拟主机6379宕机，进入6379客户端，shutdown<br><img src="https://img-blog.csdnimg.cn/2021030718031035.png" alt="在这里插入图片描述"><br>过一段时间，哨兵会通过心跳检测机制发现主机宕机，开始投票，推选出新的主机，这个例子中6381成了新主机</p><p><img src="https://img-blog.csdnimg.cn/2021030718042723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查看6381服务器信息，也验证了6381是新主机<br><img src="https://img-blog.csdnimg.cn/20210307180609188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里投票的机制，我们暂且不讨论，但是一定会从生下的从机选出主机</p><p>如果之前的主机6379重新连接，发现自己只能作为6381的从机，观察哨兵的投票记录我们可以看到，其实6379下线时，就已经沦为从机的位置了</p><p>登录6379客户端，查看信息<br><img src="https://img-blog.csdnimg.cn/20210307181204977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>优点：</p><ul><li>  哨兵集群，基于主从复制模式，拥有其全部优点</li><li>  可以主从切换，实现故障转移</li><li>  哨兵模式就是主从模式的升级版，实现自动切换，更加健壮</li></ul><p>缺点</p><ul><li>  Redis不好实现在线扩容，集群容量一旦到达上限，在线扩容十分困难</li><li>  实现哨兵模式配置的过程其实比较麻烦，我们的举例只是最简单的</li><li>  真正的全部配置，有很多，如果有哨兵集群更加复杂，</li></ul><p>后续补充哨兵的详细配置</p><h2 id="6-Redis-缓存穿透、击穿、雪崩（面试重点）"><a href="#6-Redis-缓存穿透、击穿、雪崩（面试重点）" class="headerlink" title="6.Redis 缓存穿透、击穿、雪崩（面试重点）"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>6.Redis 缓存穿透、击穿、雪崩（面试重点）</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>缓存穿透</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>概念</h4><p><img src="https://img-blog.csdnimg.cn/20210307183123161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>用户查询数据，发现Redis内存数据库中没有，也就是缓存没有命中，请求就会想持久层数据库查询，也没有，查询失败；</p><p>当用户量很大，或者恶意攻击，大量的请求进入到持久层数据库，会给数据库造成很大的压力，形成了缓存穿透</p><p>解决方案</p><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>布隆过滤器</h4><p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先校验，不符合则丢弃，避免对底层数据库直接查询<br><img src="https://img-blog.csdnimg.cn/2021030718314680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>具体原理可以自行查询</p><h4 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>缓存空对象</h4><p>当存储层不命中后，即使返回一个空对象，也可以将其缓存起来，同时设置一个过期时间，在一定时间内也可以将请求拦截在缓存中<br><img src="https://img-blog.csdnimg.cn/20210307183440577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>缺点</p><ul><li>  存储空对象，以为这缓存中需要存储更多的键值对，浪费资源</li><li>  即使空对象缓存有生命周期，到了过期时间，仍然会出现缓存层和存储层数据不一致，对业务也有影响</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>缓存击穿</h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>概念</h4><p>某些数据key非常热点，不停抗住大量并发，由于某种原因（宕机或过期），当这个key在失效的瞬间，持续大量的并发会将缓存击穿，直接请求数据库，导致数据库瞬间压力过大</p><p>缓存穿透与缓存击穿区别：穿透是查不到，击穿是本来能查到，突然失效了，发生穿透</p><p>解决方案</p><h4 id="设置热点数据永不过期"><a href="#设置热点数据永不过期" class="headerlink" title="设置热点数据永不过期"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>设置热点数据永不过期</h4><p>也有缺点，最终还是需要定期处理</p><h4 id="加互斥锁"><a href="#加互斥锁" class="headerlink" title="加互斥锁"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>加互斥锁</h4><p>分布式锁：使用分布式锁，确保每个key同时只有一个线程去查询后端服务，其他线程没有获取分布式锁的权限，只能等待，这种方式将高并发的压力转移到了分布式锁上面，对分布式锁的考验很大</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>缓存雪崩</h3><h4 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>概念</h4><p>在某一个时间段内，大量缓存集中失效（比如宕机、过期），导致访问查询都落到数据库上，对于数据库而言，产生了周期性的压力波峰，存储层调用量暴增，造成存储层挂掉</p><p><img src="https://img-blog.csdnimg.cn/20210307185110957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzI1Nzc0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>解决方案</p><h4 id="Redis高可用"><a href="#Redis高可用" class="headerlink" title="Redis高可用"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>Redis高可用</h4><p>搭建Redis集群</p><p>大厂比如阿里，在双十一会停掉部分业务，保障主业务</p><h4 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>限流降级</h4><p>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量，如，一个key只允许一个线程查询和写缓存，其他线程等待</p><h4 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a><a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187"></a>数据预热</h4><p>正式部署之前，先把可能的数据访问一遍，可以使一大部分访问的数据加载到缓存中，提前加载不同的数据；</p><p>设置不同的过期时间，让缓存失效的时间均匀分散</p><p>本文转自 <a href="https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164580136416780261920323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-114044856.pc_search_result_positive&utm_term=redis+2021&spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164580136416780261920323&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>baidu_landing_v2~default-1-114044856.pc_search_result_positive&amp;utm_term=redis+2021&amp;spm=1018.2226.3001.4187</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;文章目录&quot;&gt;&lt;a href=&quot;#文章目录&quot; class=&quot;headerlink&quot; title=&quot;文章目录&quot;&gt;&lt;/a&gt;文章目录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;  &lt;a href=&quot;about:blank#NoSQL__1&quot;&gt;一.NoSQL 简介&lt;/a&gt;&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Redis" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Redis/"/>
    
    
    <category term="Redis" scheme="https://ysluckly.github.io/tags/Redis/"/>
    
    <category term="教程" scheme="https://ysluckly.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>图解Go读写锁实现与核心原理分析</title>
    <link href="https://ysluckly.github.io/2021/11/24/go/"/>
    <id>https://ysluckly.github.io/2021/11/24/go/</id>
    <published>2021-11-24T15:59:10.000Z</published>
    <updated>2022-02-20T13:30:59.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="- 简介"></a>- 简介</h1><p>读写锁区别与互斥锁的主要区别就是读锁之间是共享的，多个goroutine可以同时加读锁，但是写锁与写锁、写锁与读锁之间则是互斥的</p><h1 id="写锁饥饿问题"><a href="#写锁饥饿问题" class="headerlink" title="- 写锁饥饿问题"></a>- 写锁饥饿问题</h1><p>因为读锁是共享的，所以如果当前已经有读锁，那后续goroutine继续加读锁正常情况下是可以加锁成功，但是如果一直有读锁进行加锁，那尝试加写锁的goroutine则可能会长期获取不到锁，这就是因为读锁而导致的写锁饥饿问题</p><h2 id="基于高低位与等待队列的实现"><a href="#基于高低位与等待队列的实现" class="headerlink" title="基于高低位与等待队列的实现"></a>基于高低位与等待队列的实现</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNzg3NTEwNi02ZDhhNjFiNWI3ZTg5YzBjLnBuZw?x-oss-process=image/format,png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>image.png</p><p>在说golang之前介绍一种JAVA里面的实现，在JAVA中ReentrantReadWriteLock实现采用一个state的高低位来进行读写锁的计数，其中高16位存储读的计数，低16位存储写的计数，并配合一个AQS来实现排队等待机制，同时AQS中的每个waiter都会有一个status，用来标识自己的状态</p><h1 id="golang的读写锁的实现"><a href="#golang的读写锁的实现" class="headerlink" title="golang的读写锁的实现"></a>golang的读写锁的实现</h1><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNzg3NTEwNi05MmE2ZTVlY2Y5NjM1YTg2LnBuZw?x-oss-process=image/format,png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>image.png</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><pre><code>Copytype RWMutex struct &#123;    w           Mutex  // held if there are pending writers    writerSem   uint32 // 用于writer等待读完成排队的信号量    readerSem   uint32 // 用于reader等待写完成排队的信号量    readerCount int32  // 读锁的计数器    readerWait  int32  // 等待读锁释放的数量&#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="写锁计数"><a href="#写锁计数" class="headerlink" title="写锁计数"></a>写锁计数</h3><p>读写锁中允许加读锁的最大数量是4294967296，在go里面对写锁的计数采用了负值进行，通过递减最大允许加读锁的数量从而进行写锁对读锁的抢占</p><pre><code>Copyconst rwmutexMaxReaders = 1 &lt;&lt; 30</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="读锁实现"><a href="#读锁实现" class="headerlink" title="读锁实现"></a>读锁实现</h2><h3 id="读锁加锁逻辑"><a href="#读锁加锁逻辑" class="headerlink" title="读锁加锁逻辑"></a>读锁加锁逻辑</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNzg3NTEwNi0zNjY5MTIyZTM2NTc1NjI4LnBuZw?x-oss-process=image/format,png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>image.png</p><pre><code>Copyfunc (rw *RWMutex) RLock() &#123;    if race.Enabled &#123;        _ = rw.w.state        race.Disable()    &#125;    // 累加reader计数器，如果小于0则表明有writer正在等待    if atomic.AddInt32(&amp;rw.readerCount, 1) &lt; 0 &#123;        // 当前有writer正在等待读锁，读锁就加入排队        runtime_SemacquireMutex(&amp;rw.readerSem, false)    &#125;    if race.Enabled &#123;        race.Enable()        race.Acquire(unsafe.Pointer(&amp;rw.readerSem))    &#125;&#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="读锁释放逻辑"><a href="#读锁释放逻辑" class="headerlink" title="读锁释放逻辑"></a>读锁释放逻辑</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNzg3NTEwNi0zNGM2OTgxN2M5OGI3NDc4LnBuZw?x-oss-process=image/format,png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>image.png</p><pre><code>Copyfunc (rw *RWMutex) RUnlock() &#123;    if race.Enabled &#123;        _ = rw.w.state        race.ReleaseMerge(unsafe.Pointer(&amp;rw.writerSem))        race.Disable()    &#125;    // 如果小于0，则表明当前有writer正在等待    if r := atomic.AddInt32(&amp;rw.readerCount, -1); r &lt; 0 &#123;        if r+1 == 0 || r+1 == -rwmutexMaxReaders &#123;            race.Enable()            throw(&quot;sync: RUnlock of unlocked RWMutex&quot;)        &#125;        // 将等待reader的计数减1，证明当前是已经有一个读的，如果值==0，则进行唤醒等待的        if atomic.AddInt32(&amp;rw.readerWait, -1) == 0 &#123;            // The last reader unblocks the writer.            runtime_Semrelease(&amp;rw.writerSem, false)        &#125;    &#125;    if race.Enabled &#123;        race.Enable()    &#125;&#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="写锁实现"><a href="#写锁实现" class="headerlink" title="写锁实现"></a>写锁实现</h2><h3 id="加写锁实现"><a href="#加写锁实现" class="headerlink" title="加写锁实现"></a>加写锁实现</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNzg3NTEwNi0yNjI2MjZhNjYyMTVhOTFlLnBuZw?x-oss-process=image/format,png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>image.png</p><pre><code>Copyfunc (rw *RWMutex) Lock() &#123;    if race.Enabled &#123;        _ = rw.w.state        race.Disable()    &#125;    // 首先获取mutex锁，同时多个goroutine只有一个可以进入到下面的逻辑    rw.w.Lock()    // 对readerCounter进行进行抢占，通过递减rwmutexMaxReaders允许最大读的数量    // 来实现写锁对读锁的抢占    r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders    // 记录需要等待多少个reader完成,如果发现不为0，则表明当前有reader正在读取，当前goroutine    // 需要进行排队等待    if r != 0 &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != 0 &#123;        runtime_SemacquireMutex(&amp;rw.writerSem, false)    &#125;    if race.Enabled &#123;        race.Enable()        race.Acquire(unsafe.Pointer(&amp;rw.readerSem))        race.Acquire(unsafe.Pointer(&amp;rw.writerSem))    &#125;&#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="释放写锁"><a href="#释放写锁" class="headerlink" title="释放写锁"></a>释放写锁</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNzg3NTEwNi0xNDZjOWFlNmU2YWFhNDViLnBuZw?x-oss-process=image/format,png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>image.png</p><pre><code>Copyfunc (rw *RWMutex) Unlock() &#123;    if race.Enabled &#123;        _ = rw.w.state        race.Release(unsafe.Pointer(&amp;rw.readerSem))        race.Disable()    &#125;    // 将reader计数器复位，上面减去了一个rwmutexMaxReaders现在再重新加回去即可复位    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)    if r &gt;= rwmutexMaxReaders &#123;        race.Enable()        throw(&quot;sync: Unlock of unlocked RWMutex&quot;)    &#125;    // 唤醒所有的读锁    for i := 0; i &lt; int(r); i++ &#123;        runtime_Semrelease(&amp;rw.readerSem, false)    &#125;    // 释放mutex    rw.w.Unlock()    if race.Enabled &#123;        race.Enable()    &#125;&#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="关键核心机制"><a href="#关键核心机制" class="headerlink" title="关键核心机制"></a>关键核心机制</h2><h3 id="写锁对读锁的抢占"><a href="#写锁对读锁的抢占" class="headerlink" title="写锁对读锁的抢占"></a>写锁对读锁的抢占</h3><p>加写锁的抢占</p><pre><code>Copy// 在加写锁的时候通过将readerCount递减最大允许加读锁的数量，来实现对加读锁的抢占r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>加读锁的抢占检测</p><pre><code>Copy// 如果没有写锁的情况下读锁的readerCount进行Add后一定是一个&gt;0的数字，这里通过检测值为负数//就实现了读锁对写锁抢占的检测if atomic.AddInt32(&amp;rw.readerCount, 1) &lt; 0 &#123;        // A writer is pending, wait for it.        runtime_SemacquireMutex(&amp;rw.readerSem, false)    &#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>写锁抢占读锁后后续的读锁就会加锁失败，但是如果想加写锁成功还要继续对已经加读锁成功的进行等待</p><pre><code>Copyif r != 0 &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != 0 &#123;    // 写锁发现需要等待的读锁释放的数量不为0，就自己自己去休眠了    runtime_SemacquireMutex(&amp;rw.writerSem, false)&#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>写锁既然休眠了，则必定要有一种唤醒机制其实就是每次释放锁的时候，当检查到有加写锁的情况下，就递减readerWait，并由最后一个释放reader lock的goroutine来实现唤醒写锁</p><pre><code>Copyif atomic.AddInt32(&amp;rw.readerWait, -1) == 0 &#123;    // The last reader unblocks the writer.    runtime_Semrelease(&amp;rw.writerSem, false)&#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="写锁的公平性"><a href="#写锁的公平性" class="headerlink" title="写锁的公平性"></a>写锁的公平性</h3><p>在加写锁的时候必须先进行mutex的加锁，而mutex本身在普通模式下是非公平的，只有在饥饿模式下才是公平的</p><pre><code>Copyrw.w.Lock()</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="写锁与读锁的公平性"><a href="#写锁与读锁的公平性" class="headerlink" title="写锁与读锁的公平性"></a>写锁与读锁的公平性</h3><p>在加读锁和写锁的工程中都使用atomic.AddInt32来进行递增，而该指令在底层是会通过LOCK来进行CPU总线加锁的，因此多个CPU同时执行readerCount其实只会有一个成功，从这上面看其实是写锁与读锁之间是相对公平的，谁先达到谁先被CPU调度执行，进行LOCK锁cache line成功，谁就加成功锁</p><h3 id="可见性与原子性问题"><a href="#可见性与原子性问题" class="headerlink" title="可见性与原子性问题"></a>可见性与原子性问题</h3><p>在并发场景中特别是JAVA中通常会提到并发里面的两个问题：可见性与内存屏障、原子性， 其中可见性通常是指在cpu多级缓存下如何保证缓存的一致性，即在一个CPU上修改了了某个数据在其他的CPU上不会继续读取旧的数据，内存屏障通常是为了CPU为了提高流水线性能，而对指令进行重排序而来，而原子性则是指的执行某个操作的过程的不可分割</p><h3 id="底层实现的CPU指令"><a href="#底层实现的CPU指令" class="headerlink" title="底层实现的CPU指令"></a>底层实现的CPU指令</h3><p>go里面并没有volatile这种关键字，那如何能保证上面的AddInt32这个操作可以满足上面的两个问题呢， 其实关键就在于底层的2条指令，通过LOCK指令配合CPU的MESI协议，实现可见性和内存屏障，同时通过XADDL则用来保证原子性，从而解决上面提到的可见性与原子性问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;- 简介&quot;&gt;&lt;/a&gt;- 简介&lt;/h1&gt;&lt;p&gt;读写锁区别与互斥锁的主要区别就是读锁之间是共享的，多个goroutine可以同时加读锁，但是写锁与写锁、写锁与读锁之间则是互斥的&lt;/</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="读写锁实现" scheme="https://ysluckly.github.io/tags/%E8%AF%BB%E5%86%99%E9%94%81%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="核心原理" scheme="https://ysluckly.github.io/tags/%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python 简明教程</title>
    <link href="https://ysluckly.github.io/2021/11/24/python3/"/>
    <id>https://ysluckly.github.io/2021/11/24/python3/</id>
    <published>2021-11-24T15:59:10.000Z</published>
    <updated>2022-02-20T13:29:02.475Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919113143.jpg" alt="Python 中文教程"></p><blockquote><p>Python is a programming language that lets you work more quickly and integrate your systems more effectively. – <a href="https://www.python.org/">python.org</a></p></blockquote><h2 id="0-安装"><a href="#0-安装" class="headerlink" title="0 安装"></a>0 安装</h2><p>可以直接从官网 <a href="https://www.python.org/downloads/">python.org/downloads</a> 下载安装，最新版本是 3.9.0。安装过程和普通的 Windows 软件一致。安装完成后，需将安装路径添加到环境变量中。</p><p>如果你使用的是 Ubuntu 等 Linux 发行版或 MacOS 系统，操作系统将自带 Python，无需安装。如果操作系统上只有 Python2，在 Debian 和 Ubuntu 上可通过如下方式安装 Python3：</p><pre><code class="bash">sudo apt-get update &amp;&amp; sudo apt-get install python3</code></pre><p>在 MacOS 上，可通过如下方式安装</p><pre><code class="bash">brew install python3</code></pre><p>若安装成功，命令行运行 <code>python -V</code> 或 <code>python3 -V</code>，你将看到：</p><pre><code class="bash">$ python3 -VPython 3.7.5</code></pre><h2 id="1-Hello-World"><a href="#1-Hello-World" class="headerlink" title="1 Hello World"></a>1 Hello World</h2><p>Python 有两种运行方式：交互式和源文件。在命令行中键入 python3 并回车，则进入了 Python 解释器的交互模式：</p><pre><code class="bash">$ python3Python 3.7.5 (default, Nov  7 2019, 10:50:52)[GCC 8.3.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; </code></pre><p>接下来，我们接着输入：<code>print(&quot;hello world&quot;)</code>，按下回车：</p><pre><code class="bash">&gt;&gt;&gt; print(&quot;hello world&quot;)hello world&gt;&gt;&gt; </code></pre><p>这样就完成了我们的第一个 Python 程序，向世界问好。<code>print()</code> 是 Python 中的一个内置函数，用来在标准输出中打印信息。</p><p>在交互模式下，每输入一行代码，按下回车，运行结果就会打印在屏幕上。因此，我们可以将 Python 当做一个简单的计算器，例如：</p><pre><code class="bash">&gt;&gt;&gt; 1 + 2 * 100201&gt;&gt;&gt; 1 + 2 ** 39</code></pre><p><code>**</code> 是 Python 中的指数运算符，这里表示 2 的 3 次方。</p><p>我们在桌面新建文件夹 test，在 test 文件夹中新建文件 <code>main.py</code>，写入：</p><pre><code class="python">print(&quot;1 + 2 =&quot;, 1 + 2)</code></pre><p>保存后，在命令行中切换到 test 文件夹，执行 <code>python main.py</code>，将会看到：</p><pre><code class="bash">$ python3 main.py1 + 2 = 3</code></pre><p>一般我们使用 IDE，例如 <a href="https://code.visualstudio.com/">VSCode</a> 或 <a href="https://www.jetbrains.com/pycharm/download">PyCharm</a> 写 Python 程序。IDE 集成了代码高亮、提示、命令行等功能，能够极大地提升代码的学习和开发效率。</p><h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2 基本语法"></a>2 基本语法</h2><pre><code class="python">ok = True # 布尔值，表示真假，True 或 Falsea = 2b = 3.56c = &quot;hello world&quot;d = a * b # 求 a 和 b 的积print(&quot;c =&quot;, c)print(&#39;&#123;0&#125; + &#123;1&#125; = &#123;2&#125;&#39;.format(a, b, d))</code></pre><p>运行这段程序：</p><pre><code class="bash">python3 main.pyc = hello world2 + 3.56 = 7.12</code></pre><ul><li>单行注释以符号 <code>#</code> 开头。</li><li>变量一般由数字、字母、下划线构成，但只能以字母或下划线开头。</li><li><code>ok = True</code>，表示将字面量，即布尔值 True 赋值给变量 ok。</li><li><code>a = 2</code>，表示将字面量，即整数 2 赋值给变量 a</li><li><code>b = 3.56</code>，表示将字面量，即浮点数 3.56 赋值给变量 b</li><li><code>c = &quot;hello world&quot;</code>，表示将字符串 hello world 赋值给变量 c。</li></ul><p>单行字符串一般使用双引号 <code>&quot;</code>，也可以使用单引号 <code>&#39;</code>，多行字符串通常使用三个单引号或三个双引号。例如：</p><pre><code class="python">a = &quot;I&#39;m 极客兔兔&quot;b = &#39;c = &quot;hello world&quot;&#39;d = &quot;&quot;&quot;这是一个多行字符串；这是第二行；这是第三行。&quot;&quot;&quot;print(a)print(b)print(d)</code></pre><p>执行结果为：</p><pre><code class="bash">$ python3 main.py                                                             I&#39;m 极客兔兔c = &quot;hello world&quot;这是一个多行字符串，这是第二行这是第三行</code></pre><p><code>format</code> 可以格式化字符串，<code>&#123;0&#125;</code> 表示用 format 的第一个参数的值替代，<code>&#123;1&#125;</code> 表示用第二个值替代，以此类推。</p><p>format 还有其他使用方式，省略序号或使用键值对：</p><pre><code class="python">name, age = &quot;小明&quot;, 13 # 一行中可以声明多个变量print(&quot;&#123;&#125;今年 &#123;&#125; 岁&quot;.format(name, age)) # 按顺序使用，&#123;&#125;可省略序号print(&quot;&#123;name&#125;明年 &#123;age&#125; 岁&quot;.format(name=name, age=age+1)) # 使用键值对</code></pre><p>执行结果：</p><pre><code class="bash">$ python3 main.py小明今年 13 岁小明明年 14 岁</code></pre><p>如果代码写的有问题，Python 执行时将会报错，例如这段：</p><pre><code class="python">age = 13print(&quot;今年 &#123; 岁\n明年 &#123;&#125; 岁&quot;.format(age, age+1)) # \n 表示换行打印</code></pre><pre><code class="bash">python3 main.pyTraceback (most recent call last):  File &quot;main.py&quot;, line 2, in &lt;module&gt;    print(&quot;今年 &#123; 岁\n明年 &#123;&#125; 岁&quot;.format(age, age+1))ValueError: unexpected &#39;&#123;&#39; in field name</code></pre><p>报错时打印了发生错误的堆栈信息：</p><ul><li><code>File &quot;main.py&quot;, line 2</code> 表示错误发生在 <code>main.py</code> 的第 2 行。</li><li><code>ValueError: unexpected &#39;&#123;&#39; in field name</code> 表示错误原因是 <code>&#123;</code> 括号使用有误。在这里，我们没有成对使用大括号作为占位符，导致报错。</li></ul><h2 id="3-运算符与表达式"><a href="#3-运算符与表达式" class="headerlink" title="3 运算符与表达式"></a>3 运算符与表达式</h2><h3 id="3-1-运算符"><a href="#3-1-运算符" class="headerlink" title="3.1 运算符"></a>3.1 运算符</h3><p>常见的加减乘除运算：</p><pre><code class="python">&gt;&gt;&gt; 1 + 2 # 加3&gt;&gt;&gt; 4 - 6 # 减-2&gt;&gt;&gt; 2 * 3 # 乘6&gt;&gt;&gt; 6 / 4 # 除1.5&gt;&gt;&gt; 6 // 4 # 除取整1&gt;&gt;&gt; 6 + 2 * (1 + 3) # 运算顺序和正常的数学运算一致，先乘除，后加减，括号优先14&gt;&gt;&gt; 2 ** 4 # 指数，2 的 4 次方16&gt;&gt;&gt; 6 % 4 # 取模/余数2</code></pre><p>大小比较运算：</p><pre><code class="python">&gt;&gt;&gt; 12 &lt; 18 # 小于True&gt;&gt;&gt; 12 &lt;= 18 # 小于等于True&gt;&gt;&gt; 1.2 &gt; 3.4 # 大于False&gt;&gt;&gt; 1.2 &gt;= 3.4 # 大于等于False&gt;&gt;&gt; 12 == 18 # 等于False&gt;&gt;&gt; 12 != 18 # 不等于True</code></pre><p>逻辑运算符：</p><pre><code class="python">&gt;&gt;&gt; 12 &gt;= 8 and 5 &gt; 6 # and 布尔与/且，全真为真，有假为假False&gt;&gt;&gt; 12 &gt;= 8 or 5 &gt; 6 # or 布尔或，全假为假，有真为真True&gt;&gt;&gt; not 5 &gt; 6 # not 布尔非True</code></pre><p>此外还支持 <code>&lt;&lt;</code> (左移)、<code>&gt;&gt;</code> (右移)、<code>&amp;</code> (按位与)、<code>|</code> (按位或)、<code>^</code> (按位异或)、<code>~</code> (按位取反) 等位运算符。</p><p>赋值运算符  <code>=</code>，将 <code>=</code> 右侧的值赋值给左侧，左侧需要一个变量。</p><pre><code class="python">a = 2a = a * (3 + 4) # 将 a * (3 + 4) 的值 14 赋值给 a。</code></pre><p>对一个变量进行计算，将计算的结果赋值给该变量，可以简写为：</p><pre><code class="python">a = 2a *= 3 + 4</code></pre><h3 id="3-2-表达式"><a href="#3-2-表达式" class="headerlink" title="3.2 表达式"></a>3.2 表达式</h3><p>Python中，值、变量和运算符共同组成的整体称为表达式，通常我们所写出的程序语句包含若干个表达式。例如上述的 <code>3 + 4</code> 即构成了一个简单的表达式。值和变量也被称作为操作数，运算符也被称为操作符。</p><h2 id="4-控制流"><a href="#4-控制流" class="headerlink" title="4 控制流"></a>4 控制流</h2><p>Python 语句是自上而下执行的，如果在这个过程中，我们希望通过一些条件判断，执行不同的逻辑怎么办呢？可以通过控制流语句实现，Python 中一共有 <code>if</code>、<code>for</code>、<code>while</code> 三个控制流语句。</p><h3 id="4-1-if-语句"><a href="#4-1-if-语句" class="headerlink" title="4.1 if 语句"></a>4.1 if 语句</h3><p><code>if</code> 用于检查条件是否为真，如果为真则执行，通常与 <code>else</code>，<code>elif</code> (else if) 结合使用。例如：</p><pre><code class="python">age = 13if age &gt;= 18:    print(&#39;adult&#39;)if age &lt; 18:    print(&#39;child&#39;)</code></pre><p>Python 使用缩进代表不同的代码块，一般缩进使用 4 个空格表示。你可以看到 <code>print()</code> 前有 4 个空格。</p><p>上述代码可以简化成：</p><pre><code class="python">age = 13if age &gt;= 18:    print(&#39;adult&#39;)else:    print(&#39;child&#39;)</code></pre><p>如果我们有多个条件判断分支时，<code>elif</code> 就能派上用场了：</p><pre><code class="python">age = 45if age &lt; 18:    print(&#39;小孩&#39;)elif age &lt; 60:    print(&#39;中年人&#39;)else:    print(&#39;老人&#39;)</code></pre><h3 id="4-2-for-语句"><a href="#4-2-for-语句" class="headerlink" title="4.2 for 语句"></a>4.2 for 语句</h3><p>有些代码块需要执行多次，这种情况我们可以使用 <code>for</code> 循环语句，例如打印数字 1 - 5：</p><pre><code class="python"># main.pyfor i in range(5): # 0, 1, 2, 3, 4 从0开始，不包含 5    print(i + 1, end=&#39; &#39;)</code></pre><p>执行结果为：</p><pre><code class="bash">python3 main.py1 2 3 4 5</code></pre><ul><li><code>print()</code> 函数默认以换行符结尾，如果我们希望替换成空格，只需要将参数 end 设置为空格即可。</li><li><code>range()</code> 也是一个内置函数，用于生成数字序列，常用于 for 循环语句中。若只传入一个参数 N，代表生成 <code>[0, N) </code>的整数序列，从 0 开始，不包含N。如果我们不想从 0 开始怎么办呢？<code>range()</code> 也支持传入多个参数，例如：</li></ul><pre><code class="python">for i in range(2, 5): # [2, 5)    print(&quot;&#123;0&#125; * &#123;0&#125; = &#123;1&#125;&quot;.format(i, i ** 2))# 结果如下# 2 * 2 = 4# 3 * 3 = 9# 4 * 4 = 16for i in range(1, 10, 2): # 第三个参数为步长 step，从1开始，每次加 2    print(i, end=&#39; &#39;)# 1 3 5 7 9for i in range(10, 2, -2): # 步长-2，从10开始，每次加-2    print(i, end=&#39; &#39;)# 10 8 6 4</code></pre><p>那如果在 for 循环中，遇到某个条件想退出循环呢？通常 <code>for</code>  还与 <code>break</code> 和 <code>continue</code> 结合使用：</p><pre><code class="python">for i in range(100):    if i &lt;= 3:        continue # i &lt;= 3，继续循环，不执行下面的语句    if i &gt;= 10:        break    # i &gt;= 10 时，终止循环    print(i, end=&#39; &#39;)# 4 5 6 7 8 9</code></pre><ul><li><code>continue</code> 语句用来跳过当前循环语句块中的其余部分，然后继续执行循环的下一个迭代。</li><li><code>break</code> 语句用来终止循环。</li><li>因此，<code>i &lt;= 3</code> 时，跳过了 print 语句，<code>i &gt;= 10</code> 时循环被终止，那么这个程序将会打印出数字 4 5 6 7 8 9。</li></ul><h3 id="4-3-while-语句"><a href="#4-3-while-语句" class="headerlink" title="4.3 while 语句"></a>4.3 while 语句</h3><p>与 <code>for</code> 循环语句类似，<code>while</code> 通常也用于循环表达式中。while 后面跟一个条件，条件为真时，执行 while 代码块；条件为假时，终止循环。一般 while 可以替代 for 循环，刚才我们使用 for 打印了数字 1 - 5，接下来用 while 改写：</p><pre><code class="python">i = 0while i &lt; 5: # 第1次迭代i==0，满足条件，第6次迭代时，i==5，不满足条件    i += 1    print(i, end=&#39;,&#39;)# 1,2,3,4,5,</code></pre><p>同样的，<code>continue</code> 和 <code>break</code> 语句也能在 <code>while</code> 语句中使用。例如我们实现一个简单的功能，用户每输入一个数字，打印这个数字的平方，直到输入 0 时结束。</p><pre><code class="python">while True:    num = input(&#39;请输入一个数字: &#39;)    num = int(num)    if num == 0:        print(&#39;结束&#39;)        break    print(&quot;&#123;&#125;^2 = &#123;&#125;&quot;.format(num, num ** 2))</code></pre><p>运行结果：</p><pre><code class="bash">python3 main.py请输入一个数字: 1212^2 = 144请输入一个数字: 1818^2 = 324请输入一个数字: 0结束</code></pre><ul><li><code>while True</code> 代表进入无限循环，只有通过 <code>break</code> 语句才能结束。</li><li><code>input()</code> 是一个内置函数，用于接受用户的输入，返回一个字符串。input 可以传入一个字符串，作为输入的提示语句。</li><li><code>num = int(num)</code> 是将 num 转换为整型，因为字符串不能计算平方，只有数字才行。</li></ul><h2 id="5-函数"><a href="#5-函数" class="headerlink" title="5 函数"></a>5 函数</h2><p>在之前的例子中，我们已经使用了 <code>print</code>、<code>range</code>、<code>input</code> 等 Python 常用的内置函数，对函数已经不陌生了。那函数是什么呢？函数可以理解为一块可以复用的代码块，可以为这个代码块起一个名字（函数名），也可以定义传入的参数（形参），以及返回结果（返回值）。函数定义一般长这个样子：关键字 <code>def</code> 作为函数的标识符，紧接着是函数名，函数名的命名规范与变量一致，通常由数字、字母和下划线构成，以字母或下划线开头。函数名后面有一对小括号和一个冒号 <code>:</code>，里面可以定义参数列表，也可以没有参数。接下来便是一个语句块作为函数体。</p><pre><code class="python">def 函数名(参数名1, 参数名2, ...):    body 函数体，函数体同样通过缩进来体现</code></pre><p>那比如我们实现一个函数 <code>area</code>，用于计算长方形的面积，接受 2 个参数长 <code>length</code> 和宽 <code>width</code>，返回一个值，即面积。</p><pre><code class="python">def area(length, width):    return length * widthprint(&#39;area1: &#39;, area(10, 8)) # area1:  80，第一次调用print(&#39;area2: &#39;, area(6, 8)) # area2:  48，第二次调用</code></pre><ul><li><code>return</code> 是 Python 中的一个关键字，用于函数体中，即跳出这个函数，不再执行。</li><li><code>return</code> 可以跟一个或多个值作为返回值，也可以没有返回值。</li><li>没有返回值时，<code>return</code> 事实上等价于 <code>return None</code>，<code>None</code> 是一个关键字，表示空。</li><li>如果函数没有 <code>return</code> 语句，系统会自动在函数的结尾添加 <code>return None</code> 语句。</li></ul><pre><code class="python">def calc(a, b):    return a // b, a % b # 多个返回值，事实上是一个元组(tuple)类型，后面章节会介绍print(calc(8, 3)) # (2, 2)x, y = calc(8, 5) # 两个返回值分别赋值给变量 x, yprint(x, y) # 1, 3</code></pre><pre><code class="python">def log(mode):    if mode == &#39;debug&#39;:        print(&#39;debug mode&#39;)        return    print(&#39;release mode&#39;)print(log(&#39;release&#39;)) # release mode# None</code></pre><h3 id="5-1-局部变量与全局变量"><a href="#5-1-局部变量与全局变量" class="headerlink" title="5.1 局部变量与全局变量"></a>5.1 局部变量与全局变量</h3><pre><code class="python">x = 10 # x 是全局变量，可在其他函数中使用def print_global():    print(x)def print_local():    x = 100 # x 是局部变量，不影响全局变量中的 x    print(x)print_global() # 10print_local() # 100print_global() # 10</code></pre><p>我们定义了全局变量 x，在 <code>print_local</code> 中定义了与全局变量同名的局部变量 x，并将 100 赋值给 x，在这里修改的是局部变量的值，局部变量只在这个函数内部有效，全局变量不会受到影响。因此，两次 <code>print_global</code> 的结果都是 10。</p><p>定义局部变量的好处在于，控制变量的作用域范围，减少各个函数之间的干扰。全局变量可以在多个函数之间共享，一般建议仅将只读的变量设置为全局变量，比如圆周率 <code>π</code> 的值。那如果我们想修改全局变量怎么办呢？可以使用 <code>global</code> 关键字：</p><pre><code class="python">x = 10 # x 是全局变量，可在其他函数中使用def print_global():    print(x)def print_local():    global x    x = 100     print(x)print_global() # 10print_local() # 100print_global() # 100</code></pre><p>在 <code>print_local</code> 中，使用 <code>global x</code> 告诉 Python x 是一个全局变量，而非局部变量。因此 <code>x = 100</code> 将修改全局变量 x 的值。所以第二个 <code>print_global()</code> 将打印 100。</p><h3 id="5-2-可选参数与默认值"><a href="#5-2-可选参数与默认值" class="headerlink" title="5.2 可选参数与默认值"></a>5.2 可选参数与默认值</h3><p>如果有多个参数，那能不能给某些参数设置默认值，这样用户可以选择性地传入或不传入该参数的值呢？答案是可以的，Python 允许给参数设置默认值，在使用者看来，就像是实现了C++的函数重载一样。</p><blockquote><p>重载函数是函数的一种特殊情况，为方便使用，C++允许在同一范围中声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，也就是说用同一个函数完成不同的功能，这就是重载函数。</p></blockquote><pre><code class="python">def greet(msg, times=1):    for i in range(times):        print(msg)greet(&#39;Hi, Jack&#39;)greet(&#39;Hello, Mr Dai&#39;, 3)</code></pre><p>执行结果：</p><pre><code class="bash">Hi, JackHi, TomHi, TomHi, Tom</code></pre><ul><li><code>greet</code> 函数的功能是打印 msg，默认是1次，但可以通过参数 times 控制。</li><li>带默认值的参数只能位于参数列表的末尾，不能位于非默认值参数前面。例如 <code>def greet(times=1, msg)</code> 是不允许的。</li><li>默认值参数可以有 0 或多个。</li></ul><p>Python 中，参数的传递还可以更加地灵活，除了按顺序传入以外，还可以通过键值对的方式传入：</p><pre><code class="python">greet(&#39;Hi, Jack&#39;, times=2) # 混合方式greet(msg=&#39;Hi, Tom&#39;, times=3)greet(times=3, msg=&#39;Hi, Tom&#39;) # 均为键值对的情况下，顺序没有关系</code></pre><p>键值对传参特别适用于参数列表非常多，且大部分均有默认参数的情况。无需关注参数的顺序，而只需将需要设置的几个参数传入即可。</p><h3 id="5-3-可变参数"><a href="#5-3-可变参数" class="headerlink" title="5.3 可变参数"></a>5.3 可变参数</h3><p>Python 还支持可变参数。函数定义时如果参数的个数是不确定的，那么就适合使用可变参数来代替。可变参数有 2 种，元组式(tuple，元组可以认为是一个不可变的有序集合)和字典式(dict)。元组式可变参数用 <code>*参数名</code> 表示，传入的实际参数会构成一个元组，例如：</p><pre><code class="python"># 实现一个求和函数，支持传入任意个数字def sum_n(*nums):    s = 0    for num in nums:        s += num    return sprint(sum_n(1, 2, 3)) # 6print(sum_n(1, 2, 3, 4, 5)) # 15</code></pre><p>字典式(键值对式)可变参数用<code>**参数名表示</code>，传入的实际参数会构成一个字典(dict)，例如：</p><pre><code class="python">def print_student(**students):    for name, age in students.items():        print(&#39;&#123;&#125;今年 &#123;&#125; 岁&#39;.format(name, age))print_student(小明=8, 小红=7)</code></pre><p>执行结果：</p><pre><code class="bash">小明今年 8 岁小红今年 7 岁</code></pre><blockquote><p>元组(tuple) 和 字典(dict) 都是 Python 内置的数据结构，我们在下一章节会讲到。</p></blockquote><h3 id="5-4-文档字符串-doc"><a href="#5-4-文档字符串-doc" class="headerlink" title="5.4 文档字符串 __doc__"></a>5.4 文档字符串 <code>__doc__</code></h3><p>给每一个函数写文档是编程的好习惯，在 Python 中，对每个函数来说，有一个内置的属性 <code>__doc__</code> 保存了函数的说明文档，Python 中称之为 <code>DocStrings</code>。那怎么定义这个属性呢？</p><pre><code class="python">def print_student(**students):    &#39;&#39;&#39;Prints name and age for every student.    key is name, and value is age.&#39;&#39;&#39;    for name, age in students.items():        print(&#39;&#123;&#125;今年 &#123;&#125; 岁&#39;.format(name, age))print_student(小明=8, 小红=7)print(print_student.__doc__) # 打印 __doc__ 的值help(print_student)</code></pre><ul><li>函数体一开始使用三个单引号<code>&#39;&#39;&#39;</code>标志 DocStrings 的开始。</li><li>第一行描述函数的作用，首字母大写。第二行为空行，第三行是详细的描述，可以包括函数每一个参数的介绍等。</li></ul><p>执行结果：</p><pre><code class="bash">小明今年 8 岁小红今年 7 岁Prints name and age for every student.    key is name, and value is age.</code></pre><pre><code class="bash">Help on function print_student in module __main__:print_student(**students)    Prints name and age for every student.    key is name, and value is age.</code></pre><ul><li><code>help()</code> 函数也是 Python 的内置函数，提供一种更优美的方式查看某个函数的 DocStrings，通常在交互模式下使用。</li></ul><h2 id="6-数据结构"><a href="#6-数据结构" class="headerlink" title="6 数据结构"></a>6 数据结构</h2><p>Python 内置了常用的几种数据结构：列表(list)、元组(tuple)、字典(dict) 和集合(set)，几乎所有程序都会用到这几种数据结构。</p><h3 id="6-1-字符串-string"><a href="#6-1-字符串-string" class="headerlink" title="6.1 字符串(string)"></a>6.1 字符串(string)</h3><p>字符串可以说是最常用的数据类型了。字符串可以使用 <code>&quot;</code>、<code>&#39;</code>、<code>&quot;&quot;&quot;</code>、<code>&#39;&#39;&#39;</code> 表示。三引号通常用于表示多行字符串。字符串是字符序列，在 Python 中，序列支持下标索引、for 循环、切片等系列操作，后面提到的列表(list)、元组(tuple)也都属于序列。字符串是不可变数据类型，不支持修改。</p><pre><code class="python">s = &quot;I&#39;m geektutu&quot;print(len(s)) # 12print(s[0], s[-1]) # I u</code></pre><p><code>[]</code> 操作符可以按照下标索引到元素的值，下标从 0 开始，支持负数，-1 表示最后一个元素，以此类推。<code>[]</code> 除了可以用于下标索引外，还可以用来切片，例如：</p><pre><code class="python">s = &quot;I&#39;m geektutu&quot;print(s[:-3]) # I&#39;m geekt，等价于 s[0:-3]print(s[4:]) # geektutu，等价于 print(s[4:len(s)])print(s[4::2]) # gettprint(s[::-1]) # tutkeeg m&#39;I</code></pre><p>切片能够快速截取序列中的一部分，使用方式可以表示为 <code>[start:end:step]</code>，与 range 类似，包含开始，不包含结束。</p><ul><li><code>start</code> 默认值为 0，如果为 0，可以省略不写。</li><li><code>end</code> 默认值为列表的长度，如果为列表长度，可以省略不写。</li><li><code>step</code> 默认值为 1，如果为1，可以省略不写。</li></ul><h3 id="6-2-列表-list"><a href="#6-2-列表-list" class="headerlink" title="6.2 列表(list)"></a>6.2 列表(list)</h3><p><code>list</code> 是一种表示有序项集合的数据结构。有序且允许重复，支持增删查改，是一种可变数据类型。</p><pre><code class="python">persons = list() # 声明一个空列表persons = [] # 声明一个空列表persons = [&#39;Tom&#39;, &#39;Jack&#39;, &#39;Jack&#39;, &#39;Sam&#39;] # 声明一个非空列表persons.append(&#39;KangKang&#39;) # 添加一个元素print(persons[1]) # Jack 打印第1个元素，下标从 0 开始。persons.remove(&#39;Jack&#39;) # 删除 Jack，只删除第一次出现的位置print(persons)  # [&#39;Tom&#39;, &#39;Jack&#39;, &#39;Sam&#39;, &#39;KangKang&#39;]del persons[-2] # 删除倒数第二个元组 Samprint(persons) # [&#39;Tom&#39;, &#39;Jack&#39;, &#39;KangKang&#39;]persons.sort() # 排序# 遍历列表for name in persons:    print(name, end=&#39; &#39;) # Jack KangKang Tom</code></pre><ul><li><code>append</code> 添加元素，<code>remove</code> 按值删除某个元素，<code>del</code> 按下标删除元素。</li><li><code>sort()</code> 用于给列表排序。</li></ul><p>列表和字符串一样，是一种序列，因此也支持切片。</p><pre><code class="python">numbers = [2, 4, 6, 8, 10]print(len(numbers)) # 长度 5print(numbers[:3]) # 2 4 6print(numbers[0:3]) # 2 4 6print(numbers[1:-1]) # 4 6 8print(numbers[1:]) # 4 6 8 10print(numbers[1:5:2]) # 4 8print(numbers[1::2]) # 4 8</code></pre><p>列表的值可以是任意类型，而且一个列表中允许不同类型的值存在，当然也允许嵌套列表存在。</p><pre><code class="python">a = [1, 1.3, &quot;Student&quot;, [1, 2, 3]]</code></pre><p>判断一个值是否在一个列表中，可以使用 <code>in</code>：</p><pre><code class="python">print(&quot;Student&quot; in a) # True</code></pre><p>列表与字符串有一个非常常用的处理组合 <code>split</code> 和 <code>join</code>：</p><pre><code class="python">s = &quot;1,5,2,4,3&quot;parts = s.split(&#39;,&#39;)print(parts) # [&#39;1&#39;, &#39;5&#39;, &#39;2&#39;, &#39;4&#39;, &#39;3&#39;]parts.sort()print(&#39;:&#39;.join(parts)) # 1:2:3:4:5</code></pre><ul><li><code>split</code> 用于将字符串按照某个分隔符切割成列表。</li><li><code>join</code> 用于将字符串列表按照某个分隔符合并在一起。</li></ul><blockquote><p>关于列表的更多操作参考 <a href="https://docs.python.org/zh-cn/3/tutorial/datastructures.html">list - Python官方文档</a></p></blockquote><h3 id="6-2-元组-tuple"><a href="#6-2-元组-tuple" class="headerlink" title="6.2 元组(tuple)"></a>6.2 元组(tuple)</h3><p>元组也是有序集合，用小括号表示。很多特性与列表(list) 一致，不同点在于元组是不可变数据类型，即不允许增删改。</p><pre><code class="python">students = (&#39;Tom&#39;, 18, &#39;Jack&#39;, 20)print(len(students))  # 4print(students[1:3]) # 切片：(18, &#39;Jack&#39;)</code></pre><p>如果尝试修改元组，会出现如下报错：</p><pre><code class="bash">students[0] = &#39;KangKang&#39;Traceback (most recent call last):  File &quot;main.py&quot;, line 4, in &lt;module&gt;    students[0] = &#39;KangKang&#39;TypeError: &#39;tuple&#39; object does not support item assignment</code></pre><blockquote><p>关于元组的更多操作参考 <a href="https://docs.python.org/zh-cn/3/tutorial/datastructures.html#tuples-and-sequences">tuple - Python官方文档</a></p></blockquote><h3 id="6-4-字典-dict"><a href="#6-4-字典-dict" class="headerlink" title="6.4 字典(dict)"></a>6.4 字典(dict)</h3><p>字典由若干个键值对构成，能够快速地根据键(key)查找到对应的值(value)，在一个字典中，键是不能重复的。字典是可变数据类型，支持增删查改。</p><pre><code class="python">students = &#123;&#125; # 声明空字典students = dict() # 声明空字典students = &#123;    &#39;Tom&#39;: 18,    &#39;Jack&#39;: 20,    &#39;Same&#39;: 19&#125;students[&#39;KangKang&#39;] = 17 # 新增students[&#39;Tom&#39;] = 20 # 修改print(students[&#39;Tom&#39;]) # 20, 通过 key 索引del students[&#39;Jack&#39;] # 删除# 遍历for name, age in students.items():    print(name, age)# Tom 20# Same 19# KangKang 17</code></pre><ul><li><p><code>items()</code> 可以同时获取键和值，除此之外，字典还支持仅获取所有键 <code>keys()</code>，所有值<code>values()</code>等方法，字典是无序的，这三个方法返回值的顺序是不能保证的。</p></li><li><p>判断字典中是否包含某个键，同样可以使用 <code>in</code>，例如 <code>if &#39;Tom&#39; in students</code>。</p></li><li><p>获取字典的键值对个数，可以使用 <code>len</code>，例如<code>len(students)</code>。</p></li></ul><blockquote><p>关于字典的更多操作参考 <a href="https://docs.python.org/zh-cn/3/tutorial/datastructures.html#dictionaries">dict - Python官方文档</a></p></blockquote><h3 id="6-4-集合-set"><a href="#6-4-集合-set" class="headerlink" title="6.4 集合(set)"></a>6.4 集合(set)</h3><p>Python 中的集合与数学中的集合类似，特点是无序且不重复。</p><pre><code class="python">s = set() # 定义空集合s1 = set([1, 2, 2, 2, 3]) # 非空集合s1.add(2) # 添加元素，重复则不添加s1.add(10)s1.remove(3) # 删除print(s1) # &#123;10, 1, 2&#125;s2 = set([5, 6, 10])print(s1 | s2) # 并集 &#123;1, 2, 5, 6, 10&#125;print(s1 &amp; s2) # 交集 &#123;10&#125;print(s1 - s2) # 差集 &#123;1, 2&#125;</code></pre><ul><li><code>set([1, 2, 2, 2, 3])</code> 将列表转换为集合，自动去重，同样也可以使用 <code>list()</code> 将集合转换为列表。</li></ul><blockquote><p>关于集合的更多操作参考 <a href="https://docs.python.org/zh-cn/3/tutorial/datastructures.html#sets">数据结构 set - Python官方文档</a></p></blockquote><h2 id="7-输入输出"><a href="#7-输入输出" class="headerlink" title="7 输入输出"></a>7 输入输出</h2><p>之前的例子我们使用了标准输入输出函数 <code>input</code> 和 <code>output</code> 实现了简单的功能。Python 常用于数据挖掘分析，文本处理是最基本的能力，使用 Python 进行文件读写也非常简单。</p><p>下面是一个非常简单的例子：将字符串 s 写入文件 <code>1.txt</code></p><pre><code class="python">s = &#39;&#39;&#39;第一行第二行第三行&#39;&#39;&#39;f = open(&#39;1.txt&#39;, &#39;w&#39;)f.write(s)f.close()</code></pre><ul><li><code>open</code> 是 Python 用于读取文件的内置函数，第一个参数是文件路径，第二个参数是打开模式，<code>w</code> 代表写模式， <code>r</code>代表只读模式。<code>w</code> 模式打开文件后，文件会被清空，如果需要追加写，则需要以<code>w+</code>模式打开文件。</li><li>如果打开文件成功，<code>open</code>会返回一个文件句柄，我们可以使用这个句柄对文件进行操作。</li><li>操作完毕后，需要将文件关闭。</li></ul><p>Python 还提供了另一种更安全、简单的方式 <code>with as</code>：</p><pre><code class="python">s = &#39;&#39;&#39;第一行第二行第三行&#39;&#39;&#39;with open(&#39;1.txt&#39;, &#39;w&#39;) as f:    f.write(s)</code></pre><p><code>with</code> 语句会在 <code>with</code> 内部的代码块执行完毕后，执行资源回收的操作，对于文件来说即关闭文件。</p><p>读取文件，并统计字数：</p><pre><code class="python">with open(&#39;1.txt&#39;, &#39;r&#39;) as f:    s = f.read()    print(len(s)) # 11</code></pre><p>我们也可以使用 <code>readlines()</code> 读取文件的所有行：</p><pre><code class="python">with open(&#39;1.txt&#39;, &#39;r&#39;) as f:    s = f.readlines()    for line in s:        print(line, end=&#39;&#39;)</code></pre><p>还有一种更高效的方式，直接遍历文件句柄 <code>f</code>：</p><pre><code class="python">with open(&#39;1.txt&#39;, &#39;r&#39;) as f:    for line in f:        print(line, end=&#39;&#39;)</code></pre><h2 id="8-异常"><a href="#8-异常" class="headerlink" title="8 异常"></a>8 异常</h2><p>尽管我们想要将代码写得尽善尽美，但是出现异常还是难免的。如果我们不对异常做任何的处理，程序会立即退出。Python 提供了 <code>try except finally</code> 机制，给开发者提供了一个处理异常的机会。</p><pre><code class="python"># main.pywith open(&#39;2.txt&#39;, &#39;r&#39;) as f:    print(f.read())print(&#39;done&#39;)</code></pre><p>如果我们执行上述程序，会出现如下错误：</p><pre><code class="bash">Traceback (most recent call last):  File &quot;main.py&quot;, line 2, in &lt;module&gt;    with open(&#39;2.txt&#39;, &#39;r&#39;) as f:FileNotFoundError: [Errno 2] No such file or directory: &#39;2.txt&#39;</code></pre><p>程序在第二行就退出了，错误原因是 <code>2.txt</code> 不存在。那我们如何捕获到这个错误并处理呢？</p><pre><code class="python"># main.pytry:    with open(&#39;2.txt&#39;, &#39;r&#39;) as f:        print(f.read())except Exception as e:    print(e)finally:    print(&#39;done&#39;)</code></pre><p>程序正常执行结束：</p><pre><code class="bash">[Errno 2] No such file or directory: &#39;2.txt&#39;done</code></pre><ul><li><code>try</code> 语句块中包含可能发生异常的代码，如果发生异常，将跳转到 <code>except</code> 语句块执行。</li><li>无论是否发生异常，<code>finally</code> 中的代码都会得到执行，<code>finally</code> 是可选的。</li></ul><p>我们也可以在 <code>except</code> 中处理完毕之后，继续将异常抛出，留给调用方处理。</p><pre><code class="python"># main.pytry:    with open(&#39;2.txt&#39;, &#39;r&#39;) as f:        print(f.read())except Exception as e:    print(e)    raise efinally:    print(&#39;done&#39;)</code></pre><p>执行结果：</p><pre><code class="bash">[Errno 2] No such file or directory: &#39;2.txt&#39;doneTraceback (most recent call last):  File &quot;main.py&quot;, line 7, in &lt;module&gt;    raise e  File &quot;main.py&quot;, line 3, in &lt;module&gt;    with open(&#39;2.txt&#39;, &#39;r&#39;) as f:FileNotFoundError: [Errno 2] No such file or directory: &#39;2.txt&#39;</code></pre><h2 id="9-模块"><a href="#9-模块" class="headerlink" title="9 模块"></a>9 模块</h2><h3 id="9-1-使用标准库模块"><a href="#9-1-使用标准库模块" class="headerlink" title="9.1 使用标准库模块"></a>9.1 使用标准库模块</h3><p>Python 标准库内置了大量的模块，提供了非常丰富的功能。比如数学库 <code>math</code>：</p><pre><code class="python">import mathprint(math.__name__) # 模块名 mathprint(math.ceil(4.3)) # 向上取整 5print(math.floor(4.8)) # 向下取整 4</code></pre><ul><li>使用 <code>import</code> 导入标准库 <code>math</code>，并调用了 <code>math</code> 的 <code>ceil</code> 和 <code>floor</code> 函数。</li><li>每一个模块有一个内置属性 <code>__name__</code>，表示模块的名称，如果开发者正在独立运行该模块，则模块名称将是 <code>__main__</code>。</li></ul><p>例如，执行 <code>main.py</code></p><pre><code class="python"># main.pyprint(__name__)if __name__ == &#39;__main__&#39;:      print(&#39;正在独立运行该模块&#39;)</code></pre><p>将会输出：</p><pre><code class="bash">__main__正在独立运行该模块</code></pre><p>如果我们导入的模块名有冲突，可以使用 <code>as</code> 为导入的模块起一个别名</p><pre><code class="python">import math as math2print(math2.__name__) # 模块名 mathprint(math2.ceil(4.3)) # 向上取整 5print(math2.floor(4.8)) # 向下取整 4</code></pre><p>有时候，导入的模块名路径很深，可以使用 <code>from xxx import xxx</code>来简化导入的路径：</p><pre><code class="python">import osprint(os.path.join(&#39;/tmp&#39;, &#39;a&#39;, &#39;b&#39;))# 可以替换为from os import pathprint(path.join(&#39;/tmp&#39;, &#39;a&#39;, &#39;b&#39;))</code></pre><h3 id="9-2-使用自己实现的模块"><a href="#9-2-使用自己实现的模块" class="headerlink" title="9.2 使用自己实现的模块"></a>9.2 使用自己实现的模块</h3><p>新建一个文件 <code>calc.py</code>，在里面实现如下的函数：</p><pre><code class="python">def area(length, width):    return length * widthprint(&#39;this is calc module&#39;)if __name__ == &#39;__main__&#39;:    assert(area(3, 4) == 12)    print(&#39;test done&#39;)</code></pre><p>执行 <code>python calc.py</code>，将会输出：</p><pre><code class="bash">this is calc moduletest done</code></pre><p>在 <code>main.py</code> 中我们可以导入模块 <code>calc</code> 并使用，在 Python 中一个 <code>.py</code> 文件就可以被视为一个模块：</p><pre><code class="python">import calcif __name__ == &#39;__main__&#39;:    print(calc.__name__)    print(calc.area(5, 10))</code></pre><p>执行 <code>python main.py</code>，将会输出：</p><pre><code class="bash">this is calc modulecalc50</code></pre><p>当模块被导入时会执行该模块的代码，因此也打印了 <code>this is calc module</code>，但没有打印 <code>test done</code>。</p><p>当 <code>calc.py</code> 作为一个模块导入时，属性 <code>__name__</code> 与文件名相同，即等于 <code>calc</code>，因此没有进入到 <code>if</code> 分支中，而被独立执行时，<code>__name__</code> 的值是 <code>__main__</code>，因此进入到了 <code>if</code> 分支，打印了 <code>test done</code>。</p><p>因此，我们可以利用这个特性，在模块被独立执行时运行一些代码，比如简单的测试逻辑，但不影响被导入时的执行逻辑。</p><h3 id="9-3-使用第三方模块"><a href="#9-3-使用第三方模块" class="headerlink" title="9.3 使用第三方模块"></a>9.3 使用第三方模块</h3><p>Python 拥有非常丰富的第三方模块，比如著名的爬虫框架 <code>scrapy</code>，数学基础库 <code>numpy</code>、数据处理利器 <code>pandas</code> 等。如果我们想使用第三方模块，只需要使用 <code>pip</code> 命令安装即可。</p><p>例如安装 numpy：</p><pre><code class="bash">pip3 install numpy</code></pre><p>如果你的机器上同时安装了 Python2 和 Python3，给特定的 Python 版本安装可以使用：</p><pre><code class="bash">python3 -m pip install numpy</code></pre><p>如果国内下载网速过慢，可以通过 <code>-i</code> 选项指定下载源：</p><pre><code class="bash">pip3 install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><p>安装完成后，就可以像使用标准库一样使用 <code>numpy</code> 了：</p><pre><code class="python">import numpy as npa = np.array([[1, 2, 3], [4, 5, 6]])b = np.array([[1, 5, 8], [2, 5, 6]])print (a - b) # 两个矩阵相减# [[ 0 -3 -5]#  [ 2  0  0]]</code></pre><h2 id="10-面向对象编程"><a href="#10-面向对象编程" class="headerlink" title="10 面向对象编程"></a>10 面向对象编程</h2><p>Python 是一门既支持过程式编程，又支持面向对象编程的一门语言。</p><blockquote><p>面向对象是相对于面向过程来讲的，面向对象方法，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。</p></blockquote><p>面向对象编程的三大特性：</p><ul><li>封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式。</li><li>继承： 子类从父类继承方法，使得子类具有父类相同的行为。</li><li>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。</li></ul><h3 id="10-1-类与对象"><a href="#10-1-类与对象" class="headerlink" title="10.1 类与对象"></a>10.1 类与对象</h3><p>Python 中使用关键字 <code>class</code> 声明一个类，一般继承基类 <code>object</code>：</p><pre><code class="python">class Student(object):    def __init__(self, name, age):        self.name = name        self.age = age    def hello(self):        print(&#39;你好，我是&#123;&#125;，今年&#123;&#125;岁&#39;.format(self.name, self.age))if __name__ == &#39;__main__&#39;:    jack = Student(&#39;Jack&#39;, 18)    jack.hello()</code></pre><ul><li>类内部声明的方法默认是实例方法，第一个参数是 <code>self</code>，代表实例本身，调用时省略。</li><li><code>__init__</code> 是一个类的构造方法，第一个参数是 <code>self</code>，后面的参数根据需要声明，使用时使用 <code>类名(参数)</code> 可创建出一个属于该类的一个实例对象。<code>name</code> 和 <code>age</code> 都属于实例变量，实例变量属于该实例，不与其他实例共享。</li><li>其他方法的声明与普通的函数实现类似，唯一不同点在于实例方法可以通过参数 <code>self</code> 获取实例的属性或调用实例的其他方法。</li></ul><h3 id="10-2-类方法与类变量"><a href="#10-2-类方法与类变量" class="headerlink" title="10.2 类方法与类变量"></a>10.2 类方法与类变量</h3><p>实例方法和实例变量是针对对象实例而言的，与实例方法和实例变量相对应的是类方法和类变量，属于该类的所有实例都可以共享，可以通过<code>类.方法</code> 或 <code>实例.方法</code> 的方式使用。</p><pre><code class="python">class Student(object):    school = &#39;东方小学&#39; # 类变量    def __init__(self, name, age):        self.name = name # 实例变量        self.age = age   # 实例变量    def hello(self):        print(&#39;你好，我是&#123;&#125;，今年&#123;&#125;岁&#39;.format(self.name, self.age))    @classmethod    def print_school(cls): # 类方法        print(cls.school)if __name__ == &#39;__main__&#39;:    jack = Student(&#39;Jack&#39;, 18)    tom = Student(&#39;Tom&#39;, 20)    jack.print_school()    tom.print_school()    Student.school = &#39;东明小学&#39; # 修改类变量    jack.print_school() # 东明小学    tom.print_school()  # 东明小学</code></pre><ul><li>实例变量在构造函数 <code>__init__</code> 内部声明，类变量在外部声明。</li><li>类内部声明的方法默认为实例方法，使用 <code>@classmethod</code> 声明类方法，第一个参数<code>cls</code> 代表类自己。</li></ul><h3 id="10-3-静态方法"><a href="#10-3-静态方法" class="headerlink" title="10.3 静态方法"></a>10.3 静态方法</h3><p>还有一类方法，既不会访问实例变量和方法，也不会访问类变量和方法，仅仅是一个辅助函数，比如因为某个实例方法实现过长，想把其中的一部分代码抽取出来独立成一个方法，提高代码可读性。而这个辅助函数仅对这个类有用，对其他类没有用。这种情况下，我们通常会将其声明为静态方法。</p><pre><code class="python">class Student(object):    def __init__(self, name, age):        self.name = name # 实例变量        self.age = age   # 实例变量    def hello(self):        print(&#39;你好，我是&#123;&#125;，今年&#123;&#125;岁&#39;.format(self.name, self.age))    @staticmethod    def help_func():        print(&#39;我是一个静态方法&#39;)if __name__ == &#39;__main__&#39;:    jack = Student(&#39;Jack&#39;, 18)    Student.help_func()    jack.help_func()</code></pre><ul><li>静态方法使用 <code>@staticmethod</code> 声明，与普通的全局函数没有任何区别，可以通过<code>类.方法</code> 或 <code>实例.方法</code> 的方式使用。与实例方法和类型方法相比，没有 <code>self</code> 或<code>cls</code> 参数。</li></ul><h3 id="10-4-继承"><a href="#10-4-继承" class="headerlink" title="10.4 继承"></a>10.4 继承</h3><pre><code class="python">class Rectangle(object):    def __init__(self, length, width):        self.length = length        self.width = width    def area(self):        return self.length * self.widthclass Square(Rectangle):    def __init__(self, length):        super(Square, self).__init__(length, length)if __name__ == &#39;__main__&#39;:    s = Square(4)    print(s.area())</code></pre><ul><li><code>Square</code> 继承了 <code>Rectangle</code>，因此拥有了 <code>Rectangle</code> 的所有属性和方法。</li><li><code>Square</code> 可以根据需要覆盖父类的方法，在这里 <code>Square</code> 覆盖了父类的构造函数，参数列表从原来的 2 个变为了 1个。</li><li>子类可以通过 <code>super(子类名, self).方法</code> 的方式调用父类的方法。</li></ul><h2 id="11-单元测试"><a href="#11-单元测试" class="headerlink" title="11 单元测试"></a>11 单元测试</h2><p>为每一个模块编写单元测试是非常好的习惯，Python 也内置了一个单元测试库 <code>unittest</code>。</p><p>新建一个文件 <code>calc.py</code>，实现 area 和 volume 两个函数：</p><pre><code class="python">def area(length, width):    if length &lt; 0 or width &lt; 0:        return 0    return length * widthdef volume(length, width, height):    if length &lt; 0 or width &lt; 0 or height &lt; 0:        return 0    return length * width * height</code></pre><p>新建文件 <code>calc_test.py</code> 添加测试用例：</p><pre><code class="python">import unittestimport calcclass TestCalc(unittest.TestCase):    def test_area(self):        self.assertEqual(calc.area(10, -1), 0)        self.assertEqual(calc.area(10, 8), 80)    def test_volume(self):        self.assertEqual(calc.volume(2, -1, 4), 0)        self.assertEqual(calc.volume(2, 3, 4), 24)if __name__ == &#39;__main__&#39;:    unittest.main()</code></pre><ul><li>添加测试用例的过程非常简单，定义一个类，继承 <code>unittest.TestCase</code>，然后定义一个或多个 <code>test_</code> 开头的方法即可。每一个 <code>test_</code> 开头的方法视为一个用例，这是 unittest 测试框架的约定。</li><li>测试用例中，可以使用 <code>assertEqual</code>、<code>assertTrue</code> 等方式检查预期输出。</li><li><code>unittest.main()</code> 将加载该模块中定义的所有用例并执行。</li></ul><pre><code class="bash">$ python3 calc_test.py ..----------------------------------------------------------------------Ran 2 tests in 0.000sOK</code></pre><p>使用如下方式可以指定测试某个模块、某个测试类，甚至是只运行某个测试用例:</p><pre><code class="bash">python -m unittest test_module1 test_module2python -m unittest test_module.TestClasspython -m unittest test_module.TestClass.test_method</code></pre><p><code>python3 calc_test.py</code> 等价于 <code>python3 -m unittest calc_test</code>。如果只想执行 <code>test_volume</code> 方法，可以这么调用：</p><pre><code class="bash">python3 -m unittest calc_test.TestCalc.test_volume</code></pre><h3 id="11-1-setUp-与-tearDown"><a href="#11-1-setUp-与-tearDown" class="headerlink" title="11.1 setUp 与 tearDown"></a>11.1 setUp 与 tearDown</h3><p>有时候，每个用例执行前后需要一些相同的准备动作和收尾动作，比如打开文件和关闭文件。如果每个用例里都调用一次，就会异常繁琐。与其他测试框架类似，unittest 提供了 <code>setUp</code> 和 <code>tearDown</code> 功能，用于设置每个用例执行前后的一些指令。unittest 还提供了 <code>setUpClass</code> 和 <code>tearDownClass</code> 两个方法，用于设置某个测试类所有用例执行前后的一些指令。</p><pre><code class="python">import unittestclass TestCalc(unittest.TestCase):    @classmethod    def setUpClass(cls):        print(&#39;所有用例执行前&#39;)    @classmethod    def tearDownClass(cls):        print(&#39;所有用例执行后&#39;)    def setUp(self):        print(&#39;单个用例执行前&#39;)    def tearDown(self):        print(&#39;单个用例执行后&#39;)    def test_1(self):        pass    def test_2(self):        passif __name__ == &#39;__main__&#39;:    unittest.main()</code></pre><p>执行结果如下：</p><pre><code class="bash">$ python3 -m unittest calc_test所有用例执行前单个用例执行前单个用例执行后.单个用例执行前单个用例执行后.所有用例执行后----------------------------------------------------------------------Ran 2 tests in 0.000sOK</code></pre><blockquote><p>关于单元测试的更多用法，可以参考 <a href="https://docs.python.org/zh-cn/3/library/unittest.html#module-unittest">unittest - Python 官方文档</a></p></blockquote><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>这篇文章托管在 <a href="https://github.com/geektutu/blog/tree/master/posts/quick-start/python">github</a>，如果有错别字或其他修改建议，可以直接提 PR，感谢您的阅读和贡献。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919113143.jpg&quot; alt=&quot;Python 中文教程&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Python is a pr</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Python3" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Python3/"/>
    
    
    <category term="Python3" scheme="https://ysluckly.github.io/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Go sqlx操作mysql教程</title>
    <link href="https://ysluckly.github.io/2021/11/24/go/"/>
    <id>https://ysluckly.github.io/2021/11/24/go/</id>
    <published>2021-11-24T13:59:10.000Z</published>
    <updated>2022-02-20T13:31:33.482Z</updated>
    
    <content type="html"><![CDATA[<p>sqlx是Go数据库操作包，它在database/sql包的基础上增加了更加高效的数据库操作函数，也就是说使用sqlx操作数据库比使用database/sql更加方便。</p><h4 id="1-sqlx关键概念介绍"><a href="#1-sqlx关键概念介绍" class="headerlink" title="1.sqlx关键概念介绍"></a>1.sqlx关键概念介绍</h4><p>sqlx定义了下面几个关键类型:</p><pre><code class="go">sqlx.DB - 代表一个数据库sqlx.Tx - 代表一个事务sqlx.Rows - 代表sql查询结果的多行记录sqlx.Row - 代表sql查询结果的一条记录</code></pre><h5 id="使用sqlx的关键步骤"><a href="#使用sqlx的关键步骤" class="headerlink" title="使用sqlx的关键步骤:"></a>使用sqlx的关键步骤:</h5><pre><code class="go">根据mysql地址和帐号密码，创建sqlx.DB对象通过sqlx.DB对象的sql查询函数，操作数据库</code></pre><h4 id="2-安装包"><a href="#2-安装包" class="headerlink" title="2.安装包"></a>2.安装包</h4><pre><code class="c">//安装sqlx包go get github.com/jmoiron/sqlx//安装mysql驱动go get github.com/go-sql-driver/mysql</code></pre><h4 id="3-导入包"><a href="#3-导入包" class="headerlink" title="3.导入包"></a>3.导入包</h4><pre><code class="c">import (    //导入mysql驱动    _ &quot;github.com/go-sql-driver/mysql&quot;    //导入sqlx包    &quot;github.com/jmoiron/sqlx&quot;)</code></pre><h4 id="3-连接数据库"><a href="#3-连接数据库" class="headerlink" title="3.连接数据库"></a>3.连接数据库</h4><pre><code class="cpp">//定义数据库对象var pool *sqlx.DB//定义mysql数据源，配置数据库地址，帐号以及密码， dsn格式下面会解释dsn := &quot;root:123456@tcp(localhost:3306)/tizi365?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;//根据数据源dsn和mysql驱动, 创建数据库对象pool, err := sqlx.Open(&quot;mysql&quot;, dsn)if err != nil &#123;    panic(err)&#125;</code></pre><p>MYSQL dsn格式：</p><blockquote><p>{username}:{password}@tcp({host}:{port})/{Dbname}?charset=utf8&amp;parseTime=True&amp;loc=Local</p></blockquote><ul><li>参数说明:</li></ul><pre><code class="c">参数    说明&#123;username&#125;    数据库帐号&#123;password&#125;    数据库密码&#123;host&#125;    数据库地址&#123;port&#125;    数据库端口&#123;Dbname&#125;    数据库名字</code></pre><p>说明: charset=utf8 用于设置字符集，parseTime=True表示将数据库时间类型转换成Go时间类型</p><h4 id="4-数据库连接池设置"><a href="#4-数据库连接池设置" class="headerlink" title="4.数据库连接池设置"></a>4.数据库连接池设置</h4><p>sqlx.DB内置了数据库连接池，在你调用sql查询函数的时候，自动从连接池申请连接，可以通过下面方式设置连接池参数:</p><pre><code class="c">//设置连接池最大连接数pool.SetMaxOpenConns(100)//设置连接池最大空闲连接数pool.SetMaxIdleConns(20)</code></pre><h4 id="5-sql语句绑定参数"><a href="#5-sql语句绑定参数" class="headerlink" title="5.sql语句绑定参数"></a>5.sql语句绑定参数</h4><p><strong>绑定参数指的是</strong>：在sql语句中通过占位符(?), 定义一些参数，然后在执行sql语句的时候再把参数传递进去。</p><p>说明： sql语句绑定参数，除了方便我们拼接sql语句参数之外，还有一个重要的功能就是参数的安全检查和过滤，避免sql注入攻击。</p><p>例子:</p><pre><code class="c">//这里通过占位符（？），定义了两个参数sql := &quot;select * from tablename where cat=? and uid=?&quot;//执行sql，并且传入两个参数, 函数的第二个参数101对应sql语句的第一个问号，第三个参数5对应第二个问号db.Queryx(sql, 101, 5)提示：sqlx.DB提供的查询函数，都支持参数绑定，教程后续会有相应的例子</code></pre><h4 id="6-插入数据"><a href="#6-插入数据" class="headerlink" title="6.插入数据"></a>6.插入数据</h4><p>sqlx为我们定义两个函数用于执行插入，更新以及执行DDL语句（创建表，修改表等等）：</p><pre><code class="bash">ExecMustExec</code></pre><p>这两个函数的作用是一样的，区别就是处理错误的机制不一样，MustExec遇到错误的时候直接抛出一个panic错误，程序就退出了；Exec是将错误和执行结果一起返回，由我们自己处理错误。</p><p>我们先定义一个mysql表结构并创建表：</p><pre><code class="c">//定义表结构schema := `CREATE TABLE place (    id int primary key auto_increment,    country varchar(50),    city varchar(50) NULL default &#39;&#39;,    telcode int);`// 调用Exec函数执行sql语句，创建表_, err := pool.Exec(schema)//错误处理if err != nil &#123;    panic(err)&#125;</code></pre><p>插入数据的例子:</p><pre><code class="cpp">//定义sql语句, 通过占位符 问号（ ? ) 定义了三个参数countryCitySql := `INSERT INTO place (country, city, telcode) VALUES (?, ?, ?)`//通过Exec插入数据, 这里传入了三个参数，对应sql语句定义的三个问号所在的位置result1,err := db.Exec(countryCitySql, &quot;中国&quot;, &quot;香港&quot;, 852)//错误处理if err != nil &#123;    fmt.Println(&quot;插入失败!&quot;)&#125;//插入成功后，获取insert idid, _ := result.LastInsertId() </code></pre><pre><code class="cpp">//通过MustExec插入数据, 如果sql语句出错，则直接抛出panic错误result2 := db.MustExec(countryCitySql, &quot;South Africa&quot;, &quot;Johannesburg&quot;, 27)//插入成功后，获取插入idid2, _ := result2.LastInsertId() </code></pre><p>提示: mysql表如果存在自增id，则可以通过Exec返回的结果对象的LastInsertId，查询新插入数据的ID</p><h4 id="7-更新数据"><a href="#7-更新数据" class="headerlink" title="7.更新数据"></a>7.更新数据</h4><pre><code class="c">//定义sql语句，通过问号定义了三个参数sql := &quot;update place set telcode=?, city=? where id=?&quot;//通过Exec更新数据, 这里传入了三个参数，对应sql语句定义的三个问号所在的位置result1,err := db.Exec(sql, 100, &quot;香港&quot;, 1)//错误处理if err != nil &#123;    fmt.Println(&quot;更新失败!&quot;)&#125;//查询更新影响行数rowsAffected, _ := result1.RowsAffected()</code></pre><h4 id="8-查询数据"><a href="#8-查询数据" class="headerlink" title="8.查询数据"></a>8.查询数据</h4><p>8.1.通过Get和Select函数查询数据<br>Get函数主要用于查询一条记录，Select用于查询多条记录。</p><p>例子:</p><pre><code class="c">//定义保存查询结果的struct变量p := Place&#123;&#125;// 查询一条记录, 并且往sql语句传入参数 1，替换sql语句中的问号，最后将查询结果保存到struct对象中err = pool.Get(&amp;p, &quot;SELECT * FROM place LIMIT ?&quot;, 1)var total int//统计表的总记录数，并将查询结果保存到一个变量中err = pool.Get(&amp;total, &quot;SELECT count(*) FROM place&quot;)//定义一个保存多条记录的struct数组变量pp := []Place&#123;&#125;// 通过Select查询多条记录，并且将结果保存至pp变量中// 这里相当于将一条记录的字段值都映射到struct字段中err = pool.Select(&amp;pp, &quot;SELECT * FROM place WHERE telcode &gt; ?&quot;, 50)var names []string// 通过Select查询多条记录，并且将结果保存至names变量中// 这里仅查询一个字段err = pool.Select(&amp;names, &quot;SELECT name FROM place LIMIT 10&quot;) </code></pre><p>8.2.通过Queryx和QueryRowx查询数据<br>相对于Get和Select函数，Queryx和QueryRowx函数要繁琐一些。<br>Queryx可以用于查询多条记录，QueryRowx函数用于查询一条记录。</p><p>Queryx例子1</p><pre><code class="c">// 查询所有的数据，这里返回的是sqlx.Rows对象rows, err := pool.Queryx(&quot;SELECT country, city, telcode FROM place&quot;)//错误检测if err !=nil &#123;    panic(err)&#125;// 循环遍历每一行记录，rows.Next()函数用于判断是否还有下一行数据for rows.Next() &#123;    //这里定义三个变量用于接收每一行数据    var country string    var city    string    var telcode int    //调用Scan函数，将当记录的数据保存到变量中，这里参数的顺序跟上面sql语句中select后面的字段顺序一致。    err = rows.Scan(&amp;country, &amp;city, &amp;telcode)&#125;</code></pre><p>Queryx例子2, 将每一行记录保存到struct/map/数组变量中<br>Rows对象支持将每一行的数据保存到struct、map或者数组中。</p><pre><code class="c">//定义保存数据的结构体， 默认struct字段名（小写）跟表的字段名一致。type Place struct &#123;    Country       string    //因为city字段允许null，所以这里可以使用sql.NullString类型    City          sql.NullString     //如果struct字段名跟表的字段名不一样，可以通过db标签设置数据库字段名    TelephoneCode int `db:&quot;telcode&quot;`&#125;//查询数据rows, err := pool.Queryx(&quot;SELECT * FROM place&quot;)//遍历数据for rows.Next() &#123;    //下面演示如何将数据保存到struct、map和数组中    //定义struct对象    var p Place    //定义map类型    m := make(map[string]interface&#123;&#125;)    //定义slice类型    s := make([]interface&#123;&#125;, 0)    //使用StructScan函数将当前记录的数据保存到struct对象中    err = rows.StructScan(&amp;p)    //保存到map    err = rows.MapScan(&amp;m)    //保存到数组    err = rows.SliceScan(&amp;s)&#125;</code></pre><p>QueryRowx例子</p><pre><code class="c">QueryRowx操作跟Queryx类似，区别就是返回一行数据//查询数据row, err := pool.QueryRowx(&quot;SELECT country, city, telcode FROM place where id = ?&quot;, 1)//定义保存数据的结构体， 默认struct字段名（小写）跟表的字段名一致。type Place struct &#123;    Country       string    City          sql.NullString     Telcode       int &#125;var p Place//使用StructScan函数将当前记录的数据保存到struct对象中err = row.StructScan(&amp;p)提示: sqlx.Row跟sqlx.Rows对象获取数据的方式一样，支持将数据保存到map,slice,struct中，可以参考上面Queryx的例子。9.删除数据//定义sql语句，通过问号定义了一个参数sql := &quot;delete from place where id=?&quot;//通过Exec删除数据, 这里传入了一个参数，对应sql语句定义的问号所在的位置result1,err := pool.Exec(sql, 1)//获取删除影响行数rowsAffected, _ := result1.RowsAffected()//错误处理if err != nil &#123;    fmt.Println(&quot;更新失败!&quot;)&#125;10.事务处理sqlx使用mysql事务的格式://开始一个事务，返回一个事务对象txtx, err := pool.Beginx()//使用事务对象tx, 执行事务err = tx.Queryx(...)err = tx.Exec(...)err = tx.Exec(...)if err != nil &#123;    //回滚事务    tx.Rollback()&#125;//提交事务err = tx.Commit()提示：注意上面的事务格式，使用的是事务对象tx执行sql，而不是数据库对象，数据库对象执行sql每次都会申请一个新的数据库连接，会导致事务无效。mysql事务例子://开始一个事务，返回一个事务对象txtx, err := pool.Beginx()//执行事务err1 = tx.Exec(&quot;delete from place where id=?&quot;, 1)err2 = tx.Exec(&quot;delete from place where id=?&quot;, 2)if err1 != nil || err2 != nil &#123;    //回滚事务    tx.Rollback()&#125;//提交事务tx.Commit()</code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://segmentfault.com/a/1190000022623847?utm_source=tag-newest">golang使用mysql实例和第三方库Gendry</a><br><a href="https://segmentfault.com/a/1190000023113675?utm_source=sf-similar-article">Go操作sqlx</a><br><a href="https://segmentfault.com/a/1190000038632750?utm_source=sf-similar-article">GO语言Gin框架数据库操作（原生、xorm、gorm）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;sqlx是Go数据库操作包，它在database/sql包的基础上增加了更加高效的数据库操作函数，也就是说使用sqlx操作数据库比使用database/sql更加方便。&lt;/p&gt;
&lt;h4 id=&quot;1-sqlx关键概念介绍&quot;&gt;&lt;a href=&quot;#1-sqlx关键概念介绍&quot; cl</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="sqlx" scheme="https://ysluckly.github.io/tags/sqlx/"/>
    
    <category term="Go数据库" scheme="https://ysluckly.github.io/tags/Go%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>VMware Pro 14 安装 Ubuntu 18.04 详细教程</title>
    <link href="https://ysluckly.github.io/2021/10/24/linux/"/>
    <id>https://ysluckly.github.io/2021/10/24/linux/</id>
    <published>2021-10-24T02:10:45.000Z</published>
    <updated>2022-02-20T13:20:27.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-下载安装-VMware-Workstation-Pro-14"><a href="#1-下载安装-VMware-Workstation-Pro-14" class="headerlink" title="1.下载安装 VMware Workstation Pro 14"></a><font color=#FF0000>1.下载安装 VMware Workstation Pro 14</font></h1><p> 进入 <a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html">VMware 官网</a>或者在软件商店下载最新版VMware虚拟机并安装</p><p> <img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/01.jpg" alt="01"></p><h1 id="2-下载-Ubuntu-18-04-系统"><a href="#2-下载-Ubuntu-18-04-系统" class="headerlink" title="2.下载 Ubuntu 18.04 系统"></a><font color=#FF0000>2.下载 Ubuntu 18.04 系统</font></h1><p>  进入 <a href="https://www.ubuntu.com/">Ubuntu 官网</a>，下载最新版 Ubuntu 系统镜像</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/02.jpg" alt="02"><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/03.jpg" alt="03"></p><h1 id="3-在-VMware-中创建虚拟机"><a href="#3-在-VMware-中创建虚拟机" class="headerlink" title="3.在 VMware 中创建虚拟机"></a><font color=#FF0000>3.在 VMware 中创建虚拟机</font></h1><p>打开安装好的 VMware Workstation Pro 14，选择创建新的虚拟机<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/04.jpg" alt="04"></p><p>在新建虚拟机向导中选择自定义（高级）<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/05.jpg" alt="05"></p><p>默认直接下一步，直到出现下图，再选择稍后安装操作系统<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/06.png" alt="06"></p><p>选择客户机操作系统为 Linux ，如果你电脑是32位就选择 Ubuntu 版本，64位就选择 Ubuntu 64 位版本<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/07.png" alt="07"></p><p>更改虚拟机名称及存放位置<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/08.png" alt="08"></p><p>为虚拟机指定处理器数量，默认即可<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/09.png" alt="09"></p><p>为虚拟机分配内存，太大了可能会导致卡顿，太小了也不好，推荐内存大小即可<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/10.png" alt="10"></p><p>以下均选择默认即可<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/11.png" alt="11"><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/13.png" alt="13"><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/14.png" alt="14"></p><p>选择创建新虚拟磁盘<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/15.png" alt="15"></p><p>选择将虚拟磁盘储存为单个文件<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/16.png" alt="16"></p><p>默认下一步<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/17.png" alt="17"></p><p>点击完成<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/18.png" alt="18"></p><p>此时我们就可以在虚拟机左侧“我的计算机”下面看到刚刚创建的虚拟机 Ubuntu 64 位，单击 Ubuntu 64 位，选择“编辑虚拟机设置”， 再选择“CD/DVD(SATA)”，选择“使用ISO映像文件”，点击“浏览”，找到先前我们下载好的 Ubuntu 64 位镜像文件，点击“确定”<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/19.jpg" alt="19"><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/20.png" alt="20"></p><h1 id="4-在虚拟机上安装-Ubuntu-系统"><a href="#4-在虚拟机上安装-Ubuntu-系统" class="headerlink" title="4.在虚拟机上安装 Ubuntu 系统"></a><font color=#FF0000>4.在虚拟机上安装 Ubuntu 系统</font></h1><p>单击 Ubuntu 64 位，选择“开启此虚拟机”<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/21.jpg" alt="21"></p><p>来到欢迎界面，选择好语言，点击“安装 Ubuntu”<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/22.jpg" alt="22"></p><p>选择键盘布局为“汉语”<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/23.jpg" alt="23"></p><p>更新和其他软件默认选择即可<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/24.jpg" alt="24"></p><p>安装类型选择“清除整个磁盘并安装 Ubuntu”，PS: 因为我们是新安装的系统，且在虚拟机中，所以可以选择清除整个磁盘，这个操作不会清除你原来电脑里面的东西<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/25.jpg" alt="25"><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/26.jpg" alt="26"></p><p>地区随便，在中国就行，默认即可<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/27.jpg" alt="27"></p><p>之后设置计算机名，密码<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/28.jpg" alt="28"></p><p>点击继续稍等一会就安装完成啦<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/29.jpg" alt="29"></p><hr><h1 id="安装过程中可能会出现的一些问题"><a href="#安装过程中可能会出现的一些问题" class="headerlink" title="安装过程中可能会出现的一些问题"></a><center><font color=#FF0000 size=7>安装过程中可能会出现的一些问题</font></center></h1><hr><h1 id="1-在虚拟机上安装-Ubuntu-系统的过程中卡死不动"><a href="#1-在虚拟机上安装-Ubuntu-系统的过程中卡死不动" class="headerlink" title=" 1.在虚拟机上安装 Ubuntu 系统的过程中卡死不动"></a><font color=#FF0000> 1.在虚拟机上安装 Ubuntu 系统的过程中卡死不动</font></h1><p> 解决方法：关闭网络，重新安装即可</p><hr><h1 id="2-Ubuntu-不能全屏显示"><a href="#2-Ubuntu-不能全屏显示" class="headerlink" title=" 2.Ubuntu 不能全屏显示"></a><font color=#FF0000> 2.Ubuntu 不能全屏显示</font></h1><p>解决方法：<br>方法①：安装 open-vm-tools：</p><pre><code class="vim">sudo apt-get install open-vm-tools </code></pre><p>然后执行：</p><pre><code class="vim">sudo apt-get install open-vm* </code></pre><p>重启即可全屏显示</p><p>方法②：在终端输入<code>xrandr</code>，并回车，我们就可以看到很多可以修改的分辨率，选择好分辨率后，比如我们要修改分辨率为 1920x1440 ，则在终端输入 <code>xrandr -s 1920x1440</code>，回车即可，注意 1920x1440 中间是<font color=#FF0000>小写字母 x</font>，本人亲测此方法并不是很完美，不能完全适应屏幕<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/30.jpg" alt="30"></p><p>方法③：安装 VMware Tools：<br>1、进入 Ubuntu 系统后，点击虚拟机上的【虚拟机】—＞【安装 VMware Tools】，回到桌面即可看到一个 VMware Tools 的 图标<br>2、复制 VMwareTools-10.0.10-4301679.tar.gz（版本根据自己的实际情况而定）到 home 目录下， 用命令 <code>tar -xzvf  VMwareTools-10.0.10-4301679.tar.gz</code> 进行解压<br>3、解压后 cd vmware_tools_distrib，打开终端<br>4、输入“sudo ./vmware-install.pl”，输入用户密码后开始安装<br>5、接下来会有很多地方需要你按 Enter或者 Yes<br>6、当你看到出现 <code>—the vmware team</code> 的字样后就可以关闭窗口了，此时窗口就会自动全屏了，如果没有全屏，重启过后就可以了<br>7、若还没有全屏显示，则将虚拟机的【查看】—&gt;【自动调整大小】—&gt;【自适应客户机】，都选上，即可实现全屏</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-下载安装-VMware-Workstation-Pro-14&quot;&gt;&lt;a href=&quot;#1-下载安装-VMware-Workstation-Pro-14&quot; class=&quot;headerlink&quot; title=&quot;1.下载安装 VMware Workstation Pr</summary>
      
    
    
    
    <category term="运维" scheme="https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="linux" scheme="https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/linux/"/>
    
    
    <category term="VMware" scheme="https://ysluckly.github.io/tags/VMware/"/>
    
    <category term="Ubuntu" scheme="https://ysluckly.github.io/tags/Ubuntu/"/>
    
  </entry>
  
</feed>
