<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>码农印象</title>
  
  
  <link href="https://ysluckly.github.io/atom.xml" rel="self"/>
  
  <link href="https://ysluckly.github.io/"/>
  <updated>2022-02-20T13:36:40.177Z</updated>
  <id>https://ysluckly.github.io/</id>
  
  <author>
    <name>码农印象</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go Mock (gomock)简明教程</title>
    <link href="https://ysluckly.github.io/2022/02/16/go/"/>
    <id>https://ysluckly.github.io/2022/02/16/go/</id>
    <published>2022-02-16T13:59:10.000Z</published>
    <updated>2022-02-20T13:36:40.177Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114756.jpg" alt="gomock"></p><h2 id="1-gomock-简介"><a href="#1-gomock-简介" class="headerlink" title="1 gomock 简介"></a>1 gomock 简介</h2><p>上一篇文章 <a href="https://geektutu.com/post/quick-go-test.html">Go Test 单元测试简明教程</a> 介绍了 Go 语言中单元测试的常用方法，包括子测试(subtests)、表格驱动测试(table-driven tests)、帮助函数(helpers)、网络测试和基准测试(Benchmark)等。这篇文章介绍一种新的测试方法，mock/stub 测试，当待测试的函数/对象的依赖关系很复杂，并且有些依赖不能直接创建，例如数据库连接、文件I/O等。这种场景就非常适合使用 mock/stub 测试。简单来说，就是用 mock 对象模拟依赖项的行为。</p><blockquote><p>GoMock is a mocking framework for the Go programming language. It integrates well with Go’s built-in testing package, but can be used in other contexts too.</p></blockquote><p><a href="https://github.com/golang/mock">gomock</a> 是官方提供的 mock 框架，同时还提供了 mockgen 工具用来辅助生成测试代码。</p><p>使用如下命令即可安装：</p><pre><code class="bash">go get -u github.com/golang/mock/gomockgo get -u github.com/golang/mock/mockgen</code></pre><h2 id="2-一个简单的-Demo"><a href="#2-一个简单的-Demo" class="headerlink" title="2 一个简单的 Demo"></a>2 一个简单的 Demo</h2><pre><code class="go">// db.gotype DB interface &#123;    Get(key string) (int, error)&#125;func GetFromDB(db DB, key string) int &#123;    if value, err := db.Get(key); err == nil &#123;        return value    &#125;    return -1&#125;</code></pre><p>假设 <code>DB</code> 是代码中负责与数据库交互的部分(在这里用 map 模拟)，测试用例中不能创建真实的数据库连接。这个时候，如果我们需要测试 <code>GetFromDB</code> 这个函数内部的逻辑，就需要 mock 接口 <code>DB</code>。</p><p>第一步：使用 <code>mockgen</code> 生成 <code>db_mock.go</code>。一般传递三个参数。包含需要被mock的接口得到源文件<code>source</code>，生成的目标文件<code>destination</code>，包名<code>package</code>。</p><pre><code class="bash">$ mockgen -source=db.go -destination=db_mock.go -package=main</code></pre><p>第二步：新建 <code>db_test.go</code>，写测试用例。</p><pre><code class="go">func TestGetFromDB(t *testing.T) &#123;    ctrl := gomock.NewController(t)    defer ctrl.Finish() // 断言 DB.Get() 方法是否被调用    m := NewMockDB(ctrl)    m.EXPECT().Get(gomock.Eq(&quot;Tom&quot;)).Return(100, errors.New(&quot;not exist&quot;))    if v := GetFromDB(m, &quot;Tom&quot;); v != -1 &#123;        t.Fatal(&quot;expected -1, but got&quot;, v)    &#125;&#125;</code></pre><ul><li>这个测试用例有2个目的，一是使用 <code>ctrl.Finish()</code> 断言 <code>DB.Get()</code> 被是否被调用，如果没有被调用，后续的 mock 就失去了意义；</li><li>二是测试方法 <code>GetFromDB()</code> 的逻辑是否正确(如果 <code>DB.Get()</code> 返回 error，那么 <code>GetFromDB()</code> 返回 -1)。</li><li><code>NewMockDB()</code> 的定义在 <code>db_mock.go</code> 中，由 mockgen 自动生成。</li></ul><p>最终的代码结构如下：</p><pre><code class="bash">project/    |--db.go    |--db_mock.go // generated by mockgen    |--db_test.go</code></pre><p>执行测试：</p><pre><code class="bash">$ go test . -cover -v=== RUN   TestGetFromDB--- PASS: TestGetFromDB (0.00s)PASScoverage: 81.2% of statementsok      example 0.008s  coverage: 81.2% of statements</code></pre><h2 id="3-打桩-stubs"><a href="#3-打桩-stubs" class="headerlink" title="3 打桩(stubs)"></a>3 打桩(stubs)</h2><p>在上面的例子中，当 <code>Get()</code> 的参数为 Tom，则返回 error，这称之为<code>打桩(stub)</code>，有明确的参数和返回值是最简单打桩方式。除此之外，检测调用次数、调用顺序，动态设置返回值等方式也经常使用。</p><p>3.1 参数(Eq, Any, Not, Nil)</p><pre><code class="go">m.EXPECT().Get(gomock.Eq(&quot;Tom&quot;)).Return(0, errors.New(&quot;not exist&quot;))m.EXPECT().Get(gomock.Any()).Return(630, nil)m.EXPECT().Get(gomock.Not(&quot;Sam&quot;)).Return(0, nil) m.EXPECT().Get(gomock.Nil()).Return(0, errors.New(&quot;nil&quot;)) </code></pre><ul><li><code>Eq(value)</code> 表示与 value 等价的值。</li><li><code>Any()</code> 可以用来表示任意的入参。</li><li><code>Not(value)</code> 用来表示非 value 以外的值。</li><li><code>Nil()</code> 表示 None 值</li></ul><p>3.2 返回值(Return, DoAndReturn)</p><pre><code class="go">m.EXPECT().Get(gomock.Not(&quot;Sam&quot;)).Return(0, nil)m.EXPECT().Get(gomock.Any()).Do(func(key string) &#123;    t.Log(key)&#125;)m.EXPECT().Get(gomock.Any()).DoAndReturn(func(key string) (int, error) &#123;    if key == &quot;Sam&quot; &#123;        return 630, nil    &#125;    return 0, errors.New(&quot;not exist&quot;)&#125;)</code></pre><ul><li><code>Return</code> 返回确定的值</li><li><code>Do</code> Mock 方法被调用时，要执行的操作吗，忽略返回值。</li><li><code>DoAndReturn</code> 可以动态地控制返回值。</li></ul><p>3.3 调用次数(Times)</p><pre><code class="go">func TestGetFromDB(t *testing.T) &#123;    ctrl := gomock.NewController(t)    defer ctrl.Finish()    m := NewMockDB(ctrl)    m.EXPECT().Get(gomock.Not(&quot;Sam&quot;)).Return(0, nil).Times(2)    GetFromDB(m, &quot;ABC&quot;)    GetFromDB(m, &quot;DEF&quot;)&#125;</code></pre><ul><li><code>Times()</code> 断言 Mock 方法被调用的次数。</li><li><code>MaxTimes()</code> 最大次数。</li><li><code>MinTimes()</code> 最小次数。</li><li><code>AnyTimes()</code> 任意次数（包括 0 次）。</li></ul><p>3.4 调用顺序(InOrder)</p><pre><code class="go">func TestGetFromDB(t *testing.T) &#123;    ctrl := gomock.NewController(t)    defer ctrl.Finish() // 断言 DB.Get() 方法是否被调用    m := NewMockDB(ctrl)    o1 := m.EXPECT().Get(gomock.Eq(&quot;Tom&quot;)).Return(0, errors.New(&quot;not exist&quot;))    o2 := m.EXPECT().Get(gomock.Eq(&quot;Sam&quot;)).Return(630, nil)    gomock.InOrder(o1, o2)    GetFromDB(m, &quot;Tom&quot;)    GetFromDB(m, &quot;Sam&quot;)&#125;</code></pre><h2 id="4-如何编写可-mock-的代码"><a href="#4-如何编写可-mock-的代码" class="headerlink" title="4 如何编写可 mock 的代码"></a>4 如何编写可 mock 的代码</h2><p>写可测试的代码与写好测试用例是同等重要的，如何写可 mock 的代码呢？</p><ul><li>mock 作用的是接口，因此将依赖抽象为接口，而不是直接依赖具体的类。</li><li>不直接依赖的实例，而是使用依赖注入降低耦合性。</li></ul><blockquote><p>在软件工程中，依赖注入的意思为，给予调用方它所需要的事物。 “依赖”是指可被方法调用的事物。依赖注入形式下，调用方不再直接指使用“依赖”，取而代之是“注入” 。“注入”是指将“依赖”传递给调用方的过程。在“注入”之后，调用方才会调用该“依赖”。传递依赖给调用方，而不是让让调用方直接获得依赖，这个是该设计的根本需求。<br>– <a href="https://zh.wikipedia.org/zh-cn/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">依赖注入 - Wikipedia</a></p></blockquote><p>如果 <code>GetFromDB()</code> 方法长这个样子</p><pre><code class="go">func GetFromDB(key string) int &#123;    db := NewDB()    if value, err := db.Get(key); err == nil &#123;        return value    &#125;    return -1&#125;</code></pre><p>对 <code>DB</code> 接口的 mock 并不能作用于 <code>GetFromDB()</code> 内部，这样写是没办法进行测试的。那如果将接口 <code>db DB</code> 通过参数传递到 <code>GetFromDB()</code>，那么就可以轻而易举地传入 Mock 对象了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114756.jpg&quot; alt=&quot;gomock&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-gomock-简介&quot;&gt;&lt;a href=&quot;#1-go</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Go语言" scheme="https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
    <category term="单元测试" scheme="https://ysluckly.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    <category term="mock框架" scheme="https://ysluckly.github.io/tags/mock%E6%A1%86%E6%9E%B6/"/>
    
    <category term="stub" scheme="https://ysluckly.github.io/tags/stub/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言简明教程</title>
    <link href="https://ysluckly.github.io/2022/02/16/go/"/>
    <id>https://ysluckly.github.io/2022/02/16/go/</id>
    <published>2022-02-16T13:59:10.000Z</published>
    <updated>2022-02-20T13:35:38.378Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114701.jpg" alt="Golang中文教程"></p><blockquote><p>Go（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。 —— <a href="https://zh.wikipedia.org/wiki/Go">Go - wikipedia.org</a></p></blockquote><h2 id="1-Go-安装"><a href="#1-Go-安装" class="headerlink" title="1 Go 安装"></a>1 Go 安装</h2><p>最新版本下载地址<a href="https://golang.org/dl/">官方下载 golang.org</a>，当前是 1.13.6。如无法访问，可以在 <strong>studygolang.com/dl</strong> 下载</p><p>使用 Linux，可以用如下方式快速安装。</p><pre><code class="bash">$ wget https://studygolang.com/dl/golang/go1.13.6.linux-amd64.tar.gz$ tar -zxvf go1.13.6.linux-amd64.tar.gz$ sudo mv go /usr/local/$ go versiongo version go1.13.6 linux/amd64</code></pre><p>从 <code>Go 1.11</code> 版本开始，Go 提供了 <a href="https://github.com/golang/go/wiki/Modules">Go Modules</a> 的机制，推荐设置以下环境变量，第三方包的下载将通过国内镜像，避免出现官方网址被屏蔽的问题。</p><pre><code class="bash">$ go env -w GOPROXY=https://goproxy.cn,direct</code></pre><p>或在 <code>~/.profile</code> 中设置环境变量</p><pre><code class="bash">export GOPROXY=https://goproxy.cn</code></pre><h2 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2 Hello World"></a>2 Hello World</h2><p>新建一个文件 <code>main.go</code>，写入</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    fmt.Println(&quot;Hello World!&quot;)&#125;</code></pre><p>执行<code>go run main.go</code> 或 <code>go run .</code>，将会输出</p><pre><code class="bash">$ go run .Hello World!</code></pre><blockquote><p>如果强制启用了 Go Modules 机制，即环境变量中设置了 GO111MODULE=on，则需要先初始化模块 go mod init hello<br>否则会报错误：go: cannot find main module; see ‘go help modules’</p></blockquote><p>我们的第一个 Go 程序就完成了，接下来我们逐行来解读这个程序：</p><ul><li>package main：声明了 main.go 所在的包，Go 语言中使用包来组织代码。一般一个文件夹即一个包，包内可以暴露类型或方法供其他包使用。</li><li>import “fmt”：fmt 是 Go 语言的一个标准库/包，用来处理标准输入输出。</li><li>func main：main 函数是整个程序的入口，main 函数所在的包名也必须为 <code>main</code>。</li><li>fmt.Println(“Hello World!”)：调用 fmt 包的 Println 方法，打印出 “Hello World!”</li></ul><p>go run main.go，其实是 2 步：</p><ul><li>go build main.go：编译成二进制可执行程序</li><li>./main：执行该程序</li></ul><h2 id="3-变量与内置数据类型"><a href="#3-变量与内置数据类型" class="headerlink" title="3 变量与内置数据类型"></a>3 变量与内置数据类型</h2><h3 id="3-1-变量-Variable"><a href="#3-1-变量-Variable" class="headerlink" title="3.1 变量(Variable)"></a>3.1 变量(Variable)</h3><p>Go 语言是静态类型的，变量声明时必须明确变量的类型。Go 语言与其他语言显著不同的一个地方在于，Go 语言的类型在变量后面。比如 java 中，声明一个整体一般写成 <code>int a = 1</code>，在 Go 语言中，需要这么写：</p><pre><code class="go">var a int // 如果没有赋值，默认为0var a int = 1 // 声明时赋值var a = 1 // 声明时赋值</code></pre><p><code>var a = 1</code>，因为 1 是 int 类型的，所以赋值时，a 自动被确定为 int 类型，所以类型名可以省略不写，这种方式还有一种更简单的表达：</p><pre><code class="go">a := 1msg := &quot;Hello World!&quot;</code></pre><h3 id="3-2-简单类型"><a href="#3-2-简单类型" class="headerlink" title="3.2 简单类型"></a>3.2 简单类型</h3><p>空值：nil</p><p>整型类型： int(取决于操作系统), int8, int16, int32, int64, uint8, uint16, …</p><p>浮点数类型：float32, float64</p><p>字节类型：byte (等价于uint8)</p><p>字符串类型：string</p><p>布尔值类型：boolean，(true 或 false)</p><pre><code class="go">var a int8 = 10var c1 byte = &#39;a&#39;var b float32 = 12.2var msg = &quot;Hello World&quot;ok := false</code></pre><h3 id="3-3-字符串"><a href="#3-3-字符串" class="headerlink" title="3.3 字符串"></a>3.3 字符串</h3><p>在 Go 语言中，字符串使用 UTF8 编码，UTF8 的好处在于，如果基本是英文，每个字符占 1 byte，和 ASCII 编码是一样的，非常节省空间，如果是中文，一般占3字节。包含中文的字符串的处理方式与纯 ASCII 码构成的字符串有点区别。</p><p>我们看下面的例子：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;reflect&quot;)func main() &#123;    str1 := &quot;Golang&quot;    str2 := &quot;Go语言&quot;    fmt.Println(reflect.TypeOf(str2[2]).Kind()) // uint8    fmt.Println(str1[2], string(str1[2]))       // 108 l    fmt.Printf(&quot;%d %c\n&quot;, str2[2], str2[2])     // 232 è    fmt.Println(&quot;len(str2)：&quot;, len(str2))       // len(str2)： 8&#125;</code></pre><ul><li>reflect.TypeOf().Kind() 可以知道某个变量的类型，我们可以看到，字符串是以 byte 数组形式保存的，类型是 uint8，占1个 byte，打印时需要用 string 进行类型转换，否则打印的是编码值。</li><li>因为字符串是以 byte 数组的形式存储的，所以，<code>str2[2]</code> 的值并不等于<code>语</code>。str2 的长度 <code>len(str2)</code> 也不是 4，而是 8（ Go 占 2 byte，语言占 6 byte）。</li></ul><p>正确的处理方式是将 string 转为 rune 数组</p><pre><code class="go">str2 := &quot;Go语言&quot;runeArr := []rune(str2)fmt.Println(reflect.TypeOf(runeArr[2]).Kind()) // int32fmt.Println(runeArr[2], string(runeArr[2]))    // 35821 语fmt.Println(&quot;len(runeArr)：&quot;, len(runeArr))    // len(runeArr)： 4</code></pre><p>转换成 <code>[]rune</code> 类型后，字符串中的每个字符，无论占多少个字节都用 int32 来表示，因而可以正确处理中文。</p><h3 id="3-4-数组-array-与切片-slice"><a href="#3-4-数组-array-与切片-slice" class="headerlink" title="3.4 数组(array)与切片(slice)"></a>3.4 数组(array)与切片(slice)</h3><p>声明数组</p><pre><code class="go">var arr [5]int     // 一维var arr2 [5][5]int // 二维 </code></pre><p>声明时初始化</p><pre><code class="go">var arr = [5]int&#123;1, 2, 3, 4, 5&#125;// 或 arr := [5]int&#123;1, 2, 3, 4, 5&#125;</code></pre><p>使用 <code>[]</code> 索引/修改数组</p><pre><code class="go">arr := [5]int&#123;1, 2, 3, 4, 5&#125;for i := 0; i &lt; len(arr); i++ &#123;    arr[i] += 100&#125;fmt.Println(arr)  // [101 102 103 104 105]</code></pre><p>数组的长度不能改变，如果想拼接2个数组，或是获取子数组，需要使用切片。切片是数组的抽象。 切片使用数组作为底层结构。切片包含三个组件：容量，长度和指向底层数组的指针,切片可以随时进行扩展</p><p>声明切片：</p><pre><code class="go">slice1 := make([]float32, 0) // 长度为0的切片slice2 := make([]float32, 3, 5) // [0 0 0] 长度为3容量为5的切片fmt.Println(len(slice2), cap(slice2)) // 3 5</code></pre><p>使用切片：</p><pre><code class="go">// 添加元素，切片容量可以根据需要自动扩展slice2 = append(slice2, 1, 2, 3, 4) // [0, 0, 0, 1, 2, 3, 4]fmt.Println(len(slice2), cap(slice2)) // 7 12// 子切片 [start, end)sub1 := slice2[3:] // [1 2 3 4]sub2 := slice2[:3] // [0 0 0]sub3 := slice2[1:4] // [0 0 1]// 合并切片combined := append(sub1, sub2...) // [1, 2, 3, 4, 0, 0, 0]</code></pre><ul><li>声明切片时可以为切片设置容量大小，为切片预分配空间。在实际使用的过程中，如果容量不够，切片容量会自动扩展。</li><li><code>sub2...</code> 是切片解构的写法，将切片解构为 N 个独立的元素。</li></ul><h3 id="3-5-字典-键值对，map"><a href="#3-5-字典-键值对，map" class="headerlink" title="3.5 字典(键值对，map)"></a>3.5 字典(键值对，map)</h3><p>map 类似于 java 的 HashMap，Python的字典(dict)，是一种存储键值对(Key-Value)的数据解构。使用方式和其他语言几乎没有区别。</p><pre><code class="go">// 仅声明m1 := make(map[string]int)// 声明时初始化m2 := map[string]string&#123;    &quot;Sam&quot;: &quot;Male&quot;,    &quot;Alice&quot;: &quot;Female&quot;,&#125;// 赋值/修改m1[&quot;Tom&quot;] = 18</code></pre><h3 id="3-6-指针-pointer"><a href="#3-6-指针-pointer" class="headerlink" title="3.6 指针(pointer)"></a>3.6 指针(pointer)</h3><p>指针即某个值的地址，类型定义时使用符号<code>*</code>，对一个已经存在的变量，使用 <code>&amp;</code> 获取该变量的地址。</p><pre><code class="go">str := &quot;Golang&quot;var p *string = &amp;str // p 是指向 str 的指针*p = &quot;Hello&quot;fmt.Println(str) // Hello 修改了 p，str 的值也发生了改变</code></pre><p>一般来说，指针通常在函数传递参数，或者给某个类型定义新的方法时使用。Go 语言中，参数是按值传递的，如果不使用指针，函数内部将会拷贝一份参数的副本，对参数的修改并不会影响到外部变量的值。如果参数使用指针，对参数的传递将会影响到外部变量。</p><p>例如：</p><pre><code class="go">func add(num int) &#123;    num += 1&#125;func realAdd(num *int) &#123;    *num += 1&#125;func main() &#123;    num := 100    add(num)    fmt.Println(num)  // 100，num 没有变化    realAdd(&amp;num)    fmt.Println(num)  // 101，指针传递，num 被修改&#125;</code></pre><h2 id="4-流程控制-if-for-switch"><a href="#4-流程控制-if-for-switch" class="headerlink" title="4 流程控制(if, for, switch)"></a>4 流程控制(if, for, switch)</h2><h3 id="4-1-条件语句-if-else"><a href="#4-1-条件语句-if-else" class="headerlink" title="4.1 条件语句 if else"></a>4.1 条件语句 if else</h3><pre><code class="go">age := 18if age &lt; 18 &#123;    fmt.Printf(&quot;Kid&quot;)&#125; else &#123;    fmt.Printf(&quot;Adult&quot;)&#125;// 可以简写为：if age := 18; age &lt; 18 &#123;    fmt.Printf(&quot;Kid&quot;)&#125; else &#123;    fmt.Printf(&quot;Adult&quot;)&#125;</code></pre><h3 id="4-2-switch"><a href="#4-2-switch" class="headerlink" title="4.2 switch"></a>4.2 switch</h3><pre><code class="go">type Gender int8const (    MALE   Gender = 1    FEMALE Gender = 2)gender := MALEswitch gender &#123;case FEMALE:    fmt.Println(&quot;female&quot;)case MALE:    fmt.Println(&quot;male&quot;)default:    fmt.Println(&quot;unknown&quot;)&#125;// male</code></pre><ul><li>在这里，使用了<code>type</code> 关键字定义了一个新的类型 Gender。</li><li>使用 const 定义了 MALE 和 FEMALE 2 个常量，Go 语言中没有枚举(enum)的概念，一般可以用常量的方式来模拟枚举。</li><li>和其他语言不同的地方在于，Go 语言的 switch 不需要 break，匹配到某个 case，执行完该 case 定义的行为后，默认不会继续往下执行。如果需要继续往下执行，需要使用 fallthrough，例如：</li></ul><pre><code class="go">switch gender &#123;case FEMALE:    fmt.Println(&quot;female&quot;)    fallthroughcase MALE:    fmt.Println(&quot;male&quot;)    fallthroughdefault:    fmt.Println(&quot;unknown&quot;)&#125;// 输出结果// male// unknown</code></pre><h3 id="4-3-for-循环"><a href="#4-3-for-循环" class="headerlink" title="4.3 for 循环"></a>4.3 for 循环</h3><p>一个简单的累加的例子，break 和 continue 的用法与其他语言没有区别。</p><pre><code class="go">sum := 0for i := 0; i &lt; 10; i++ &#123;    if sum &gt; 50 &#123;        break    &#125;    sum += i&#125;</code></pre><p>对数组(arr)、切片(slice)、字典(map) 使用 for range 遍历：</p><pre><code class="go">nums := []int&#123;10, 20, 30, 40&#125;for i, num := range nums &#123;    fmt.Println(i, num)&#125;// 0 10// 1 20// 2 30// 3 40m2 := map[string]string&#123;    &quot;Sam&quot;:   &quot;Male&quot;,    &quot;Alice&quot;: &quot;Female&quot;,&#125;for key, value := range m2 &#123;    fmt.Println(key, value)&#125;// Sam Male// Alice Female</code></pre><h2 id="5-函数-functions"><a href="#5-函数-functions" class="headerlink" title="5 函数(functions)"></a>5 函数(functions)</h2><h3 id="5-1-参数与返回值"><a href="#5-1-参数与返回值" class="headerlink" title="5.1 参数与返回值"></a>5.1 参数与返回值</h3><p>一个典型的函数定义如下，使用关键字 <code>func</code>，参数可以有多个，返回值也支持有多个。特别地，<code>package main</code> 中的<code>func main()</code> 约定为可执行程序的入口。</p><pre><code class="go">func funcName(param1 Type1, param2 Type2, ...) (return1 Type3, ...) &#123;    // body&#125;</code></pre><p>例如，实现2个数的加法（一个返回值）和除法（多个返回值）：</p><pre><code class="go">func add(num1 int, num2 int) int &#123;    return num1 + num2&#125;func div(num1 int, num2 int) (int, int) &#123;    return num1 / num2, num1 % num2&#125;func main() &#123;    quo, rem := div(100, 17)    fmt.Println(quo, rem)     // 5 15    fmt.Println(add(100, 17)) // 117&#125;</code></pre><p>也可以给返回值命名，简化 return，例如 add 函数可以改写为</p><pre><code class="go">func add(num1 int, num2 int) (ans int) &#123;    ans = num1 + num2    return&#125;</code></pre><h3 id="5-2-错误处理-error-handling"><a href="#5-2-错误处理-error-handling" class="headerlink" title="5.2 错误处理(error handling)"></a>5.2 错误处理(error handling)</h3><p>如果函数实现过程中，如果出现不能处理的错误，可以返回给调用者处理。比如我们调用标准库函数<code>os.Open</code>读取文件，<code>os.Open</code> 有2个返回值，第一个是 <code>*File</code>，第二个是 <code>error</code>， 如果调用成功，error 的值是 nil，如果调用失败，例如文件不存在，我们可以通过 error 知道具体的错误信息。</p><pre><code class="go">import (    &quot;fmt&quot;    &quot;os&quot;)func main() &#123;    _, err := os.Open(&quot;filename.txt&quot;)    if err != nil &#123;        fmt.Println(err)    &#125;&#125;// open filename.txt: no such file or directory</code></pre><p>可以通过 <code>errorw.New</code> 返回自定义的错误</p><pre><code class="go">import (    &quot;errors&quot;    &quot;fmt&quot;)func hello(name string) error &#123;    if len(name) == 0 &#123;        return errors.New(&quot;error: name is null&quot;)    &#125;    fmt.Println(&quot;Hello,&quot;, name)    return nil&#125;func main() &#123;    if err := hello(&quot;&quot;); err != nil &#123;        fmt.Println(err)    &#125;&#125;// error: name is null</code></pre><p>error 往往是能预知的错误，但是也可能出现一些不可预知的错误，例如数组越界，这种错误可能会导致程序非正常退出，在 Go 语言中称之为 panic。</p><pre><code class="go">func get(index int) int &#123;    arr := [3]int&#123;2, 3, 4&#125;    return arr[index]&#125;func main() &#123;    fmt.Println(get(5))    fmt.Println(&quot;finished&quot;)&#125;</code></pre><pre><code class="bash">$ go run .panic: runtime error: index out of range [5] with length 3goroutine 1 [running]:exit status 2</code></pre><p>在 Python、Java 等语言中有 <code>try...catch</code> 机制，在 <code>try</code> 中捕获各种类型的异常，在 <code>catch</code> 中定义异常处理的行为。Go 语言也提供了类似的机制 <code>defer</code> 和 <code>recover</code>。</p><pre><code class="go">func get(index int) (ret int) &#123;    defer func() &#123;        if r := recover(); r != nil &#123;            fmt.Println(&quot;Some error happened!&quot;, r)            ret = -1        &#125;    &#125;()    arr := [3]int&#123;2, 3, 4&#125;    return arr[index]&#125;func main() &#123;    fmt.Println(get(5))    fmt.Println(&quot;finished&quot;)&#125;</code></pre><pre><code class="bash">$ go run .Some error happened! runtime error: index out of range [5] with length 3-1finished</code></pre><ul><li>在 get 函数中，使用 defer 定义了异常处理的函数，在协程退出前，会执行完 defer 挂载的任务。因此如果触发了 panic，控制权就交给了 defer。</li><li>在 defer 的处理逻辑中，使用 recover，使程序恢复正常，并且将返回值设置为 -1，在这里也可以不处理返回值，如果不处理返回值，返回值将被置为默认值 0。</li></ul><h2 id="6-结构体，方法和接口"><a href="#6-结构体，方法和接口" class="headerlink" title="6 结构体，方法和接口"></a>6 结构体，方法和接口</h2><h3 id="6-1-结构体-struct-和方法-methods"><a href="#6-1-结构体-struct-和方法-methods" class="headerlink" title="6.1 结构体(struct) 和方法(methods)"></a>6.1 结构体(struct) 和方法(methods)</h3><p>结构体类似于其他语言中的 class，可以在结构体中定义多个字段，为结构体实现方法，实例化等。接下来我们定义一个结构体 Student，并为 Student 添加 name，age 字段，并实现 <code>hello()</code> 方法。</p><pre><code class="go">type Student struct &#123;    name string    age  int&#125;func (stu *Student) hello(person string) string &#123;    return fmt.Sprintf(&quot;hello %s, I am %s&quot;, person, stu.name)&#125;func main() &#123;    stu := &amp;Student&#123;        name: &quot;Tom&quot;,    &#125;    msg := stu.hello(&quot;Jack&quot;)    fmt.Println(msg) // hello Jack, I am Tom&#125;</code></pre><ul><li>使用 <code>Student&#123;field: value, ...&#125;</code>的形式创建 Student 的实例，字段不需要每个都赋值，没有显性赋值的变量将被赋予默认值，例如 age 将被赋予默认值 0。</li><li>实现方法与实现函数的区别在于，<code>func</code> 和函数名<code>hello</code> 之间，加上该方法对应的实例名 <code>stu</code> 及其类型 <code>*Student</code>，可以通过实例名访问该实例的字段<code>name</code>和其他方法了。</li><li>调用方法通过 <code>实例名.方法名(参数)</code> 的方式。</li></ul><p>除此之外，还可以使用 <code>new</code> 实例化：</p><pre><code class="go">func main() &#123;    stu2 := new(Student)    fmt.Println(stu2.hello(&quot;Alice&quot;)) // hello Alice, I am  , name 被赋予默认值&quot;&quot;&#125;</code></pre><h3 id="6-2-接口-interfaces"><a href="#6-2-接口-interfaces" class="headerlink" title="6.2 接口(interfaces)"></a>6.2 接口(interfaces)</h3><p>一般而言，接口定义了一组方法的集合，接口不能被实例化，一个类型可以实现多个接口。</p><p>举一个简单的例子，定义一个接口 <code>Person</code>和对应的方法 <code>getName()</code> 和 <code>getAge()</code>：</p><pre><code class="go">type Person interface &#123;    getName() string&#125;type Student struct &#123;    name string    age  int&#125;func (stu *Student) getName() string &#123;    return stu.name&#125;type Worker struct &#123;    name   string    gender string&#125;func (w *Worker) getName() string &#123;    return w.name&#125;func main() &#123;    var p Person = &amp;Student&#123;        name: &quot;Tom&quot;,        age:  18,    &#125;    fmt.Println(p.getName()) // Tom&#125;</code></pre><ul><li>Go 语言中，并不需要显式地声明实现了哪一个接口，只需要直接实现该接口对应的方法即可。</li><li>实例化 <code>Student</code>后，强制类型转换为接口类型 Person。</li></ul><p>在上面的例子中，我们在 main 函数中尝试将 Student 实例类型转换为 Person，如果 Student 没有完全实现 Person 的方法，比如我们将 <code>(*Student).getName()</code> 删掉，编译时会出现如下报错信息。</p><pre><code class="bash"> *Student does not implement Person (missing getName method)</code></pre><p>但是删除 <code>(*Worker).getName()</code> 程序并不会报错，因为我们并没有在 main 函数中使用。这种情况下我们如何确保某个类型实现了某个接口的所有方法呢？一般可以使用下面的方法进行检测，如果实现不完整，编译期将会报错。</p><pre><code class="go">var _ Person = (*Student)(nil)var _ Person = (*Worker)(nil)</code></pre><ul><li>将空值 nil 转换为 *Student 类型，再转换为 Person 接口，如果转换失败，说明 Student 并没有实现 Person 接口的所有方法。</li><li>Worker 同上。</li></ul><p>实例可以强制类型转换为接口，接口也可以强制类型转换为实例。</p><pre><code class="go">func main() &#123;    var p Person = &amp;Student&#123;        name: &quot;Tom&quot;,        age:  18,    &#125;    stu := p.(*Student) // 接口转为实例    fmt.Println(stu.getAge())&#125;</code></pre><h3 id="6-3-空接口"><a href="#6-3-空接口" class="headerlink" title="6.3 空接口"></a>6.3 空接口</h3><p>如果定义了一个没有任何方法的空接口，那么这个接口可以表示任意类型。例如</p><pre><code class="go">func main() &#123;    m := make(map[string]interface&#123;&#125;)    m[&quot;name&quot;] = &quot;Tom&quot;    m[&quot;age&quot;] = 18    m[&quot;scores&quot;] = [3]int&#123;98, 99, 85&#125;    fmt.Println(m) // map[age:18 name:Tom scores:[98 99 85]]&#125;</code></pre><h2 id="7-并发编程-goroutine"><a href="#7-并发编程-goroutine" class="headerlink" title="7 并发编程(goroutine)"></a>7 并发编程(goroutine)</h2><h3 id="7-1-sync"><a href="#7-1-sync" class="headerlink" title="7.1 sync"></a>7.1 sync</h3><p>Go 语言提供了 sync 和 channel 两种方式支持协程(goroutine)的并发。</p><p>例如我们希望并发下载 N 个资源，多个并发协程之间不需要通信，那么就可以使用 sync.WaitGroup，等待所有并发协程执行结束。</p><pre><code class="go">import (    &quot;fmt&quot;    &quot;sync&quot;    &quot;time&quot;)var wg sync.WaitGroupfunc download(url string) &#123;    fmt.Println(&quot;start to download&quot;, url)    time.Sleep(time.Second) // 模拟耗时操作    wg.Done()&#125;func main() &#123;    for i := 0; i &lt; 3; i++ &#123;        wg.Add(1)        go download(&quot;a.com/&quot; + string(i+&#39;0&#39;))    &#125;    wg.Wait()    fmt.Println(&quot;Done!&quot;)&#125;</code></pre><ul><li>wg.Add(1)：为 wg 添加一个计数，wg.Done()，减去一个计数。</li><li>go download()：启动新的协程并发执行 download 函数。</li><li>wg.Wait()：等待所有的协程执行结束。</li></ul><pre><code class="bash">$  time go run .start to download a.com/2start to download a.com/0start to download a.com/1Done!real    0m1.563s</code></pre><p>可以看到串行需要 3s 的下载操作，并发后，只需要 1s。</p><h3 id="7-2-channel"><a href="#7-2-channel" class="headerlink" title="7.2 channel"></a>7.2 channel</h3><pre><code class="go">var ch = make(chan string, 10) // 创建大小为 10 的缓冲信道func download(url string) &#123;    fmt.Println(&quot;start to download&quot;, url)    time.Sleep(time.Second)    ch &lt;- url // 将 url 发送给信道&#125;func main() &#123;    for i := 0; i &lt; 3; i++ &#123;        go download(&quot;a.com/&quot; + string(i+&#39;0&#39;))    &#125;    for i := 0; i &lt; 3; i++ &#123;        msg := &lt;-ch // 等待信道返回消息。        fmt.Println(&quot;finish&quot;, msg)    &#125;    fmt.Println(&quot;Done!&quot;)&#125;</code></pre><p>使用 channel 信道，可以在协程之间传递消息。阻塞等待并发协程返回消息。</p><pre><code class="bash">$ time go run .start to download a.com/2start to download a.com/0start to download a.com/1finish a.com/2finish a.com/1finish a.com/0Done!real    0m1.528s</code></pre><h2 id="8-单元测试-unit-test"><a href="#8-单元测试-unit-test" class="headerlink" title="8 单元测试(unit test)"></a>8 单元测试(unit test)</h2><p>假设我们希望测试 package main 下 <code>calc.go</code> 中的函数，要只需要新建 <code>calc_test.go</code> 文件，在<code>calc_test.go</code>中新建测试用例即可。</p><pre><code class="go">// calc.gopackage mainfunc add(num1 int, num2 int) int &#123;    return num1 + num2&#125;</code></pre><pre><code class="go">// calc_test.gopackage mainimport &quot;testing&quot;func TestAdd(t *testing.T) &#123;    if ans := add(1, 2); ans != 3 &#123;        t.Error(&quot;add(1, 2) should be equal to 3&quot;)    &#125;&#125;</code></pre><p>运行 <code>go test</code>，将自动运行当前 package 下的所有测试用例，如果需要查看详细的信息，可以添加<code>-v</code>参数。</p><pre><code class="bash">$ go test -v=== RUN   TestAdd--- PASS: TestAdd (0.00s)PASSok      example 0.040s</code></pre><h2 id="9-包-Package-和模块-Modules"><a href="#9-包-Package-和模块-Modules" class="headerlink" title="9 包(Package)和模块(Modules)"></a>9 包(Package)和模块(Modules)</h2><h3 id="9-1-Package"><a href="#9-1-Package" class="headerlink" title="9.1 Package"></a>9.1 Package</h3><p>一般来说，一个文件夹可以作为 package，同一个 package 内部变量、类型、方法等定义可以相互看到。</p><p>比如我们新建一个文件 <code>calc.go</code>， <code>main.go</code> 平级，分别定义 add 和 main 方法。</p><pre><code class="go">// calc.gopackage mainfunc add(num1 int, num2 int) int &#123;    return num1 + num2&#125;</code></pre><pre><code class="go">// main.gopackage mainimport &quot;fmt&quot;func main() &#123;    fmt.Println(add(3, 5)) // 8&#125;</code></pre><p>运行 <code>go run main.go</code>，会报错，add 未定义：</p><pre><code class="bash">./main.go:6:14: undefined: add</code></pre><p>因为 <code>go run main.go</code> 仅编译 main.go 一个文件，所以命令需要换成 </p><pre><code class="bash">$ go run main.go calc.go8</code></pre><p>或 </p><pre><code class="bash">$ go run .8</code></pre><p>Go 语言也有 Public 和 Private 的概念，粒度是包。如果类型/接口/方法/函数/字段的首字母大写，则是 Public 的，对其他 package 可见，如果首字母小写，则是 Private 的，对其他 package 不可见。</p><h3 id="9-2-Modules"><a href="#9-2-Modules" class="headerlink" title="9.2 Modules"></a>9.2 Modules</h3><p><a href="https://github.com/golang/go/wiki/Modules">Go Modules</a> 是 Go 1.11 版本之后引入的，Go 1.11 之前使用 $GOPATH 机制。Go Modules 可以算作是较为完善的包管理工具。同时支持代理，国内也能享受高速的第三方包镜像服务。接下来简单介绍 <code>go mod</code> 的使用。Go Modules 在 1.13 版本仍是可选使用的，环境变量 GO111MODULE 的值默认为 AUTO，强制使用 Go Modules 进行依赖管理，可以将 GO111MODULE 设置为 ON。</p><p>在一个空文件夹下，初始化一个 Module</p><pre><code class="bash">$ go mod init examplego: creating new go.mod: module example</code></pre><p>此时，在当前文件夹下生成了<code>go.mod</code>，这个文件记录当前模块的模块名以及所有依赖包的版本。</p><p>接着，我们在当前目录下新建文件 <code>main.go</code>，添加如下代码：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;rsc.io/quote&quot;)func main() &#123;    fmt.Println(quote.Hello())  // Ahoy, world!&#125;</code></pre><p>运行 <code>go run .</code>，将会自动触发第三方包 <code>rsc.io/quote</code>的下载，具体的版本信息也记录在了<code>go.mod</code>中：</p><pre><code class="bash">module examplego 1.13require rsc.io/quote v3.1.0+incompatible</code></pre><p>我们在当前目录，添加一个子 package calc，代码目录如下：</p><pre><code class="bash">demo/   |--calc/      |--calc.go   |--main.go</code></pre><p>在 <code>calc.go</code> 中写入</p><pre><code class="go">package calcfunc Add(num1 int, num2 int) int &#123;    return num1 + num2&#125;</code></pre><p>在 package main 中如何使用 package cal 中的 Add 函数呢？<code>import 模块名/子目录名</code> 即可，修改后的 main 函数如下：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;example/calc&quot;    &quot;rsc.io/quote&quot;)func main() &#123;    fmt.Println(quote.Hello())    fmt.Println(calc.Add(10, 3))&#125;</code></pre><pre><code class="bash">$ go run .Ahoy, world!13</code></pre><h2 id="附-参考"><a href="#附-参考" class="headerlink" title="附 参考"></a>附 参考</h2><ul><li><a href="https://golang.org/">golang 官方文档 - golang.org</a></li><li><a href="https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md">goproxy.cn 文档 - github.com</a></li><li><a href="https://github.com/golang/go/wiki/Modules">Go Modules - github.com</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114701.jpg&quot; alt=&quot;Golang中文教程&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Go（又称Golang）是Go</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Go语言" scheme="https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Go语言程序设计" scheme="https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Go语言教程中文版" scheme="https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%E4%B8%AD%E6%96%87%E7%89%88/"/>
    
  </entry>
  
  <entry>
    <title>Go Mmap 文件内存映射简明教程</title>
    <link href="https://ysluckly.github.io/2022/02/11/go/"/>
    <id>https://ysluckly.github.io/2022/02/11/go/</id>
    <published>2022-02-11T13:59:10.000Z</published>
    <updated>2022-02-20T13:36:11.469Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114728.jpg" alt="golang mmap"></p><h2 id="1-mmap-简介"><a href="#1-mmap-简介" class="headerlink" title="1 mmap 简介"></a>1 mmap 简介</h2><blockquote><p>In computing, mmap is a POSIX-compliant Unix system call that maps files or devices into memory. It is a method of memory-mapped file I/O.<br>– <a href="https://en.wikipedia.org/wiki/Mmap">mmap - wikipedia.org</a></p></blockquote><p>简单理解，mmap 是一种将文件/设备映射到内存的方法，实现文件的磁盘地址和进程虚拟地址空间中的一段虚拟地址的一一映射关系。也就是说，可以在某个进程中通过操作这一段映射的内存，实现对文件的读写等操作。修改了这一段内存的内容，文件对应位置的内容也会同步修改，而读取这一段内存的内容，相当于读取文件对应位置的内容。</p><p>mmap 另一个非常重要的特性是：减少内存的拷贝次数。在 linux 系统中，文件的读写操作通常通过 read 和 write 这两个系统调用来实现，这个过程会产生频繁的内存拷贝。比如 read 函数就涉及了 2 次内存拷贝：</p><ul><li><ol><li>操作系统读取磁盘文件到页缓存；</li></ol></li><li><ol start="2"><li>从页缓存将数据拷贝到 read 传递的 buf 中(例如进程中创建的byte数组)。</li></ol></li></ul><p>mmap 只需要一次拷贝。即操作系统读取磁盘文件到页缓存，进程内部直接通过指针方式修改映射的内存。因此 mmap 特别适合读写频繁的场景，既减少了内存拷贝次数，提高效率，又简化了操作。KV数据库 <a href="https://github.com/etcd-io/bbolt">bbolt</a> 就使用了这个方法持久化数据。</p><h2 id="2-标准库-mmap"><a href="#2-标准库-mmap" class="headerlink" title="2 标准库 mmap"></a>2 标准库 mmap</h2><p>Go 语言标准库 <a href="https://godoc.org/golang.org/x/exp/mmap">golang.org/x/exp/mmap</a> 仅实现了 read 操作，后续能否支持 write 操作未知。使用场景非常有限。看一个简单的例子：</p><p>从第4个byte开始，读取 tmp.txt 2个byte的内容。</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;golang.org/x/exp/mmap&quot;)func main() &#123;    at, _ := mmap.Open(&quot;./tmp.txt&quot;)    buff := make([]byte, 2)    _, _ = at.ReadAt(buff, 4)    _ = at.Close()    fmt.Println(string(buff))&#125;</code></pre><pre><code class="bash">$ echo &quot;abcdefg&quot; &gt; tmp.txt$ go run .ef</code></pre><p>如果使用 <code>os.File</code> 操作，代码几乎是一样的，<code>os.File</code> 还支持写操作 <code>WriteAt</code>：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;os&quot;)func main() &#123;    f, _ := os.OpenFile(&quot;tmp.txt&quot;, os.O_CREATE|os.O_RDWR, 0644)    _, _ = f.WriteAt([]byte(&quot;abcdefg&quot;), 0)    buff := make([]byte, 2)    _, _ = f.ReadAt(buff, 4)    _ = f.Close()    fmt.Println(string(buff))&#125;</code></pre><h2 id="3-mmap-linux"><a href="#3-mmap-linux" class="headerlink" title="3 mmap(linux)"></a>3 mmap(linux)</h2><p>如果要支持 write 操作，那么就需要直接调用 mmap 的系统调用来实现了。Linux 和 Windows 都支持 mmap，但接口有所不同。对于 linux 系统，mmap 方法定义如下：</p><pre><code class="go">func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, err error)</code></pre><p>每个参数的含义分别是：</p><pre><code class="go">- fd：待映射的文件描述符。- offset：映射到内存区域的起始位置，0 表示由内核指定内存地址。- length：要映射的内存区域的大小。- prot：内存保护标志位，可以通过或运算符`|`组合    - PROT_EXEC  // 页内容可以被执行    - PROT_READ  // 页内容可以被读取    - PROT_WRITE // 页可以被写入    - PROT_NONE  // 页不可访问- flags：映射对象的类型，常用的是以下两类    - MAP_SHARED  // 共享映射，写入数据会复制回文件, 与映射该文件的其他进程共享。    - MAP_PRIVATE // 建立一个写入时拷贝的私有映射，写入数据不影响原文件。</code></pre><p>首先定义2个常量和数据类型Demo：</p><pre><code class="go">const defaultMaxFileSize = 1 &lt;&lt; 30        // 假设文件最大为 1Gconst defaultMemMapSize = 128 * (1 &lt;&lt; 20) // 假设映射的内存大小为 128Mtype Demo struct &#123;    file    *os.File    data    *[defaultMaxFileSize]byte    dataRef []byte&#125;func _assert(condition bool, msg string, v ...interface&#123;&#125;) &#123;    if !condition &#123;        panic(fmt.Sprintf(msg, v...))    &#125;&#125;</code></pre><ul><li>内存有换页机制，映射的物理内存可以远小于文件。</li><li>Demo结构体由3个字段构成，file 即文件描述符，data 是映射内存的起始地址，dataRef 用于后续取消映射。</li></ul><p>定义 mmap, grow, ummap 三个方法：</p><pre><code class="go">func (demo *Demo) mmap() &#123;    b, err := syscall.Mmap(int(demo.file.Fd()), 0, defaultMemMapSize, syscall.PROT_WRITE|syscall.PROT_READ, syscall.MAP_SHARED)    _assert(err == nil, &quot;failed to mmap&quot;, err)    demo.dataRef = b    demo.data = (*[defaultMaxFileSize]byte)(unsafe.Pointer(&amp;b[0]))&#125;func (demo *Demo) grow(size int64) &#123;    if info, _ := demo.file.Stat(); info.Size() &gt;= size &#123;        return    &#125;    _assert(demo.file.Truncate(size) == nil, &quot;failed to truncate&quot;)&#125;func (demo *Demo) munmap() &#123;    _assert(syscall.Munmap(demo.dataRef) == nil, &quot;failed to munmap&quot;)    demo.data = nil    demo.dataRef = nil&#125;</code></pre><ul><li>mmap 传入的内存保护标志位为 <code>syscall.PROT_WRITE|syscall.PROT_READ</code>，即可读可写，映射类型为 <code>syscall.MAP_SHARED</code>，即对内存的修改会同步到文件。</li><li><code>syscall.Mmap</code> 返回的是一个切片对象，需要从该切片中获取到内存的起始地址，并转换为可操作的 byte 数组，byte数组的长度为 <code>defaultMaxFileSize</code>。</li><li>grow 用于修改文件的大小，Linux 不允许操作超过文件大小之外的内存地址。例如文件大小为 4K，可访问的地址是<code>data[0~4095]</code>，如果访问 <code>data[10000]</code> 会报错。</li><li>munmap 用于取消映射。</li></ul><p>在文件中写入 <code>hello, geektutu!</code></p><pre><code class="go">func main() &#123;    _ = os.Remove(&quot;tmp.txt&quot;)    f, _ := os.OpenFile(&quot;tmp.txt&quot;, os.O_CREATE|os.O_RDWR, 0644)    demo := &amp;Demo&#123;file: f&#125;    demo.grow(1)    demo.mmap()    defer demo.munmap()    msg := &quot;hello geektutu!&quot;    demo.grow(int64(len(msg) * 2))    for i, v := range msg &#123;        demo.data[2*i] = byte(v)        demo.data[2*i+1] = byte(&#39; &#39;)    &#125;&#125;</code></pre><ul><li>在调用 <code>mmap</code> 之前，调用了 <code>grow(1)</code>，因为在 <code>mmap</code> 中使用 <code>&amp;b[0]</code> 获取到映射内存的起始地址，所以文件大小至少为 1 byte。</li><li>接下来，便是通过直接操作 <code>demo.data</code>，修改文件内容了。</li></ul><p>运行：</p><pre><code class="bash">$ go run .$ cat tmp.txth e l l o   g e e k t u t u !</code></pre><h2 id="4-mmap-Windows"><a href="#4-mmap-Windows" class="headerlink" title="4 mmap(Windows)"></a>4 mmap(Windows)</h2><p>相对于 Linux，Windows 上 mmap 的使用要复杂一些。</p><pre><code class="go">func (demo *Demo) mmap() &#123;    h, err := syscall.CreateFileMapping(syscall.Handle(demo.file.Fd()), nil, syscall.PAGE_READWRITE, 0, defaultMemMapSize, nil)    _assert(h != 0, &quot;failed to map&quot;, err)    addr, err := syscall.MapViewOfFile(h, syscall.FILE_MAP_WRITE, 0, 0, uintptr(defaultMemMapSize))    _assert(addr != 0, &quot;MapViewOfFile failed&quot;, err)    err = syscall.CloseHandle(syscall.Handle(h));    _assert(err == nil, &quot;CloseHandle failed&quot;)    // Convert to a byte array.    demo.data = (*[defaultMaxFileSize]byte)(unsafe.Pointer(addr))&#125;func (demo *Demo) munmap() &#123;    addr := (uintptr)(unsafe.Pointer(&amp;demo.data[0]))    _assert(syscall.UnmapViewOfFile(addr) == nil, &quot;failed to munmap&quot;)&#125;</code></pre><ul><li>需要 <code>CreateFileMapping</code> 和 <code>MapViewOfFile</code> 两步才能完成内存映射。<code>MapViewOfFile</code> 返回映射成功的内存地址，因此可以直接将该地址转换成 byte 数组。</li><li>Windows 对文件的大小没有要求，直接操作内存<code>data</code>，文件大小会自动发生改变。</li></ul><p>使用时无需关注文件的大小。</p><pre><code class="go">func main() &#123;    _ = os.Remove(&quot;tmp.txt&quot;)    f, _ := os.OpenFile(&quot;tmp.txt&quot;, os.O_CREATE|os.O_RDWR, 0644)    demo := &amp;Demo&#123;file: f&#125;    demo.mmap()    defer demo.munmap()    msg := &quot;hello geektutu!&quot;    for i, v := range msg &#123;        demo.data[2*i] = byte(v)        demo.data[2*i+1] = byte(&#39; &#39;)    &#125;&#125;</code></pre><pre><code class="go">$ go run .$ cat .\tmp.txth e l l o   g e e k t u t u !</code></pre><h2 id="附-参考"><a href="#附-参考" class="headerlink" title="附 参考"></a>附 参考</h2><ul><li><a href="https://github.com/edsrzf/mmap-go">edsrzf/mmap-go - github.com</a></li><li><a href="https://golang.org/pkg/syscall/">golang 官方文档 syscall - golang.org</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114728.jpg&quot; alt=&quot;golang mmap&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-mmap-简介&quot;&gt;&lt;a href=&quot;#1</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="golang" scheme="https://ysluckly.github.io/tags/golang/"/>
    
    <category term="mmap" scheme="https://ysluckly.github.io/tags/mmap/"/>
    
    <category term="memory mapping" scheme="https://ysluckly.github.io/tags/memory-mapping/"/>
    
    <category term="windows" scheme="https://ysluckly.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>休闲娱乐-小游戏</title>
    <link href="https://ysluckly.github.io/2022/02/02/gamesh/"/>
    <id>https://ysluckly.github.io/2022/02/02/gamesh/</id>
    <published>2022-02-01T17:00:10.000Z</published>
    <updated>2022-02-20T13:54:25.410Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>休闲小游戏是小游戏的一种。一般都是在看技术博客累的时候玩的，后来发展成网页游戏。并成为网络游戏集，并加以利用加入网络等元素，可以和网友进行比拼，使得休闲小游戏得以发展。</p></blockquote><h4 id="①、2048-小游戏-点击进入…"><a href="#①、2048-小游戏-点击进入…" class="headerlink" title="①、2048-小游戏 | 点击进入…"></a>①、2048-小游戏 | <a href="https://ysluckly.github.io/games/2048/index.html">点击进入…</a></h4><h4 id="②、五子棋-小游戏-点击进入…"><a href="#②、五子棋-小游戏-点击进入…" class="headerlink" title="②、五子棋- 小游戏 | 点击进入…"></a>②、五子棋- 小游戏 | <a href="https://ysluckly.github.io/games/gobang/index.html">点击进入…</a></h4><h4 id="③、圈小猫-小游戏-点击进入…"><a href="#③、圈小猫-小游戏-点击进入…" class="headerlink" title="③、圈小猫-小游戏 | 点击进入…"></a>③、圈小猫-小游戏 | <a href="https://ysluckly.github.io/games/cat/index.html">点击进入…</a></h4><h4 id="④、3D元素周期表-小游戏-点击进入…"><a href="#④、3D元素周期表-小游戏-点击进入…" class="headerlink" title="④、3D元素周期表-小游戏 | 点击进入…"></a>④、3D元素周期表-小游戏 | <a href="https://ysluckly.github.io/games/element/index.html">点击进入…</a></h4><h4 id="⑤、弹钢琴-小游戏-点击进入…"><a href="#⑤、弹钢琴-小游戏-点击进入…" class="headerlink" title="⑤、弹钢琴-小游戏 | 点击进入…"></a>⑤、弹钢琴-小游戏 | <a href="https://ysluckly.github.io/games/piano/index.html">点击进入…</a></h4><h4 id="⑥、吃豆人-小游戏-点击进入…"><a href="#⑥、吃豆人-小游戏-点击进入…" class="headerlink" title="⑥、吃豆人-小游戏 | 点击进入…"></a>⑥、吃豆人-小游戏 | <a href="https://ysluckly.github.io/games/PacMan/index.html">点击进入…</a></h4>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;休闲小游戏是小游戏的一种。一般都是在看技术博客累的时候玩的，后来发展成网页游戏。并成为网络游戏集，并加以利用加入网络等元素，可以和网友进行比拼，使得休闲小游戏得以发展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;①、2048-小游戏-点击</summary>
      
    
    
    
    <category term="工具" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="game" scheme="https://ysluckly.github.io/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>Go WebAssembly (Wasm) 简明教程</title>
    <link href="https://ysluckly.github.io/2022/01/17/go/"/>
    <id>https://ysluckly.github.io/2022/01/17/go/</id>
    <published>2022-01-17T13:59:10.000Z</published>
    <updated>2022-02-20T13:38:38.925Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919113247.jpg" alt="Golang WebAssembly"></p><h2 id="1-WebAssembly-简介"><a href="#1-WebAssembly-简介" class="headerlink" title="1 WebAssembly 简介"></a>1 WebAssembly 简介</h2><blockquote><p>WebAssembly是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如C / C ++等语言提供一个编译目标，以便它们可以在Web上运行。它也被设计为可以与JavaScript共存，允许两者一起工作。  —— <a href="https://developer.mozilla.org/zh-CN/docs/WebAssembly">MDN web docs - mozilla.org</a></p></blockquote><p>从 MDN 的介绍中，我们可以得出几个结论：</p><ul><li>1）WebAssembly 是一种二进制编码格式，而不是一门新的语言。</li><li><ol start="2"><li>WebAssembly 不是为了取代 JavaScript，而是一种补充（至少现阶段是这样），结合 WebAssembly 的性能优势，很大可能集中在对性能要求高（例如游戏，AI），或是对交互体验要求高（例如移动端）的场景。</li></ol></li><li>3）C/C++ 等语言可以编译 WebAssembly 的目标文件，也就是说，其他语言可以通过编译器支持，而写出能够在浏览器前端运行的代码。</li></ul><p>Go 语言在 1.11 版本(2018年8月) 加入了对 WebAssembly (Wasm) 的原生支持，使用 Go 语言开发 WebAssembly 相关的应用变得更加地简单。Go 语言的内建支持是 Go 语言进军前端的一个重要的里程碑。在这之前，如果想使用 Go 语言开发前端，需要使用 <a href="https://github.com/gopherjs/gopherjs">GopherJS</a>，GopherJS 是一个编译器，可以将 Go 语言转换成可以在浏览器中运行的 JavaScript 代码。新版本的 Go 则直接将 Go 代码编译为 wasm 二进制文件，而不再需要转为 JavaScript 代码。更巧的是，实现 GopherJS 和在 Go 语言中内建支持 WebAssembly 的是同一拨人。</p><p>Go 语言实现的函数可以直接导出供 JavaScript 代码调用，同时，Go 语言内置了 <a href="https://github.com/golang/go/tree/master/src/syscall/js">syscall/js</a> 包，可以在 Go 语言中直接调用 JavaScript 函数，包括对 DOM 树的操作。</p><h2 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2 Hello World"></a>2 Hello World</h2><p>如果对 Go 语言不熟悉，推荐 <a href="https://geektutu.com/post/quick-golang.html">Go 语言简明教程</a>，一篇文章快速入门。</p><p>接下来，我们使用 Go 语言实现一个最简单的程序，在网页上弹出 <code>Hello World</code>。</p><p>第一步，新建文件 main.go，使用 js.Global().get(‘alert’) 获取全局的 alert 对象，通过 Invoke 方法调用。等价于在 js 中调用 <code>window.alert(&quot;Hello World&quot;)</code>。</p><pre><code class="go">// main.gopackage mainimport &quot;syscall/js&quot;func main() &#123;    alert := js.Global().Get(&quot;alert&quot;)    alert.Invoke(&quot;Hello World!&quot;)&#125;</code></pre><p>第二步，将 main.go 编译为 static/main.wasm</p><blockquote><p>如果启用了 <code>GO MODULES</code>，则需要使用 go mod init 初始化模块，或设置 GO111MODULE=auto。</p></blockquote><pre><code class="bash">$ GOOS=js GOARCH=wasm go build -o static/main.wasm</code></pre><p>第三步，拷贝 wasm_exec.js (JavaScript 支持文件，加载 wasm 文件时需要) 到 static 文件夹</p><pre><code class="bash">$ cp &quot;$(go env GOROOT)/misc/wasm/wasm_exec.js&quot; static</code></pre><p>第四步，创建 index.html，引用 <code>static/main.wasm</code> 和 <code>static/wasm_exec.js</code>。</p><pre><code class="html">&lt;html&gt;&lt;script src=&quot;static/wasm_exec.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    const go = new Go();    WebAssembly.instantiateStreaming(fetch(&quot;static/main.wasm&quot;), go.importObject)        .then((result) =&gt; go.run(result.instance));&lt;/script&gt;&lt;/html&gt;</code></pre><p>第五步，使用 goexec 启动 Web 服务</p><blockquote><p>如果没有安装 goexec，可用 <code>go get -u github.com/shurcooL/goexec</code> 安装，需要将 $GOBIN 或 $GOPATH/bin 加入环境变量</p></blockquote><p>当前的目录结构如下：</p><pre><code class="bash">demo/   |--static/      |--wasm_exec.js      |--main.wasm   |--main.go   |--index.html</code></pre><pre><code class="bash">$ goexec &#39;http.ListenAndServe(`:9999`, http.FileServer(http.Dir(`.`)))&#39;</code></pre><p>浏览器访问 localhost:9999，则会有一个弹出窗口，上面写着 *Hello World!*。</p><p><img src="quick-go-wasm/hello_world.png" alt="go wasm hello world demo"></p><p>为了避免每次编译都需要输入繁琐的命令，可将这个过程写在 <code>Makefile</code> 中</p><pre><code class="makefile">all: static/main.wasm static/wasm_exec.js    goexec &#39;http.ListenAndServe(`:9999`, http.FileServer(http.Dir(`.`)))&#39;static/wasm_exec.js:    cp &quot;$(shell go env GOROOT)/misc/wasm/wasm_exec.js&quot; staticstatic/main.wasm : main.go    GO111MODULE=auto GOOS=js GOARCH=wasm go build -o static/main.wasm .</code></pre><p>这样一个敲一下 make 就够了，代码已经上传到 <a href="https://github.com/geektutu/7days-golang/tree/master/demo-wasm">7days-golang - github.com</a>。</p><h2 id="3-注册函数-Register-Functions"><a href="#3-注册函数-Register-Functions" class="headerlink" title="3 注册函数(Register Functions)"></a>3 注册函数(Register Functions)</h2><p>在 Go 语言中调用 JavaScript 函数是一方面，另一方面，如果仅仅是使用 WebAssembly 替代性能要求高的模块，那么就需要注册函数，以便其他 JavaScript 代码调用。</p><p>假设我们需要注册一个计算斐波那契数列的函数，可以这么实现。</p><pre><code class="go">// main.gopackage mainimport &quot;syscall/js&quot;func fib(i int) int &#123;    if i == 0 || i == 1 &#123;        return 1    &#125;    return fib(i-1) + fib(i-2)&#125;func fibFunc(this js.Value, args []js.Value) interface&#123;&#125; &#123;    return js.ValueOf(fib(args[0].Int()))&#125;func main() &#123;    done := make(chan int, 0)    js.Global().Set(&quot;fibFunc&quot;, js.FuncOf(fibFunc))    &lt;-done&#125;</code></pre><ul><li>fib 是一个普通的 Go 函数，通过递归计算第 i 个斐波那契数，接收一个 int 入参，返回值也是 int。</li><li>定义了 fibFunc 函数，为 fib 函数套了一个壳，从 args[0] 获取入参，计算结果用 js.ValueOf 包装，并返回。</li><li>使用 js.Global().Set() 方法，将注册函数 fibFunc 到全局，以便在浏览器中能够调用。</li></ul><p><code>js.Value</code> 可以将 Js 的值转换为 Go 的值，比如 args[0].Int()，则是转换为 Go 语言中的整型。<code>js.ValueOf</code>，则用来将 Go 的值，转换为 Js 的值。另外，注册函数的时候，使用 js.FuncOf 将函数转换为 <code>Func</code> 类型，只有 Func 类型的函数，才能在 JavaScript 中调用。可以认为这是 Go 与 JavaScript 之间的接口/约定。</p><p><code>js.Func()</code> 接受一个函数类型作为其参数，该函数的定义必须是：</p><pre><code class="go">func(this Value, args []Value) interface&#123;&#125;// this 即 JavaScript 中的 this// args 是在 JavaScript 中调用该函数的参数列表。// 返回值需用 js.ValueOf 映射成 JavaScript 的值</code></pre><p>在 main 函数中，创建了信道(chan) done，阻塞主协程(goroutine)。fibFunc 如果在 JavaScript 中被调用，会开启一个新的子协程执行。</p><blockquote><p>A wrapped function triggered during a call from Go to JavaScript gets executed on the same goroutine. A wrapped function triggered by JavaScript’s event loop gets executed on an extra goroutine.  —— <a href="https://golang.org/pkg/syscall/js/#FuncOf">FuncOf - golang.org</a></p></blockquote><p>接下来，修改之前的 index.html，在其中添加一个输入框(num)，一个按钮(btn) 和一个文本框(ans，用来显示计算结果)，并给按钮添加了一个点击事件，调用 fibFunc，并将计算结果显示在文本框(ans)中。</p><pre><code class="html">&lt;html&gt;...&lt;body&gt;    &lt;input id=&quot;num&quot; type=&quot;number&quot; /&gt;    &lt;button id=&quot;btn&quot; onclick=&quot;ans.innerHTML=fibFunc(num.value * 1)&quot;&gt;Click&lt;/button&gt;    &lt;p id=&quot;ans&quot;&gt;1&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>使用之前的命令重新编译 main.go，并在 9999 端口启动 Web 服务，如果我们已经将命令写在 Makefile 中了，只需要运行 <code>make</code> 即可。</p><p>接下来访问 localhost:9999，可以看到如下效果。输入一个数字，点击<code>Click</code>，计算结果显示在输入框下方。</p><p><img src="quick-go-wasm/register_functions.png" alt="register functions demo"></p><h2 id="4-操作-DOM"><a href="#4-操作-DOM" class="headerlink" title="4 操作 DOM"></a>4 操作 DOM</h2><p>在上一个例子中，仅仅是注册了全局函数 fibFunc，事件注册，调用，对 DOM 元素的操作都是在 HTML<br>中通过原生的 JavaScript 函数实现的。这些事情，能不能全部在 Go 语言中完成呢？答案可以。</p><p>首先修改 index.html，删除事件注册部分和 对 DOM 元素的操作部分。</p><pre><code class="html">&lt;html&gt;...&lt;body&gt;    &lt;input id=&quot;num&quot; type=&quot;number&quot; /&gt;    &lt;button id=&quot;btn&quot;&gt;Click&lt;/button&gt;    &lt;p id=&quot;ans&quot;&gt;1&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>修改 main.go：</p><pre><code class="go">package mainimport (    &quot;strconv&quot;    &quot;syscall/js&quot;)func fib(i int) int &#123;    if i == 0 || i == 1 &#123;        return 1    &#125;    return fib(i-1) + fib(i-2)&#125;var (    document = js.Global().Get(&quot;document&quot;)    numEle   = document.Call(&quot;getElementById&quot;, &quot;num&quot;)    ansEle   = document.Call(&quot;getElementById&quot;, &quot;ans&quot;)    btnEle   = js.Global().Get(&quot;btn&quot;))func fibFunc(this js.Value, args []js.Value) interface&#123;&#125; &#123;    v := numEle.Get(&quot;value&quot;)    if num, err := strconv.Atoi(v.String()); err == nil &#123;        ansEle.Set(&quot;innerHTML&quot;, js.ValueOf(fib(num)))    &#125;    return nil&#125;func main() &#123;    done := make(chan int, 0)    btnEle.Call(&quot;addEventListener&quot;, &quot;click&quot;, js.FuncOf(fibFunc))    &lt;-done&#125;</code></pre><ul><li>通过 <code>js.Global().Get(&quot;btn&quot;)</code> 或 <code>document.Call(&quot;getElementById&quot;, &quot;num&quot;)</code> 两种方式获取到 DOM 元素。</li><li>btnEle 调用 <code>addEventListener</code> 为 btn 绑定点击事件 fibFunc。</li><li>在 fibFunc 中使用 <code>numEle.Get(&quot;value&quot;)</code> 获取到 numEle 的值（字符串），转为整型并调用 fib 计算出结果。</li><li>ansEle 调用 <code>Set(&quot;innerHTML&quot;, ...)</code> 渲染计算结果。</li></ul><p>重新编译 main.go，访问 localhost:9999，效果与之前是一致的。</p><h2 id="5-回调函数-Callback-Functions"><a href="#5-回调函数-Callback-Functions" class="headerlink" title="5 回调函数(Callback Functions)"></a>5 回调函数(Callback Functions)</h2><p>在 JavaScript 中，异步+回调是非常常见的，比如请求一个 Restful API，注册一个回调函数，待数据获取到，再执行回调函数的逻辑，这个期间程序可以继续做其他的事情。Go 语言可以通过协程实现异步。</p><p>假设 fib 的计算非常耗时，那么可以启动注册一个回调函数，待 fib 计算完成后，再把计算结果显示出来。</p><p>我们先修改 main.go，使得 fibFunc 支持传入回调函数。</p><pre><code class="go">package mainimport (    &quot;syscall/js&quot;    &quot;time&quot;)func fib(i int) int &#123;    if i == 0 || i == 1 &#123;        return 1    &#125;    return fib(i-1) + fib(i-2)&#125;func fibFunc(this js.Value, args []js.Value) interface&#123;&#125; &#123;    callback := args[len(args)-1]    go func() &#123;        time.Sleep(3 * time.Second)        v := fib(args[0].Int())        callback.Invoke(v)    &#125;()    js.Global().Get(&quot;ans&quot;).Set(&quot;innerHTML&quot;, &quot;Waiting 3s...&quot;)    return nil&#125;func main() &#123;    done := make(chan int, 0)    js.Global().Set(&quot;fibFunc&quot;, js.FuncOf(fibFunc))    &lt;-done&#125;</code></pre><ul><li>假设调用 fibFunc 时，回调函数作为最后一个参数，那么通过 args[len(args)-1] 便可以获取到该函数。这与其他类型参数的传递并无区别。</li><li>使用 <code>go func()</code> 启动子协程，调用 fib 计算结果，计算结束后，调用回调函数 <code>callback</code>，并将计算结果传递给回调函数，使用 time.Sleep() 模拟 3s 的耗时操作。</li><li>计算结果出来前，先在界面上显示 <code>Waiting 3s...</code></li></ul><p>接下来我们修改 index.html，为按钮添加点击事件，调用 fibFunc</p><pre><code class="html">&lt;html&gt;...&lt;body&gt;    &lt;input id=&quot;num&quot; type=&quot;number&quot; /&gt;    &lt;button id=&quot;btn&quot; onclick=&quot;fibFunc(num.value * 1, (v)=&gt; ans.innerHTML=v)&quot;&gt;Click&lt;/button&gt;    &lt;p id=&quot;ans&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>为 btn 注册了点击事件，第一个参数是待计算的数字，从 num 输入框获取。</li><li>第二个参数是一个回调函数，将参数 v 显示在 ans 文本框中。</li></ul><p>接下来，重新编译 main.go，访问 localhost:9999，随便输入一个数字，点击 Click。页面会先显示 <code>Waiting 3s...</code>，3s过后显示计算结果。</p><p><img src="quick-go-wasm/callback.png" alt="go wasm callback demo"></p><h2 id="6-进一步的尝试"><a href="#6-进一步的尝试" class="headerlink" title="6 进一步的尝试"></a>6 进一步的尝试</h2><h3 id="6-1-工具框架"><a href="#6-1-工具框架" class="headerlink" title="6.1 工具框架"></a>6.1 工具框架</h3><ul><li>WebAssembly 的二进制分析工具 <a href="https://wasdk.github.io/wasmcodeexplorer/">WebAssembly Code Explorer</a></li><li>使用NodeJs 或浏览器测试 Go Wasm 代码 <a href="https://github.com/golang/go/wiki/WebAssembly#executing-webassembly-with-nodejs">Github Wiki</a></li><li>借鉴 Vue 实现的 Golang WebAssembly 前端框架 <a href="https://www.vugu.org/doc/start">Vugu</a>，完全使用 Go，不用写任何的 JavaScript 代码。</li></ul><h3 id="6-2-Demo-项目"><a href="#6-2-Demo-项目" class="headerlink" title="6.2 Demo/项目"></a>6.2 Demo/项目</h3><ul><li>使用 Go Assembly 前端渲染的一些<a href="https://stdiopt.github.io/gowasm-experiments/">例子</a></li><li><a href="https://github.com/dave/jsgo">jsgo</a> 这个项目汇聚一些小而精的项目，包括 <a href="https://jsgo.io/hajimehoshi/ebiten/examples/2048">2048</a>，<a href="https://jsgo.io/hajimehoshi/ebiten/examples/blocks">俄罗斯方块</a>等游戏，还有证明 Go 可以完整开发前端项目的 <a href="https://jsgo.io/dave/todomvc">TodoMVC</a></li></ul><h3 id="6-3-相关文档"><a href="#6-3-相关文档" class="headerlink" title="6.3 相关文档"></a>6.3 相关文档</h3><ul><li><a href="https://golang.org/pkg/syscall/js">syscall/js 官方文档 - golang.org</a></li><li><a href="https://github.com/golang/go/wiki/WebAssembly">Go WebAssembly 官方文档 - github.com</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919113247.jpg&quot; alt=&quot;Golang WebAssembly&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-WebAssembly-简</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Go WebAssembly" scheme="https://ysluckly.github.io/tags/Go-WebAssembly/"/>
    
    <category term="wasm" scheme="https://ysluckly.github.io/tags/wasm/"/>
    
    <category term="gopherjs" scheme="https://ysluckly.github.io/tags/gopherjs/"/>
    
  </entry>
  
  <entry>
    <title>Go RPC &amp; TLS 鉴权简明教程</title>
    <link href="https://ysluckly.github.io/2022/01/16/go/"/>
    <id>https://ysluckly.github.io/2022/01/16/go/</id>
    <published>2022-01-16T13:59:10.000Z</published>
    <updated>2022-02-20T13:37:43.335Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了 Go 语言远程过程调用(Remote Procedure Call, RPC)的使用方式，示例基于 Golang 标准库 net/rpc，同时介绍了如何基于 TLS/SSL 实现服务器端和客户端的单向鉴权、双向鉴权。</p><h2 id="1-RPC-简介"><a href="#1-RPC-简介" class="headerlink" title="1 RPC 简介"></a>1 RPC 简介</h2><blockquote><p>远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。RPC是一种服务器-客户端（Client/Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。<br>– <a href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8">远程过程调用 - Wikipedia.org</a></p></blockquote><p>划重点：<strong>程序员就像调用本地程序一样，无需关注细节</strong></p><p>RPC 协议假定某种传输协议(TCP, UDP)存在，为通信程序之间携带信息数据。使用 RPC 协议，无需关注底层网络技术协议，调用远程方法就像在调用本地方法一样。</p><p>RPC 流程：</p><p><img src="quick-go-rpc/rpc-procedure.jpg" alt="RPC PROCEDURE"></p><p>RPC 模型是一个典型的客户端-服务器模型(Client-Server, CS)，相比于调用本地的接口，RPC 还需要知道的是服务器端的地址信息。本地调用，好比两个人面对面说话，而 RPC 好比打电话，需要知道对方的电话号码，但是并不需要关心语音是怎么编码，如何传输，又如何解码的。</p><p>接下来我们将展示如何将一个简单的本地调用的程序一步步地改造一个 RPC 服务。</p><p>示例使用 Go 语言，RPC 使用 Golang 提供的<code>net/rpc</code> 标准库</p><h2 id="2-一个简单的计算二次方的程序"><a href="#2-一个简单的计算二次方的程序" class="headerlink" title="2 一个简单的计算二次方的程序"></a>2 一个简单的计算二次方的程序</h2><p>不考虑 RPC 调用，仅考虑本地调用的场景，程序实现如下：</p><pre><code class="go">// main.gopackage mainimport &quot;log&quot;type Result struct &#123;    Num, Ans int&#125;type Cal intfunc (cal *Cal) Square(num int) *Result &#123;    return &amp;Result&#123;        Num: num,        Ans: num * num,    &#125;&#125;func main() &#123;    cal := new(Cal)    result := cal.Square(12)    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)&#125;</code></pre><p>在这个20行的程序中，我们做了以下几件事：</p><ul><li><code>Cal</code> 结构体，提供了 Square 方法，用于计算传入参数 num 的 二次方。</li><li><code>Result</code> 结构体，包含 Num 和 Ans 两个字段，Ans 是计算后的值，Num 是待计算的值。</li><li><code>main</code> 函数，测试我们实现的 Square 方法。</li></ul><p>运行 main.go，将会输出</p><pre><code class="go">$ go run main.go2020/01/13 20:27:08 12^2 = 144</code></pre><h2 id="3-RPC-需要满足什么条件"><a href="#3-RPC-需要满足什么条件" class="headerlink" title="3 RPC 需要满足什么条件"></a>3 RPC 需要满足什么条件</h2><p>虽然说，远程过程调用并不需要我们关心如何编解码，如何通信，但是最基本的，如果一个方法需要支持远程过程调用，需要满足一定的约束和规范。不同 RPC 框架的约束和规范是不同的，如果使用 Golang 的标准库 <code>net/rpc</code>，方法需要长这个样子：</p><pre><code class="go">func (t *T) MethodName(argType T1, replyType *T2) error</code></pre><p>即需要满足以下 5 个条件：</p><ul><li><ol><li>方法类型（T）是导出的（首字母大写） </li></ol></li><li><ol start="2"><li>方法名（MethodName）是导出的</li></ol></li><li><ol start="3"><li>方法有2个参数(argType T1, replyType *T2)，均为导出/内置类型</li></ol></li><li><ol start="4"><li>方法的第2个参数一个指针(replyType *T2)</li></ol></li><li><ol start="5"><li>方法的返回值类型是 error</li></ol></li></ul><p><code>net/rpc</code> 对参数个数的限制比较严格，仅能有2个，第一个参数是调用者提供的请求参数，第二个参数是返回给调用者的响应参数，也就是说，服务端需要将计算结果写在第二个参数中。如果调用过程中发生错误，会返回 error 给调用者。</p><p>接下来，我们改造下 Square 函数，以满足上述 5 个条件。</p><pre><code class="go">func (cal *Cal) Square(num int, result *Result) error &#123;    result.Num = num    result.Ans = num * num    return nil&#125;func main() &#123;    cal := new(Cal)    var result Result    cal.Square(11, &amp;result)    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)&#125;</code></pre><ul><li>Cal 和 Square 均为导出类型，满足条件 1) 和 2) </li><li>2 个参数，<code>num int</code> 为内置类型，<code>result *Result</code> 为导出类型，满足条件 3)</li><li>第2个参数 <code>result *Result</code> 是一个指针，满足条件 4) </li><li>返回值类型是 error，满足条件 5)</li></ul><p>至此，方法 Cal.Square 满足了 RPC 调用的5个条件。</p><h2 id="4-RPC-服务与调用"><a href="#4-RPC-服务与调用" class="headerlink" title="4 RPC 服务与调用"></a>4 RPC 服务与调用</h2><h3 id="4-1-基于HTTP，启动-RPC-服务"><a href="#4-1-基于HTTP，启动-RPC-服务" class="headerlink" title="4.1 基于HTTP，启动 RPC 服务"></a>4.1 基于HTTP，启动 RPC 服务</h3><p>RPC 是一个典型的客户端-服务器(Client-Server, CS) 架构模型，很显然，需要将 Cal.Square 方法放在服务端。服务端需要提供一个套接字服务，处理客户端发送的请求。通常可以基于 HTTP 协议，监听一个端口，等待 HTTP 请求。</p><p>接下来我们新建一个文件夹 server，将 Cal.Square 方法移动到 server/main.go 中，并在 main 函数中启动 RPC 服务。</p><pre><code class="go">// server/main.gopackage mainimport (    &quot;log&quot;    &quot;net&quot;    &quot;net/http&quot;    &quot;net/rpc&quot;)type Result struct &#123;    Num, Ans int&#125;type Cal intfunc (cal *Cal) Square(num int, result *Result) error &#123;    result.Num = num    result.Ans = num * num    return nil&#125;func main() &#123;    rpc.Register(new(Cal))    rpc.HandleHTTP()    log.Printf(&quot;Serving RPC server on port %d&quot;, 1234)    if err := http.ListenAndServe(&quot;:1234&quot;, nil); err != nil &#123;        log.Fatal(&quot;Error serving: &quot;, err)    &#125;&#125;</code></pre><ul><li>使用 <code>rpc.Register</code>，发布 Cal 中满足 RPC 注册条件的方法（Cal.Square）</li><li>使用 <code>rpc.HandleHTTP</code> 注册用于处理 RPC 消息的 HTTP Handler</li><li>使用 <code>http.ListenAndServe</code> 监听 1234 端口，等待 RPC 请求。</li></ul><p>我们在 server 目录下，执行</p><pre><code class="bash">$ go run main.go2020/01/13 20:59:22 Serving RPC server on port 1234</code></pre><p>此时，RPC 服务已经启动，等待客户端的调用。</p><h3 id="4-2-实现客户端"><a href="#4-2-实现客户端" class="headerlink" title="4.2 实现客户端"></a>4.2 实现客户端</h3><p>我们在 client 目录中新建文件 client/main.go，创建 HTTP 客户端，调用 Cal.Square 方法。</p><pre><code class="go">// client/main.gopackage mainimport (    &quot;log&quot;    &quot;net/rpc&quot;)type Result struct &#123;    Num, Ans int&#125;func main() &#123;    client, _ := rpc.DialHTTP(&quot;tcp&quot;, &quot;localhost:1234&quot;)    var result Result    if err := client.Call(&quot;Cal.Square&quot;, 12, &amp;result); err != nil &#123;        log.Fatal(&quot;Failed to call Cal.Square. &quot;, err)    &#125;    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)&#125;</code></pre><p>在客户端的实现中，因为要用到 Result 类型，简单起见，我们拷贝了 <code>Result</code> 的定义。</p><ul><li>使用 <code>rpc.DialHTTP</code> 创建了 HTTP 客户端 client，并且创建了与 localhost:1234 的链接，1234 恰好是 RPC 服务监听的端口。</li><li>使用 <code>rpc.Call</code> 调用远程方法，第1个参数是方法名 Cal.Square，后两个参数与 Cal.Square 的定义的参数相对应。</li></ul><p>我们在 client 目录下，执行</p><pre><code class="bash">2020/01/13 21:17:45 12^2 = 144</code></pre><p>如果能够返回计算的结果，说明调用成功。</p><h3 id="4-3-异步调用"><a href="#4-3-异步调用" class="headerlink" title="4.3 异步调用"></a>4.3 异步调用</h3><p><code>client.Call</code> 是同步调用的方式，会阻塞当前的程序，直到结果返回。如果有异步调用的需求，可以考虑使用<code>client.Go</code>，如下</p><pre><code class="go">func main() &#123;    client, _ := rpc.DialHTTP(&quot;tcp&quot;, &quot;localhost:1234&quot;)    var result Result    asyncCall := client.Go(&quot;Cal.Square&quot;, 12, &amp;result, nil)    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)    &lt;-asyncCall.Done    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)&#125;</code></pre><p>执行结果如下：</p><pre><code>2020/01/13 21:34:26 0^2 = 02020/01/13 21:34:26 12^2 = 144</code></pre><p>因为 <code>client.Go</code> 是异步调用，因此第一次打印 result，result 没有被赋值。而通过调用 <code>&lt;-asyncCall.Done</code>，阻塞当前程序直到 RPC 调用结束，因此第二次打印 result 时，能够看到正确的赋值。</p><h2 id="5-证书鉴权-TLS-SSL"><a href="#5-证书鉴权-TLS-SSL" class="headerlink" title="5 证书鉴权(TLS/SSL)"></a>5 证书鉴权(TLS/SSL)</h2><h3 id="5-1-客户端对服务器端鉴权"><a href="#5-1-客户端对服务器端鉴权" class="headerlink" title="5.1 客户端对服务器端鉴权"></a>5.1 客户端对服务器端鉴权</h3><p>HTTP 协议默认是不加密的，我们可以使用证书来保证通信过程的安全。</p><p>生成私钥和自签名的证书，并将  server.key 权限设置为只读，保证私钥的安全。</p><pre><code class="bash"># 生成私钥openssl genrsa -out server.key 2048# 生成证书openssl req -new -x509 -key server.key -out server.crt -days 3650# 只读权限chmod 400 server.key</code></pre><p>执行完，当前文件夹下多出了 server.crt 和 server.key 2 个文件。</p><p>服务器端可以使用生成的 server.crt 和 server.key 文件启动 TLS 的端口监听。</p><pre><code class="go">// server/main.goimport (    &quot;crypto/tls&quot;    &quot;log&quot;    &quot;net/rpc&quot;)func main() &#123;    rpc.Register(new(Cal))    cert, _ := tls.LoadX509KeyPair(&quot;server.crt&quot;, &quot;server.key&quot;)    config := &amp;tls.Config&#123;        Certificates: []tls.Certificate&#123;cert&#125;,    &#125;    listener, _ := tls.Listen(&quot;tcp&quot;, &quot;:1234&quot;, config)    log.Printf(&quot;Serving RPC server on port %d&quot;, 1234)    for &#123;        conn, _ := listener.Accept()        defer conn.Close()        go rpc.ServeConn(conn)    &#125;&#125;</code></pre><p>客户端也需要做相应的修改，使用 <code>tls.Dial</code> 代替 <code>rpc.DialHTTP</code> 连接服务端，如果客户端不需要对服务端鉴权，那么可以设置 <code>InsecureSkipVerify:true</code>，即可跳过对服务端的鉴权，例如：</p><pre><code class="go">// client/main.goimport (    &quot;crypto/tls&quot;    &quot;log&quot;    &quot;net/rpc&quot;)func main() &#123;    config := &amp;tls.Config&#123;        InsecureSkipVerify: true,    &#125;    conn, _ := tls.Dial(&quot;tcp&quot;, &quot;localhost:1234&quot;, config)    defer conn.Close()    client := rpc.NewClient(conn)    var result Result    if err := client.Call(&quot;Cal.Square&quot;, 12, &amp;result); err != nil &#123;        log.Fatal(&quot;Failed to call Cal.Square. &quot;, err)    &#125;    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)&#125;</code></pre><p>如果需要对服务器端鉴权，那么需要将服务端的证书添加到信任证书池中，如下：</p><pre><code class="go">// client/main.gofunc main() &#123;    certPool := x509.NewCertPool()    certBytes, err := ioutil.ReadFile(&quot;../server/server.crt&quot;)    if err != nil &#123;        log.Fatal(&quot;Failed to read server.crt&quot;)    &#125;    certPool.AppendCertsFromPEM(certBytes)    config := &amp;tls.Config&#123;        RootCAs: certPool,    &#125;    conn, _ := tls.Dial(&quot;tcp&quot;, &quot;localhost:1234&quot;, config)    defer conn.Close()    client := rpc.NewClient(conn)    var result Result    if err := client.Call(&quot;Cal.Square&quot;, 12, &amp;result); err != nil &#123;        log.Fatal(&quot;Failed to call Cal.Square. &quot;, err)    &#125;    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)&#125;</code></pre><h3 id="5-2-服务器端对客户端的鉴权"><a href="#5-2-服务器端对客户端的鉴权" class="headerlink" title="5.2 服务器端对客户端的鉴权"></a>5.2 服务器端对客户端的鉴权</h3><p>服务器端对客户端的鉴权是类似的，核心在于 <code>tls.Config</code> 的配置：</p><ul><li>把对方的证书添加到自己的信任证书池 <code>RootCAs</code>(客户端配置)，<code>ClientCAs</code>(服务器端配置) 中。</li><li>创建链接时，配置自己的证书 <code>Certificates</code>。</li></ul><p>客户端的 config 作如下修改：</p><pre><code class="go">// client/main.gocert, _ := tls.LoadX509KeyPair(&quot;client.crt&quot;, &quot;client.key&quot;)certPool := x509.NewCertPool()certBytes, _ := ioutil.ReadFile(&quot;../server/server.crt&quot;)certPool.AppendCertsFromPEM(certBytes)config := &amp;tls.Config&#123;    Certificates: []tls.Certificate&#123;cert&#125;,    RootCAs: certPool,&#125;</code></pre><p>服务器端的 config 作如下修改：</p><pre><code class="go">// server/main.gocert, _ := tls.LoadX509KeyPair(&quot;server.crt&quot;, &quot;server.key&quot;)certPool := x509.NewCertPool()certBytes, _ := ioutil.ReadFile(&quot;../client/client.crt&quot;)certPool.AppendCertsFromPEM(certBytes)config := &amp;tls.Config&#123;    Certificates: []tls.Certificate&#123;cert&#125;,    ClientAuth:   tls.RequireAndVerifyClientCert,    ClientCAs:    certPool,&#125;</code></pre><h2 id="附：参考"><a href="#附：参考" class="headerlink" title="附：参考"></a>附：参考</h2><ol><li><a href="https://golang.org/pkg/net/rpc/">Golang net/rpc 官方文档 - golang.org</a></li><li><a href="https://github.com/denji/golang-tls">Golang TLS 配置 - github.com</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文介绍了 Go 语言远程过程调用(Remote Procedure Call, RPC)的使用方式，示例基于 Golang 标准库 net/rpc，同时介绍了如何基于 TLS/SSL 实现服务器端和客户端的单向鉴权、双向鉴权。&lt;/p&gt;
&lt;h2 id=&quot;1-RPC-简介&quot;&gt;</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="TLS" scheme="https://ysluckly.github.io/tags/TLS/"/>
    
    <category term="Golang" scheme="https://ysluckly.github.io/tags/Golang/"/>
    
    <category term="RPC" scheme="https://ysluckly.github.io/tags/RPC/"/>
    
    <category term="证书" scheme="https://ysluckly.github.io/tags/%E8%AF%81%E4%B9%A6/"/>
    
    <category term="鉴权" scheme="https://ysluckly.github.io/tags/%E9%89%B4%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Go Protobuf 简明教程</title>
    <link href="https://ysluckly.github.io/2022/01/16/go/"/>
    <id>https://ysluckly.github.io/2022/01/16/go/</id>
    <published>2022-01-16T13:59:10.000Z</published>
    <updated>2022-02-20T13:37:12.952Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114831.jpg" alt="Golang Protocol Buffers"></p><h2 id="1-Protocol-Buffers-简介"><a href="#1-Protocol-Buffers-简介" class="headerlink" title="1 Protocol Buffers 简介"></a>1 Protocol Buffers 简介</h2><p>protobuf 即 Protocol Buffers，是一种轻便高效的结构化数据存储格式，与语言、平台无关，可扩展可序列化。protobuf 性能和效率大幅度优于 JSON、XML 等其他的结构化数据格式。protobuf 是以二进制方式存储的，占用空间小，但也带来了可读性差的缺点。protobuf 在通信协议和数据存储等领域应用广泛。例如著名的分布式缓存工具 <a href="https://memcached.org/">Memcached</a> 的 Go 语言版本<a href="https://github.com/golang/groupcache">groupcache</a> 就使用了 protobuf 作为其 RPC 数据格式。</p><p>Protobuf 在 <code>.proto</code> 定义需要处理的结构化数据，可以通过 <code>protoc</code> 工具，将 <code>.proto</code> 文件转换为 C、C++、Golang、Java、Python 等多种语言的代码，兼容性好，易于使用。</p><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h2><h3 id="2-1-protoc"><a href="#2-1-protoc" class="headerlink" title="2.1 protoc"></a>2.1 protoc</h3><p>从 <a href="https://github.com/protocolbuffers/protobuf/releases">Protobuf Releases</a> 下载最先版本的发布包安装。如果是 Ubuntu，可以按照如下步骤操作（以3.11.2为例）。</p><pre><code class="bash"># 下载安装包$ wget https://github.com/protocolbuffers/protobuf/releases/download/v3.11.2/protoc-3.11.2-linux-x86_64.zip# 解压到 /usr/local 目录下$ sudo 7z x protoc-3.11.2-linux-x86_64.zip -o/usr/local</code></pre><p>如果不想安装在 /usr/local 目录下，可以解压到其他的其他，并把解压路径下的 bin 目录 加入到环境变量即可。</p><p>如果能正常显示版本，则表示安装成功。</p><pre><code class="bash">$ protoc --versionlibprotoc 3.11.2</code></pre><h3 id="2-2-protoc-gen-go"><a href="#2-2-protoc-gen-go" class="headerlink" title="2.2 protoc-gen-go"></a>2.2 protoc-gen-go</h3><p>我们需要在 Golang 中使用 protobuf，还需要安装 protoc-gen-go，这个工具用来将 <code>.proto</code> 文件转换为 Golang 代码。</p><pre><code class="bash">go get -u github.com/golang/protobuf/protoc-gen-go</code></pre><p>protoc-gen-go 将自动安装到 <code>$GOPATH/bin</code> 目录下，也需要将这个目录加入到环境变量中。</p><h2 id="3-定义消息类型"><a href="#3-定义消息类型" class="headerlink" title="3 定义消息类型"></a>3 定义消息类型</h2><p>接下来，我们创建一个非常简单的示例，<code>student.proto</code></p><pre><code class="go">syntax = &quot;proto3&quot;;package main;// this is a commentmessage Student &#123;  string name = 1;  bool male = 2;  repeated int32 scores = 3;&#125;</code></pre><p>在当前目录下执行：</p><pre><code class="bash">$ protoc --go_out=. *.proto$ lsstudent.pb.go  student.proto</code></pre><p>即是，将该目录下的所有的 .proto 文件转换为 Go 代码，我们可以看到该目录下多出了一个 Go 文件 <em>student.pb.go</em>。这个文件内部定义了一个结构体 Student，以及相关的方法：</p><pre><code class="go">type Student struct &#123;    Name string `protobuf:&quot;bytes,1,opt,name=name,proto3&quot; json:&quot;name,omitempty&quot;`    Male bool `protobuf:&quot;varint,2,opt,name=male,proto3&quot; json:&quot;male,omitempty&quot;`    Scores []int32 `protobuf:&quot;varint,3,rep,packed,name=scores,proto3&quot; json:&quot;scores,omitempty&quot;`    ...&#125;</code></pre><p>逐行解读<code>student.proto</code></p><ul><li>protobuf 有2个版本，默认版本是 proto2，如果需要 proto3，则需要在非空非注释第一行使用 <code>syntax = &quot;proto3&quot;</code> 标明版本。</li><li><code>package</code>，即包名声明符是可选的，用来防止不同的消息类型有命名冲突。</li><li>消息类型 使用 <code>message</code> 关键字定义，Student 是类型名，name, male, scores 是该类型的 3 个字段，类型分别为 string, bool 和 []int32。字段可以是标量类型，也可以是合成类型。</li><li>每个字段的修饰符默认是 singular，一般省略不写，<code>repeated</code> 表示字段可重复，即用来表示 Go 语言中的数组类型。</li><li>每个字符 <code>=</code>后面的数字称为标识符，每个字段都需要提供一个唯一的标识符。标识符用来在消息的二进制格式中识别各个字段，一旦使用就不能够再改变，标识符的取值范围为 [1, 2^29 - 1] 。</li><li>.proto 文件可以写注释，单行注释 <code>//</code>，多行注释 <code>/* ... */</code></li><li>一个 .proto 文件中可以写多个消息类型，即对应多个结构体(struct)。</li></ul><p>接下来，就可以在项目代码中直接使用了，以下是一个非常简单的例子，即证明被序列化的和反序列化后的实例，包含相同的数据。</p><pre><code class="go">package mainimport (    &quot;log&quot;    &quot;github.com/golang/protobuf/proto&quot;)func main() &#123;    test := &amp;Student&#123;        Name: &quot;geektutu&quot;,        Male:  true,        Scores: []int32&#123;98, 85, 88&#125;,    &#125;    data, err := proto.Marshal(test)    if err != nil &#123;        log.Fatal(&quot;marshaling error: &quot;, err)    &#125;    newTest := &amp;Student&#123;&#125;    err = proto.Unmarshal(data, newTest)    if err != nil &#123;        log.Fatal(&quot;unmarshaling error: &quot;, err)    &#125;    // Now test and newTest contain the same data.    if test.GetName() != newTest.GetName() &#123;        log.Fatalf(&quot;data mismatch %q != %q&quot;, test.GetName(), newTest.GetName())    &#125;&#125;</code></pre><ul><li>保留字段(Reserved Field)</li></ul><p>更新消息类型时，可能会将某些字段/标识符删除。这些被删掉的字段/标识符可能被重新使用，如果加载老版本的数据时，可能会造成数据冲突，在升级时，可以将这些字段/标识符保留(reserved)，这样就不会被重新使用了，protoc 会检查。</p><pre><code class="go">message Foo &#123;  reserved 2, 15, 9 to 11;  reserved &quot;foo&quot;, &quot;bar&quot;;&#125;</code></pre><h2 id="4-字段类型"><a href="#4-字段类型" class="headerlink" title="4 字段类型"></a>4 字段类型</h2><h3 id="4-1-标量类型-Scalar"><a href="#4-1-标量类型-Scalar" class="headerlink" title="4.1 标量类型(Scalar)"></a>4.1 标量类型(Scalar)</h3><table><thead><tr><th>proto类型</th><th>go类型</th><th>备注</th><th>proto类型</th><th>go类型</th><th>备注</th></tr></thead><tbody><tr><td>double</td><td>float64</td><td></td><td>float</td><td>float32</td><td></td></tr><tr><td>int32</td><td>int32</td><td></td><td>int64</td><td>int64</td><td></td></tr><tr><td>uint32</td><td>uint32</td><td></td><td>uint64</td><td>uint64</td><td></td></tr><tr><td>sint32</td><td>int32</td><td>适合负数</td><td>sint64</td><td>int64</td><td>适合负数</td></tr><tr><td>fixed32</td><td>uint32</td><td>固长编码，适合大于2^28的值</td><td>fixed64</td><td>uint64</td><td>固长编码，适合大于2^56的值</td></tr><tr><td>sfixed32</td><td>int32</td><td>固长编码</td><td>sfixed64</td><td>int64</td><td>固长编码</td></tr><tr><td>bool</td><td>bool</td><td></td><td>string</td><td>string</td><td>UTF8 编码，长度不超过 2^32</td></tr><tr><td>bytes</td><td>[]byte</td><td>任意字节序列，长度不超过 2^32</td><td></td><td></td><td></td></tr></tbody></table><p>标量类型如果没有被赋值，则不会被序列化，解析时，会赋予默认值。</p><ul><li>strings：空字符串</li><li>bytes：空序列</li><li>bools：false</li><li>数值类型：0</li></ul><h3 id="4-2-枚举-Enumerations"><a href="#4-2-枚举-Enumerations" class="headerlink" title="4.2 枚举(Enumerations)"></a>4.2 枚举(Enumerations)</h3><p>枚举类型适用于提供一组预定义的值，选择其中一个。例如我们将性别定义为枚举类型。</p><pre><code class="go">message Student &#123;  string name = 1;  enum Gender &#123;    FEMALE = 0;    MALE = 1;  &#125;  Gender gender = 2;  repeated int32 scores = 3;&#125;</code></pre><ul><li>枚举类型的第一个选项的标识符必须是0，这也是枚举类型的默认值。</li><li>别名（Alias），允许为不同的枚举值赋予相同的标识符，称之为别名，需要打开<code>allow_alias</code>选项。</li></ul><pre><code class="go">message EnumAllowAlias &#123;  enum Status &#123;    option allow_alias = true;    UNKOWN = 0;    STARTED = 1;    RUNNING = 1;  &#125;&#125;</code></pre><h3 id="4-3-使用其他消息类型"><a href="#4-3-使用其他消息类型" class="headerlink" title="4.3 使用其他消息类型"></a>4.3 使用其他消息类型</h3><p><code>Result</code>是另一个消息类型，在 SearchReponse 作为一个消息字段类型使用。</p><pre><code class="go">message SearchResponse &#123;  repeated Result results = 1; &#125;message Result &#123;  string url = 1;  string title = 2;  repeated string snippets = 3;&#125;</code></pre><p>嵌套写也是支持的：</p><pre><code class="go">message SearchResponse &#123;  message Result &#123;    string url = 1;    string title = 2;    repeated string snippets = 3;  &#125;  repeated Result results = 1;&#125;</code></pre><p>如果定义在其他文件中，可以导入其他消息类型来使用：</p><pre><code class="go">import &quot;myproject/other_protos.proto&quot;;</code></pre><h3 id="4-4-任意类型-Any"><a href="#4-4-任意类型-Any" class="headerlink" title="4.4 任意类型(Any)"></a>4.4 任意类型(Any)</h3><p>Any 可以表示不在 .proto 中定义任意的内置类型。</p><pre><code class="go">import &quot;google/protobuf/any.proto&quot;;message ErrorStatus &#123;  string message = 1;  repeated google.protobuf.Any details = 2;&#125;</code></pre><h3 id="4-5-oneof"><a href="#4-5-oneof" class="headerlink" title="4.5 oneof"></a>4.5 oneof</h3><pre><code class="go">message SampleMessage &#123;  oneof test_oneof &#123;    string name = 4;    SubMessage sub_message = 9;  &#125;&#125;</code></pre><h3 id="4-6-map"><a href="#4-6-map" class="headerlink" title="4.6 map"></a>4.6 map</h3><pre><code class="go">message MapRequest &#123;  map&lt;string, int32&gt; points = 1;&#125;</code></pre><h2 id="5-定义服务-Services"><a href="#5-定义服务-Services" class="headerlink" title="5 定义服务(Services)"></a>5 定义服务(Services)</h2><p>如果消息类型是用来远程通信的(Remote Procedure Call, RPC)，可以在 .proto 文件中定义 RPC 服务接口。例如我们定义了一个名为 SearchService 的 RPC 服务，提供了 <code>Search</code> 接口，入参是 <code>SearchRequest</code> 类型，返回类型是 <code>SearchResponse</code></p><pre><code class="go">service SearchService &#123;  rpc Search (SearchRequest) returns (SearchResponse);&#125;</code></pre><p>官方仓库也提供了一个<a href="https://github.com/protocolbuffers/protobuf/blob/master/docs/third_party.md">插件列表</a>，帮助开发基于 Protocol Buffer 的 RPC 服务。</p><h2 id="6-protoc-其他参数"><a href="#6-protoc-其他参数" class="headerlink" title="6 protoc 其他参数"></a>6 protoc 其他参数</h2><p>命令行使用方法</p><pre><code class="bash">protoc --proto_path=IMPORT_PATH --&lt;lang&gt;_out=DST_DIR path/to/file.proto</code></pre><ul><li><code>--proto_path=IMPORT_PATH</code>：可以在 .proto 文件中 import 其他的 .proto 文件，proto_path 即用来指定其他 .proto 文件的查找目录。如果没有引入其他的 .proto 文件，该参数可以省略。</li><li><code>--&lt;lang&gt;_out=DST_DIR</code>：指定生成代码的目标文件夹，例如 –go_out=. 即生成 GO 代码在当前文件夹，另外支持 cpp/java/python/ruby/objc/csharp/php 等语言</li></ul><h2 id="7-推荐风格"><a href="#7-推荐风格" class="headerlink" title="7 推荐风格"></a>7 推荐风格</h2><ul><li><p>文件(Files)</p><ul><li>文件名使用小写下划线的命名风格，例如 lower_snake_case.proto</li><li>每行不超过 80 字符</li><li>使用 2 个空格缩进</li></ul></li><li><p>包(Packages)</p><ul><li>包名应该和目录结构对应，例如文件在<code>my/package/</code>目录下，包名应为 <code>my.package</code></li></ul></li><li><p>消息和字段(Messages &amp; Fields)</p><ul><li>消息名使用首字母大写驼峰风格(CamelCase)，例如<code>message StudentRequest &#123; ... &#125;</code></li><li>字段名使用小写下划线的风格，例如 <code>string status_code = 1</code></li><li>枚举类型，枚举名使用首字母大写驼峰风格，例如 <code>enum FooBar</code>，枚举值使用全大写下划线隔开的风格(CAPITALS_WITH_UNDERSCORES )，例如 FOO_DEFAULT=1</li></ul></li><li><p>服务(Services) </p><ul><li>RPC 服务名和方法名，均使用首字母大写驼峰风格，例如<code>service FooService&#123; rpc GetSomething() &#125;</code></li></ul></li></ul><h2 id="附：参考"><a href="#附：参考" class="headerlink" title="附：参考"></a>附：参考</h2><ol><li><a href="https://github.com/protocolbuffers/protobuf">protobuf 代码仓库 - github.com</a></li><li><a href="https://github.com/golang/protobuf">golang protobuf 代码仓库 - github.com</a></li><li><a href="https://en.wikipedia.org/wiki/Remote_procedure_call">Remote procedure call 远程过程调用 - wikipedia.org</a></li><li><a href="https://github.com/golang/groupcache">Groupcache Go语言版 memcached - github.com</a></li><li><a href="https://developers.google.com/protocol-buffers/docs/proto3">Language Guide (proto3) 官方指南 - google.com</a></li><li><a href="https://developers.google.com/protocol-buffers/docs/style">Proto Style Guide 代码风格指南 - google.com</a></li><li><a href="https://github.com/protocolbuffers/protobuf/blob/master/docs/third_party.md">Protocol Buffer 插件列表 - github.com</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114831.jpg&quot; alt=&quot;Golang Protocol Buffers&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-Protocol</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Golang" scheme="https://ysluckly.github.io/tags/Golang/"/>
    
    <category term="RPC" scheme="https://ysluckly.github.io/tags/RPC/"/>
    
    <category term="Protocol Buffers" scheme="https://ysluckly.github.io/tags/Protocol-Buffers/"/>
    
    <category term="Protobuf" scheme="https://ysluckly.github.io/tags/Protobuf/"/>
    
  </entry>
  
  <entry>
    <title>Go Test 单元测试简明教程</title>
    <link href="https://ysluckly.github.io/2022/01/16/go/"/>
    <id>https://ysluckly.github.io/2022/01/16/go/</id>
    <published>2022-01-16T13:59:10.000Z</published>
    <updated>2022-02-20T13:38:12.755Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919113329.jpg" alt="golang test"></p><h2 id="1-如何写好单元测试"><a href="#1-如何写好单元测试" class="headerlink" title="1 如何写好单元测试"></a>1 如何写好单元测试</h2><p>单元测试(Unit Tests, UT) 是一个优秀项目不可或缺的一部分，特别是在一些频繁变动和多人合作开发的项目中尤为重要。你或多或少都会有因为自己的提交，导致应用挂掉或服务宕机的经历。如果这个时候你的修改导致测试用例失败，你再重新审视自己的修改，发现之前的修改还有一些特殊场景没有包含，恭喜你减少了一次上库失误。也会有这样的情况，项目很大，启动环境很复杂，你优化了一个函数的性能，或是添加了某个新的特性，如果部署在正式环境上之后再进行测试，成本太高。对于这种场景，几个小小的测试用例或许就能够覆盖大部分的测试场景。而且在开发过程中，效率最高的莫过于所见即所得了，单元测试也能够帮助你做到这一点，试想一下，假如你一口气写完一千行代码，debug 的过程也不会轻松，如果在这个过程中，对于一些逻辑较为复杂的函数，同时添加一些测试用例，即时确保正确性，最后集成的时候，会是另外一番体验。</p><p>如何写好单元测试呢？</p><p>首先，学会写测试用例。比如如何测试单个函数/方法；比如如何做基准测试；比如如何写出简洁精炼的测试代码；再比如遇到数据库访问等的方法调用时，如何 <code>mock</code>。</p><p>然后，写可测试的代码。<code>高内聚，低耦合</code>是软件工程的原则，同样，对测试而言，函数/方法写法不同，测试难度也是不一样的。职责单一，参数类型简单，与其他函数耦合度低的函数往往更容易测试。我们经常会说，“这种代码没法测试”，这种时候，就得思考函数的写法可不可以改得更好一些。为了代码可测试而重构是值得的。</p><p>接下来将介绍如何使用 Go 语言的标准库 <code>testing</code> 进行单元测试。</p><h2 id="2-一个简单例子"><a href="#2-一个简单例子" class="headerlink" title="2 一个简单例子"></a>2 一个简单例子</h2><p>Go 语言推荐测试文件和源代码文件放在一块，测试文件以 <code>_test.go</code> 结尾。比如，当前 package 有 <code>calc.go</code> 一个文件，我们想测试 <code>calc.go</code> 中的 <code>Add</code> 和 <code>Mul</code> 函数，那么应该新建 <code>calc_test.go</code> 作为测试文件。</p><pre><code class="bash">example/   |--calc.go   |--calc_test.go</code></pre><p>假如 <code>calc.go</code> 的代码如下：</p><pre><code class="go">package mainfunc Add(a int, b int) int &#123;    return a + b&#125;func Mul(a int, b int) int &#123;    return a * b&#125;</code></pre><p>那么 <code>calc_test.go</code> 中的测试用例可以这么写：</p><pre><code class="go">package mainimport &quot;testing&quot;func TestAdd(t *testing.T) &#123;    if ans := Add(1, 2); ans != 3 &#123;        t.Errorf(&quot;1 + 2 expected be 3, but %d got&quot;, ans)    &#125;    if ans := Add(-10, -20); ans != -30 &#123;        t.Errorf(&quot;-10 + -20 expected be -30, but %d got&quot;, ans)    &#125;&#125;</code></pre><ul><li>测试用例名称一般命名为 <code>Test</code> 加上待测试的方法名。</li><li>测试用的参数有且只有一个，在这里是 <code>t *testing.T</code>。</li><li>基准测试(benchmark)的参数是 <code>*testing.B</code>，TestMain 的参数是 <code>*testing.M</code> 类型。</li></ul><p>运行 <code>go test</code>，该 package 下所有的测试用例都会被执行。</p><pre><code class="bash">$ go testok      example 0.009s</code></pre><p>或 <code>go test -v</code>，<code>-v</code> 参数会显示每个用例的测试结果，另外 <code>-cover</code> 参数可以查看覆盖率。</p><pre><code class="bash">$ go test -v=== RUN   TestAdd--- PASS: TestAdd (0.00s)=== RUN   TestMul--- PASS: TestMul (0.00s)PASSok      example 0.007s</code></pre><p>如果只想运行其中的一个用例，例如 <code>TestAdd</code>，可以用 <code>-run</code> 参数指定，该参数支持通配符 <code>*</code>，和部分正则表达式，例如 <code>^</code>、<code>$</code>。</p><pre><code class="bash">$ go test -run TestAdd -v=== RUN   TestAdd--- PASS: TestAdd (0.00s)PASSok      example 0.007s</code></pre><h2 id="3-子测试-Subtests"><a href="#3-子测试-Subtests" class="headerlink" title="3 子测试(Subtests)"></a>3 子测试(Subtests)</h2><p>子测试是 Go 语言内置支持的，可以在某个测试用例中，根据测试场景使用 <code>t.Run</code>创建不同的子测试用例：</p><pre><code class="go">// calc_test.gofunc TestMul(t *testing.T) &#123;    t.Run(&quot;pos&quot;, func(t *testing.T) &#123;        if Mul(2, 3) != 6 &#123;            t.Fatal(&quot;fail&quot;)        &#125;    &#125;)    t.Run(&quot;neg&quot;, func(t *testing.T) &#123;        if Mul(2, -3) != -6 &#123;            t.Fatal(&quot;fail&quot;)        &#125;    &#125;)&#125;</code></pre><ul><li>之前的例子测试失败时使用 <code>t.Error/t.Errorf</code>，这个例子中使用 <code>t.Fatal/t.Fatalf</code>，区别在于前者遇错不停，还会继续执行其他的测试用例，后者遇错即停。</li></ul><p>运行某个测试用例的子测试：</p><pre><code class="bash">$ go test -run TestMul/pos -v=== RUN   TestMul=== RUN   TestMul/pos--- PASS: TestMul (0.00s)    --- PASS: TestMul/pos (0.00s)PASSok      example 0.008s</code></pre><p>对于多个子测试的场景，更推荐如下的写法(table-driven tests)：</p><pre><code class="go">//  calc_test.gofunc TestMul(t *testing.T) &#123;    cases := []struct &#123;        Name           string        A, B, Expected int    &#125;&#123;        &#123;&quot;pos&quot;, 2, 3, 6&#125;,        &#123;&quot;neg&quot;, 2, -3, -6&#125;,        &#123;&quot;zero&quot;, 2, 0, 0&#125;,    &#125;    for _, c := range cases &#123;        t.Run(c.Name, func(t *testing.T) &#123;            if ans := Mul(c.A, c.B); ans != c.Expected &#123;                t.Fatalf(&quot;%d * %d expected %d, but %d got&quot;,                    c.A, c.B, c.Expected, ans)            &#125;        &#125;)    &#125;&#125;</code></pre><p>所有用例的数据组织在切片 <code>cases</code> 中，看起来就像一张表，借助循环创建子测试。这样写的好处有：</p><ul><li>新增用例非常简单，只需给 cases 新增一条测试数据即可。</li><li>测试代码可读性好，直观地能够看到每个子测试的参数和期待的返回值。</li><li>用例失败时，报错信息的格式比较统一，测试报告易于阅读。</li></ul><p>如果数据量较大，或是一些二进制数据，推荐使用相对路径从文件中读取。</p><h2 id="4-帮助函数-helpers"><a href="#4-帮助函数-helpers" class="headerlink" title="4 帮助函数(helpers)"></a>4 帮助函数(helpers)</h2><p>对一些重复的逻辑，抽取出来作为公共的帮助函数(helpers)，可以增加测试代码的可读性和可维护性。 借助帮助函数，可以让测试用例的主逻辑看起来更清晰。</p><p>例如，我们可以将创建子测试的逻辑抽取出来：</p><pre><code class="go">// calc_test.gopackage mainimport &quot;testing&quot;type calcCase struct&#123; A, B, Expected int &#125;func createMulTestCase(t *testing.T, c *calcCase) &#123;    // t.Helper()    if ans := Mul(c.A, c.B); ans != c.Expected &#123;        t.Fatalf(&quot;%d * %d expected %d, but %d got&quot;,            c.A, c.B, c.Expected, ans)    &#125;&#125;func TestMul(t *testing.T) &#123;    createMulTestCase(t, &amp;calcCase&#123;2, 3, 6&#125;)    createMulTestCase(t, &amp;calcCase&#123;2, -3, -6&#125;)    createMulTestCase(t, &amp;calcCase&#123;2, 0, 1&#125;) // wrong case&#125;</code></pre><p>在这里，我们故意创建了一个错误的测试用例，运行 <code>go test</code>，用例失败，会报告错误发生的文件和行号信息：</p><pre><code class="bash">$ go test--- FAIL: TestMul (0.00s)    calc_test.go:11: 2 * 0 expected 1, but 0 gotFAILexit status 1FAIL    example 0.007s</code></pre><p>可以看到，错误发生在第11行，也就是帮助函数 <code>createMulTestCase</code> 内部。18, 19, 20行都调用了该方法，我们第一时间并不能够确定是哪一行发生了错误。有些帮助函数还可能在不同的函数中被调用，报错信息都在同一处，不方便问题定位。因此，Go 语言在 1.9 版本中引入了 <code>t.Helper()</code>，用于标注该函数是帮助函数，报错时将输出帮助函数调用者的信息，而不是帮助函数的内部信息。</p><p>修改 <code>createMulTestCase</code>，调用 <code>t.Helper()</code></p><pre><code class="go">func createMulTestCase(c *calcCase, t *testing.T) &#123;    t.Helper()    t.Run(c.Name, func(t *testing.T) &#123;        if ans := Mul(c.A, c.B); ans != c.Expected &#123;            t.Fatalf(&quot;%d * %d expected %d, but %d got&quot;,                c.A, c.B, c.Expected, ans)        &#125;    &#125;)&#125;</code></pre><p>运行 <code>go test</code>，报错信息如下，可以非常清晰地知道，错误发生在第 20 行。</p><pre><code class="bash">$ go test--- FAIL: TestMul (0.00s)    calc_test.go:20: 2 * 0 expected 1, but 0 gotFAILexit status 1FAIL    example 0.006s</code></pre><p>关于 <code>helper</code> 函数的 2 个建议：</p><ul><li>不要返回错误， 帮助函数内部直接使用 <code>t.Error</code> 或 <code>t.Fatal</code> 即可，在用例主逻辑中不会因为太多的错误处理代码，影响可读性。</li><li>调用 <code>t.Helper()</code> 让报错信息更准确，有助于定位。</li></ul><h2 id="5-setup-和-teardown"><a href="#5-setup-和-teardown" class="headerlink" title="5 setup 和 teardown"></a>5 setup 和 teardown</h2><p>如果在同一个测试文件中，每一个测试用例运行前后的逻辑是相同的，一般会写在 setup 和 teardown 函数中。例如执行前需要实例化待测试的对象，如果这个对象比较复杂，很适合将这一部分逻辑提取出来；执行后，可能会做一些资源回收类的工作，例如关闭网络连接，释放文件等。标准库 <code>testing</code> 提供了这样的机制：</p><pre><code class="go">func setup() &#123;    fmt.Println(&quot;Before all tests&quot;)&#125;func teardown() &#123;    fmt.Println(&quot;After all tests&quot;)&#125;func Test1(t *testing.T) &#123;    fmt.Println(&quot;I&#39;m test1&quot;)&#125;func Test2(t *testing.T) &#123;    fmt.Println(&quot;I&#39;m test2&quot;)&#125;func TestMain(m *testing.M) &#123;    setup()    code := m.Run()    teardown()    os.Exit(code)&#125;</code></pre><ul><li>在这个测试文件中，包含有2个测试用例，<code>Test1</code> 和 <code>Test2</code>。</li><li>如果测试文件中包含函数 <code>TestMain</code>，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。</li><li>调用 <code>m.Run()</code> 触发所有测试用例的执行，并使用 <code>os.Exit()</code> 处理返回的状态码，如果不为0，说明有用例失败。</li><li>因此可以在调用 <code>m.Run()</code> 前后做一些额外的准备(setup)和回收(teardown)工作。</li></ul><p>执行 <code>go test</code>，将会输出</p><pre><code class="bash">$ go testBefore all testsI&#39;m test1I&#39;m test2PASSAfter all testsok      example 0.006s</code></pre><h2 id="6-网络测试-Network"><a href="#6-网络测试-Network" class="headerlink" title="6 网络测试(Network)"></a>6 网络测试(Network)</h2><h3 id="6-1-TCP-HTTP"><a href="#6-1-TCP-HTTP" class="headerlink" title="6.1 TCP/HTTP"></a>6.1 TCP/HTTP</h3><p>假设需要测试某个 API 接口的 handler 能够正常工作，例如 helloHandler </p><pre><code class="go">func helloHandler(w http.ResponseWriter, r *http.Request) &#123;    w.Write([]byte(&quot;hello world&quot;))&#125;</code></pre><p>那我们可以创建真实的网络连接进行测试：</p><pre><code class="go">// test codeimport (    &quot;io/ioutil&quot;    &quot;net&quot;    &quot;net/http&quot;    &quot;testing&quot;)func handleError(t *testing.T, err error) &#123;    t.Helper()    if err != nil &#123;        t.Fatal(&quot;failed&quot;, err)    &#125;&#125;func TestConn(t *testing.T) &#123;    ln, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:0&quot;)    handleError(t, err)    defer ln.Close()    http.HandleFunc(&quot;/hello&quot;, helloHandler)    go http.Serve(ln, nil)    resp, err := http.Get(&quot;http://&quot; + ln.Addr().String() + &quot;/hello&quot;)    handleError(t, err)    defer resp.Body.Close()    body, err := ioutil.ReadAll(resp.Body)    handleError(t, err)    if string(body) != &quot;hello world&quot; &#123;        t.Fatal(&quot;expected hello world, but got&quot;, string(body))    &#125;&#125;</code></pre><ul><li><code>net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:0&quot;)</code>：监听一个未被占用的端口，并返回 Listener。</li><li>调用 <code>http.Serve(ln, nil)</code> 启动 http 服务。</li><li>使用 <code>http.Get</code> 发起一个 Get 请求，检查返回值是否正确。</li><li>尽量不对 <code>http</code> 和 <code>net</code> 库使用 mock，这样可以覆盖较为真实的场景。</li></ul><h3 id="6-2-httptest"><a href="#6-2-httptest" class="headerlink" title="6.2 httptest"></a>6.2 httptest</h3><p>针对 http 开发的场景，使用标准库 <code>net/http/httptest</code> 进行测试更为高效。</p><p>上述的测试用例改写如下：</p><pre><code class="go">// test codeimport (    &quot;io/ioutil&quot;    &quot;net/http&quot;    &quot;net/http/httptest&quot;    &quot;testing&quot;)func TestConn(t *testing.T) &#123;    req := httptest.NewRequest(&quot;GET&quot;, &quot;http://example.com/foo&quot;, nil)    w := httptest.NewRecorder()    helloHandler(w, req)    bytes, _ := ioutil.ReadAll(w.Result().Body)    if string(bytes) != &quot;hello world&quot; &#123;        t.Fatal(&quot;expected hello world, but got&quot;, string(bytes))    &#125;&#125;</code></pre><p>使用 httptest 模拟请求对象(req)和响应对象(w)，达到了相同的目的。</p><h2 id="7-Benchmark-基准测试"><a href="#7-Benchmark-基准测试" class="headerlink" title="7 Benchmark 基准测试"></a>7 Benchmark 基准测试</h2><p>基准测试用例的定义如下：</p><pre><code class="go">func BenchmarkName(b *testing.B)&#123;    // ...&#125;</code></pre><ul><li>函数名必须以 <code>Benchmark</code> 开头，后面一般跟待测试的函数名</li><li>参数为 <code>b *testing.B</code>。</li><li>执行基准测试时，需要添加 <code>-bench</code> 参数。</li></ul><p>例如：</p><pre><code class="go">func BenchmarkHello(b *testing.B) &#123;    for i := 0; i &lt; b.N; i++ &#123;        fmt.Sprintf(&quot;hello&quot;)    &#125;&#125;</code></pre><pre><code class="bash">$ go test -benchmem -bench ....BenchmarkHello-16   15991854   71.6 ns/op   5 B/op   1 allocs/op...</code></pre><p>基准测试报告每一列值对应的含义如下：</p><pre><code class="go">type BenchmarkResult struct &#123;    N         int           // 迭代次数    T         time.Duration // 基准测试花费的时间    Bytes     int64         // 一次迭代处理的字节数    MemAllocs uint64        // 总的分配内存的次数    MemBytes  uint64        // 总的分配内存的字节数&#125;</code></pre><p>如果在运行前基准测试需要一些耗时的配置，则可以使用 <code>b.ResetTimer()</code> 先重置定时器，例如：</p><pre><code class="go">func BenchmarkHello(b *testing.B) &#123;    ... // 耗时操作    b.ResetTimer()    for i := 0; i &lt; b.N; i++ &#123;        fmt.Sprintf(&quot;hello&quot;)    &#125;&#125;</code></pre><p>使用 <code>RunParallel</code> 测试并发性能</p><pre><code class="go">func BenchmarkParallel(b *testing.B) &#123;    templ := template.Must(template.New(&quot;test&quot;).Parse(&quot;Hello, &#123;&#123;.&#125;&#125;!&quot;))    b.RunParallel(func(pb *testing.PB) &#123;        var buf bytes.Buffer        for pb.Next() &#123;            // 所有 goroutine 一起，循环一共执行 b.N 次            buf.Reset()            templ.Execute(&amp;buf, &quot;World&quot;)        &#125;    &#125;)&#125;</code></pre><pre><code class="bash">$ go test -benchmem -bench ....BenchmarkParallel-16   3325430     375 ns/op   272 B/op   8 allocs/op...</code></pre><h2 id="附-参考"><a href="#附-参考" class="headerlink" title="附 参考"></a>附 参考</h2><ul><li><a href="https://geektutu.com/post/quick-gomock.html">Go Mock (gomock) 简明教程</a></li><li><a href="https://golang.org/pkg/testing/">testing - golang.org</a></li><li><a href="https://about.sourcegraph.com/go/advanced-testing-in-go">Advanced Testing in Go - sourcegraph.com</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919113329.jpg&quot; alt=&quot;golang test&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-如何写好单元测试&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="golang test" scheme="https://ysluckly.github.io/tags/golang-test/"/>
    
    <category term="unit tests" scheme="https://ysluckly.github.io/tags/unit-tests/"/>
    
    <category term="golang testing" scheme="https://ysluckly.github.io/tags/golang-testing/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 基础教程</title>
    <link href="https://ysluckly.github.io/2021/12/31/mysql/"/>
    <id>https://ysluckly.github.io/2021/12/31/mysql/</id>
    <published>2021-12-31T14:00:42.000Z</published>
    <updated>2022-02-20T13:42:53.249Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210914230736.jpg" alt="linux"></p><table border="0" align="left"><tbody><tr><td align="left" valign="top"><p>mysql资源</p><p>　　<a href="http://dev.mysql.com/doc/refman/5.1/zh/index.html">mysql5.1中文参考手册</a></p><p>mysql管理</p><p>　　<a id="homepage1_HomePageDays_DaysList_DayItem_0_DayList_0_TitleUrl_0" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/02/2751113.html">基于linux使用mysql二进制包安装mysql5.5</a></p><p>　　<a id="homepage1_HomePageDays_DaysList_DayItem_0_DayList_0_TitleUrl_5" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/02/2751222.html">mysql client命令行选项</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/02/2751395.html">mysqld服务器系统变量和状态变量</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/02/2751408.html">mysql SQL服务器模式</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/02/2751721.html">mysql 账户管理</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/02/2751780.html">mysql日志文件</a></p><p>　　</p><p>　　<a href="http://dev.mysql.com/doc/refman/5.1/zh/column-types.html">mysql列类型</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/02/2751840.html">mysql数据库操作</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/03/2752082.html">mysql创建和删除表</a><a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/03/2752082.html"><br></a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/04/2754254.html">mysql修改表</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/04/2754379.html">mysql索引操作</a></p><p>　　<a id="cb_post_title_url" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/04/2754128.html">mysql索引详解</a></p><p>&nbsp;</p><p>　　<a id="cb_post_title_url" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/05/2754757.html">mysql select操作</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/05/2754938.html">mysql insert操作</a></p><p>　　<a id="cb_post_title_url" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/05/2755683.html">mysql load操作</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/06/2756392.html">mysql update操作</a></p><p>　　<a id="cb_post_title_url" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/06/2756420.html">mysql 删除操作</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/06/2757972.html">mysql join操作</a></p><p>　　<a href="http://dev.mysql.com/doc/refman/5.1/zh/sql-syntax.html#subqueries">mysql子查询</a></p><p>　　<a href="http://dev.mysql.com/doc/refman/5.1/zh/functions.html#cast-functions">mysql函数</a></p><p>&nbsp;</p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/07/2758014.html">mysql show操作</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/07/2758021.html">mysql flush操作</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/07/2758025.html">mysql kill操作</a></p><p>　　<a href="http://dev.mysql.com/doc/refman/5.1/zh/client-side-scripts.html#mysqlcheck">mysql表维护操作</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/13/2768485.html">mysql导入导出</a></p><p>　　<a id="homepage1_HomePageDays_DaysList_DayItem_0_DayList_0_TitleUrl_0" href="http://www.cnblogs.com/ggjucheng/p/3349256.html">分析MySQL慢日志</a></p><p>mysql使用</p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3352291.html">MySQL类型转换</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3352280.html">MySQL：日期函数、时间函数总结</a></p><p>&nbsp;　　</p></td><td align="left" valign="top"><p>mysql调优</p><p>　　<a id="cb_post_title_url" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765237.html">MySQL执行计划解读</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/15/2772058.html">MySQL Profiling 的使用</a></p><p>&nbsp;　 &nbsp;<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/07/2758058.html">mysql常见sql优化</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/15/2771535.html">mysql日志设置优化</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765336.html">MySQL缓存参数优化</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765347.html">MySQL表结构优化</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765428.html">MySQL 索引优化</a>&nbsp;</p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765465.html">MySQL SQL优化</a></p><p>　　<a id="cb_post_title_url" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765469.html">MySQ 存储引擎选择</a></p><p>&nbsp;　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/15/2771877.html">MySQL硬件瓶颈分析</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/15/2771856.html">硬件环境对系统性能的影响</a></p><p>&nbsp;</p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765479.html">MySQL内存使用-全局共享</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765484.html">MySQL内存使用-线程独享</a></p><p>　　<a id="cb_post_title_url" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/14/2770445.html">mysql数据库锁定机制</a></p><p>　　<a id="homepage1_HomePageDays_DaysList_DayItem_0_DayList_0_TitleUrl_0" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/15/2772148.html">Join的实现原理及优化思路</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/18/2776449.html">mysql ORDER BY,GROUP BY 和DISTINCT原理</a></p><p>　　<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html#more-100">MySQL索引背后的数据结构及算法原理</a></p><p>mysql架构</p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/13/2768856.html">mysql主要应用场景</a></p><p>　　<a id="cb_post_title_url" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/13/2768863.html">MySQL Server系统架构</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/13/2768879.html">MySQL Replication 常用架构</a></p><p>　　<a id="cb_post_title_url" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/13/2768959.html">可扩展性设计之数据切分</a></p><p>　　<a id="homepage1_HomePageDays_DaysList_DayItem_0_DayList_0_TitleUrl_2" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/15/2771686.html">可扩展性设计之Cache与Search的利用</a></p><p>&nbsp;　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3349107.html">MySQL key/value存储方案</a></p></td><td align="left" valign="top"><p>db</p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3349104.html">互联网 DBA 需要做那些事</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3349113.html">列式数据库</a></p><p>nosql</p><p>　　<a href="http://sebug.net/paper/databases/nosql/Nosql.html">NoSQL数据库笔谈</a></p><p>　　<a href="http://www.programmer.com.cn/9260/">如何“打败”CAP定理</a></p><p>　　<a href="http://djt.qq.com/article/view/234">NoSQL 在腾讯应用实践</a></p><p>memcached</p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3349237.html">memcached简介</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3349240.html">memcached应用场景</a></p><p>&nbsp;　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3349233.html">Linux下memcached的安装和启动</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3349247.html">在Java中使用Memcached</a></p><p>&nbsp;</p><p>redis文档</p><p>　　<a href="http://redis.io/documentation">redis官方文档</a></p><p>　　<a href="http://www.redis.cn/">redis中文官方文档</a></p><p>　　<a href="http://redis.readthedocs.org/en/latest/" rel="bookmark">Redis命令参考中文版翻译</a></p><p>redis入门资料</p><p>　　<a href="http://files.cnblogs.com/ggjucheng/Redis%E4%B8%AD%E6%96%87%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C.pdf">redis中文入门手册</a></p><p>　　<a href="http://vdisk.weibo.com/s/rNPx2">redis深入浅出</a></p><p>redis应用</p><p>　　<a href="http://blog.nosqlfan.com/html/2235.html?ref=rediszt">Redis作者谈Redis应用场景</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3348273.html">Redis容量及使用规划</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3348277.html">Redis几个认识误区(转)</a></p><p>　<a href="http://www.cnblogs.com/ggjucheng/p/3348268.html">　浅谈Redis数据库的键值设计</a></p><p>　　<a class="titlelink" href="http://www.cnblogs.com/ggjucheng/p/3348271.html">案例:用Redis来存储关注关系(php版)</a></p></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210914230736.jpg&quot; alt=&quot;linux&quot;&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbod</summary>
      
    
    
    
    <category term="数据库" scheme="https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
    <category term="mysql" scheme="https://ysluckly.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Go Gin 简明教程</title>
    <link href="https://ysluckly.github.io/2021/12/26/go/"/>
    <id>https://ysluckly.github.io/2021/12/26/go/</id>
    <published>2021-12-26T13:59:10.000Z</published>
    <updated>2022-02-20T13:34:56.295Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114636.jpg" alt="Gin"></p><p>关键字：<strong>Gin教程</strong> <strong>Gin中文文档</strong> <strong>Go语言Web框架</strong> <strong>Go环境搭建</strong></p><h2 id="Gin-简介"><a href="#Gin-简介" class="headerlink" title="Gin 简介"></a>Gin 简介</h2><blockquote><p>Gin is a HTTP web framework written in Go (Golang). It features a Martini-like API with much better performance – up to 40 times faster. If you need smashing performance, get yourself some Gin. </p></blockquote><p>Gin 是使用 Go/golang 语言实现的 HTTP Web 框架。接口简洁，性能极高。截止 <em>1.4.0</em> 版本，包含测试代码，仅14K，其中测试代码 9K 左右，也就是说框架源码仅 5K 左右。</p><pre><code class="bash">$ find . -name &quot;*_test.go&quot; | xargs cat | wc -l8657$ find . -name &quot;*.go&quot; | xargs cat | wc -l14115</code></pre><h4 id="Gin-特性"><a href="#Gin-特性" class="headerlink" title="Gin 特性"></a>Gin 特性</h4><ul><li><p><strong>快速</strong>：路由不使用反射，基于Radix树，内存占用少。</p></li><li><p><strong>中间件</strong>：HTTP请求，可先经过一系列中间件处理，例如：Logger，Authorization，GZIP等。这个特性和 NodeJs 的 <code>Koa</code> 框架很像。中间件机制也极大地提高了框架的可扩展性。</p></li><li><p><strong>异常处理</strong>：服务始终可用，不会宕机。Gin 可以捕获 panic，并恢复。而且有极为便利的机制处理HTTP请求过程中发生的错误。</p></li><li><p><strong>JSON</strong>：Gin可以解析并验证请求的JSON。这个特性对<code>Restful API</code>的开发尤其有用。</p></li><li><p><strong>路由分组</strong>：例如将需要授权和不需要授权的API分组，不同版本的API分组。而且分组可嵌套，且性能不受影响。</p></li><li><p><strong>渲染内置</strong>：原生支持JSON，XML和HTML的渲染。</p></li></ul><h2 id="安装Go-amp-Gin"><a href="#安装Go-amp-Gin" class="headerlink" title="安装Go &amp; Gin"></a>安装Go &amp; Gin</h2><blockquote><p>初学者建议先阅读 <a href="https://geektutu.com/post/quick-golang.html">Go 语言简明教程</a>。<br>一篇文章介绍了 Go 基本类型，结构体，单元测试，并发编程，依赖管理等内容。Go 1.13 以上版本的安装推荐该教程的方式。</p></blockquote><ul><li>安装 Go (Ubuntu)</li></ul><pre><code class="bash">$ sudo apt-get install golang-go$ go version# go version go1.6.2 linux/amd64</code></pre><p>Ubuntu自带版本太老了，安装新版可以使用如下命令。</p><pre><code>$ sudo add-apt-repository ppa:gophers/archive$ sudo apt-get update$ sudo apt-get install golang-1.11-go</code></pre><p>默认安装在/usr/lib/go-1.11，需要将<code>/usr/lib/go-1.11/bin</code>手动加入环境变量。在 .bashrc 中添加下面的配置，并 <code>source ~/.bashrc</code></p><pre><code class="bash">export PATH=$PATH:/usr/lib/go-1.11/bin</code></pre><p>参考：<a href="https://github.com/golang/go/wiki/Ubuntu">Golang Ubuntu - Github</a></p><ul><li>安装 Go (Mac)</li></ul><pre><code class="bash">$ brew install go$ go version# go version go1.12.5 darwin/amd64</code></pre><ul><li>设置环境变量</li></ul><p>在 ~/.bashrc 中添加 GOPATH 变量</p><pre><code class="bash">export GOPATH=~/goexport PATH=$PATH:$GOPATH/bin</code></pre><p>添加完后，<code>source ~/.bashrc</code></p><ul><li>安装一些辅助的工具库</li></ul><p>由于网络原因，不能够直接访问 golang.org，但相关的库已经镜像到 <a href="https://github.com/golang">Golang - Github</a></p><p>例如，直接安装 go-outline 时会报网络错误，因为<code>golang.org/x/tools</code>是<code>go-outline</code>的依赖库。</p><pre><code class="bash">$ go get -u -v github.com/ramya-rao-a/go-outlinegithub.com/ramya-rao-a/go-outline (download)Fetching https://golang.org/x/tools/go/buildutil?go-get=1https fetch failed: Get https://golang.org/x/tools/go/buildutil?go-get=1: dial tcp 216.239.37.1:443: i/o timeout</code></pre><p>因此，可以先从 Github 手动安装好，再安装 <code>go-outline</code> 和 <code>goreturns</code>。</p><pre><code class="bash">git clone https://github.com/golang/tools.git $GOPATH/src/golang.org/x/toolsgo get -v github.com/ramya-rao-a/go-outlinego get -v github.com/sqs/goreturnsgo get -v github.com/rogpeppe/godef</code></pre><p>Go语言有大量的辅助工具，如果你使用<code>VSCode</code>，将会提示你将必要的工具，例如静态检查、自动补全等工具依次安装完毕。</p><ul><li>安装 Gin</li></ul><pre><code class="bash">go get -u -v github.com/gin-gonic/gin</code></pre><p><code>-v</code>：打印出被构建的代码包的名字<br><code>-u</code>：已存在相关的代码包，强行更新代码包及其依赖包</p><h2 id="第一个Gin程序"><a href="#第一个Gin程序" class="headerlink" title="第一个Gin程序"></a>第一个Gin程序</h2><p>在一个空文件夹里新建文件<code>main.go</code>。</p><pre><code class="go">// geektutu.com// main.gopackage mainimport &quot;github.com/gin-gonic/gin&quot;func main() &#123;    r := gin.Default()    r.GET(&quot;/&quot;, func(c *gin.Context) &#123;        c.String(200, &quot;Hello, Geektutu&quot;)    &#125;)    r.Run() // listen and serve on 0.0.0.0:8080&#125;</code></pre><ol><li>首先，我们使用了<code>gin.Default()</code>生成了一个实例，这个实例即 WSGI 应用程序。</li><li>接下来，我们使用<code>r.Get(&quot;/&quot;, ...)</code>声明了一个路由，告诉 Gin 什么样的URL 能触发传入的函数，这个函数返回我们想要显示在用户浏览器中的信息。</li><li>最后用 <code>r.Run()</code>函数来让应用运行在本地服务器上，默认监听端口是 _8080_，可以传入参数设置端口，例如<code>r.Run(&quot;:9999&quot;)</code>即运行在 _9999_端口。</li></ol><ul><li>运行</li></ul><pre><code class="bash">$ go run main.go[GIN-debug] GET    /                         --&gt; main.main.func1 (3 handlers)[GIN-debug] Environment variable PORT is undefined. Using port :8080 by default[GIN-debug] Listening and serving HTTP on :8080</code></pre><ul><li>浏览器访问 <code>http://localhost:8080</code></li></ul><p><img src="quick-go-gin/hello_gin.jpg" alt="Hello Gin"></p><h2 id="路由-Route"><a href="#路由-Route" class="headerlink" title="路由(Route)"></a>路由(Route)</h2><p>路由方法有 <strong>GET, POST, PUT, PATCH, DELETE</strong> 和 <strong>OPTIONS</strong>，还有<strong>Any</strong>，可匹配以上任意类型的请求。</p><h4 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h4><pre><code class="go">// 无参数r.GET(&quot;/&quot;, func(c *gin.Context) &#123;    c.String(http.StatusOK, &quot;Who are you?&quot;)&#125;)</code></pre><pre><code class="bash">$ curl http://localhost:9999/Who are you?</code></pre><p><code>curl</code>参数可参考<code>https://man.linuxde.net/curl</code></p><h4 id="解析路径参数"><a href="#解析路径参数" class="headerlink" title="解析路径参数"></a>解析路径参数</h4><p>有时候我们需要动态的路由，如 <code>/user/:name</code>，通过调用不同的 url 来传入不同的 name。<code>/user/:name/*role</code>，<code>*</code> 代表可选。</p><pre><code class="go">// 匹配 /user/geektutur.GET(&quot;/user/:name&quot;, func(c *gin.Context) &#123;    name := c.Param(&quot;name&quot;)    c.String(http.StatusOK, &quot;Hello %s&quot;, name)&#125;)</code></pre><pre><code class="bash">$ curl http://localhost:9999/user/geektutuHello geektutu</code></pre><h4 id="获取Query参数"><a href="#获取Query参数" class="headerlink" title="获取Query参数"></a>获取Query参数</h4><pre><code class="go">// 匹配users?name=xxx&amp;role=xxx，role可选r.GET(&quot;/users&quot;, func(c *gin.Context) &#123;    name := c.Query(&quot;name&quot;)    role := c.DefaultQuery(&quot;role&quot;, &quot;teacher&quot;)    c.String(http.StatusOK, &quot;%s is a %s&quot;, name, role)&#125;)</code></pre><pre><code class="bash">$ curl &quot;http://localhost:9999/users?name=Tom&amp;role=student&quot;Tom is a student</code></pre><h4 id="获取POST参数"><a href="#获取POST参数" class="headerlink" title="获取POST参数"></a>获取POST参数</h4><pre><code class="go">// POSTr.POST(&quot;/form&quot;, func(c *gin.Context) &#123;    username := c.PostForm(&quot;username&quot;)    password := c.DefaultPostForm(&quot;password&quot;, &quot;000000&quot;) // 可设置默认值    c.JSON(http.StatusOK, gin.H&#123;        &quot;username&quot;: username,        &quot;password&quot;: password,    &#125;)&#125;)</code></pre><pre><code class="bash">$ curl http://localhost:9999/form  -X POST -d &#39;username=geektutu&amp;password=1234&#39;&#123;&quot;password&quot;:&quot;1234&quot;,&quot;username&quot;:&quot;geektutu&quot;&#125;</code></pre><h4 id="Query和POST混合参数"><a href="#Query和POST混合参数" class="headerlink" title="Query和POST混合参数"></a>Query和POST混合参数</h4><pre><code class="go">// GET 和 POST 混合r.POST(&quot;/posts&quot;, func(c *gin.Context) &#123;    id := c.Query(&quot;id&quot;)    page := c.DefaultQuery(&quot;page&quot;, &quot;0&quot;)    username := c.PostForm(&quot;username&quot;)    password := c.DefaultPostForm(&quot;username&quot;, &quot;000000&quot;) // 可设置默认值    c.JSON(http.StatusOK, gin.H&#123;        &quot;id&quot;:       id,        &quot;page&quot;:     page,        &quot;username&quot;: username,        &quot;password&quot;: password,    &#125;)&#125;)</code></pre><pre><code class="bash">$ curl &quot;http://localhost:9999/posts?id=9876&amp;page=7&quot;  -X POST -d &#39;username=geektutu&amp;password=1234&#39;&#123;&quot;id&quot;:&quot;9876&quot;,&quot;page&quot;:&quot;7&quot;,&quot;password&quot;:&quot;1234&quot;,&quot;username&quot;:&quot;geektutu&quot;&#125;</code></pre><h4 id="Map参数-字典参数"><a href="#Map参数-字典参数" class="headerlink" title="Map参数(字典参数)"></a>Map参数(字典参数)</h4><pre><code class="go">r.POST(&quot;/post&quot;, func(c *gin.Context) &#123;    ids := c.QueryMap(&quot;ids&quot;)    names := c.PostFormMap(&quot;names&quot;)    c.JSON(http.StatusOK, gin.H&#123;        &quot;ids&quot;:   ids,        &quot;names&quot;: names,    &#125;)&#125;)</code></pre><pre><code class="bash">$ curl -g &quot;http://localhost:9999/post?ids[Jack]=001&amp;ids[Tom]=002&quot; -X POST -d &#39;names[a]=Sam&amp;names[b]=David&#39;&#123;&quot;ids&quot;:&#123;&quot;Jack&quot;:&quot;001&quot;,&quot;Tom&quot;:&quot;002&quot;&#125;,&quot;names&quot;:&#123;&quot;a&quot;:&quot;Sam&quot;,&quot;b&quot;:&quot;David&quot;&#125;&#125;</code></pre><h4 id="重定向-Redirect"><a href="#重定向-Redirect" class="headerlink" title="重定向(Redirect)"></a>重定向(Redirect)</h4><pre><code class="go">r.GET(&quot;/redirect&quot;, func(c *gin.Context) &#123;    c.Redirect(http.StatusMovedPermanently, &quot;/index&quot;)&#125;)r.GET(&quot;/goindex&quot;, func(c *gin.Context) &#123;    c.Request.URL.Path = &quot;/&quot;    r.HandleContext(c)&#125;)</code></pre><pre><code class="bash">$ curl -i http://localhost:9999/redirectHTTP/1.1 301 Moved PermanentlyContent-Type: text/html; charset=utf-8Location: /Date: Thu, 08 Aug 2019 17:22:14 GMTContent-Length: 36&lt;a href=&quot;/&quot;&gt;Moved Permanently&lt;/a&gt;.$ curl &quot;http://localhost:9999/goindex&quot;Who are you?</code></pre><h4 id="分组路由-Grouping-Routes"><a href="#分组路由-Grouping-Routes" class="headerlink" title="分组路由(Grouping Routes)"></a>分组路由(Grouping Routes)</h4><p>如果有一组路由，前缀都是<code>/api/v1</code>开头，是否每个路由都需要加上<code>/api/v1</code>这个前缀呢？答案是不需要，分组路由可以解决这个问题。利用分组路由还可以更好地实现权限控制，例如将需要登录鉴权的路由放到同一分组中去，简化权限控制。</p><pre><code class="go">// group routes 分组路由defaultHandler := func(c *gin.Context) &#123;    c.JSON(http.StatusOK, gin.H&#123;        &quot;path&quot;: c.FullPath(),    &#125;)&#125;// group: v1v1 := r.Group(&quot;/v1&quot;)&#123;    v1.GET(&quot;/posts&quot;, defaultHandler)    v1.GET(&quot;/series&quot;, defaultHandler)&#125;// group: v2v2 := r.Group(&quot;/v2&quot;)&#123;    v2.GET(&quot;/posts&quot;, defaultHandler)    v2.GET(&quot;/series&quot;, defaultHandler)&#125;</code></pre><pre><code class="bash">$ curl http://localhost:9999/v1/posts&#123;&quot;path&quot;:&quot;/v1/posts&quot;&#125;$ curl http://localhost:9999/v2/posts&#123;&quot;path&quot;:&quot;/v2/posts&quot;&#125;</code></pre><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><h4 id="单个文件"><a href="#单个文件" class="headerlink" title="单个文件"></a>单个文件</h4><pre><code class="go">r.POST(&quot;/upload1&quot;, func(c *gin.Context) &#123;    file, _ := c.FormFile(&quot;file&quot;)    // c.SaveUploadedFile(file, dst)    c.String(http.StatusOK, &quot;%s uploaded!&quot;, file.Filename)&#125;)</code></pre><h4 id="多个文件"><a href="#多个文件" class="headerlink" title="多个文件"></a>多个文件</h4><pre><code class="go">r.POST(&quot;/upload2&quot;, func(c *gin.Context) &#123;    // Multipart form    form, _ := c.MultipartForm()    files := form.File[&quot;upload[]&quot;]    for _, file := range files &#123;        log.Println(file.Filename)        // c.SaveUploadedFile(file, dst)    &#125;    c.String(http.StatusOK, &quot;%d files uploaded!&quot;, len(files))&#125;)</code></pre><h2 id="HTML模板-Template"><a href="#HTML模板-Template" class="headerlink" title="HTML模板(Template)"></a>HTML模板(Template)</h2><pre><code class="go">type student struct &#123;    Name string    Age  int8&#125;r.LoadHTMLGlob(&quot;templates/*&quot;)stu1 := &amp;student&#123;Name: &quot;Geektutu&quot;, Age: 20&#125;stu2 := &amp;student&#123;Name: &quot;Jack&quot;, Age: 22&#125;r.GET(&quot;/arr&quot;, func(c *gin.Context) &#123;    c.HTML(http.StatusOK, &quot;arr.tmpl&quot;, gin.H&#123;        &quot;title&quot;:  &quot;Gin&quot;,        &quot;stuArr&quot;: [2]*student&#123;stu1, stu2&#125;,    &#125;)&#125;)</code></pre><pre><code class="html">&lt;!-- templates/arr.tmpl --&gt;&lt;html&gt;&lt;body&gt;    &lt;p&gt;hello, &#123;&#123;.title&#125;&#125;&lt;/p&gt;    &#123;&#123;range $index, $ele := .stuArr &#125;&#125;    &lt;p&gt;&#123;&#123; $index &#125;&#125;: &#123;&#123; $ele.Name &#125;&#125; is &#123;&#123; $ele.Age &#125;&#125; years old&lt;/p&gt;    &#123;&#123; end &#125;&#125;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="shell">$ curl http://localhost:9999/arr&lt;html&gt;&lt;body&gt;    &lt;p&gt;hello, Gin&lt;/p&gt;    &lt;p&gt;0: Geektutu is 20 years old&lt;/p&gt;    &lt;p&gt;1: Jack is 22 years old&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>Gin默认使用模板Go语言标准库的模板<code>text/template</code>和<code>html/template</code>，语法与标准库一致，支持各种复杂场景的渲染。</li><li>参考官方文档<a href="https://golang.org/pkg/text/template/">text/template</a>，<a href="https://golang.org/pkg/html/template/">html/template</a></li></ul><h2 id="中间件-Middleware"><a href="#中间件-Middleware" class="headerlink" title="中间件(Middleware)"></a>中间件(Middleware)</h2><pre><code class="go">// 作用于全局r.Use(gin.Logger())r.Use(gin.Recovery())// 作用于单个路由r.GET(&quot;/benchmark&quot;, MyBenchLogger(), benchEndpoint)// 作用于某个组authorized := r.Group(&quot;/&quot;)authorized.Use(AuthRequired())&#123;    authorized.POST(&quot;/login&quot;, loginEndpoint)    authorized.POST(&quot;/submit&quot;, submitEndpoint)&#125;</code></pre><p>如何自定义中间件呢？</p><pre><code class="go">func Logger() gin.HandlerFunc &#123;    return func(c *gin.Context) &#123;        t := time.Now()        // 给Context实例设置一个值        c.Set(&quot;geektutu&quot;, &quot;1111&quot;)        // 请求前        c.Next()        // 请求后        latency := time.Since(t)        log.Print(latency)    &#125;&#125;</code></pre><h2 id="热加载调试-Hot-Reload"><a href="#热加载调试-Hot-Reload" class="headerlink" title="热加载调试 Hot Reload"></a>热加载调试 Hot Reload</h2><p>Python 的 <code>Flask</code>框架，有 <em>debug</em> 模式，启动时传入 <em>debug=True</em> 就可以热加载(Hot Reload, Live Reload)了。即更改源码，保存后，自动触发更新，浏览器上刷新即可。免去了杀进程、重新启动之苦。</p><p>Gin 原生不支持，但有很多额外的库可以支持。例如</p><ul><li>github.com/codegangsta/gin</li><li>github.com/pilu/fresh</li></ul><p>这次，我们采用 <em>github.com/pilu/fresh</em> 。</p><pre><code class="bash">go get -v -u github.com/pilu/fresh</code></pre><p>安装好后，只需要将<code>go run main.go</code>命令换成<code>fresh</code>即可。每次更改源文件，代码将自动重新编译(Auto Compile)。</p><p>参考 <a href="https://github.com/gravityblast/fresh">github.com/pilu/fresh - Github</a></p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="https://github.com/gin-gonic/gin">Golang Gin - Github</a></li><li><a href="https://gin-gonic.com/">Gin Web Framework - 英文官方网站</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114636.jpg&quot; alt=&quot;Gin&quot;&gt;&lt;/p&gt;
&lt;p&gt;关键字：&lt;strong&gt;Gin教程&lt;/strong&gt; &lt;strong&gt;</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Gin" scheme="https://ysluckly.github.io/tags/Gin/"/>
    
  </entry>
  
  <entry>
    <title>Go Context 并发编程简明教程</title>
    <link href="https://ysluckly.github.io/2021/12/25/go/"/>
    <id>https://ysluckly.github.io/2021/12/25/go/</id>
    <published>2021-12-25T13:59:10.000Z</published>
    <updated>2022-02-20T13:33:13.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为什么需要-Context"><a href="#1-为什么需要-Context" class="headerlink" title="1 为什么需要 Context"></a>1 为什么需要 Context</h2><p>WaitGroup 和信道(channel)是常见的 2 种并发控制的方式。</p><p>如果并发启动了多个子协程，需要等待所有的子协程完成任务，WaitGroup 非常适合于这类场景，例如下面的例子：</p><pre><code class="go">var wg sync.WaitGroupfunc doTask(n int) &#123;    time.Sleep(time.Duration(n))    fmt.Printf(&quot;Task %d Done\n&quot;, n)    wg.Done()&#125;func main() &#123;    for i := 0; i &lt; 3; i++ &#123;        wg.Add(1)        go doTask(i + 1)    &#125;    wg.Wait()    fmt.Println(&quot;All Task Done&quot;)&#125;</code></pre><p><code>wg.Wait()</code> 会等待所有的子协程任务全部完成，所有子协程结束后，才会执行 <code>wg.Wait()</code> 后面的代码。</p><pre><code class="bash">Task 3 DoneTask 1 DoneTask 2 DoneAll Task Done</code></pre><p>WaitGroup 只是傻傻地等待子协程结束，但是并不能主动通知子协程退出。假如开启了一个定时轮询的子协程，有没有什么办法，通知该子协程退出呢？这种场景下，可以使用 <code>select+chan</code> 的机制。</p><pre><code class="go">var stop chan boolfunc reqTask(name string) &#123;    for &#123;        select &#123;        case &lt;-stop:            fmt.Println(&quot;stop&quot;, name)            return        default:            fmt.Println(name, &quot;send request&quot;)            time.Sleep(1 * time.Second)        &#125;    &#125;&#125;func main() &#123;    stop = make(chan bool)    go reqTask(&quot;worker1&quot;)    time.Sleep(3 * time.Second)    stop &lt;- true    time.Sleep(3 * time.Second)&#125;</code></pre><p>子协程使用 for 循环定时轮询，如果 <code>stop</code> 信道有值，则退出，否则继续轮询。</p><pre><code class="bash">worker1 send requestworker1 send requestworker1 send requeststop worker1</code></pre><p>更复杂的场景如何做并发控制呢？比如子协程中开启了新的子协程，或者需要同时控制多个子协程。这种场景下，<code>select+chan</code>的方式就显得力不从心了。</p><p>Go 语言提供了 Context 标准库可以解决这类场景的问题，Context 的作用和它的名字很像，上下文，即子协程的下上文。Context 有两个主要的功能：</p><ul><li>通知子协程退出（正常退出，超时退出等）；</li><li>传递必要的参数。</li></ul><h2 id="2-context-WithCancel"><a href="#2-context-WithCancel" class="headerlink" title="2 context.WithCancel"></a>2 context.WithCancel</h2><p><code>context.WithCancel()</code> 创建可取消的 Context 对象，即可以主动通知子协程退出。</p><h3 id="2-1-控制单个协程"><a href="#2-1-控制单个协程" class="headerlink" title="2.1 控制单个协程"></a>2.1 控制单个协程</h3><p>使用 Context 改写上述的例子，效果与 <code>select+chan</code> 相同。</p><pre><code class="go">func reqTask(ctx context.Context, name string) &#123;    for &#123;        select &#123;        case &lt;-ctx.Done():            fmt.Println(&quot;stop&quot;, name)            return        default:            fmt.Println(name, &quot;send request&quot;)            time.Sleep(1 * time.Second)        &#125;    &#125;&#125;func main() &#123;    ctx, cancel := context.WithCancel(context.Background())    go reqTask(ctx, &quot;worker1&quot;)    time.Sleep(3 * time.Second)    cancel()    time.Sleep(3 * time.Second)&#125;</code></pre><ul><li><code>context.Backgroud()</code> 创建根 Context，通常在 main 函数、初始化和测试代码中创建，作为顶层 Context。</li><li><code>context.WithCancel(parent)</code> 创建可取消的子 Context，同时返回函数 <code>cancel</code>。</li><li>在子协程中，使用 select 调用 <code>&lt;-ctx.Done()</code> 判断是否需要退出。</li><li>主协程中，调用 <code>cancel()</code> 函数通知子协程退出。</li></ul><h3 id="2-2-控制多个协程"><a href="#2-2-控制多个协程" class="headerlink" title="2.2 控制多个协程"></a>2.2 控制多个协程</h3><pre><code class="go">func main() &#123;    ctx, cancel := context.WithCancel(context.Background())    go reqTask(ctx, &quot;worker1&quot;)    go reqTask(ctx, &quot;worker2&quot;)    time.Sleep(3 * time.Second)    cancel()    time.Sleep(3 * time.Second)&#125;</code></pre><p>为每个子协程传递相同的上下文 <code>ctx</code> 即可，调用 <code>cancel()</code> 函数后该 Context 控制的所有子协程都会退出。</p><pre><code class="bash">worker1 send requestworker2 send requestworker1 send requestworker2 send requestworker1 send requestworker2 send requeststop worker1stop worker2</code></pre><h2 id="3-context-WithValue"><a href="#3-context-WithValue" class="headerlink" title="3 context.WithValue"></a>3 context.WithValue</h2><p>如果需要往子协程中传递参数，可以使用 <code>context.WithValue()</code>。</p><pre><code class="go">type Options struct&#123; Interval time.Duration &#125;func reqTask(ctx context.Context, name string) &#123;    for &#123;        select &#123;        case &lt;-ctx.Done():            fmt.Println(&quot;stop&quot;, name)            return        default:            fmt.Println(name, &quot;send request&quot;)            op := ctx.Value(&quot;options&quot;).(*Options)            time.Sleep(op.Interval * time.Second)        &#125;    &#125;&#125;func main() &#123;    ctx, cancel := context.WithCancel(context.Background())    vCtx := context.WithValue(ctx, &quot;options&quot;, &amp;Options&#123;1&#125;)    go reqTask(vCtx, &quot;worker1&quot;)    go reqTask(vCtx, &quot;worker2&quot;)    time.Sleep(3 * time.Second)    cancel()    time.Sleep(3 * time.Second)&#125;</code></pre><ul><li><code>context.WithValue()</code> 创建了一个基于 <code>ctx</code> 的子 Context，并携带了值 <code>options</code>。</li><li>在子协程中，使用 <code>ctx.Value(&quot;options&quot;)</code> 获取到传递的值，读取/修改该值。</li></ul><h2 id="4-context-WithTimeout"><a href="#4-context-WithTimeout" class="headerlink" title="4 context.WithTimeout"></a>4 context.WithTimeout</h2><p>如果需要控制子协程的执行时间，可以使用 <code>context.WithTimeout</code> 创建具有超时通知机制的 Context 对象。</p><pre><code>func main() &#123;    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)    go reqTask(ctx, &quot;worker1&quot;)    go reqTask(ctx, &quot;worker2&quot;)    time.Sleep(3 * time.Second)    fmt.Println(&quot;before cancel&quot;)    cancel()    time.Sleep(3 * time.Second)&#125;</code></pre><p><code>WithTimeout()</code>的使用与 <code>WithCancel()</code> 类似，多了一个参数，用于设置超时时间。执行结果如下：</p><pre><code class="bash">worker2 send requestworker1 send requestworker1 send requestworker2 send requeststop worker2stop worker1before cancel</code></pre><p>因为超时时间设置为 2s，但是 main 函数中，3s 后才会调用 <code>cancel()</code>，因此，在调用 <code>cancel()</code> 函数前，子协程因为超时已经退出了。</p><h2 id="5-context-WithDeadline"><a href="#5-context-WithDeadline" class="headerlink" title="5 context.WithDeadline"></a>5 context.WithDeadline</h2><p>超时退出可以控制子协程的最长执行时间，那 <code>context.WithDeadline()</code> 则可以控制子协程的最迟退出时间。</p><pre><code class="go">func reqTask(ctx context.Context, name string) &#123;    for &#123;        select &#123;        case &lt;-ctx.Done():            fmt.Println(&quot;stop&quot;, name, ctx.Err())            return        default:            fmt.Println(name, &quot;send request&quot;)            time.Sleep(1 * time.Second)        &#125;    &#125;&#125;func main() &#123;    ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(1*time.Second))    go reqTask(ctx, &quot;worker1&quot;)    go reqTask(ctx, &quot;worker2&quot;)    time.Sleep(3 * time.Second)    fmt.Println(&quot;before cancel&quot;)    cancel()    time.Sleep(3 * time.Second)&#125;</code></pre><ul><li><code>WithDeadline</code> 用于设置截止时间。在这个例子中，将截止时间设置为1s后，<code>cancel()</code> 函数在 3s 后调用，因此子协程将在调用 <code>cancel()</code> 函数前结束。</li><li>在子协程中，可以通过 <code>ctx.Err()</code> 获取到子协程退出的错误原因。</li></ul><p>运行结果如下：</p><pre><code class="bash">worker2 send requestworker1 send requeststop worker2 context deadline exceededstop worker1 context deadline exceededbefore cancel</code></pre><p>可以看到，子协程 <code>worker1</code> 和 <code>worker2</code> 均是因为截止时间到了而退出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-为什么需要-Context&quot;&gt;&lt;a href=&quot;#1-为什么需要-Context&quot; class=&quot;headerlink&quot; title=&quot;1 为什么需要 Context&quot;&gt;&lt;/a&gt;1 为什么需要 Context&lt;/h2&gt;&lt;p&gt;WaitGroup 和信道(chan</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="并发编程" scheme="https://ysluckly.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="上下文" scheme="https://ysluckly.github.io/tags/%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
    <category term="信道" scheme="https://ysluckly.github.io/tags/%E4%BF%A1%E9%81%93/"/>
    
    <category term="超时退出" scheme="https://ysluckly.github.io/tags/%E8%B6%85%E6%97%B6%E9%80%80%E5%87%BA/"/>
    
    <category term="golang" scheme="https://ysluckly.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go2 新特性简明教程</title>
    <link href="https://ysluckly.github.io/2021/12/24/go/"/>
    <id>https://ysluckly.github.io/2021/12/24/go/</id>
    <published>2021-12-24T13:59:10.000Z</published>
    <updated>2022-02-20T13:32:23.306Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114535.jpg" alt="quick-go2"></p><p>图片引用自<code>udemy.com</code></p><h2 id="Go-的演进"><a href="#Go-的演进" class="headerlink" title="Go 的演进"></a>Go 的演进</h2><p>Go语言/golang 诞生于2007年，经过12年的发展，Go逐渐成为了云计算领域新一代的开发语言。Go语言在牺牲很少性能的情况下，语法简洁，功能强大。我是Python的重度用户，在学习Go时，却有一种在学习Python的感觉。并非语法相似，而是Go语言作为一门编译型语言，竟然能够像Python一样，少量的代码就能够完成尽可能多的事情。Go语言仿佛是C和Python的结合体。</p><p>Go是如何火起来的呢？我觉得有几个主要的原因，除了语言本身性能好，语法简单，易上手外。Go语言原生支持<code>Goroutine</code>和<code>Channel</code>，极大地降低了并发和异步编程的复杂度。对于服务端编程，并发和异步尤其重要，相比之下，C++，Java等语言的并发和异步控制逻辑过于复杂。另外，杀手级应用<code>Docker</code>的出现起到了很大的推动作用。</p><p>Go语言也有很多令人诟病的地方，例如包管理机制，Go直到v1.6才默认开启了vendor机制，vendor机制非常简陋，简单说就是在项目目录下增加一个vendor文件夹，里面放第三方依赖。vendor机制是没有版本概念的，而且不能解决vendor目录嵌套的问题以及同名包函数冲突问题。后来社区涌现了大量的包管理工具，仅官方推荐的包管理工具就有15种之多，应用比较广泛的，如dep、govendor。直到v1.11，官方增加了Go modules机制，才算较为完整地解决了包管理的问题。</p><p>Go2 可以说是Go语言一个非常重要的里程碑，Go1 目前虽然已经到了1.12版本，事实上每一个版本很少涉及语法层面的变化，而且每个版本都是向前兼容的。较大的改动如下：</p><ul><li>Go1.2 切片操作</li></ul><pre><code class="go">var a = make([]int, 10)var b = a[i:j:k]</code></pre><ul><li>Go1.4 for语言加强</li></ul><pre><code class="go">// &lt;= 1.3for i, v := range x &#123;    // ...&#125;for i := range x &#123;    // ...&#125;// 1.4 新增var times [5][0]intfor i := 0; i &lt; len(times); i++ &#123;    // ...&#125;for _ = range times &#123;    // ...&#125;</code></pre><ul><li>Go1.9 类型别名</li></ul><pre><code class="go">type T1 = T2</code></pre><h2 id="Go-2-设计草案"><a href="#Go-2-设计草案" class="headerlink" title="Go 2 设计草案"></a>Go 2 设计草案</h2><p>为了进一步完善Go语言，提供更好的体验。Go语言社区目前发布了三类重要的设计草案，分别是<code>错误处理(Error handling)</code>、<code>错误值(Error values)</code>、<code>泛型(Generics)</code>，这几个草案代表了社区重点关注的完善方向，但并不代表最终的实现。</p><h3 id="错误处理-Error-Handling"><a href="#错误处理-Error-Handling" class="headerlink" title="错误处理(Error Handling)"></a>错误处理(Error Handling)</h3><p>Go1 的错误处理机制非常简单，通过返回值的方式，强迫调用者对错误进行处理，这种设计导致会在代码中写大量的<code>if</code>判断。例如：</p><pre><code class="go">func CopyFile(src, dst string) &#123;    r := os.Open(src)    defer r.Close()    w := os.Create(dst)    io.Copy(w, r)    w.Close()&#125;</code></pre><p>IO操作容易引发错误，文件打开失败，创建失败，拷贝失败等都会产生错误。如果要对这个函数进行完整的错误处理，代码将变成这样：</p><pre><code class="go">func CopyFile(src, dst string) error &#123;    r, err := os.Open(src)    if err != nil &#123;        return err    &#125;    defer r.Close()    w, err := os.Create(dst)    if err != nil &#123;        return err    &#125;    defer w.Close()    if _, err := io.Copy(w, r); err != nil &#123;        return err    &#125;    if err := w.Close(); err != nil &#123;        return err    &#125;&#125;</code></pre><p>看似逻辑清晰，但不够优雅，充斥了大量重复的逻辑。这是Go错误处理机制的缺陷。同时，因为错误处理机制的繁琐，很多开发者在开发应用时，很少去检查并处理错误，程序的健壮性得不到保证。</p><p>为了解决这个问题，Go2 发布了一个设计草案供社区讨论，Go2将会完善错误处理机制，错误处理的语法将会简洁很多。</p><p>这个提案引入了<code>handle err</code>和<code>check</code>关键字，上面的函数可以简化成：</p><pre><code class="go">func CopyFile(src, dst string) error &#123;    handle err &#123;        return fmt.Errorf(&quot;copy %s %s: %v&quot;, src, dst, err)    &#125;    r := check os.Open(src)    defer r.Close()    w := check os.Create(dst)    check io.Copy(w, r)    check w.Close()&#125;</code></pre><p>为什么不使用被Java、Python等语言采用的<code>try</code>关键字呢？比如写成：</p><pre><code class="go">data := try parseHexdump(string(hex))</code></pre><p>上面的写法看似和谐，但<code>try</code>关键字直接应用在 error values 时，可读性就没那么好了：</p><pre><code class="go">data, err := parseHexdump(string(hex))if err == ErrBadHex &#123;    ... special handling ...&#125;try err</code></pre><p>很明显，在这种场景下，<code>check err</code>显然比<code>try err</code>更有意义。</p><h3 id="错误值-Error-values"><a href="#错误值-Error-values" class="headerlink" title="错误值(Error values)"></a>错误值(Error values)</h3><p>同样由于错误处理机制设计得较为简陋，Go语言对<code>Error values</code>支持有限。任何值，只要实现了<code>error</code>接口，都是错误类型。由于缺少细粒度的设计，在各种库当中，判断是否产生错误以及产生了哪类错误的方式多种多样，例如<code>io.EOF</code>，<code>os.IsNotExist</code>，<code>err.Error()</code>等，。另外，Go语言目前没有机制追溯到完整的错误链条。例如，</p><pre><code class="go">func funcB() error &#123;    if v, err := funcA(); if err != nil &#123;        return fmt.Errorf(&quot;connect to db: %v&quot;, err)    &#125;&#125;func funcC() error &#123;    v, err := funcB()    if err != nil &#123;        return fmt.Errorf(&quot;write users database: %v&quot;, err)    &#125;&#125;</code></pre><p><code>funcC</code>返回的错误信息是：</p><pre><code class="bash">write users database: connect to db: open /etc/xx.conf: permission denied</code></pre><p>每一层，用额外的字符串对错误进行封装，是目前最常用的方法，除了通过字符串解析，很难还原出完整的错误链条。</p><p>为了解决Error values缺少标准的问题，有2个提案，分别针对<code>Error inspection</code>和<code>Error formatting</code>。</p><ul><li>针对 Error inspection ，为error定义了一个可选的接口<code>Unwrap</code>，用来返回错误链上的下一个错误。</li></ul><pre><code class="go">package errorstype Wrapper interface &#123;    Unwrap() error&#125;</code></pre><p>例如，</p><pre><code class="go">// WriteError 实现 Unwrap 接口func (e *WriteError) Unwrap() error &#123; return e.Err &#125;</code></pre><ul><li>针对 Error format，定义了一个可选的接口<code>Format</code>，用来返回错误信息。</li></ul><pre><code class="go">package errorstype Formatter interface &#123;    Format(p Printer) (next error)&#125;</code></pre><p>例如，</p><pre><code class="go">func (e *WriteError) Format(p errors.Printer) (next error) &#123;    p.Printf(&quot;write %s database&quot;, e.Database)    if p.Detail() &#123;        p.Printf(&quot;more detail here&quot;)    &#125;    return e.Err&#125;</code></pre><h3 id="泛型-Generics"><a href="#泛型-Generics" class="headerlink" title="泛型(Generics)"></a>泛型(Generics)</h3><p>Go语言当前可使用<code>inferface&#123;&#125;</code>，允许函数参数和返回值是任何类型的值。但这过于灵活，很多时候需要在获取参数后使用类型断言，进而决定下一步的处理。对比C++/Java的标准容器，Go语言在泛型方面有很大不足，因此针对泛型的提案即希望弥补这方面的不足。提案希望能够支持以下功能：</p><pre><code class="go">type List(type T) []T// 返回map的键func Keys(type K, V)(m map[K]V) []K// 去重过滤func Uniq(&lt;-chan T) &lt;-chan T// 合并func Merge(chans ...&lt;-chan T) &lt;-chan T// 使用自定义排序函数排序func SortSlice(data []T, less func(x, y T) bool)</code></pre><p>例如，我们需要返回一个map对象中所有的键，而希望这个键的类型可以是任意类型。</p><pre><code class="go">var ints List(int)keysA := Keys(int, string)(map[int]string&#123;1:&quot;one&quot;, 2: &quot;two&quot;&#125;)keysB := Keys(string, string)(map[string]string&#123;&quot;name&quot;:&quot;geektutu&quot;, &quot;age&quot;: &quot;twenty&quot;&#125;)// [1, 2]</code></pre><blockquote><p>参考：<a href="https://github.com/golang/go/wiki/Go2">Go2 wiki - Github</a></p></blockquote><h2 id="Go-2-新特性"><a href="#Go-2-新特性" class="headerlink" title="Go 2 新特性"></a>Go 2 新特性</h2><p>Go2还未正式发布，发布后更新</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114535.jpg&quot; alt=&quot;quick-go2&quot;&gt;&lt;/p&gt;
&lt;p&gt;图片引用自&lt;code&gt;udemy.com&lt;/code&gt;&lt;/</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Go语言" scheme="https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
    <category term="GO2" scheme="https://ysluckly.github.io/tags/GO2/"/>
    
    <category term="泛型" scheme="https://ysluckly.github.io/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP 基础教程</title>
    <link href="https://ysluckly.github.io/2021/12/17/tcp/ip/"/>
    <id>https://ysluckly.github.io/2021/12/17/tcp/ip/</id>
    <published>2021-12-17T14:00:42.000Z</published>
    <updated>2022-02-20T13:42:14.489Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210914230121.jpg" alt="linux"></p><p>　　基础</p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/11/01/2750217.html">TCP Implementation in Linux: A Brief Tutorial</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/02/02/2335495.html">基于tcpdump实例讲解TCP/IP协议</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/p/3348492.html">tcp-ip-状态详解</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/15/2323070.html">纳格算法</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/15/2323081.html">TCP延迟确认</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/02/03/2337046.html">糊涂窗口综合症</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/02/02/2335994.html">TCP慢启动算法</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/02/03/2337420.html">拥塞避免算法</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/02/05/2339217.html">TCP的超时与重传</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/02/05/2339228.html">快速重传与快速恢复算法</a></p><p>　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/02/05/2339212.html">TCP的坚持定时器</a></p><p>　　编程</p><p>　　　　TCP客户端和服务端入门</p><p>　　　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/17/2324584.html">Linux/Unix服务端和客户端Socket编程入门实例</a></p><p>　　　　IO复用</p><p>　　　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/17/2324859.html">Linux/Unix IO多路复用之select网络编程</a></p><p>　　　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/17/2324968.html">Linux/Unix IO多路复用之poll网络编程</a></p><p>　　　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/17/2324974.html">Linux IO多路复用之epoll网络编程</a></p><p>　　　　套接字选项</p><p>　　　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/02/17/2355874.html">Socket选项概览</a></p><p>　　　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/15/2323068.html">网络编程中Nagle算法和Delayed ACK的测试</a></p><p>　　　　原始套接字</p><p>　　　　　　<a href="http://www.cnblogs.com/ggjucheng/archive/2012/02/17/2355564.html">C++ Ping源码</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210914230121.jpg&quot; alt=&quot;linux&quot;&gt;&lt;/p&gt;
&lt;p&gt;　　基础&lt;/p&gt;
&lt;p&gt;　　　　&lt;a href=&quot;http://w</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="网络编程" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="tcp/ip" scheme="https://ysluckly.github.io/tags/tcp-ip/"/>
    
  </entry>
  
  <entry>
    <title>图解Go读写锁实现与核心原理分析</title>
    <link href="https://ysluckly.github.io/2021/11/24/go/"/>
    <id>https://ysluckly.github.io/2021/11/24/go/</id>
    <published>2021-11-24T15:59:10.000Z</published>
    <updated>2022-02-20T13:30:59.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="- 简介"></a>- 简介</h1><p>读写锁区别与互斥锁的主要区别就是读锁之间是共享的，多个goroutine可以同时加读锁，但是写锁与写锁、写锁与读锁之间则是互斥的</p><h1 id="写锁饥饿问题"><a href="#写锁饥饿问题" class="headerlink" title="- 写锁饥饿问题"></a>- 写锁饥饿问题</h1><p>因为读锁是共享的，所以如果当前已经有读锁，那后续goroutine继续加读锁正常情况下是可以加锁成功，但是如果一直有读锁进行加锁，那尝试加写锁的goroutine则可能会长期获取不到锁，这就是因为读锁而导致的写锁饥饿问题</p><h2 id="基于高低位与等待队列的实现"><a href="#基于高低位与等待队列的实现" class="headerlink" title="基于高低位与等待队列的实现"></a>基于高低位与等待队列的实现</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNzg3NTEwNi02ZDhhNjFiNWI3ZTg5YzBjLnBuZw?x-oss-process=image/format,png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>image.png</p><p>在说golang之前介绍一种JAVA里面的实现，在JAVA中ReentrantReadWriteLock实现采用一个state的高低位来进行读写锁的计数，其中高16位存储读的计数，低16位存储写的计数，并配合一个AQS来实现排队等待机制，同时AQS中的每个waiter都会有一个status，用来标识自己的状态</p><h1 id="golang的读写锁的实现"><a href="#golang的读写锁的实现" class="headerlink" title="golang的读写锁的实现"></a>golang的读写锁的实现</h1><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNzg3NTEwNi05MmE2ZTVlY2Y5NjM1YTg2LnBuZw?x-oss-process=image/format,png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>image.png</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><pre><code>Copytype RWMutex struct &#123;    w           Mutex  // held if there are pending writers    writerSem   uint32 // 用于writer等待读完成排队的信号量    readerSem   uint32 // 用于reader等待写完成排队的信号量    readerCount int32  // 读锁的计数器    readerWait  int32  // 等待读锁释放的数量&#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="写锁计数"><a href="#写锁计数" class="headerlink" title="写锁计数"></a>写锁计数</h3><p>读写锁中允许加读锁的最大数量是4294967296，在go里面对写锁的计数采用了负值进行，通过递减最大允许加读锁的数量从而进行写锁对读锁的抢占</p><pre><code>Copyconst rwmutexMaxReaders = 1 &lt;&lt; 30</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="读锁实现"><a href="#读锁实现" class="headerlink" title="读锁实现"></a>读锁实现</h2><h3 id="读锁加锁逻辑"><a href="#读锁加锁逻辑" class="headerlink" title="读锁加锁逻辑"></a>读锁加锁逻辑</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNzg3NTEwNi0zNjY5MTIyZTM2NTc1NjI4LnBuZw?x-oss-process=image/format,png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>image.png</p><pre><code>Copyfunc (rw *RWMutex) RLock() &#123;    if race.Enabled &#123;        _ = rw.w.state        race.Disable()    &#125;    // 累加reader计数器，如果小于0则表明有writer正在等待    if atomic.AddInt32(&amp;rw.readerCount, 1) &lt; 0 &#123;        // 当前有writer正在等待读锁，读锁就加入排队        runtime_SemacquireMutex(&amp;rw.readerSem, false)    &#125;    if race.Enabled &#123;        race.Enable()        race.Acquire(unsafe.Pointer(&amp;rw.readerSem))    &#125;&#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="读锁释放逻辑"><a href="#读锁释放逻辑" class="headerlink" title="读锁释放逻辑"></a>读锁释放逻辑</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNzg3NTEwNi0zNGM2OTgxN2M5OGI3NDc4LnBuZw?x-oss-process=image/format,png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>image.png</p><pre><code>Copyfunc (rw *RWMutex) RUnlock() &#123;    if race.Enabled &#123;        _ = rw.w.state        race.ReleaseMerge(unsafe.Pointer(&amp;rw.writerSem))        race.Disable()    &#125;    // 如果小于0，则表明当前有writer正在等待    if r := atomic.AddInt32(&amp;rw.readerCount, -1); r &lt; 0 &#123;        if r+1 == 0 || r+1 == -rwmutexMaxReaders &#123;            race.Enable()            throw(&quot;sync: RUnlock of unlocked RWMutex&quot;)        &#125;        // 将等待reader的计数减1，证明当前是已经有一个读的，如果值==0，则进行唤醒等待的        if atomic.AddInt32(&amp;rw.readerWait, -1) == 0 &#123;            // The last reader unblocks the writer.            runtime_Semrelease(&amp;rw.writerSem, false)        &#125;    &#125;    if race.Enabled &#123;        race.Enable()    &#125;&#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="写锁实现"><a href="#写锁实现" class="headerlink" title="写锁实现"></a>写锁实现</h2><h3 id="加写锁实现"><a href="#加写锁实现" class="headerlink" title="加写锁实现"></a>加写锁实现</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNzg3NTEwNi0yNjI2MjZhNjYyMTVhOTFlLnBuZw?x-oss-process=image/format,png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>image.png</p><pre><code>Copyfunc (rw *RWMutex) Lock() &#123;    if race.Enabled &#123;        _ = rw.w.state        race.Disable()    &#125;    // 首先获取mutex锁，同时多个goroutine只有一个可以进入到下面的逻辑    rw.w.Lock()    // 对readerCounter进行进行抢占，通过递减rwmutexMaxReaders允许最大读的数量    // 来实现写锁对读锁的抢占    r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders    // 记录需要等待多少个reader完成,如果发现不为0，则表明当前有reader正在读取，当前goroutine    // 需要进行排队等待    if r != 0 &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != 0 &#123;        runtime_SemacquireMutex(&amp;rw.writerSem, false)    &#125;    if race.Enabled &#123;        race.Enable()        race.Acquire(unsafe.Pointer(&amp;rw.readerSem))        race.Acquire(unsafe.Pointer(&amp;rw.writerSem))    &#125;&#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="释放写锁"><a href="#释放写锁" class="headerlink" title="释放写锁"></a>释放写锁</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNzg3NTEwNi0xNDZjOWFlNmU2YWFhNDViLnBuZw?x-oss-process=image/format,png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>image.png</p><pre><code>Copyfunc (rw *RWMutex) Unlock() &#123;    if race.Enabled &#123;        _ = rw.w.state        race.Release(unsafe.Pointer(&amp;rw.readerSem))        race.Disable()    &#125;    // 将reader计数器复位，上面减去了一个rwmutexMaxReaders现在再重新加回去即可复位    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)    if r &gt;= rwmutexMaxReaders &#123;        race.Enable()        throw(&quot;sync: Unlock of unlocked RWMutex&quot;)    &#125;    // 唤醒所有的读锁    for i := 0; i &lt; int(r); i++ &#123;        runtime_Semrelease(&amp;rw.readerSem, false)    &#125;    // 释放mutex    rw.w.Unlock()    if race.Enabled &#123;        race.Enable()    &#125;&#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="关键核心机制"><a href="#关键核心机制" class="headerlink" title="关键核心机制"></a>关键核心机制</h2><h3 id="写锁对读锁的抢占"><a href="#写锁对读锁的抢占" class="headerlink" title="写锁对读锁的抢占"></a>写锁对读锁的抢占</h3><p>加写锁的抢占</p><pre><code>Copy// 在加写锁的时候通过将readerCount递减最大允许加读锁的数量，来实现对加读锁的抢占r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>加读锁的抢占检测</p><pre><code>Copy// 如果没有写锁的情况下读锁的readerCount进行Add后一定是一个&gt;0的数字，这里通过检测值为负数//就实现了读锁对写锁抢占的检测if atomic.AddInt32(&amp;rw.readerCount, 1) &lt; 0 &#123;        // A writer is pending, wait for it.        runtime_SemacquireMutex(&amp;rw.readerSem, false)    &#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>写锁抢占读锁后后续的读锁就会加锁失败，但是如果想加写锁成功还要继续对已经加读锁成功的进行等待</p><pre><code>Copyif r != 0 &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != 0 &#123;    // 写锁发现需要等待的读锁释放的数量不为0，就自己自己去休眠了    runtime_SemacquireMutex(&amp;rw.writerSem, false)&#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>写锁既然休眠了，则必定要有一种唤醒机制其实就是每次释放锁的时候，当检查到有加写锁的情况下，就递减readerWait，并由最后一个释放reader lock的goroutine来实现唤醒写锁</p><pre><code>Copyif atomic.AddInt32(&amp;rw.readerWait, -1) == 0 &#123;    // The last reader unblocks the writer.    runtime_Semrelease(&amp;rw.writerSem, false)&#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="写锁的公平性"><a href="#写锁的公平性" class="headerlink" title="写锁的公平性"></a>写锁的公平性</h3><p>在加写锁的时候必须先进行mutex的加锁，而mutex本身在普通模式下是非公平的，只有在饥饿模式下才是公平的</p><pre><code>Copyrw.w.Lock()</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="写锁与读锁的公平性"><a href="#写锁与读锁的公平性" class="headerlink" title="写锁与读锁的公平性"></a>写锁与读锁的公平性</h3><p>在加读锁和写锁的工程中都使用atomic.AddInt32来进行递增，而该指令在底层是会通过LOCK来进行CPU总线加锁的，因此多个CPU同时执行readerCount其实只会有一个成功，从这上面看其实是写锁与读锁之间是相对公平的，谁先达到谁先被CPU调度执行，进行LOCK锁cache line成功，谁就加成功锁</p><h3 id="可见性与原子性问题"><a href="#可见性与原子性问题" class="headerlink" title="可见性与原子性问题"></a>可见性与原子性问题</h3><p>在并发场景中特别是JAVA中通常会提到并发里面的两个问题：可见性与内存屏障、原子性， 其中可见性通常是指在cpu多级缓存下如何保证缓存的一致性，即在一个CPU上修改了了某个数据在其他的CPU上不会继续读取旧的数据，内存屏障通常是为了CPU为了提高流水线性能，而对指令进行重排序而来，而原子性则是指的执行某个操作的过程的不可分割</p><h3 id="底层实现的CPU指令"><a href="#底层实现的CPU指令" class="headerlink" title="底层实现的CPU指令"></a>底层实现的CPU指令</h3><p>go里面并没有volatile这种关键字，那如何能保证上面的AddInt32这个操作可以满足上面的两个问题呢， 其实关键就在于底层的2条指令，通过LOCK指令配合CPU的MESI协议，实现可见性和内存屏障，同时通过XADDL则用来保证原子性，从而解决上面提到的可见性与原子性问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;- 简介&quot;&gt;&lt;/a&gt;- 简介&lt;/h1&gt;&lt;p&gt;读写锁区别与互斥锁的主要区别就是读锁之间是共享的，多个goroutine可以同时加读锁，但是写锁与写锁、写锁与读锁之间则是互斥的&lt;/</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="读写锁实现" scheme="https://ysluckly.github.io/tags/%E8%AF%BB%E5%86%99%E9%94%81%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="核心原理" scheme="https://ysluckly.github.io/tags/%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python 简明教程</title>
    <link href="https://ysluckly.github.io/2021/11/24/python3/"/>
    <id>https://ysluckly.github.io/2021/11/24/python3/</id>
    <published>2021-11-24T15:59:10.000Z</published>
    <updated>2022-02-20T13:29:02.475Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919113143.jpg" alt="Python 中文教程"></p><blockquote><p>Python is a programming language that lets you work more quickly and integrate your systems more effectively. – <a href="https://www.python.org/">python.org</a></p></blockquote><h2 id="0-安装"><a href="#0-安装" class="headerlink" title="0 安装"></a>0 安装</h2><p>可以直接从官网 <a href="https://www.python.org/downloads/">python.org/downloads</a> 下载安装，最新版本是 3.9.0。安装过程和普通的 Windows 软件一致。安装完成后，需将安装路径添加到环境变量中。</p><p>如果你使用的是 Ubuntu 等 Linux 发行版或 MacOS 系统，操作系统将自带 Python，无需安装。如果操作系统上只有 Python2，在 Debian 和 Ubuntu 上可通过如下方式安装 Python3：</p><pre><code class="bash">sudo apt-get update &amp;&amp; sudo apt-get install python3</code></pre><p>在 MacOS 上，可通过如下方式安装</p><pre><code class="bash">brew install python3</code></pre><p>若安装成功，命令行运行 <code>python -V</code> 或 <code>python3 -V</code>，你将看到：</p><pre><code class="bash">$ python3 -VPython 3.7.5</code></pre><h2 id="1-Hello-World"><a href="#1-Hello-World" class="headerlink" title="1 Hello World"></a>1 Hello World</h2><p>Python 有两种运行方式：交互式和源文件。在命令行中键入 python3 并回车，则进入了 Python 解释器的交互模式：</p><pre><code class="bash">$ python3Python 3.7.5 (default, Nov  7 2019, 10:50:52)[GCC 8.3.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; </code></pre><p>接下来，我们接着输入：<code>print(&quot;hello world&quot;)</code>，按下回车：</p><pre><code class="bash">&gt;&gt;&gt; print(&quot;hello world&quot;)hello world&gt;&gt;&gt; </code></pre><p>这样就完成了我们的第一个 Python 程序，向世界问好。<code>print()</code> 是 Python 中的一个内置函数，用来在标准输出中打印信息。</p><p>在交互模式下，每输入一行代码，按下回车，运行结果就会打印在屏幕上。因此，我们可以将 Python 当做一个简单的计算器，例如：</p><pre><code class="bash">&gt;&gt;&gt; 1 + 2 * 100201&gt;&gt;&gt; 1 + 2 ** 39</code></pre><p><code>**</code> 是 Python 中的指数运算符，这里表示 2 的 3 次方。</p><p>我们在桌面新建文件夹 test，在 test 文件夹中新建文件 <code>main.py</code>，写入：</p><pre><code class="python">print(&quot;1 + 2 =&quot;, 1 + 2)</code></pre><p>保存后，在命令行中切换到 test 文件夹，执行 <code>python main.py</code>，将会看到：</p><pre><code class="bash">$ python3 main.py1 + 2 = 3</code></pre><p>一般我们使用 IDE，例如 <a href="https://code.visualstudio.com/">VSCode</a> 或 <a href="https://www.jetbrains.com/pycharm/download">PyCharm</a> 写 Python 程序。IDE 集成了代码高亮、提示、命令行等功能，能够极大地提升代码的学习和开发效率。</p><h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2 基本语法"></a>2 基本语法</h2><pre><code class="python">ok = True # 布尔值，表示真假，True 或 Falsea = 2b = 3.56c = &quot;hello world&quot;d = a * b # 求 a 和 b 的积print(&quot;c =&quot;, c)print(&#39;&#123;0&#125; + &#123;1&#125; = &#123;2&#125;&#39;.format(a, b, d))</code></pre><p>运行这段程序：</p><pre><code class="bash">python3 main.pyc = hello world2 + 3.56 = 7.12</code></pre><ul><li>单行注释以符号 <code>#</code> 开头。</li><li>变量一般由数字、字母、下划线构成，但只能以字母或下划线开头。</li><li><code>ok = True</code>，表示将字面量，即布尔值 True 赋值给变量 ok。</li><li><code>a = 2</code>，表示将字面量，即整数 2 赋值给变量 a</li><li><code>b = 3.56</code>，表示将字面量，即浮点数 3.56 赋值给变量 b</li><li><code>c = &quot;hello world&quot;</code>，表示将字符串 hello world 赋值给变量 c。</li></ul><p>单行字符串一般使用双引号 <code>&quot;</code>，也可以使用单引号 <code>&#39;</code>，多行字符串通常使用三个单引号或三个双引号。例如：</p><pre><code class="python">a = &quot;I&#39;m 极客兔兔&quot;b = &#39;c = &quot;hello world&quot;&#39;d = &quot;&quot;&quot;这是一个多行字符串；这是第二行；这是第三行。&quot;&quot;&quot;print(a)print(b)print(d)</code></pre><p>执行结果为：</p><pre><code class="bash">$ python3 main.py                                                             I&#39;m 极客兔兔c = &quot;hello world&quot;这是一个多行字符串，这是第二行这是第三行</code></pre><p><code>format</code> 可以格式化字符串，<code>&#123;0&#125;</code> 表示用 format 的第一个参数的值替代，<code>&#123;1&#125;</code> 表示用第二个值替代，以此类推。</p><p>format 还有其他使用方式，省略序号或使用键值对：</p><pre><code class="python">name, age = &quot;小明&quot;, 13 # 一行中可以声明多个变量print(&quot;&#123;&#125;今年 &#123;&#125; 岁&quot;.format(name, age)) # 按顺序使用，&#123;&#125;可省略序号print(&quot;&#123;name&#125;明年 &#123;age&#125; 岁&quot;.format(name=name, age=age+1)) # 使用键值对</code></pre><p>执行结果：</p><pre><code class="bash">$ python3 main.py小明今年 13 岁小明明年 14 岁</code></pre><p>如果代码写的有问题，Python 执行时将会报错，例如这段：</p><pre><code class="python">age = 13print(&quot;今年 &#123; 岁\n明年 &#123;&#125; 岁&quot;.format(age, age+1)) # \n 表示换行打印</code></pre><pre><code class="bash">python3 main.pyTraceback (most recent call last):  File &quot;main.py&quot;, line 2, in &lt;module&gt;    print(&quot;今年 &#123; 岁\n明年 &#123;&#125; 岁&quot;.format(age, age+1))ValueError: unexpected &#39;&#123;&#39; in field name</code></pre><p>报错时打印了发生错误的堆栈信息：</p><ul><li><code>File &quot;main.py&quot;, line 2</code> 表示错误发生在 <code>main.py</code> 的第 2 行。</li><li><code>ValueError: unexpected &#39;&#123;&#39; in field name</code> 表示错误原因是 <code>&#123;</code> 括号使用有误。在这里，我们没有成对使用大括号作为占位符，导致报错。</li></ul><h2 id="3-运算符与表达式"><a href="#3-运算符与表达式" class="headerlink" title="3 运算符与表达式"></a>3 运算符与表达式</h2><h3 id="3-1-运算符"><a href="#3-1-运算符" class="headerlink" title="3.1 运算符"></a>3.1 运算符</h3><p>常见的加减乘除运算：</p><pre><code class="python">&gt;&gt;&gt; 1 + 2 # 加3&gt;&gt;&gt; 4 - 6 # 减-2&gt;&gt;&gt; 2 * 3 # 乘6&gt;&gt;&gt; 6 / 4 # 除1.5&gt;&gt;&gt; 6 // 4 # 除取整1&gt;&gt;&gt; 6 + 2 * (1 + 3) # 运算顺序和正常的数学运算一致，先乘除，后加减，括号优先14&gt;&gt;&gt; 2 ** 4 # 指数，2 的 4 次方16&gt;&gt;&gt; 6 % 4 # 取模/余数2</code></pre><p>大小比较运算：</p><pre><code class="python">&gt;&gt;&gt; 12 &lt; 18 # 小于True&gt;&gt;&gt; 12 &lt;= 18 # 小于等于True&gt;&gt;&gt; 1.2 &gt; 3.4 # 大于False&gt;&gt;&gt; 1.2 &gt;= 3.4 # 大于等于False&gt;&gt;&gt; 12 == 18 # 等于False&gt;&gt;&gt; 12 != 18 # 不等于True</code></pre><p>逻辑运算符：</p><pre><code class="python">&gt;&gt;&gt; 12 &gt;= 8 and 5 &gt; 6 # and 布尔与/且，全真为真，有假为假False&gt;&gt;&gt; 12 &gt;= 8 or 5 &gt; 6 # or 布尔或，全假为假，有真为真True&gt;&gt;&gt; not 5 &gt; 6 # not 布尔非True</code></pre><p>此外还支持 <code>&lt;&lt;</code> (左移)、<code>&gt;&gt;</code> (右移)、<code>&amp;</code> (按位与)、<code>|</code> (按位或)、<code>^</code> (按位异或)、<code>~</code> (按位取反) 等位运算符。</p><p>赋值运算符  <code>=</code>，将 <code>=</code> 右侧的值赋值给左侧，左侧需要一个变量。</p><pre><code class="python">a = 2a = a * (3 + 4) # 将 a * (3 + 4) 的值 14 赋值给 a。</code></pre><p>对一个变量进行计算，将计算的结果赋值给该变量，可以简写为：</p><pre><code class="python">a = 2a *= 3 + 4</code></pre><h3 id="3-2-表达式"><a href="#3-2-表达式" class="headerlink" title="3.2 表达式"></a>3.2 表达式</h3><p>Python中，值、变量和运算符共同组成的整体称为表达式，通常我们所写出的程序语句包含若干个表达式。例如上述的 <code>3 + 4</code> 即构成了一个简单的表达式。值和变量也被称作为操作数，运算符也被称为操作符。</p><h2 id="4-控制流"><a href="#4-控制流" class="headerlink" title="4 控制流"></a>4 控制流</h2><p>Python 语句是自上而下执行的，如果在这个过程中，我们希望通过一些条件判断，执行不同的逻辑怎么办呢？可以通过控制流语句实现，Python 中一共有 <code>if</code>、<code>for</code>、<code>while</code> 三个控制流语句。</p><h3 id="4-1-if-语句"><a href="#4-1-if-语句" class="headerlink" title="4.1 if 语句"></a>4.1 if 语句</h3><p><code>if</code> 用于检查条件是否为真，如果为真则执行，通常与 <code>else</code>，<code>elif</code> (else if) 结合使用。例如：</p><pre><code class="python">age = 13if age &gt;= 18:    print(&#39;adult&#39;)if age &lt; 18:    print(&#39;child&#39;)</code></pre><p>Python 使用缩进代表不同的代码块，一般缩进使用 4 个空格表示。你可以看到 <code>print()</code> 前有 4 个空格。</p><p>上述代码可以简化成：</p><pre><code class="python">age = 13if age &gt;= 18:    print(&#39;adult&#39;)else:    print(&#39;child&#39;)</code></pre><p>如果我们有多个条件判断分支时，<code>elif</code> 就能派上用场了：</p><pre><code class="python">age = 45if age &lt; 18:    print(&#39;小孩&#39;)elif age &lt; 60:    print(&#39;中年人&#39;)else:    print(&#39;老人&#39;)</code></pre><h3 id="4-2-for-语句"><a href="#4-2-for-语句" class="headerlink" title="4.2 for 语句"></a>4.2 for 语句</h3><p>有些代码块需要执行多次，这种情况我们可以使用 <code>for</code> 循环语句，例如打印数字 1 - 5：</p><pre><code class="python"># main.pyfor i in range(5): # 0, 1, 2, 3, 4 从0开始，不包含 5    print(i + 1, end=&#39; &#39;)</code></pre><p>执行结果为：</p><pre><code class="bash">python3 main.py1 2 3 4 5</code></pre><ul><li><code>print()</code> 函数默认以换行符结尾，如果我们希望替换成空格，只需要将参数 end 设置为空格即可。</li><li><code>range()</code> 也是一个内置函数，用于生成数字序列，常用于 for 循环语句中。若只传入一个参数 N，代表生成 <code>[0, N) </code>的整数序列，从 0 开始，不包含N。如果我们不想从 0 开始怎么办呢？<code>range()</code> 也支持传入多个参数，例如：</li></ul><pre><code class="python">for i in range(2, 5): # [2, 5)    print(&quot;&#123;0&#125; * &#123;0&#125; = &#123;1&#125;&quot;.format(i, i ** 2))# 结果如下# 2 * 2 = 4# 3 * 3 = 9# 4 * 4 = 16for i in range(1, 10, 2): # 第三个参数为步长 step，从1开始，每次加 2    print(i, end=&#39; &#39;)# 1 3 5 7 9for i in range(10, 2, -2): # 步长-2，从10开始，每次加-2    print(i, end=&#39; &#39;)# 10 8 6 4</code></pre><p>那如果在 for 循环中，遇到某个条件想退出循环呢？通常 <code>for</code>  还与 <code>break</code> 和 <code>continue</code> 结合使用：</p><pre><code class="python">for i in range(100):    if i &lt;= 3:        continue # i &lt;= 3，继续循环，不执行下面的语句    if i &gt;= 10:        break    # i &gt;= 10 时，终止循环    print(i, end=&#39; &#39;)# 4 5 6 7 8 9</code></pre><ul><li><code>continue</code> 语句用来跳过当前循环语句块中的其余部分，然后继续执行循环的下一个迭代。</li><li><code>break</code> 语句用来终止循环。</li><li>因此，<code>i &lt;= 3</code> 时，跳过了 print 语句，<code>i &gt;= 10</code> 时循环被终止，那么这个程序将会打印出数字 4 5 6 7 8 9。</li></ul><h3 id="4-3-while-语句"><a href="#4-3-while-语句" class="headerlink" title="4.3 while 语句"></a>4.3 while 语句</h3><p>与 <code>for</code> 循环语句类似，<code>while</code> 通常也用于循环表达式中。while 后面跟一个条件，条件为真时，执行 while 代码块；条件为假时，终止循环。一般 while 可以替代 for 循环，刚才我们使用 for 打印了数字 1 - 5，接下来用 while 改写：</p><pre><code class="python">i = 0while i &lt; 5: # 第1次迭代i==0，满足条件，第6次迭代时，i==5，不满足条件    i += 1    print(i, end=&#39;,&#39;)# 1,2,3,4,5,</code></pre><p>同样的，<code>continue</code> 和 <code>break</code> 语句也能在 <code>while</code> 语句中使用。例如我们实现一个简单的功能，用户每输入一个数字，打印这个数字的平方，直到输入 0 时结束。</p><pre><code class="python">while True:    num = input(&#39;请输入一个数字: &#39;)    num = int(num)    if num == 0:        print(&#39;结束&#39;)        break    print(&quot;&#123;&#125;^2 = &#123;&#125;&quot;.format(num, num ** 2))</code></pre><p>运行结果：</p><pre><code class="bash">python3 main.py请输入一个数字: 1212^2 = 144请输入一个数字: 1818^2 = 324请输入一个数字: 0结束</code></pre><ul><li><code>while True</code> 代表进入无限循环，只有通过 <code>break</code> 语句才能结束。</li><li><code>input()</code> 是一个内置函数，用于接受用户的输入，返回一个字符串。input 可以传入一个字符串，作为输入的提示语句。</li><li><code>num = int(num)</code> 是将 num 转换为整型，因为字符串不能计算平方，只有数字才行。</li></ul><h2 id="5-函数"><a href="#5-函数" class="headerlink" title="5 函数"></a>5 函数</h2><p>在之前的例子中，我们已经使用了 <code>print</code>、<code>range</code>、<code>input</code> 等 Python 常用的内置函数，对函数已经不陌生了。那函数是什么呢？函数可以理解为一块可以复用的代码块，可以为这个代码块起一个名字（函数名），也可以定义传入的参数（形参），以及返回结果（返回值）。函数定义一般长这个样子：关键字 <code>def</code> 作为函数的标识符，紧接着是函数名，函数名的命名规范与变量一致，通常由数字、字母和下划线构成，以字母或下划线开头。函数名后面有一对小括号和一个冒号 <code>:</code>，里面可以定义参数列表，也可以没有参数。接下来便是一个语句块作为函数体。</p><pre><code class="python">def 函数名(参数名1, 参数名2, ...):    body 函数体，函数体同样通过缩进来体现</code></pre><p>那比如我们实现一个函数 <code>area</code>，用于计算长方形的面积，接受 2 个参数长 <code>length</code> 和宽 <code>width</code>，返回一个值，即面积。</p><pre><code class="python">def area(length, width):    return length * widthprint(&#39;area1: &#39;, area(10, 8)) # area1:  80，第一次调用print(&#39;area2: &#39;, area(6, 8)) # area2:  48，第二次调用</code></pre><ul><li><code>return</code> 是 Python 中的一个关键字，用于函数体中，即跳出这个函数，不再执行。</li><li><code>return</code> 可以跟一个或多个值作为返回值，也可以没有返回值。</li><li>没有返回值时，<code>return</code> 事实上等价于 <code>return None</code>，<code>None</code> 是一个关键字，表示空。</li><li>如果函数没有 <code>return</code> 语句，系统会自动在函数的结尾添加 <code>return None</code> 语句。</li></ul><pre><code class="python">def calc(a, b):    return a // b, a % b # 多个返回值，事实上是一个元组(tuple)类型，后面章节会介绍print(calc(8, 3)) # (2, 2)x, y = calc(8, 5) # 两个返回值分别赋值给变量 x, yprint(x, y) # 1, 3</code></pre><pre><code class="python">def log(mode):    if mode == &#39;debug&#39;:        print(&#39;debug mode&#39;)        return    print(&#39;release mode&#39;)print(log(&#39;release&#39;)) # release mode# None</code></pre><h3 id="5-1-局部变量与全局变量"><a href="#5-1-局部变量与全局变量" class="headerlink" title="5.1 局部变量与全局变量"></a>5.1 局部变量与全局变量</h3><pre><code class="python">x = 10 # x 是全局变量，可在其他函数中使用def print_global():    print(x)def print_local():    x = 100 # x 是局部变量，不影响全局变量中的 x    print(x)print_global() # 10print_local() # 100print_global() # 10</code></pre><p>我们定义了全局变量 x，在 <code>print_local</code> 中定义了与全局变量同名的局部变量 x，并将 100 赋值给 x，在这里修改的是局部变量的值，局部变量只在这个函数内部有效，全局变量不会受到影响。因此，两次 <code>print_global</code> 的结果都是 10。</p><p>定义局部变量的好处在于，控制变量的作用域范围，减少各个函数之间的干扰。全局变量可以在多个函数之间共享，一般建议仅将只读的变量设置为全局变量，比如圆周率 <code>π</code> 的值。那如果我们想修改全局变量怎么办呢？可以使用 <code>global</code> 关键字：</p><pre><code class="python">x = 10 # x 是全局变量，可在其他函数中使用def print_global():    print(x)def print_local():    global x    x = 100     print(x)print_global() # 10print_local() # 100print_global() # 100</code></pre><p>在 <code>print_local</code> 中，使用 <code>global x</code> 告诉 Python x 是一个全局变量，而非局部变量。因此 <code>x = 100</code> 将修改全局变量 x 的值。所以第二个 <code>print_global()</code> 将打印 100。</p><h3 id="5-2-可选参数与默认值"><a href="#5-2-可选参数与默认值" class="headerlink" title="5.2 可选参数与默认值"></a>5.2 可选参数与默认值</h3><p>如果有多个参数，那能不能给某些参数设置默认值，这样用户可以选择性地传入或不传入该参数的值呢？答案是可以的，Python 允许给参数设置默认值，在使用者看来，就像是实现了C++的函数重载一样。</p><blockquote><p>重载函数是函数的一种特殊情况，为方便使用，C++允许在同一范围中声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，也就是说用同一个函数完成不同的功能，这就是重载函数。</p></blockquote><pre><code class="python">def greet(msg, times=1):    for i in range(times):        print(msg)greet(&#39;Hi, Jack&#39;)greet(&#39;Hello, Mr Dai&#39;, 3)</code></pre><p>执行结果：</p><pre><code class="bash">Hi, JackHi, TomHi, TomHi, Tom</code></pre><ul><li><code>greet</code> 函数的功能是打印 msg，默认是1次，但可以通过参数 times 控制。</li><li>带默认值的参数只能位于参数列表的末尾，不能位于非默认值参数前面。例如 <code>def greet(times=1, msg)</code> 是不允许的。</li><li>默认值参数可以有 0 或多个。</li></ul><p>Python 中，参数的传递还可以更加地灵活，除了按顺序传入以外，还可以通过键值对的方式传入：</p><pre><code class="python">greet(&#39;Hi, Jack&#39;, times=2) # 混合方式greet(msg=&#39;Hi, Tom&#39;, times=3)greet(times=3, msg=&#39;Hi, Tom&#39;) # 均为键值对的情况下，顺序没有关系</code></pre><p>键值对传参特别适用于参数列表非常多，且大部分均有默认参数的情况。无需关注参数的顺序，而只需将需要设置的几个参数传入即可。</p><h3 id="5-3-可变参数"><a href="#5-3-可变参数" class="headerlink" title="5.3 可变参数"></a>5.3 可变参数</h3><p>Python 还支持可变参数。函数定义时如果参数的个数是不确定的，那么就适合使用可变参数来代替。可变参数有 2 种，元组式(tuple，元组可以认为是一个不可变的有序集合)和字典式(dict)。元组式可变参数用 <code>*参数名</code> 表示，传入的实际参数会构成一个元组，例如：</p><pre><code class="python"># 实现一个求和函数，支持传入任意个数字def sum_n(*nums):    s = 0    for num in nums:        s += num    return sprint(sum_n(1, 2, 3)) # 6print(sum_n(1, 2, 3, 4, 5)) # 15</code></pre><p>字典式(键值对式)可变参数用<code>**参数名表示</code>，传入的实际参数会构成一个字典(dict)，例如：</p><pre><code class="python">def print_student(**students):    for name, age in students.items():        print(&#39;&#123;&#125;今年 &#123;&#125; 岁&#39;.format(name, age))print_student(小明=8, 小红=7)</code></pre><p>执行结果：</p><pre><code class="bash">小明今年 8 岁小红今年 7 岁</code></pre><blockquote><p>元组(tuple) 和 字典(dict) 都是 Python 内置的数据结构，我们在下一章节会讲到。</p></blockquote><h3 id="5-4-文档字符串-doc"><a href="#5-4-文档字符串-doc" class="headerlink" title="5.4 文档字符串 __doc__"></a>5.4 文档字符串 <code>__doc__</code></h3><p>给每一个函数写文档是编程的好习惯，在 Python 中，对每个函数来说，有一个内置的属性 <code>__doc__</code> 保存了函数的说明文档，Python 中称之为 <code>DocStrings</code>。那怎么定义这个属性呢？</p><pre><code class="python">def print_student(**students):    &#39;&#39;&#39;Prints name and age for every student.    key is name, and value is age.&#39;&#39;&#39;    for name, age in students.items():        print(&#39;&#123;&#125;今年 &#123;&#125; 岁&#39;.format(name, age))print_student(小明=8, 小红=7)print(print_student.__doc__) # 打印 __doc__ 的值help(print_student)</code></pre><ul><li>函数体一开始使用三个单引号<code>&#39;&#39;&#39;</code>标志 DocStrings 的开始。</li><li>第一行描述函数的作用，首字母大写。第二行为空行，第三行是详细的描述，可以包括函数每一个参数的介绍等。</li></ul><p>执行结果：</p><pre><code class="bash">小明今年 8 岁小红今年 7 岁Prints name and age for every student.    key is name, and value is age.</code></pre><pre><code class="bash">Help on function print_student in module __main__:print_student(**students)    Prints name and age for every student.    key is name, and value is age.</code></pre><ul><li><code>help()</code> 函数也是 Python 的内置函数，提供一种更优美的方式查看某个函数的 DocStrings，通常在交互模式下使用。</li></ul><h2 id="6-数据结构"><a href="#6-数据结构" class="headerlink" title="6 数据结构"></a>6 数据结构</h2><p>Python 内置了常用的几种数据结构：列表(list)、元组(tuple)、字典(dict) 和集合(set)，几乎所有程序都会用到这几种数据结构。</p><h3 id="6-1-字符串-string"><a href="#6-1-字符串-string" class="headerlink" title="6.1 字符串(string)"></a>6.1 字符串(string)</h3><p>字符串可以说是最常用的数据类型了。字符串可以使用 <code>&quot;</code>、<code>&#39;</code>、<code>&quot;&quot;&quot;</code>、<code>&#39;&#39;&#39;</code> 表示。三引号通常用于表示多行字符串。字符串是字符序列，在 Python 中，序列支持下标索引、for 循环、切片等系列操作，后面提到的列表(list)、元组(tuple)也都属于序列。字符串是不可变数据类型，不支持修改。</p><pre><code class="python">s = &quot;I&#39;m geektutu&quot;print(len(s)) # 12print(s[0], s[-1]) # I u</code></pre><p><code>[]</code> 操作符可以按照下标索引到元素的值，下标从 0 开始，支持负数，-1 表示最后一个元素，以此类推。<code>[]</code> 除了可以用于下标索引外，还可以用来切片，例如：</p><pre><code class="python">s = &quot;I&#39;m geektutu&quot;print(s[:-3]) # I&#39;m geekt，等价于 s[0:-3]print(s[4:]) # geektutu，等价于 print(s[4:len(s)])print(s[4::2]) # gettprint(s[::-1]) # tutkeeg m&#39;I</code></pre><p>切片能够快速截取序列中的一部分，使用方式可以表示为 <code>[start:end:step]</code>，与 range 类似，包含开始，不包含结束。</p><ul><li><code>start</code> 默认值为 0，如果为 0，可以省略不写。</li><li><code>end</code> 默认值为列表的长度，如果为列表长度，可以省略不写。</li><li><code>step</code> 默认值为 1，如果为1，可以省略不写。</li></ul><h3 id="6-2-列表-list"><a href="#6-2-列表-list" class="headerlink" title="6.2 列表(list)"></a>6.2 列表(list)</h3><p><code>list</code> 是一种表示有序项集合的数据结构。有序且允许重复，支持增删查改，是一种可变数据类型。</p><pre><code class="python">persons = list() # 声明一个空列表persons = [] # 声明一个空列表persons = [&#39;Tom&#39;, &#39;Jack&#39;, &#39;Jack&#39;, &#39;Sam&#39;] # 声明一个非空列表persons.append(&#39;KangKang&#39;) # 添加一个元素print(persons[1]) # Jack 打印第1个元素，下标从 0 开始。persons.remove(&#39;Jack&#39;) # 删除 Jack，只删除第一次出现的位置print(persons)  # [&#39;Tom&#39;, &#39;Jack&#39;, &#39;Sam&#39;, &#39;KangKang&#39;]del persons[-2] # 删除倒数第二个元组 Samprint(persons) # [&#39;Tom&#39;, &#39;Jack&#39;, &#39;KangKang&#39;]persons.sort() # 排序# 遍历列表for name in persons:    print(name, end=&#39; &#39;) # Jack KangKang Tom</code></pre><ul><li><code>append</code> 添加元素，<code>remove</code> 按值删除某个元素，<code>del</code> 按下标删除元素。</li><li><code>sort()</code> 用于给列表排序。</li></ul><p>列表和字符串一样，是一种序列，因此也支持切片。</p><pre><code class="python">numbers = [2, 4, 6, 8, 10]print(len(numbers)) # 长度 5print(numbers[:3]) # 2 4 6print(numbers[0:3]) # 2 4 6print(numbers[1:-1]) # 4 6 8print(numbers[1:]) # 4 6 8 10print(numbers[1:5:2]) # 4 8print(numbers[1::2]) # 4 8</code></pre><p>列表的值可以是任意类型，而且一个列表中允许不同类型的值存在，当然也允许嵌套列表存在。</p><pre><code class="python">a = [1, 1.3, &quot;Student&quot;, [1, 2, 3]]</code></pre><p>判断一个值是否在一个列表中，可以使用 <code>in</code>：</p><pre><code class="python">print(&quot;Student&quot; in a) # True</code></pre><p>列表与字符串有一个非常常用的处理组合 <code>split</code> 和 <code>join</code>：</p><pre><code class="python">s = &quot;1,5,2,4,3&quot;parts = s.split(&#39;,&#39;)print(parts) # [&#39;1&#39;, &#39;5&#39;, &#39;2&#39;, &#39;4&#39;, &#39;3&#39;]parts.sort()print(&#39;:&#39;.join(parts)) # 1:2:3:4:5</code></pre><ul><li><code>split</code> 用于将字符串按照某个分隔符切割成列表。</li><li><code>join</code> 用于将字符串列表按照某个分隔符合并在一起。</li></ul><blockquote><p>关于列表的更多操作参考 <a href="https://docs.python.org/zh-cn/3/tutorial/datastructures.html">list - Python官方文档</a></p></blockquote><h3 id="6-2-元组-tuple"><a href="#6-2-元组-tuple" class="headerlink" title="6.2 元组(tuple)"></a>6.2 元组(tuple)</h3><p>元组也是有序集合，用小括号表示。很多特性与列表(list) 一致，不同点在于元组是不可变数据类型，即不允许增删改。</p><pre><code class="python">students = (&#39;Tom&#39;, 18, &#39;Jack&#39;, 20)print(len(students))  # 4print(students[1:3]) # 切片：(18, &#39;Jack&#39;)</code></pre><p>如果尝试修改元组，会出现如下报错：</p><pre><code class="bash">students[0] = &#39;KangKang&#39;Traceback (most recent call last):  File &quot;main.py&quot;, line 4, in &lt;module&gt;    students[0] = &#39;KangKang&#39;TypeError: &#39;tuple&#39; object does not support item assignment</code></pre><blockquote><p>关于元组的更多操作参考 <a href="https://docs.python.org/zh-cn/3/tutorial/datastructures.html#tuples-and-sequences">tuple - Python官方文档</a></p></blockquote><h3 id="6-4-字典-dict"><a href="#6-4-字典-dict" class="headerlink" title="6.4 字典(dict)"></a>6.4 字典(dict)</h3><p>字典由若干个键值对构成，能够快速地根据键(key)查找到对应的值(value)，在一个字典中，键是不能重复的。字典是可变数据类型，支持增删查改。</p><pre><code class="python">students = &#123;&#125; # 声明空字典students = dict() # 声明空字典students = &#123;    &#39;Tom&#39;: 18,    &#39;Jack&#39;: 20,    &#39;Same&#39;: 19&#125;students[&#39;KangKang&#39;] = 17 # 新增students[&#39;Tom&#39;] = 20 # 修改print(students[&#39;Tom&#39;]) # 20, 通过 key 索引del students[&#39;Jack&#39;] # 删除# 遍历for name, age in students.items():    print(name, age)# Tom 20# Same 19# KangKang 17</code></pre><ul><li><p><code>items()</code> 可以同时获取键和值，除此之外，字典还支持仅获取所有键 <code>keys()</code>，所有值<code>values()</code>等方法，字典是无序的，这三个方法返回值的顺序是不能保证的。</p></li><li><p>判断字典中是否包含某个键，同样可以使用 <code>in</code>，例如 <code>if &#39;Tom&#39; in students</code>。</p></li><li><p>获取字典的键值对个数，可以使用 <code>len</code>，例如<code>len(students)</code>。</p></li></ul><blockquote><p>关于字典的更多操作参考 <a href="https://docs.python.org/zh-cn/3/tutorial/datastructures.html#dictionaries">dict - Python官方文档</a></p></blockquote><h3 id="6-4-集合-set"><a href="#6-4-集合-set" class="headerlink" title="6.4 集合(set)"></a>6.4 集合(set)</h3><p>Python 中的集合与数学中的集合类似，特点是无序且不重复。</p><pre><code class="python">s = set() # 定义空集合s1 = set([1, 2, 2, 2, 3]) # 非空集合s1.add(2) # 添加元素，重复则不添加s1.add(10)s1.remove(3) # 删除print(s1) # &#123;10, 1, 2&#125;s2 = set([5, 6, 10])print(s1 | s2) # 并集 &#123;1, 2, 5, 6, 10&#125;print(s1 &amp; s2) # 交集 &#123;10&#125;print(s1 - s2) # 差集 &#123;1, 2&#125;</code></pre><ul><li><code>set([1, 2, 2, 2, 3])</code> 将列表转换为集合，自动去重，同样也可以使用 <code>list()</code> 将集合转换为列表。</li></ul><blockquote><p>关于集合的更多操作参考 <a href="https://docs.python.org/zh-cn/3/tutorial/datastructures.html#sets">数据结构 set - Python官方文档</a></p></blockquote><h2 id="7-输入输出"><a href="#7-输入输出" class="headerlink" title="7 输入输出"></a>7 输入输出</h2><p>之前的例子我们使用了标准输入输出函数 <code>input</code> 和 <code>output</code> 实现了简单的功能。Python 常用于数据挖掘分析，文本处理是最基本的能力，使用 Python 进行文件读写也非常简单。</p><p>下面是一个非常简单的例子：将字符串 s 写入文件 <code>1.txt</code></p><pre><code class="python">s = &#39;&#39;&#39;第一行第二行第三行&#39;&#39;&#39;f = open(&#39;1.txt&#39;, &#39;w&#39;)f.write(s)f.close()</code></pre><ul><li><code>open</code> 是 Python 用于读取文件的内置函数，第一个参数是文件路径，第二个参数是打开模式，<code>w</code> 代表写模式， <code>r</code>代表只读模式。<code>w</code> 模式打开文件后，文件会被清空，如果需要追加写，则需要以<code>w+</code>模式打开文件。</li><li>如果打开文件成功，<code>open</code>会返回一个文件句柄，我们可以使用这个句柄对文件进行操作。</li><li>操作完毕后，需要将文件关闭。</li></ul><p>Python 还提供了另一种更安全、简单的方式 <code>with as</code>：</p><pre><code class="python">s = &#39;&#39;&#39;第一行第二行第三行&#39;&#39;&#39;with open(&#39;1.txt&#39;, &#39;w&#39;) as f:    f.write(s)</code></pre><p><code>with</code> 语句会在 <code>with</code> 内部的代码块执行完毕后，执行资源回收的操作，对于文件来说即关闭文件。</p><p>读取文件，并统计字数：</p><pre><code class="python">with open(&#39;1.txt&#39;, &#39;r&#39;) as f:    s = f.read()    print(len(s)) # 11</code></pre><p>我们也可以使用 <code>readlines()</code> 读取文件的所有行：</p><pre><code class="python">with open(&#39;1.txt&#39;, &#39;r&#39;) as f:    s = f.readlines()    for line in s:        print(line, end=&#39;&#39;)</code></pre><p>还有一种更高效的方式，直接遍历文件句柄 <code>f</code>：</p><pre><code class="python">with open(&#39;1.txt&#39;, &#39;r&#39;) as f:    for line in f:        print(line, end=&#39;&#39;)</code></pre><h2 id="8-异常"><a href="#8-异常" class="headerlink" title="8 异常"></a>8 异常</h2><p>尽管我们想要将代码写得尽善尽美，但是出现异常还是难免的。如果我们不对异常做任何的处理，程序会立即退出。Python 提供了 <code>try except finally</code> 机制，给开发者提供了一个处理异常的机会。</p><pre><code class="python"># main.pywith open(&#39;2.txt&#39;, &#39;r&#39;) as f:    print(f.read())print(&#39;done&#39;)</code></pre><p>如果我们执行上述程序，会出现如下错误：</p><pre><code class="bash">Traceback (most recent call last):  File &quot;main.py&quot;, line 2, in &lt;module&gt;    with open(&#39;2.txt&#39;, &#39;r&#39;) as f:FileNotFoundError: [Errno 2] No such file or directory: &#39;2.txt&#39;</code></pre><p>程序在第二行就退出了，错误原因是 <code>2.txt</code> 不存在。那我们如何捕获到这个错误并处理呢？</p><pre><code class="python"># main.pytry:    with open(&#39;2.txt&#39;, &#39;r&#39;) as f:        print(f.read())except Exception as e:    print(e)finally:    print(&#39;done&#39;)</code></pre><p>程序正常执行结束：</p><pre><code class="bash">[Errno 2] No such file or directory: &#39;2.txt&#39;done</code></pre><ul><li><code>try</code> 语句块中包含可能发生异常的代码，如果发生异常，将跳转到 <code>except</code> 语句块执行。</li><li>无论是否发生异常，<code>finally</code> 中的代码都会得到执行，<code>finally</code> 是可选的。</li></ul><p>我们也可以在 <code>except</code> 中处理完毕之后，继续将异常抛出，留给调用方处理。</p><pre><code class="python"># main.pytry:    with open(&#39;2.txt&#39;, &#39;r&#39;) as f:        print(f.read())except Exception as e:    print(e)    raise efinally:    print(&#39;done&#39;)</code></pre><p>执行结果：</p><pre><code class="bash">[Errno 2] No such file or directory: &#39;2.txt&#39;doneTraceback (most recent call last):  File &quot;main.py&quot;, line 7, in &lt;module&gt;    raise e  File &quot;main.py&quot;, line 3, in &lt;module&gt;    with open(&#39;2.txt&#39;, &#39;r&#39;) as f:FileNotFoundError: [Errno 2] No such file or directory: &#39;2.txt&#39;</code></pre><h2 id="9-模块"><a href="#9-模块" class="headerlink" title="9 模块"></a>9 模块</h2><h3 id="9-1-使用标准库模块"><a href="#9-1-使用标准库模块" class="headerlink" title="9.1 使用标准库模块"></a>9.1 使用标准库模块</h3><p>Python 标准库内置了大量的模块，提供了非常丰富的功能。比如数学库 <code>math</code>：</p><pre><code class="python">import mathprint(math.__name__) # 模块名 mathprint(math.ceil(4.3)) # 向上取整 5print(math.floor(4.8)) # 向下取整 4</code></pre><ul><li>使用 <code>import</code> 导入标准库 <code>math</code>，并调用了 <code>math</code> 的 <code>ceil</code> 和 <code>floor</code> 函数。</li><li>每一个模块有一个内置属性 <code>__name__</code>，表示模块的名称，如果开发者正在独立运行该模块，则模块名称将是 <code>__main__</code>。</li></ul><p>例如，执行 <code>main.py</code></p><pre><code class="python"># main.pyprint(__name__)if __name__ == &#39;__main__&#39;:      print(&#39;正在独立运行该模块&#39;)</code></pre><p>将会输出：</p><pre><code class="bash">__main__正在独立运行该模块</code></pre><p>如果我们导入的模块名有冲突，可以使用 <code>as</code> 为导入的模块起一个别名</p><pre><code class="python">import math as math2print(math2.__name__) # 模块名 mathprint(math2.ceil(4.3)) # 向上取整 5print(math2.floor(4.8)) # 向下取整 4</code></pre><p>有时候，导入的模块名路径很深，可以使用 <code>from xxx import xxx</code>来简化导入的路径：</p><pre><code class="python">import osprint(os.path.join(&#39;/tmp&#39;, &#39;a&#39;, &#39;b&#39;))# 可以替换为from os import pathprint(path.join(&#39;/tmp&#39;, &#39;a&#39;, &#39;b&#39;))</code></pre><h3 id="9-2-使用自己实现的模块"><a href="#9-2-使用自己实现的模块" class="headerlink" title="9.2 使用自己实现的模块"></a>9.2 使用自己实现的模块</h3><p>新建一个文件 <code>calc.py</code>，在里面实现如下的函数：</p><pre><code class="python">def area(length, width):    return length * widthprint(&#39;this is calc module&#39;)if __name__ == &#39;__main__&#39;:    assert(area(3, 4) == 12)    print(&#39;test done&#39;)</code></pre><p>执行 <code>python calc.py</code>，将会输出：</p><pre><code class="bash">this is calc moduletest done</code></pre><p>在 <code>main.py</code> 中我们可以导入模块 <code>calc</code> 并使用，在 Python 中一个 <code>.py</code> 文件就可以被视为一个模块：</p><pre><code class="python">import calcif __name__ == &#39;__main__&#39;:    print(calc.__name__)    print(calc.area(5, 10))</code></pre><p>执行 <code>python main.py</code>，将会输出：</p><pre><code class="bash">this is calc modulecalc50</code></pre><p>当模块被导入时会执行该模块的代码，因此也打印了 <code>this is calc module</code>，但没有打印 <code>test done</code>。</p><p>当 <code>calc.py</code> 作为一个模块导入时，属性 <code>__name__</code> 与文件名相同，即等于 <code>calc</code>，因此没有进入到 <code>if</code> 分支中，而被独立执行时，<code>__name__</code> 的值是 <code>__main__</code>，因此进入到了 <code>if</code> 分支，打印了 <code>test done</code>。</p><p>因此，我们可以利用这个特性，在模块被独立执行时运行一些代码，比如简单的测试逻辑，但不影响被导入时的执行逻辑。</p><h3 id="9-3-使用第三方模块"><a href="#9-3-使用第三方模块" class="headerlink" title="9.3 使用第三方模块"></a>9.3 使用第三方模块</h3><p>Python 拥有非常丰富的第三方模块，比如著名的爬虫框架 <code>scrapy</code>，数学基础库 <code>numpy</code>、数据处理利器 <code>pandas</code> 等。如果我们想使用第三方模块，只需要使用 <code>pip</code> 命令安装即可。</p><p>例如安装 numpy：</p><pre><code class="bash">pip3 install numpy</code></pre><p>如果你的机器上同时安装了 Python2 和 Python3，给特定的 Python 版本安装可以使用：</p><pre><code class="bash">python3 -m pip install numpy</code></pre><p>如果国内下载网速过慢，可以通过 <code>-i</code> 选项指定下载源：</p><pre><code class="bash">pip3 install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><p>安装完成后，就可以像使用标准库一样使用 <code>numpy</code> 了：</p><pre><code class="python">import numpy as npa = np.array([[1, 2, 3], [4, 5, 6]])b = np.array([[1, 5, 8], [2, 5, 6]])print (a - b) # 两个矩阵相减# [[ 0 -3 -5]#  [ 2  0  0]]</code></pre><h2 id="10-面向对象编程"><a href="#10-面向对象编程" class="headerlink" title="10 面向对象编程"></a>10 面向对象编程</h2><p>Python 是一门既支持过程式编程，又支持面向对象编程的一门语言。</p><blockquote><p>面向对象是相对于面向过程来讲的，面向对象方法，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。</p></blockquote><p>面向对象编程的三大特性：</p><ul><li>封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式。</li><li>继承： 子类从父类继承方法，使得子类具有父类相同的行为。</li><li>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。</li></ul><h3 id="10-1-类与对象"><a href="#10-1-类与对象" class="headerlink" title="10.1 类与对象"></a>10.1 类与对象</h3><p>Python 中使用关键字 <code>class</code> 声明一个类，一般继承基类 <code>object</code>：</p><pre><code class="python">class Student(object):    def __init__(self, name, age):        self.name = name        self.age = age    def hello(self):        print(&#39;你好，我是&#123;&#125;，今年&#123;&#125;岁&#39;.format(self.name, self.age))if __name__ == &#39;__main__&#39;:    jack = Student(&#39;Jack&#39;, 18)    jack.hello()</code></pre><ul><li>类内部声明的方法默认是实例方法，第一个参数是 <code>self</code>，代表实例本身，调用时省略。</li><li><code>__init__</code> 是一个类的构造方法，第一个参数是 <code>self</code>，后面的参数根据需要声明，使用时使用 <code>类名(参数)</code> 可创建出一个属于该类的一个实例对象。<code>name</code> 和 <code>age</code> 都属于实例变量，实例变量属于该实例，不与其他实例共享。</li><li>其他方法的声明与普通的函数实现类似，唯一不同点在于实例方法可以通过参数 <code>self</code> 获取实例的属性或调用实例的其他方法。</li></ul><h3 id="10-2-类方法与类变量"><a href="#10-2-类方法与类变量" class="headerlink" title="10.2 类方法与类变量"></a>10.2 类方法与类变量</h3><p>实例方法和实例变量是针对对象实例而言的，与实例方法和实例变量相对应的是类方法和类变量，属于该类的所有实例都可以共享，可以通过<code>类.方法</code> 或 <code>实例.方法</code> 的方式使用。</p><pre><code class="python">class Student(object):    school = &#39;东方小学&#39; # 类变量    def __init__(self, name, age):        self.name = name # 实例变量        self.age = age   # 实例变量    def hello(self):        print(&#39;你好，我是&#123;&#125;，今年&#123;&#125;岁&#39;.format(self.name, self.age))    @classmethod    def print_school(cls): # 类方法        print(cls.school)if __name__ == &#39;__main__&#39;:    jack = Student(&#39;Jack&#39;, 18)    tom = Student(&#39;Tom&#39;, 20)    jack.print_school()    tom.print_school()    Student.school = &#39;东明小学&#39; # 修改类变量    jack.print_school() # 东明小学    tom.print_school()  # 东明小学</code></pre><ul><li>实例变量在构造函数 <code>__init__</code> 内部声明，类变量在外部声明。</li><li>类内部声明的方法默认为实例方法，使用 <code>@classmethod</code> 声明类方法，第一个参数<code>cls</code> 代表类自己。</li></ul><h3 id="10-3-静态方法"><a href="#10-3-静态方法" class="headerlink" title="10.3 静态方法"></a>10.3 静态方法</h3><p>还有一类方法，既不会访问实例变量和方法，也不会访问类变量和方法，仅仅是一个辅助函数，比如因为某个实例方法实现过长，想把其中的一部分代码抽取出来独立成一个方法，提高代码可读性。而这个辅助函数仅对这个类有用，对其他类没有用。这种情况下，我们通常会将其声明为静态方法。</p><pre><code class="python">class Student(object):    def __init__(self, name, age):        self.name = name # 实例变量        self.age = age   # 实例变量    def hello(self):        print(&#39;你好，我是&#123;&#125;，今年&#123;&#125;岁&#39;.format(self.name, self.age))    @staticmethod    def help_func():        print(&#39;我是一个静态方法&#39;)if __name__ == &#39;__main__&#39;:    jack = Student(&#39;Jack&#39;, 18)    Student.help_func()    jack.help_func()</code></pre><ul><li>静态方法使用 <code>@staticmethod</code> 声明，与普通的全局函数没有任何区别，可以通过<code>类.方法</code> 或 <code>实例.方法</code> 的方式使用。与实例方法和类型方法相比，没有 <code>self</code> 或<code>cls</code> 参数。</li></ul><h3 id="10-4-继承"><a href="#10-4-继承" class="headerlink" title="10.4 继承"></a>10.4 继承</h3><pre><code class="python">class Rectangle(object):    def __init__(self, length, width):        self.length = length        self.width = width    def area(self):        return self.length * self.widthclass Square(Rectangle):    def __init__(self, length):        super(Square, self).__init__(length, length)if __name__ == &#39;__main__&#39;:    s = Square(4)    print(s.area())</code></pre><ul><li><code>Square</code> 继承了 <code>Rectangle</code>，因此拥有了 <code>Rectangle</code> 的所有属性和方法。</li><li><code>Square</code> 可以根据需要覆盖父类的方法，在这里 <code>Square</code> 覆盖了父类的构造函数，参数列表从原来的 2 个变为了 1个。</li><li>子类可以通过 <code>super(子类名, self).方法</code> 的方式调用父类的方法。</li></ul><h2 id="11-单元测试"><a href="#11-单元测试" class="headerlink" title="11 单元测试"></a>11 单元测试</h2><p>为每一个模块编写单元测试是非常好的习惯，Python 也内置了一个单元测试库 <code>unittest</code>。</p><p>新建一个文件 <code>calc.py</code>，实现 area 和 volume 两个函数：</p><pre><code class="python">def area(length, width):    if length &lt; 0 or width &lt; 0:        return 0    return length * widthdef volume(length, width, height):    if length &lt; 0 or width &lt; 0 or height &lt; 0:        return 0    return length * width * height</code></pre><p>新建文件 <code>calc_test.py</code> 添加测试用例：</p><pre><code class="python">import unittestimport calcclass TestCalc(unittest.TestCase):    def test_area(self):        self.assertEqual(calc.area(10, -1), 0)        self.assertEqual(calc.area(10, 8), 80)    def test_volume(self):        self.assertEqual(calc.volume(2, -1, 4), 0)        self.assertEqual(calc.volume(2, 3, 4), 24)if __name__ == &#39;__main__&#39;:    unittest.main()</code></pre><ul><li>添加测试用例的过程非常简单，定义一个类，继承 <code>unittest.TestCase</code>，然后定义一个或多个 <code>test_</code> 开头的方法即可。每一个 <code>test_</code> 开头的方法视为一个用例，这是 unittest 测试框架的约定。</li><li>测试用例中，可以使用 <code>assertEqual</code>、<code>assertTrue</code> 等方式检查预期输出。</li><li><code>unittest.main()</code> 将加载该模块中定义的所有用例并执行。</li></ul><pre><code class="bash">$ python3 calc_test.py ..----------------------------------------------------------------------Ran 2 tests in 0.000sOK</code></pre><p>使用如下方式可以指定测试某个模块、某个测试类，甚至是只运行某个测试用例:</p><pre><code class="bash">python -m unittest test_module1 test_module2python -m unittest test_module.TestClasspython -m unittest test_module.TestClass.test_method</code></pre><p><code>python3 calc_test.py</code> 等价于 <code>python3 -m unittest calc_test</code>。如果只想执行 <code>test_volume</code> 方法，可以这么调用：</p><pre><code class="bash">python3 -m unittest calc_test.TestCalc.test_volume</code></pre><h3 id="11-1-setUp-与-tearDown"><a href="#11-1-setUp-与-tearDown" class="headerlink" title="11.1 setUp 与 tearDown"></a>11.1 setUp 与 tearDown</h3><p>有时候，每个用例执行前后需要一些相同的准备动作和收尾动作，比如打开文件和关闭文件。如果每个用例里都调用一次，就会异常繁琐。与其他测试框架类似，unittest 提供了 <code>setUp</code> 和 <code>tearDown</code> 功能，用于设置每个用例执行前后的一些指令。unittest 还提供了 <code>setUpClass</code> 和 <code>tearDownClass</code> 两个方法，用于设置某个测试类所有用例执行前后的一些指令。</p><pre><code class="python">import unittestclass TestCalc(unittest.TestCase):    @classmethod    def setUpClass(cls):        print(&#39;所有用例执行前&#39;)    @classmethod    def tearDownClass(cls):        print(&#39;所有用例执行后&#39;)    def setUp(self):        print(&#39;单个用例执行前&#39;)    def tearDown(self):        print(&#39;单个用例执行后&#39;)    def test_1(self):        pass    def test_2(self):        passif __name__ == &#39;__main__&#39;:    unittest.main()</code></pre><p>执行结果如下：</p><pre><code class="bash">$ python3 -m unittest calc_test所有用例执行前单个用例执行前单个用例执行后.单个用例执行前单个用例执行后.所有用例执行后----------------------------------------------------------------------Ran 2 tests in 0.000sOK</code></pre><blockquote><p>关于单元测试的更多用法，可以参考 <a href="https://docs.python.org/zh-cn/3/library/unittest.html#module-unittest">unittest - Python 官方文档</a></p></blockquote><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>这篇文章托管在 <a href="https://github.com/geektutu/blog/tree/master/posts/quick-start/python">github</a>，如果有错别字或其他修改建议，可以直接提 PR，感谢您的阅读和贡献。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919113143.jpg&quot; alt=&quot;Python 中文教程&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Python is a pr</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Python3" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Python3/"/>
    
    
    <category term="Python3" scheme="https://ysluckly.github.io/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Go sqlx操作mysql教程</title>
    <link href="https://ysluckly.github.io/2021/11/24/go/"/>
    <id>https://ysluckly.github.io/2021/11/24/go/</id>
    <published>2021-11-24T13:59:10.000Z</published>
    <updated>2022-02-20T13:31:33.482Z</updated>
    
    <content type="html"><![CDATA[<p>sqlx是Go数据库操作包，它在database/sql包的基础上增加了更加高效的数据库操作函数，也就是说使用sqlx操作数据库比使用database/sql更加方便。</p><h4 id="1-sqlx关键概念介绍"><a href="#1-sqlx关键概念介绍" class="headerlink" title="1.sqlx关键概念介绍"></a>1.sqlx关键概念介绍</h4><p>sqlx定义了下面几个关键类型:</p><pre><code class="go">sqlx.DB - 代表一个数据库sqlx.Tx - 代表一个事务sqlx.Rows - 代表sql查询结果的多行记录sqlx.Row - 代表sql查询结果的一条记录</code></pre><h5 id="使用sqlx的关键步骤"><a href="#使用sqlx的关键步骤" class="headerlink" title="使用sqlx的关键步骤:"></a>使用sqlx的关键步骤:</h5><pre><code class="go">根据mysql地址和帐号密码，创建sqlx.DB对象通过sqlx.DB对象的sql查询函数，操作数据库</code></pre><h4 id="2-安装包"><a href="#2-安装包" class="headerlink" title="2.安装包"></a>2.安装包</h4><pre><code class="c">//安装sqlx包go get github.com/jmoiron/sqlx//安装mysql驱动go get github.com/go-sql-driver/mysql</code></pre><h4 id="3-导入包"><a href="#3-导入包" class="headerlink" title="3.导入包"></a>3.导入包</h4><pre><code class="c">import (    //导入mysql驱动    _ &quot;github.com/go-sql-driver/mysql&quot;    //导入sqlx包    &quot;github.com/jmoiron/sqlx&quot;)</code></pre><h4 id="3-连接数据库"><a href="#3-连接数据库" class="headerlink" title="3.连接数据库"></a>3.连接数据库</h4><pre><code class="cpp">//定义数据库对象var pool *sqlx.DB//定义mysql数据源，配置数据库地址，帐号以及密码， dsn格式下面会解释dsn := &quot;root:123456@tcp(localhost:3306)/tizi365?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;//根据数据源dsn和mysql驱动, 创建数据库对象pool, err := sqlx.Open(&quot;mysql&quot;, dsn)if err != nil &#123;    panic(err)&#125;</code></pre><p>MYSQL dsn格式：</p><blockquote><p>{username}:{password}@tcp({host}:{port})/{Dbname}?charset=utf8&amp;parseTime=True&amp;loc=Local</p></blockquote><ul><li>参数说明:</li></ul><pre><code class="c">参数    说明&#123;username&#125;    数据库帐号&#123;password&#125;    数据库密码&#123;host&#125;    数据库地址&#123;port&#125;    数据库端口&#123;Dbname&#125;    数据库名字</code></pre><p>说明: charset=utf8 用于设置字符集，parseTime=True表示将数据库时间类型转换成Go时间类型</p><h4 id="4-数据库连接池设置"><a href="#4-数据库连接池设置" class="headerlink" title="4.数据库连接池设置"></a>4.数据库连接池设置</h4><p>sqlx.DB内置了数据库连接池，在你调用sql查询函数的时候，自动从连接池申请连接，可以通过下面方式设置连接池参数:</p><pre><code class="c">//设置连接池最大连接数pool.SetMaxOpenConns(100)//设置连接池最大空闲连接数pool.SetMaxIdleConns(20)</code></pre><h4 id="5-sql语句绑定参数"><a href="#5-sql语句绑定参数" class="headerlink" title="5.sql语句绑定参数"></a>5.sql语句绑定参数</h4><p><strong>绑定参数指的是</strong>：在sql语句中通过占位符(?), 定义一些参数，然后在执行sql语句的时候再把参数传递进去。</p><p>说明： sql语句绑定参数，除了方便我们拼接sql语句参数之外，还有一个重要的功能就是参数的安全检查和过滤，避免sql注入攻击。</p><p>例子:</p><pre><code class="c">//这里通过占位符（？），定义了两个参数sql := &quot;select * from tablename where cat=? and uid=?&quot;//执行sql，并且传入两个参数, 函数的第二个参数101对应sql语句的第一个问号，第三个参数5对应第二个问号db.Queryx(sql, 101, 5)提示：sqlx.DB提供的查询函数，都支持参数绑定，教程后续会有相应的例子</code></pre><h4 id="6-插入数据"><a href="#6-插入数据" class="headerlink" title="6.插入数据"></a>6.插入数据</h4><p>sqlx为我们定义两个函数用于执行插入，更新以及执行DDL语句（创建表，修改表等等）：</p><pre><code class="bash">ExecMustExec</code></pre><p>这两个函数的作用是一样的，区别就是处理错误的机制不一样，MustExec遇到错误的时候直接抛出一个panic错误，程序就退出了；Exec是将错误和执行结果一起返回，由我们自己处理错误。</p><p>我们先定义一个mysql表结构并创建表：</p><pre><code class="c">//定义表结构schema := `CREATE TABLE place (    id int primary key auto_increment,    country varchar(50),    city varchar(50) NULL default &#39;&#39;,    telcode int);`// 调用Exec函数执行sql语句，创建表_, err := pool.Exec(schema)//错误处理if err != nil &#123;    panic(err)&#125;</code></pre><p>插入数据的例子:</p><pre><code class="cpp">//定义sql语句, 通过占位符 问号（ ? ) 定义了三个参数countryCitySql := `INSERT INTO place (country, city, telcode) VALUES (?, ?, ?)`//通过Exec插入数据, 这里传入了三个参数，对应sql语句定义的三个问号所在的位置result1,err := db.Exec(countryCitySql, &quot;中国&quot;, &quot;香港&quot;, 852)//错误处理if err != nil &#123;    fmt.Println(&quot;插入失败!&quot;)&#125;//插入成功后，获取insert idid, _ := result.LastInsertId() </code></pre><pre><code class="cpp">//通过MustExec插入数据, 如果sql语句出错，则直接抛出panic错误result2 := db.MustExec(countryCitySql, &quot;South Africa&quot;, &quot;Johannesburg&quot;, 27)//插入成功后，获取插入idid2, _ := result2.LastInsertId() </code></pre><p>提示: mysql表如果存在自增id，则可以通过Exec返回的结果对象的LastInsertId，查询新插入数据的ID</p><h4 id="7-更新数据"><a href="#7-更新数据" class="headerlink" title="7.更新数据"></a>7.更新数据</h4><pre><code class="c">//定义sql语句，通过问号定义了三个参数sql := &quot;update place set telcode=?, city=? where id=?&quot;//通过Exec更新数据, 这里传入了三个参数，对应sql语句定义的三个问号所在的位置result1,err := db.Exec(sql, 100, &quot;香港&quot;, 1)//错误处理if err != nil &#123;    fmt.Println(&quot;更新失败!&quot;)&#125;//查询更新影响行数rowsAffected, _ := result1.RowsAffected()</code></pre><h4 id="8-查询数据"><a href="#8-查询数据" class="headerlink" title="8.查询数据"></a>8.查询数据</h4><p>8.1.通过Get和Select函数查询数据<br>Get函数主要用于查询一条记录，Select用于查询多条记录。</p><p>例子:</p><pre><code class="c">//定义保存查询结果的struct变量p := Place&#123;&#125;// 查询一条记录, 并且往sql语句传入参数 1，替换sql语句中的问号，最后将查询结果保存到struct对象中err = pool.Get(&amp;p, &quot;SELECT * FROM place LIMIT ?&quot;, 1)var total int//统计表的总记录数，并将查询结果保存到一个变量中err = pool.Get(&amp;total, &quot;SELECT count(*) FROM place&quot;)//定义一个保存多条记录的struct数组变量pp := []Place&#123;&#125;// 通过Select查询多条记录，并且将结果保存至pp变量中// 这里相当于将一条记录的字段值都映射到struct字段中err = pool.Select(&amp;pp, &quot;SELECT * FROM place WHERE telcode &gt; ?&quot;, 50)var names []string// 通过Select查询多条记录，并且将结果保存至names变量中// 这里仅查询一个字段err = pool.Select(&amp;names, &quot;SELECT name FROM place LIMIT 10&quot;) </code></pre><p>8.2.通过Queryx和QueryRowx查询数据<br>相对于Get和Select函数，Queryx和QueryRowx函数要繁琐一些。<br>Queryx可以用于查询多条记录，QueryRowx函数用于查询一条记录。</p><p>Queryx例子1</p><pre><code class="c">// 查询所有的数据，这里返回的是sqlx.Rows对象rows, err := pool.Queryx(&quot;SELECT country, city, telcode FROM place&quot;)//错误检测if err !=nil &#123;    panic(err)&#125;// 循环遍历每一行记录，rows.Next()函数用于判断是否还有下一行数据for rows.Next() &#123;    //这里定义三个变量用于接收每一行数据    var country string    var city    string    var telcode int    //调用Scan函数，将当记录的数据保存到变量中，这里参数的顺序跟上面sql语句中select后面的字段顺序一致。    err = rows.Scan(&amp;country, &amp;city, &amp;telcode)&#125;</code></pre><p>Queryx例子2, 将每一行记录保存到struct/map/数组变量中<br>Rows对象支持将每一行的数据保存到struct、map或者数组中。</p><pre><code class="c">//定义保存数据的结构体， 默认struct字段名（小写）跟表的字段名一致。type Place struct &#123;    Country       string    //因为city字段允许null，所以这里可以使用sql.NullString类型    City          sql.NullString     //如果struct字段名跟表的字段名不一样，可以通过db标签设置数据库字段名    TelephoneCode int `db:&quot;telcode&quot;`&#125;//查询数据rows, err := pool.Queryx(&quot;SELECT * FROM place&quot;)//遍历数据for rows.Next() &#123;    //下面演示如何将数据保存到struct、map和数组中    //定义struct对象    var p Place    //定义map类型    m := make(map[string]interface&#123;&#125;)    //定义slice类型    s := make([]interface&#123;&#125;, 0)    //使用StructScan函数将当前记录的数据保存到struct对象中    err = rows.StructScan(&amp;p)    //保存到map    err = rows.MapScan(&amp;m)    //保存到数组    err = rows.SliceScan(&amp;s)&#125;</code></pre><p>QueryRowx例子</p><pre><code class="c">QueryRowx操作跟Queryx类似，区别就是返回一行数据//查询数据row, err := pool.QueryRowx(&quot;SELECT country, city, telcode FROM place where id = ?&quot;, 1)//定义保存数据的结构体， 默认struct字段名（小写）跟表的字段名一致。type Place struct &#123;    Country       string    City          sql.NullString     Telcode       int &#125;var p Place//使用StructScan函数将当前记录的数据保存到struct对象中err = row.StructScan(&amp;p)提示: sqlx.Row跟sqlx.Rows对象获取数据的方式一样，支持将数据保存到map,slice,struct中，可以参考上面Queryx的例子。9.删除数据//定义sql语句，通过问号定义了一个参数sql := &quot;delete from place where id=?&quot;//通过Exec删除数据, 这里传入了一个参数，对应sql语句定义的问号所在的位置result1,err := pool.Exec(sql, 1)//获取删除影响行数rowsAffected, _ := result1.RowsAffected()//错误处理if err != nil &#123;    fmt.Println(&quot;更新失败!&quot;)&#125;10.事务处理sqlx使用mysql事务的格式://开始一个事务，返回一个事务对象txtx, err := pool.Beginx()//使用事务对象tx, 执行事务err = tx.Queryx(...)err = tx.Exec(...)err = tx.Exec(...)if err != nil &#123;    //回滚事务    tx.Rollback()&#125;//提交事务err = tx.Commit()提示：注意上面的事务格式，使用的是事务对象tx执行sql，而不是数据库对象，数据库对象执行sql每次都会申请一个新的数据库连接，会导致事务无效。mysql事务例子://开始一个事务，返回一个事务对象txtx, err := pool.Beginx()//执行事务err1 = tx.Exec(&quot;delete from place where id=?&quot;, 1)err2 = tx.Exec(&quot;delete from place where id=?&quot;, 2)if err1 != nil || err2 != nil &#123;    //回滚事务    tx.Rollback()&#125;//提交事务tx.Commit()</code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://segmentfault.com/a/1190000022623847?utm_source=tag-newest">golang使用mysql实例和第三方库Gendry</a><br><a href="https://segmentfault.com/a/1190000023113675?utm_source=sf-similar-article">Go操作sqlx</a><br><a href="https://segmentfault.com/a/1190000038632750?utm_source=sf-similar-article">GO语言Gin框架数据库操作（原生、xorm、gorm）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;sqlx是Go数据库操作包，它在database/sql包的基础上增加了更加高效的数据库操作函数，也就是说使用sqlx操作数据库比使用database/sql更加方便。&lt;/p&gt;
&lt;h4 id=&quot;1-sqlx关键概念介绍&quot;&gt;&lt;a href=&quot;#1-sqlx关键概念介绍&quot; cl</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="sqlx" scheme="https://ysluckly.github.io/tags/sqlx/"/>
    
    <category term="Go数据库" scheme="https://ysluckly.github.io/tags/Go%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>VMware Pro 14 安装 Ubuntu 18.04 详细教程</title>
    <link href="https://ysluckly.github.io/2021/10/24/linux/"/>
    <id>https://ysluckly.github.io/2021/10/24/linux/</id>
    <published>2021-10-24T02:10:45.000Z</published>
    <updated>2022-02-20T13:20:27.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-下载安装-VMware-Workstation-Pro-14"><a href="#1-下载安装-VMware-Workstation-Pro-14" class="headerlink" title="1.下载安装 VMware Workstation Pro 14"></a><font color=#FF0000>1.下载安装 VMware Workstation Pro 14</font></h1><p> 进入 <a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html">VMware 官网</a>或者在软件商店下载最新版VMware虚拟机并安装</p><p> <img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/01.jpg" alt="01"></p><h1 id="2-下载-Ubuntu-18-04-系统"><a href="#2-下载-Ubuntu-18-04-系统" class="headerlink" title="2.下载 Ubuntu 18.04 系统"></a><font color=#FF0000>2.下载 Ubuntu 18.04 系统</font></h1><p>  进入 <a href="https://www.ubuntu.com/">Ubuntu 官网</a>，下载最新版 Ubuntu 系统镜像</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/02.jpg" alt="02"><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/03.jpg" alt="03"></p><h1 id="3-在-VMware-中创建虚拟机"><a href="#3-在-VMware-中创建虚拟机" class="headerlink" title="3.在 VMware 中创建虚拟机"></a><font color=#FF0000>3.在 VMware 中创建虚拟机</font></h1><p>打开安装好的 VMware Workstation Pro 14，选择创建新的虚拟机<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/04.jpg" alt="04"></p><p>在新建虚拟机向导中选择自定义（高级）<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/05.jpg" alt="05"></p><p>默认直接下一步，直到出现下图，再选择稍后安装操作系统<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/06.png" alt="06"></p><p>选择客户机操作系统为 Linux ，如果你电脑是32位就选择 Ubuntu 版本，64位就选择 Ubuntu 64 位版本<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/07.png" alt="07"></p><p>更改虚拟机名称及存放位置<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/08.png" alt="08"></p><p>为虚拟机指定处理器数量，默认即可<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/09.png" alt="09"></p><p>为虚拟机分配内存，太大了可能会导致卡顿，太小了也不好，推荐内存大小即可<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/10.png" alt="10"></p><p>以下均选择默认即可<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/11.png" alt="11"><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/13.png" alt="13"><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/14.png" alt="14"></p><p>选择创建新虚拟磁盘<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/15.png" alt="15"></p><p>选择将虚拟磁盘储存为单个文件<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/16.png" alt="16"></p><p>默认下一步<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/17.png" alt="17"></p><p>点击完成<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/18.png" alt="18"></p><p>此时我们就可以在虚拟机左侧“我的计算机”下面看到刚刚创建的虚拟机 Ubuntu 64 位，单击 Ubuntu 64 位，选择“编辑虚拟机设置”， 再选择“CD/DVD(SATA)”，选择“使用ISO映像文件”，点击“浏览”，找到先前我们下载好的 Ubuntu 64 位镜像文件，点击“确定”<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/19.jpg" alt="19"><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/20.png" alt="20"></p><h1 id="4-在虚拟机上安装-Ubuntu-系统"><a href="#4-在虚拟机上安装-Ubuntu-系统" class="headerlink" title="4.在虚拟机上安装 Ubuntu 系统"></a><font color=#FF0000>4.在虚拟机上安装 Ubuntu 系统</font></h1><p>单击 Ubuntu 64 位，选择“开启此虚拟机”<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/21.jpg" alt="21"></p><p>来到欢迎界面，选择好语言，点击“安装 Ubuntu”<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/22.jpg" alt="22"></p><p>选择键盘布局为“汉语”<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/23.jpg" alt="23"></p><p>更新和其他软件默认选择即可<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/24.jpg" alt="24"></p><p>安装类型选择“清除整个磁盘并安装 Ubuntu”，PS: 因为我们是新安装的系统，且在虚拟机中，所以可以选择清除整个磁盘，这个操作不会清除你原来电脑里面的东西<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/25.jpg" alt="25"><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/26.jpg" alt="26"></p><p>地区随便，在中国就行，默认即可<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/27.jpg" alt="27"></p><p>之后设置计算机名，密码<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/28.jpg" alt="28"></p><p>点击继续稍等一会就安装完成啦<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/29.jpg" alt="29"></p><hr><h1 id="安装过程中可能会出现的一些问题"><a href="#安装过程中可能会出现的一些问题" class="headerlink" title="安装过程中可能会出现的一些问题"></a><center><font color=#FF0000 size=7>安装过程中可能会出现的一些问题</font></center></h1><hr><h1 id="1-在虚拟机上安装-Ubuntu-系统的过程中卡死不动"><a href="#1-在虚拟机上安装-Ubuntu-系统的过程中卡死不动" class="headerlink" title=" 1.在虚拟机上安装 Ubuntu 系统的过程中卡死不动"></a><font color=#FF0000> 1.在虚拟机上安装 Ubuntu 系统的过程中卡死不动</font></h1><p> 解决方法：关闭网络，重新安装即可</p><hr><h1 id="2-Ubuntu-不能全屏显示"><a href="#2-Ubuntu-不能全屏显示" class="headerlink" title=" 2.Ubuntu 不能全屏显示"></a><font color=#FF0000> 2.Ubuntu 不能全屏显示</font></h1><p>解决方法：<br>方法①：安装 open-vm-tools：</p><pre><code class="vim">sudo apt-get install open-vm-tools </code></pre><p>然后执行：</p><pre><code class="vim">sudo apt-get install open-vm* </code></pre><p>重启即可全屏显示</p><p>方法②：在终端输入<code>xrandr</code>，并回车，我们就可以看到很多可以修改的分辨率，选择好分辨率后，比如我们要修改分辨率为 1920x1440 ，则在终端输入 <code>xrandr -s 1920x1440</code>，回车即可，注意 1920x1440 中间是<font color=#FF0000>小写字母 x</font>，本人亲测此方法并不是很完美，不能完全适应屏幕<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A06/30.jpg" alt="30"></p><p>方法③：安装 VMware Tools：<br>1、进入 Ubuntu 系统后，点击虚拟机上的【虚拟机】—＞【安装 VMware Tools】，回到桌面即可看到一个 VMware Tools 的 图标<br>2、复制 VMwareTools-10.0.10-4301679.tar.gz（版本根据自己的实际情况而定）到 home 目录下， 用命令 <code>tar -xzvf  VMwareTools-10.0.10-4301679.tar.gz</code> 进行解压<br>3、解压后 cd vmware_tools_distrib，打开终端<br>4、输入“sudo ./vmware-install.pl”，输入用户密码后开始安装<br>5、接下来会有很多地方需要你按 Enter或者 Yes<br>6、当你看到出现 <code>—the vmware team</code> 的字样后就可以关闭窗口了，此时窗口就会自动全屏了，如果没有全屏，重启过后就可以了<br>7、若还没有全屏显示，则将虚拟机的【查看】—&gt;【自动调整大小】—&gt;【自适应客户机】，都选上，即可实现全屏</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-下载安装-VMware-Workstation-Pro-14&quot;&gt;&lt;a href=&quot;#1-下载安装-VMware-Workstation-Pro-14&quot; class=&quot;headerlink&quot; title=&quot;1.下载安装 VMware Workstation Pr</summary>
      
    
    
    
    <category term="运维" scheme="https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="linux" scheme="https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/linux/"/>
    
    
    <category term="VMware" scheme="https://ysluckly.github.io/tags/VMware/"/>
    
    <category term="Ubuntu" scheme="https://ysluckly.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>主流 Markdown 编辑器推荐</title>
    <link href="https://ysluckly.github.io/2021/10/24/tools/"/>
    <id>https://ysluckly.github.io/2021/10/24/tools/</id>
    <published>2021-10-24T02:10:45.000Z</published>
    <updated>2022-02-20T13:20:18.333Z</updated>
    
    <content type="html"><![CDATA[<font color=#4094C7>Markdown ，2004年由 John Gruberis 设计和开发，是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式，以下将介绍目前比较流行的一些 Markdown 编辑器（排名不分先后）</font><hr><h1 id="MarkdownPad"><a href="#MarkdownPad" class="headerlink" title=" - MarkdownPad "></a><font color=#FF0000> - MarkdownPad </font></h1><p>目前分为 MarkdownPad2 和 MarkdownPad Pro 版本，后者收费，我们使用前者足矣，用户可以通过键盘快捷键和工具栏按钮来使用或者移除 Markdown 各种语法格式，支持自定义配色方案、字体、大小和布局 、即时HTML预览、HTML和PDF导出，被很多人称赞为 Windows 平台最好用的 Markdown 编辑器，实用性强，仅支持 Windows 系统，个人觉得在 Windows 10 系统上界面并不是很好看，有时候添加音乐什么的，资源多了，实时预览会显示资源加载失败，<a href="http://markdownpad.com/">点击此处</a>访问 MarkdownPad 官网</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/MarkdownPad2.jpg" alt="MarkdownPad 2"></p><hr><h1 id="BookPad"><a href="#BookPad" class="headerlink" title="- BookPad "></a><font color=#FF0000>- BookPad </font></h1><p> 无意间在 Microsoft Store 上发现的，完美搭配 Win10 系统，界面非常简洁漂亮，2017年9月份发布，大小30.82 MB，官方网站：<a href="https://sosfos.wordpress.com/">https://sosfos.wordpress.com/</a> ，收费13人民币，可免费使用7天，各种功能应有尽有，和其他编辑器不相上下，本来想着百度百度看看有没有破解版，结果全网看不见 BookPad 的影子，估计是新出来的还不为人所知吧，可以直接在 Microsoft Store 搜索下载，或者点击链接获取：<a href="https://www.microsoft.com/store/apps/9N6P5ZH2SJSX">https://www.microsoft.com/store/apps/9N6P5ZH2SJSX</a></p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/BookPad.jpg" alt="BookPad"></p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/BookPad2.jpg" alt="BookPad2"></p><hr><h1 id="小书匠"><a href="#小书匠" class="headerlink" title=" - 小书匠"></a><font color=#FF0000> - 小书匠</font></h1><p> 分为免费版和收费版，收费版¥20/年，其实免费版的功能已经足够强大了，多种编辑模式、多种主题选择、多种编辑器实现、丰富的语法支持、第三方同步、强大的文件管理功能，让人使用一次就爱上了它，支持 Windows 和 Web，推荐使用，<a href="http://soft.xiaoshujiang.com/">点击此处</a>访问小书匠官网</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/xiaoshujiang.jpg" alt="小书匠"><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/xiaoshujiang2.jpg" alt="小书匠2"></p><hr><h1 id="Typora"><a href="#Typora" class="headerlink" title=" - Typora"></a><font color=#FF0000> - Typora</font></h1><p>Typora 同样支持 Windows、OS X 和 Linux，Typora 支持即时渲染技术，这也是与其他 Markdown 编辑器最显著的区别，支持数学编辑，可与 Word 直接格式转换，在 Pandoc 的支持下进行多种文档格式转换，Typora 适合那些对码字手速和排版顺畅度有要求的人群，譬如码农、网站小编等，<a href="https://www.typora.io/">点击此处</a>访问 Typora 官网</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/Typora.jpg" alt="Typora"></p><hr><h1 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title=" - Visual Studio Code"></a><font color=#FF0000> - Visual Studio Code</font></h1><p>Visual Studio Code 是众所周知的神器，是微软推出一款轻量级的文本编辑工具，类似于 Sublime，它已经默认集成 Markdown 文档编辑插件，原生就支持高亮 Markdown 的语法，但想要实时预览还需要选择 Markdown: Open Preview to the Side 命令实现，相关教程请<a href="https://www.cnblogs.com/shawWey/p/8931697.html">点击此处</a>，<a href="https://code.visualstudio.com/">点击此处</a> 访问 Visual Studio Code 官网</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/VisualStudioCode.jpg" alt="Visual Studio Code"></p><hr><h1 id="Marxico"><a href="#Marxico" class="headerlink" title="- Marxico"></a><font color=#FF0000>- Marxico</font></h1><p>Marxico 中文名马克飞象，提供桌面客户端以及离线 Chrome App，支持移动端 Web，可以直接把文本存到印象笔记，<a href="http://marxi.co/">点击此处</a>访问 Marxico，<a href="https://maxiang.io/">点击此处</a>访问 马克飞象</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/Marxico.jpg" alt="马克飞象"></p><hr><h1 id="Sublime-Text-3"><a href="#Sublime-Text-3" class="headerlink" title=" - Sublime Text 3"></a><font color=#FF0000> - Sublime Text 3</font></h1><p>Sublime Text 3 是基于 Vim 开发的跨平台代码编辑器，收费80美元，好像可以免费试用，支持 OS X、Windows、Ubuntu 等 UNIX 及 Linux 操作系统，由于其功能的多样性而广受好评，界面简约大方，定位专业，原生支持的编程语言就多达十几种，通过第三方插件，还能实现更多语法的支持，其中就包括 Markdown ，但也有个缺点，就是不能实时预览，但是用户可以通过 Markdown Preview 的插件实现对 Markdown 的预览，具体教程请<a href="https://blog.csdn.net/qazxswed807/article/details/51235792">点击此处</a>查看，<a href="http://www.sublimetext.com/">点击此处</a>访问 Sublime Text 官网</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/SublimeText.jpg" alt="SublimeText"></p><hr><h1 id="Mou"><a href="#Mou" class="headerlink" title=" - Mou "></a><font color=#FF0000> - Mou </font></h1><p>Mou 是一款由国人独立开发者罗晨开发的实时预览型 Markdown 编辑器，仅支持 OS X操作系统，是目前同类应用中对汉字兼容性最好的作品，也是目前最好用的免费 Markdown 编辑器，提供语法高亮、在线预览、同步滚动、全屏模式，支持自定保存、自动匹配，允许自定义主题，支持 CSS，HTML 和 PDF 导出等功能，<a href="http://25.io/mou/">点击此处</a>访问 Mou 官网</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/Mou.jpg" alt="Mou"></p><hr><h1 id="Atom"><a href="#Atom" class="headerlink" title=" - Atom"></a><font color=#FF0000> - Atom</font></h1><p>Atom 是 Github 专门为程序员推出的一个跨平台文本编辑器，具有简洁和直观的图形用户界面，并有很多有趣的特点：支持CSS，HTML，JavaScript等网页编程语言，当然也支持 Markdown ，支持宏，自动完成分屏功能，集成了文件管理器，<a href="https://atom.io/">点击此处</a>访问 Atom 官网</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/Atom.jpg" alt="Atom"></p><hr><h1 id="Smark"><a href="#Smark" class="headerlink" title=" - Smark"></a><font color=#FF0000> - Smark</font></h1><p>国人编写的开源软件，Windows / Linux 等主流系统跨平台支持，完美支持 LaTex 数学公式、脚注、尾注等，支持使用本地 MathJax 调用，不需要在线访问 MathJax CDN，用户可配置的 Markdown 语法高亮显示，美观整洁，多种格式文件导出支持，简洁友好的界面布局，完备的各类快捷键，能极大地提高工作效率，<a href="https://gitee.com/elerao/Smark">点击此处</a>访问 Smark 官网</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/smark.jpg" alt="Smark"></p><hr><h1 id="Haroopad"><a href="#Haroopad" class="headerlink" title=" - Haroopad"></a><font color=#FF0000> - Haroopad</font></h1><p>Haroopad 覆盖三大主流桌面系统，支持 Windows、OS X 和 Linux，多种主题样式供你选择，语法标亮支持 54 种编程语言，该工具重点推荐 Ubuntu/Linux 用户使用，<a href="http://pad.haroopress.com/user.html">点击此处</a>访问 Haroopad 官网</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/Haroopad.jpg" alt="Haroopad"></p><hr><h1 id="CuteMarkEd"><a href="#CuteMarkEd" class="headerlink" title="- CuteMarkEd"></a><font color=#FF0000>- CuteMarkEd</font></h1><p>CuteMarkEd 是一个基于qt5的跨平台的 Markdown 编辑器，开源的， 提供实时 HTML 预览、数学表达式、源码高亮和PDF导出，<a href="https://cloose.github.io/CuteMarkEd/">点击此处</a> 访问 CuteMarkEd 官网</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/CuteMarkEd.jpg" alt="CuteMarkEd"></p><hr><h1 id="MarkPad"><a href="#MarkPad" class="headerlink" title=" - MarkPad"></a><font color=#FF0000> - MarkPad</font></h1><p>MarkPad 是款开源的 Markdown 编辑器，与 Window 8 风格和谐友好的界面，可以直接在你的博客或者 GitHub 中打开、保存文档，直接将图片粘贴到 Markdown 文档中，<a href="http://code52.org/DownmarkerWPF/">点击此处</a>访问 MarkPad 官网</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/MarkPad.jpg" alt="MarkPad"></p><hr><h1 id="Cmd-Markdown"><a href="#Cmd-Markdown" class="headerlink" title="- Cmd Markdown"></a><font color=#FF0000>- Cmd Markdown</font></h1><p>作业部落出品，是一款不错的工具和博客平台兼顾的产品，同时支持 Linux、Mac 和 Windows 操作系统，此外还提供 Web 在线创作，社交化批注、智能云同步，最简单的方法，满足多种写作需要，<a href="https://www.zybuluo.com/cmd/">点击此处</a>访问 Cmd Markdown 官网</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/CmdMarkdown.jpg" alt="Cmd Markdown"></p><hr><h1 id="FarBox"><a href="#FarBox" class="headerlink" title="- FarBox"></a><font color=#FF0000>- FarBox</font></h1><p>同样是一款不错的 Markdown 编辑器和博客平台兼顾的产品，让用户通过Dropbox（现在默认是自己的同步服务器）直接建立个人网站。FarBox编辑器免费，同时支持 Linux、Mac 和 Windows 操作系统，Farbox服务可以免费试用，在本地编辑器内写作自动同步发布在个人博客，对于希望有个人博客但却不愿折腾的小白来说，是个不错的选择，<a href="https://www.farbox.com/">点击此处</a>访问 FarBox 官网</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/FarBox.jpg" alt="FarBox"></p><hr><h1 id="Miu"><a href="#Miu" class="headerlink" title="- Miu"></a><font color=#FF0000>- Miu</font></h1><p>Miu 是一款 Windows 下的 Markdown 编辑器，支持 Markdown 高亮、代码高亮、即时预览，以及可以快速发布到 Github Gist，小众软件，界面美观，已经找不到官网了，小众软件网有提供百度云下载，<a href="https://www.appinn.com/miu-markdown-editor/">Miu 下载地址</a></p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/Miu.jpg" alt="Miu"></p><hr><h1 id="MacDown"><a href="#MacDown" class="headerlink" title="- MacDown"></a><font color=#FF0000>- MacDown</font></h1><p>MacDown 引用了许多 Mou 的设计方式，仅支持 Mac ，开源免费，<a href="http://macdown.uranusjr.com/">点击此处</a>访问 MacDown 官网</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/MacDown.jpg" alt="MacDown"></p><hr><h1 id="Ulysses"><a href="#Ulysses" class="headerlink" title="- Ulysses"></a><font color=#FF0000>- Ulysses</font></h1><p>一款由国外开发商 The Soulmen 制作的 Markdown 编辑器。与其它同类应用相比，Ulysses 最大的不同在于，它能根据内置的文件管理器，以及与 iCloud 云服务器的实时同步方案，达到最快捷的文章整理效率，支持OS X , iPad，26人民币每月，14天免费试用，<a href="https://ulysses.app/">点击此处</a>访问 Ulysses 官网</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/Ulysses.jpg" alt="Ulysses"></p><hr><h1 id="Byword"><a href="#Byword" class="headerlink" title="- Byword"></a><font color=#FF0000>- Byword</font></h1><p>一款轻量级的 Markdown 编辑器，支持Mac，iPhone和iPad，界面极简，功能强大，貌似要付费使用，<a href="https://bywordapp.com/">点击此处</a> 访问 Byword 官网</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/Byword.jpg" alt="Byword"></p><hr><h1 id="MaHua"><a href="#MaHua" class="headerlink" title="- MaHua"></a><font color=#FF0000>- MaHua</font></h1><p>一个在线编辑 Markdown 文档的编辑器，小众软件，VIM 快捷键支持，完美兼容 Github 的 Markdown 语法，界面稍许简陋，<a href="http://mahua.jser.me/">点击此处</a>访问 MaHua</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/MaHua.jpg" alt="MaHua"></p><hr><h1 id="Dillinger"><a href="#Dillinger" class="headerlink" title="- Dillinger"></a><font color=#FF0000>- Dillinger</font></h1><p>来自国外的 Markdown 编辑器，漂亮强大，支持md、 html、pdf 文件导出，支持Dropbox、Github、Google Drive、Onedrive 一键保存，<a href="https://dillinger.io/">点击此处</a>访问 Dillinger</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/Dillinger.jpg" alt="Dillinger"></p><hr><h1 id="CSDN"><a href="#CSDN" class="headerlink" title=" - CSDN"></a><font color=#FF0000> - CSDN</font></h1><p>中国专业IT社区CSDN (Chinese Software Developer Network) 创立于1999年，致力于为中国软件开发者提供知识传播、在线学习、职业发展等全生命周期服务。CSDN的在线编辑器功能强大，支持导出为HTML和md文件，注册账号后即可开始创作，<a href="https://www.csdn.net/">点击此处</a>访问CSDN官网</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/CSDN.jpg" alt="CSDN"></p><hr><h1 id="简书"><a href="#简书" class="headerlink" title=" - 简书"></a><font color=#FF0000> - 简书</font></h1><p>简书是一个优质的创作社区，你可以在线创作并发表到社区，是国内优质原创内容输出平台，简书从一开始就已经支持 Markdown 和富文本编辑，是一个为专门为作者打造的平台，<a href="https://www.jianshu.com/">点击此处</a>访问简书官网</p><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A05/jianshu.jpg" alt="简书"></p><hr><p><strong><font color=#4094C7>在写博客的时候，我们不希望都是千篇一律的没有色彩，多了解一些 Markdown 语法技巧有利于丰富我们的博客，看起来更有 feel ！</font></strong></p><hr><h1 id="–-插入图片"><a href="#–-插入图片" class="headerlink" title=" – 插入图片 "></a><font color=#FF0000> – 插入图片 </font></h1><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A03/01.jpg" alt="车"></p><p>如果你使用 MarkdownPad 的话就比较方便，可以直接选择插入本地图片或者是网络图片，实质是通过以下代码实现的，小括号里面就是你的图片地址，中括号里面是图片的替代文字，比如上面的图片代码如下：</p><pre><code class="markdown">![车](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A03/01.jpg)</code></pre><h1 id="–-插入音乐"><a href="#–-插入音乐" class="headerlink" title=" – 插入音乐 "></a><font color=#FF0000> – 插入音乐 </font></h1><p>打开网页版<a href="https://music.163.com/">网易云音乐</a>，选择你准备插入的音乐，点击生成外链播放器，前提是要有版权，不然是无法生成外链播放器的，选择好尺寸后，复制底下的HTML代码</p><p>然后将此HTML代码粘贴到你想要放的地方，可自行调节播放器的大小，其中 <font color=#FF0000>auto=1</font> 表示打开网页自动播放音乐，<font color=#FF0000>auto=0</font> 表示关闭自动播放音乐，比如See You Again (中英文版) - 罗艺恒这首歌曲代码如下：</p><pre><code class="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=32405683&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A03/02.jpg" alt="02"><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A03/03.jpg" alt="03"></p><h1 id="–-插入视频"><a href="#–-插入视频" class="headerlink" title=" – 插入视频 "></a><font color=#FF0000> – 插入视频 </font></h1><p>高考毕业了我们为下一届的学弟学妹们录制高考加油视频，我担任后期制作，在这里就以该视频为例٩(๑❛ᴗ❛๑)۶，在腾讯视频播放页面找到分享按钮，复制该视频的通用代码（其他视频播放平台也一样）,粘贴到文章中对应位置即可，可根据情况调整视频播放器的大小<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A03/04.jpg" alt="04"></p><pre><code class="html">&lt;iframe frameborder=&quot;0&quot; width=&quot;840&quot;  height=&quot;500&quot; src=&quot;https://v.qq.com/txp/iframe/player.html?vid=x0643zvgtf7&quot; allowFullScreen=&quot;true&quot;&gt;&lt;/iframe&gt;</code></pre><iframe frameborder="0" width="840"  height="500" src="https://v.qq.com/txp/iframe/player.html?vid=x0643zvgtf7" allowFullScreen="true"></iframe><hr><h1 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续…… "></a><center><font color=#FF0000>未完待续…… </font></center></h1><p>要细数 Markdown 编辑器的话，可能永远也数不尽，而且每个人的看法也不同，正所谓萝卜白菜各有所爱，什么编辑器不是最重要的，重要的是我们能写出优质的文章，不断学习进步！不断提升自我！</p><p>参考资料：<br><a href="http://www.williamlong.info/archives/4319.html">《好用的Markdown编辑器一览》</a>（By：月光）<br><a href="https://blog.csdn.net/jinhui157/article/details/73872795/">《10款流行的Markdown编辑器，总有一款适合你》</a>（By：xiaoxiao_engineer）<br><a href="https://sspai.com/post/27792">《解决作者们的焦虑：7 款优秀 Markdown 编辑工具推荐》</a>（By：JailJT）<br><a href="https://www.jianshu.com/p/191d1e21f7ed">《markdown基本语法》</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;font color=#4094C7&gt;
Markdown ，2004年由 John Gruberis 设计和开发，是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式，以下将介绍目前比较流行的一些 Markdown 编辑器（排名不分</summary>
      
    
    
    
    <category term="工具" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="markdown" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/markdown/"/>
    
    
    <category term="Markdown" scheme="https://ysluckly.github.io/tags/Markdown/"/>
    
    <category term="编辑器" scheme="https://ysluckly.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>利用Cloudflare为基于GitHub Pages的Hexo博客添加HTTPS支持</title>
    <link href="https://ysluckly.github.io/2021/10/24/hexo/"/>
    <id>https://ysluckly.github.io/2021/10/24/hexo/</id>
    <published>2021-10-24T02:10:45.000Z</published>
    <updated>2022-02-20T13:20:10.317Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>HTTP（超文本传输协议），是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议，所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。</p></blockquote><blockquote><p>HTTPS（超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。</p></blockquote><hr><h1 id="–-前言"><a href="#–-前言" class="headerlink" title="– 前言"></a><font color=#FF000>– 前言</font></h1><p>GitHub Pages 自带的域名（xxx.github.io）支持开启 https 服务，可以在仓库的【Settings】- 【GitHub Pages】下勾选【Enforce HTTPS】即可，但是如果你设置了自定义域名的话，就比较复杂了，因为 hexo 博客是托管在 GitHub 上的，没有自己的服务器，因此也不支持上传 SSL 证书，从2018年5月1日起，GitHub官方也支持自定义域名开启https了，实现方法可参考我的文章：<a href="https://www.itrhx.com/2019/08/11/A28-hexo-add-https/">《利用官方支持为基于GitHub Pages的Hexo博客启用HTTPS》</a>，另外一种方法就是利用 Cloudflare 的 CDN 中转来启用 HTTPS，这种方法的弊端就是国内访问速度可能会变慢，本文主要讲述这种方法</p><p>Cloudflare 是一家美国的跨国科技企业，以向客户提供网站安全管理、性能优化及相关的技术支持为主要业务，它提供了免费的 https 服务，注意不是应用SSL证书，实现原理：用户到CDN服务器的连接为 https 方式，而CDN服务器到 GithubPages 服务器的连接为 http 方式，在CDN服务器那里加上反向代理</p><h1 id="–-注册-Cloudflare"><a href="#–-注册-Cloudflare" class="headerlink" title="– 注册 Cloudflare"></a><font color=#FF000>– 注册 Cloudflare</font></h1><p>到 <a href="https://dash.cloudflare.com/sign-up">Cloudflare官网</a> 注册账号<br><fancybox><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A26/01.jpg" alt="01.jpg"><br></fancybox></p><h1 id="–-添加站点"><a href="#–-添加站点" class="headerlink" title="– 添加站点"></a><font color=#FF000>– 添加站点</font></h1><p>添加你的站点，一直下一步即可<br><fancybox><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A26/02.jpg" alt="02.jpg"><br></fancybox><br><fancybox><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A26/03.jpg" alt="03.jpg"><br></fancybox><br>如果你已经在域名服务商那里解析过域名的话，之后就会出现你域名的解析列表，如果还没有解析过，可以参考<a href="https://blog.csdn.net/qq_36759224/article/details/82121420#font_colorFF000__Hexo_font_270">《为hexo博客配置个性域名》</a><br><fancybox><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A26/04.jpg" alt="04.jpg"><br></fancybox></p><h1 id="–修改DNS"><a href="#–修改DNS" class="headerlink" title="–修改DNS"></a><font color=#FF000>–修改DNS</font></h1><p>点击下一步 Cloudflare 会提供给你两个 DNS 地址<br><fancybox><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A26/05.jpg" alt="05.jpg"><br></fancybox><br>到域名服务商那里修改DNS，以阿里云为例，依次选择【控制台】-【域名】，选择你的域名，点击【管理】-【修改DNS】，将上面 Cloudflare 提供的两个 DNS 地址填进去，会过几分钟才生效<br><fancybox><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A26/08.jpg" alt="08.jpg"><br></fancybox><br><fancybox><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A26/09.jpg" alt="09.jpg"><br></fancybox><br><fancybox><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A26/10.jpg" alt="10.jpg"><br></fancybox></p><h1 id="–开启-HTTPS"><a href="#–开启-HTTPS" class="headerlink" title="–开启 HTTPS"></a><font color=#FF000>–开启 HTTPS</font></h1><p>在 Cloudflare 管理页面，点击【Crypto】选项，选择 SSL 的模式为【full】，注意：在CloudFlare 上激活站点后，可能需要24小时才能颁发新证书，耐心等待即可<br><fancybox><br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A26/07.jpg" alt="07.jpg"><br></fancybox></p><p>关于三种模式 Flexible、Full、Full (Strict) 的区别：</p><ul><li><p>Flexible：访客与 Cloudflare 之间是加密的，Cloudflare 到站点服务器是不加密的</p></li><li><p>Full：访客到 Cloudflare、Cloudflare 到站点服务器都是加密的，它不会验证你服务器上的证书是否合法，因此你可以在你服务器上安装任何证书，包括自签名证书</p></li><li><p>Full (strict)：访客到 Cloudflare、Cloudflare 到站点服务器都是加密的，它会验证你服务器上的证书是否合法，你必须在你的服务器上安装有可信赖的CA证书，并且这个证书必须是未过期，包含有域名等信息的</p></li></ul><p>至此，我们的域名就支持 https 访问了，但是当用户输入 <a href="http://xxxxxx/">http://xxxxxx</a> 访问时，浏览器依旧会以 http 协议来访问，并不会跳转到 https，这时候就需要利用重定向来解决了</p><h1 id="–重定向强制-HTTPS"><a href="#–重定向强制-HTTPS" class="headerlink" title="–重定向强制 HTTPS"></a><font color=#FF000>–重定向强制 HTTPS</font></h1><p>Cloudflare 提供了一个名叫 Page Rules 的页面规则的功能，我们可以利用此功能对 URL 做一些处理，当用户访问是 HTTP 的时候重定向到 HTTPS，点击【Page Rules】选项，点击【Create Page Rules】，新建如下规则并保存即可</p><fancybox>![06.jpg](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A26/06.jpg)</fancybox><p>现在我们的 Hexo 博客就实现了全站 HTTPS！</p><h4 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h4><p><a href="https://itrhx.blog.csdn.net/category_9285510.html">Hexo建站系列教程</a><br><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163213403016780265411993%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163213403016780265411993&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82729029.pc_search_es_clickV2&utm_term=hexo&spm=1018.2226.3001.4187">hexo建站教程最全</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;HTTP（超文本传输协议），是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议，所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。&lt;/p&gt;</summary>
      
    
    
    
    <category term="工具" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="hexo" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
    <category term="Cloudflare" scheme="https://ysluckly.github.io/tags/Cloudflare/"/>
    
  </entry>
  
  <entry>
    <title>免费CDN：jsDelivr + Github</title>
    <link href="https://ysluckly.github.io/2021/10/24/hexo/"/>
    <id>https://ysluckly.github.io/2021/10/24/hexo/</id>
    <published>2021-10-24T02:10:45.000Z</published>
    <updated>2022-02-20T13:20:04.982Z</updated>
    
    <content type="html"><![CDATA[<p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科</p><p>放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。</p><hr><h1 id="1、新建Github仓库"><a href="#1、新建Github仓库" class="headerlink" title="1、新建Github仓库 "></a><font color=#FF0000>1、新建Github仓库 </font></h1><p><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A18/01.jpg" alt="01"></p><h1 id="2、克隆Github仓库到本地"><a href="#2、克隆Github仓库到本地" class="headerlink" title="2、克隆Github仓库到本地 "></a><font color=#FF0000>2、克隆Github仓库到本地 </font></h1><p>  点击 Clone or download，一键复制仓库地址<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A18/04.jpg" alt="04"></p><p> 在本地目录右键 Git Bash Here，执行以下命令：</p><pre><code class="git">git clone 一键复制的仓库地址</code></pre><h1 id="3、上传资源"><a href="#3、上传资源" class="headerlink" title="3、上传资源 "></a><font color=#FF0000>3、上传资源 </font></h1><p>  复制需要上传的资源到本地git仓库（注：jsDelivr不支持加载超过20M的资源），在本地git仓库目录下右键 Git Bash Here，执行以下命令：</p><pre><code class="git">git status                    //查看状态git add .                     //添加所有文件到暂存区git commit -m &#39;第一次提交&#39;      //把文件提交到仓库git push                      //推送至远程仓库</code></pre><h1 id="4、发布仓库"><a href="#4、发布仓库" class="headerlink" title="4、发布仓库 "></a><font color=#FF0000>4、发布仓库 </font></h1><p>  点击release发布<br><img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A18/02.jpg" alt="02"></p><p>  自定义发布版本号<br>  <img src="https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A18/03.jpg" alt="03"></p><h1 id="5、通过jsDelivr引用资源"><a href="#5、通过jsDelivr引用资源" class="headerlink" title="5、通过jsDelivr引用资源 "></a><font color=#FF0000>5、通过jsDelivr引用资源 </font></h1><p>使用方法：<a href="https://cdn.jsdelivr.net/gh/%E4%BD%A0%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BD%A0%E7%9A%84%E4%BB%93%E5%BA%93%E5%90%8D@%E5%8F%91%E5%B8%83%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84">https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</a><br>例如：<a href="https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/ys-thx.png">https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/ys-thx.png</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.1/css/style.css">https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.1/css/style.css</a><br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4">https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4</a></p><p>注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下：</p><ul><li><p>// 加载任何Github发布、提交或分支<br><a href="https://cdn.jsdelivr.net/gh/user/repo@version/file">https://cdn.jsdelivr.net/gh/user/repo@version/file</a></p></li><li><p>// 加载 jQuery v3.2.1<br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js</a></p></li><li><p>// 使用版本范围而不是特定版本<br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js</a><br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js</a></p></li><li><p>// 完全省略该版本以获取最新版本<br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js</a></p></li><li><p>// 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成<br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js</a></p></li><li><p>// 在末尾添加 / 以获取资源目录列表<br><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/">https://cdn.jsdelivr.net/gh/jquery/jquery/</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关</summary>
      
    
    
    
    <category term="工具" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="hexo" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
    <category term="jsDelivr" scheme="https://ysluckly.github.io/tags/jsDelivr/"/>
    
    <category term="CDN" scheme="https://ysluckly.github.io/tags/CDN/"/>
    
  </entry>
  
</feed>
