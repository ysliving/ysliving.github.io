<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>码农印象</title>
  
  
  <link href="https://ysluckly.github.io/atom.xml" rel="self"/>
  
  <link href="https://ysluckly.github.io/"/>
  <updated>2022-02-25T15:57:28.031Z</updated>
  <id>https://ysluckly.github.io/</id>
  
  <author>
    <name>码农印象</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL数据库面试题</title>
    <link href="https://ysluckly.github.io/2022/03/03/mysql/"/>
    <id>https://ysluckly.github.io/2022/03/03/mysql/</id>
    <published>2022-03-03T07:29:32.000Z</published>
    <updated>2022-02-25T15:57:28.031Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li><ul><li><a href="about:blank#_37">数据库基础知识</a><ul><li><ul><li><a href="about:blank#_39">为什么要使用数据库</a><ul><li>  <a href="about:blank#SQL_63">什么是SQL？</a></li><li>  <a href="about:blank#MySQL_71">什么是MySQL?</a></li><li>  <a href="about:blank#_77">数据库三大范式是什么</a></li><li>  <a href="about:blank#mysql_89">mysql有关权限的表都有哪几个</a></li><li>  <a href="about:blank#MySQLbinlog_101">MySQL的binlog有有几种录入格式？分别有什么区别？</a></li></ul></li></ul></li><li>  <a href="about:blank#_115">数据类型</a></li><li><ul><li>  <a href="about:blank#mysql_117">mysql有哪些数据类型</a></li></ul></li><li>  <a href="about:blank#_184">引擎</a></li><li><ul><li><a href="about:blank#MySQLMyISAMInnoDB_186">MySQL存储引擎MyISAM与InnoDB区别</a><ul><li>  <a href="about:blank#MyISAMInnoDB_217">MyISAM索引与InnoDB索引的区别？</a></li><li>  <a href="about:blank#InnoDB4_226">InnoDB引擎的4大特性</a></li><li>  <a href="about:blank#_238">存储引擎选择</a></li></ul></li></ul></li><li>  <a href="about:blank#_250">索引</a></li><li><ul><li><a href="about:blank#_252">什么是索引？</a><ul><li>  <a href="about:blank#_262">索引有哪些优缺点？</a></li><li>  <a href="about:blank#_276">索引使用场景（重点）</a></li><li>  <a href="about:blank#_321">索引有哪几种类型？</a></li><li>  <a href="about:blank#bhash_345">索引的数据结构（b树，hash）</a></li><li>  <a href="about:blank#_383">索引的基本原理</a></li><li>  <a href="about:blank#_399">索引算法有哪些？</a></li><li>  <a href="about:blank#_420">索引设计的原则？</a></li><li>  <a href="about:blank#_429">创建索引的原则（重中之重）</a></li><li>  <a href="about:blank#_451">创建索引的三种方式，删除索引</a></li><li>  <a href="about:blank#_517">创建索引时需要注意什么？</a></li><li>  <a href="about:blank#_525">使用索引查询一定能提高查询的性能吗？为什么</a></li><li>  <a href="about:blank#_535">百万级别或以上的数据如何删除</a></li><li>  <a href="about:blank#_546">前缀索引</a></li><li>  <a href="about:blank#_558">什么是最左前缀原则？什么是最左匹配原则</a></li><li>  <a href="about:blank#BB_566">B树和B+树的区别</a></li><li>  <a href="about:blank#B_576">使用B树的好处</a></li><li>  <a href="about:blank#B_582">使用B+树的好处</a></li><li>  <a href="about:blank#HashB_588">Hash索引和B+树所有有什么区别或者说优劣呢?</a></li><li>  <a href="about:blank#BB_609">数据库为什么使用B+树而不是B树</a></li><li>  <a href="about:blank#B_619">B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，</a></li><li>  <a href="about:blank#_627">什么是聚簇索引？何时使用聚簇索引与非聚簇索引</a></li><li>  <a href="about:blank#_640">非聚簇索引一定会回表查询吗？</a></li><li>  <a href="about:blank#_648">联合索引是什么？为什么需要注意联合索引中的顺序？</a></li></ul></li></ul></li><li>  <a href="about:blank#_662">事务</a></li><li><ul><li><a href="about:blank#_664">什么是数据库事务？</a><ul><li>  <a href="about:blank#ACID_674">事物的四大特性(ACID)介绍一下?</a></li><li>  <a href="about:blank#_687">什么是脏读？幻读？不可重复读？</a></li><li>  <a href="about:blank#MySQL_695">什么是事务的隔离级别？MySQL的默认隔离级别是什么？</a></li></ul></li></ul></li><li>  <a href="about:blank#_725">锁</a></li><li><ul><li><a href="about:blank#MySQL_727">对MySQL的锁了解吗</a><ul><li>  <a href="about:blank#_735">隔离级别与锁的关系</a></li><li>  <a href="about:blank#InnoDB_747">按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</a></li><li>  <a href="about:blank#MySQL_772">从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了</a></li><li>  <a href="about:blank#MySQLInnoDB_788">MySQL中InnoDB引擎的行锁是怎么实现的？</a></li><li>  <a href="about:blank#InnoDB_798">InnoDB存储引擎的锁的算法有三种</a></li><li>  <a href="about:blank#_814">什么是死锁？怎么解决？</a></li><li>  <a href="about:blank#_830">数据库的乐观锁和悲观锁是什么？怎么实现的？</a></li></ul></li></ul></li><li>  <a href="about:blank#_848">视图</a></li><li><ul><li><a href="about:blank#_850">为什么要使用视图？什么是视图？</a><ul><li>  <a href="about:blank#_858">视图有哪些特点？</a></li><li>  <a href="about:blank#_881">视图的使用场景有哪些？</a></li><li>  <a href="about:blank#_899">视图的优点</a></li><li>  <a href="about:blank#_907">视图的缺点</a></li><li>  <a href="about:blank#_917">什么是游标？</a></li></ul></li></ul></li><li>  <a href="about:blank#_925">存储过程与函数</a></li><li><ul><li>  <a href="about:blank#_927">什么是存储过程？有哪些优缺点？</a></li></ul></li><li>  <a href="about:blank#_955">触发器</a></li><li><ul><li><a href="about:blank#_957">什么是触发器？触发器的使用场景有哪些？</a><ul><li>  <a href="about:blank#MySQL_971">MySQL中都有哪些触发器？</a></li></ul></li></ul></li><li>  <a href="about:blank#SQL_986">常用SQL语句</a></li><li><ul><li><a href="about:blank#SQL_988">SQL语句主要分为哪几类</a><ul><li>  <a href="about:blank#_1014">超键、候选键、主键、外键分别是什么？</a></li><li>  <a href="about:blank#SQL__1023">SQL 约束有哪几种？</a></li><li>  <a href="about:blank#_1035">六种关联查询</a></li><li>  <a href="about:blank#_1160">什么是子查询</a></li><li>  <a href="about:blank#_1168">子查询的三种情况</a></li><li>  <a href="about:blank#mysql_in__exists__1197">mysql中 in 和 exists 区别</a></li><li>  <a href="about:blank#varcharchar_1207">varchar与char的区别</a></li><li>  <a href="about:blank#varchar5050_1233">varchar(50)中50的涵义</a></li><li>  <a href="about:blank#int2020_1239">int(20)中20的涵义</a></li><li>  <a href="about:blank#mysql_1247">mysql为什么这么设计</a></li><li>  <a href="about:blank#mysqlint10char10varchar10_1253">mysql中int(10)和char(10)以及varchar(10)的区别</a></li><li>  <a href="about:blank#FLOATDOUBLE_1267">FLOAT和DOUBLE的区别是什么？</a></li><li>  <a href="about:blank#dropdeletetruncate_1274">drop、delete与truncate的区别</a></li><li>  <a href="about:blank#UNIONUNION_ALL_1289">UNION与UNION ALL的区别？</a></li></ul></li></ul></li><li>  <a href="about:blank#SQL_1298">SQL优化</a></li><li><ul><li><a href="about:blank#SQL_1300">如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</a><ul><li>  <a href="about:blank#SQL_1378">SQL的生命周期？</a></li><li>  <a href="about:blank#_1398">大表数据查询，怎么优化</a></li><li>  <a href="about:blank#_1408">超大分页怎么处理？</a></li><li>  <a href="about:blank#mysql__1431">mysql 分页</a></li><li>  <a href="about:blank#_1455">慢查询日志</a></li><li>  <a href="about:blank#sql_1479">关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</a></li><li>  <a href="about:blank#_1493">为什么要尽量设定一个主键？</a></li><li>  <a href="about:blank#IDUUID_1499">主键使用自增ID还是UUID？</a></li><li>  <a href="about:blank#not_null_1511">字段为什么要求定义为not null？</a></li><li>  <a href="about:blank#_1517">如果要存储用户的密码散列，应该使用什么字段进行存储？</a></li><li>  <a href="about:blank#_1523">优化查询过程中的数据访问</a></li><li>  <a href="about:blank#_1541">优化长难的查询语句</a></li><li>  <a href="about:blank#_1557">优化特定类型的查询语句</a></li><li>  <a href="about:blank#_1568">优化关联查询</a></li><li>  <a href="about:blank#_1575">优化子查询</a></li><li>  <a href="about:blank#LIMIT_1586">优化LIMIT分页</a></li><li>  <a href="about:blank#UNION_1593">优化UNION查询</a></li><li>  <a href="about:blank#WHERE_1599">优化WHERE子句</a></li></ul></li></ul></li><li>  <a href="about:blank#_1664">数据库优化</a></li><li><ul><li><a href="about:blank#_1666">为什么要优化</a><ul><li>  <a href="about:blank#_1676">数据库结构优化</a></li><li>  <a href="about:blank#MySQLcpu500_1706">MySQL数据库cpu飙升到500%的话他怎么处理？</a></li><li>  <a href="about:blank#CRUD_1718">大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</a></li><li><ul><li><a href="about:blank#_1744">垂直分表</a><ul><li><ul><li><a href="about:blank#_1750">适用场景</a><ul><li>  <a href="about:blank#_1755">缺点</a></li></ul></li></ul></li><li>  <a href="about:blank#_1785">水平分表：</a></li><li><ul><li><a href="about:blank#_1791">适用场景</a><ul><li>  <a href="about:blank#_1796">水平切分的缺点</a></li></ul></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#MySQL_1836">MySQL的复制原理以及流程</a></li><li>  <a href="about:blank#_1883">读写分离有哪些解决方案？</a></li><li>  <a href="about:blank#mysqldumpxtranbackup_1908">备份计划，mysqldump以及xtranbackup的实现原理</a></li><li>  <a href="about:blank#_1954">数据表损坏的修复方式有哪些？</a></li></ul></li></ul></li></ul></li></ul></li></ul><p>Java面试总结汇总，整理了包括Java基础知识，集合容器，并发编程，JVM，常用开源框架Spring，MyBatis，数据库，中间件等，包含了作为一个Java工程师在面试中需要用到或者可能用到的绝大部分知识。欢迎大家阅读，本人见识有限，写的博客难免有错误或者疏忽的地方，还望各位大佬指点，在此表示感激不尽。文章持续更新中…</p><table><thead><tr><th>序号</th><th>内容</th><th>链接地址</th></tr></thead><tbody><tr><td>1</td><td>Java基础知识面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104390612">https://thinkwon.blog.csdn.net/article/details/104390612</a></td></tr><tr><td>2</td><td>Java集合容器面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104588551">https://thinkwon.blog.csdn.net/article/details/104588551</a></td></tr><tr><td>3</td><td>Java异常面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104390689">https://thinkwon.blog.csdn.net/article/details/104390689</a></td></tr><tr><td>4</td><td>并发编程面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104863992">https://thinkwon.blog.csdn.net/article/details/104863992</a></td></tr><tr><td>5</td><td>JVM面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104390752">https://thinkwon.blog.csdn.net/article/details/104390752</a></td></tr><tr><td>6</td><td>Spring面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104397516">https://thinkwon.blog.csdn.net/article/details/104397516</a></td></tr><tr><td>7</td><td>Spring MVC面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104397427">https://thinkwon.blog.csdn.net/article/details/104397427</a></td></tr><tr><td>8</td><td>Spring Boot面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104397299">https://thinkwon.blog.csdn.net/article/details/104397299</a></td></tr><tr><td>9</td><td>Spring Cloud面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104397367">https://thinkwon.blog.csdn.net/article/details/104397367</a></td></tr><tr><td>10</td><td>MyBatis面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/101292950">https://thinkwon.blog.csdn.net/article/details/101292950</a></td></tr><tr><td>11</td><td>Redis面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/103522351">https://thinkwon.blog.csdn.net/article/details/103522351</a></td></tr><tr><td>12</td><td>MySQL数据库面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104778621">https://thinkwon.blog.csdn.net/article/details/104778621</a></td></tr><tr><td>13</td><td>消息中间件MQ与RabbitMQ面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104588612">https://thinkwon.blog.csdn.net/article/details/104588612</a></td></tr><tr><td>14</td><td>Dubbo面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104390006">https://thinkwon.blog.csdn.net/article/details/104390006</a></td></tr><tr><td>15</td><td>Linux面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104588679">https://thinkwon.blog.csdn.net/article/details/104588679</a></td></tr><tr><td>16</td><td>Tomcat面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104397665">https://thinkwon.blog.csdn.net/article/details/104397665</a></td></tr><tr><td>17</td><td>ZooKeeper面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104397719">https://thinkwon.blog.csdn.net/article/details/104397719</a></td></tr><tr><td>18</td><td>Netty面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/104391081">https://thinkwon.blog.csdn.net/article/details/104391081</a></td></tr><tr><td>19</td><td>架构设计&amp;分布式&amp;数据结构与算法面试题（2020最新版）</td><td><a href="https://thinkwon.blog.csdn.net/article/details/105870730">https://thinkwon.blog.csdn.net/article/details/105870730</a></td></tr></tbody></table><h2 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>数据库基础知识</h2><h3 id="为什么要使用数据库"><a href="#为什么要使用数据库" class="headerlink" title="为什么要使用数据库"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>为什么要使用数据库</h3><p><strong>数据保存在内存</strong></p><p>优点： 存取速度快</p><p>缺点： 数据不能永久保存</p><p><strong>数据保存在文件</strong></p><p>优点： 数据永久保存</p><p>缺点：1）速度比内存操作慢，频繁的IO操作。2）查询数据不方便</p><p><strong>数据保存在数据库</strong></p><p>1）数据永久保存</p><p>2）使用SQL语句，查询方便效率高。</p><p>3）管理数据方便</p><h3 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是SQL？</h3><p>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</p><p>作用：用于存取数据、查询、更新和管理关系数据库系统。</p><h3 id="什么是MySQL"><a href="#什么是MySQL" class="headerlink" title="什么是MySQL?"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是MySQL?</h3><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</p><h3 id="数据库三大范式是什么"><a href="#数据库三大范式是什么" class="headerlink" title="数据库三大范式是什么"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>数据库三大范式是什么</h3><p>第一范式：每个列都不可以再拆分。</p><p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p><p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p><p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p><h3 id="mysql有关权限的表都有哪几个"><a href="#mysql有关权限的表都有哪几个" class="headerlink" title="mysql有关权限的表都有哪几个"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>mysql有关权限的表都有哪几个</h3><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：</p><ul><li>  user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li><li>  db权限表：记录各个帐号在各个数据库上的操作权限。</li><li>  table_priv权限表：记录数据表级的操作权限。</li><li>  columns_priv权限表：记录数据列级的操作权限。</li><li>  host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li></ul><h3 id="MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h3><p>有三种格式，statement，row和mixed。</p><ul><li>  statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li><li>  row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li><li>  mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li></ul><p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>数据类型</h2><h3 id="mysql有哪些数据类型"><a href="#mysql有哪些数据类型" class="headerlink" title="mysql有哪些数据类型"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>mysql有哪些数据类型</h3><table><thead><tr><th><strong>分类</strong></th><th><strong>类型名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>整数类型</strong></td><td>tinyInt</td><td>很小的整数(8位二进制)</td></tr><tr><td></td><td>smallint</td><td>小的整数(16位二进制)</td></tr><tr><td></td><td>mediumint</td><td>中等大小的整数(24位二进制)</td></tr><tr><td></td><td>int(integer)</td><td>普通大小的整数(32位二进制)</td></tr><tr><td><strong>小数类型</strong></td><td>float</td><td>单精度浮点数</td></tr><tr><td></td><td>double</td><td>双精度浮点数</td></tr><tr><td></td><td>decimal(m,d)</td><td>压缩严格的定点数</td></tr><tr><td><strong>日期类型</strong></td><td>year</td><td>YYYY 1901~2155</td></tr><tr><td></td><td>time</td><td>HH:MM:SS -838:59:59~838:59:59</td></tr><tr><td></td><td>date</td><td>YYYY-MM-DD 1000-01-01~9999-12-3</td></tr><tr><td></td><td>datetime</td><td>YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59</td></tr><tr><td></td><td>timestamp</td><td>YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC</td></tr><tr><td><strong>文本、二进制类型</strong></td><td>CHAR(M)</td><td>M为0~255之间的整数</td></tr><tr><td></td><td>VARCHAR(M)</td><td>M为0~65535之间的整数</td></tr><tr><td></td><td>TINYBLOB</td><td>允许长度0~255字节</td></tr><tr><td></td><td>BLOB</td><td>允许长度0~65535字节</td></tr><tr><td></td><td>MEDIUMBLOB</td><td>允许长度0~167772150字节</td></tr><tr><td></td><td>LONGBLOB</td><td>允许长度0~4294967295字节</td></tr><tr><td></td><td>TINYTEXT</td><td>允许长度0~255字节</td></tr><tr><td></td><td>TEXT</td><td>允许长度0~65535字节</td></tr><tr><td></td><td>MEDIUMTEXT</td><td>允许长度0~167772150字节</td></tr><tr><td></td><td>LONGTEXT</td><td>允许长度0~4294967295字节</td></tr><tr><td></td><td>VARBINARY(M)</td><td>允许长度0~M个字节的变长字节字符串</td></tr><tr><td></td><td>BINARY(M)</td><td>允许长度0~M个字节的定长字节字符串</td></tr></tbody></table><ul><li><p><code>1、整数类型</code>，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。<br>  <code>长度</code>：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。<br>  <code>例子</code>，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p></li><li><p><code>2、实数类型</code>，包括FLOAT、DOUBLE、DECIMAL。<br>  DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。<br>  而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。<br>  计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p></li><li><p><code>3、字符串类型</code>，包括VARCHAR、CHAR、TEXT、BLOB<br>  VARCHAR用于存储可变长字符串，它比定长类型更节省空间。<br>  VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。<br>  VARCHAR存储的内容超出设置的长度时，内容会被截断。<br>  CHAR是定长的，根据定义的字符串长度分配足够的空间。<br>  CHAR会根据需要使用空格进行填充方便比较。<br>  CHAR适合存储很短的字符串，或者所有值都接近同一个长度。<br>  CHAR存储的内容超出设置的长度时，内容同样会被截断。</p><p>  <strong>使用策略：</strong><br>  对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。<br>  对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。<br>  使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。<br>  尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。</p></li><li><p><code>4、枚举类型（ENUM）</code>，把不重复的数据存储为一个预定义的集合。<br>  有时可以使用ENUM代替常用的字符串类型。<br>  ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。<br>  ENUM在内部存储时，其实存的是整数。<br>  尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。<br>  排序是按照内部存储的整数</p></li><li><p><code>5、日期和时间类型</code>，尽量使用timestamp，空间效率高于datetime，<br>  用整数保存时间戳通常不方便处理。<br>  如果需要存储微妙，可以使用bigint存储。<br>  看到这里，这道真题是不是就比较容易回答了。</p></li></ul><h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>引擎</h2><h3 id="MySQL存储引擎MyISAM与InnoDB区别"><a href="#MySQL存储引擎MyISAM与InnoDB区别" class="headerlink" title="MySQL存储引擎MyISAM与InnoDB区别"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>MySQL存储引擎MyISAM与InnoDB区别</h3><p>存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p><p>常用的存储引擎有以下：</p><ul><li>  <strong>Innodb引擎</strong>：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li><li>  <strong>MyIASM引擎</strong>(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</li><li>  <strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li></ul><p><strong>MyISAM与InnoDB区别</strong></p><table><thead><tr><th></th><th>MyISAM</th><th>Innodb</th></tr></thead><tbody><tr><td>存储结构</td><td>每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td><td>所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td></tr><tr><td>存储空间</td><td>MyISAM可被压缩，存储空间较小</td><td>InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td></tr><tr><td>可移植性、备份及恢复</td><td>由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td><td>免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了</td></tr><tr><td>文件格式</td><td>数据和索引是分别存储的，数据<code>.MYD</code>，索引<code>.MYI</code></td><td>数据和索引是集中存储的，<code>.ibd</code></td></tr><tr><td>记录存储顺序</td><td>按记录插入顺序保存</td><td>按主键大小有序插入</td></tr><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td><td>表级锁定</td><td>行级锁定、表级锁定，锁定力度小并发能力高</td></tr><tr><td>SELECT</td><td>MyISAM更优</td><td></td></tr><tr><td>INSERT、UPDATE、DELETE</td><td></td><td>InnoDB更优</td></tr><tr><td>select count(*)</td><td>myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td><td></td></tr><tr><td>索引的实现方式</td><td>B+树索引，myisam 是堆表</td><td>B+树索引，Innodb 是索引组织表</td></tr><tr><td>哈希索引</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr></tbody></table><h3 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>MyISAM索引与InnoDB索引的区别？</h3><ul><li>  InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li><li>  InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li><li>  MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li><li>  InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li></ul><h3 id="InnoDB引擎的4大特性"><a href="#InnoDB引擎的4大特性" class="headerlink" title="InnoDB引擎的4大特性"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>InnoDB引擎的4大特性</h3><ul><li><p>  插入缓冲（insert buffer)</p></li><li><p>  二次写(double write)</p></li><li><p>  自适应哈希索引(ahi)</p></li><li><p>  预读(read ahead)</p></li></ul><h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>存储引擎选择</h3><p>如果没有特别的需求，使用默认的<code>Innodb</code>即可。</p><p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p><p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>索引</h2><h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是索引？</h3><p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p><p>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p><p>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</p><h3 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>索引有哪些优缺点？</h3><p>索引的优点</p><ul><li>  可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>  通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ul><p>索引的缺点</p><ul><li>  时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li><li>  空间方面：索引需要占物理空间。</li></ul><h3 id="索引使用场景（重点）"><a href="#索引使用场景（重点）" class="headerlink" title="索引使用场景（重点）"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>索引使用场景（重点）</h3><p>where</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzE5LzE2OTA0NTk2ZTFiNTU4YjI?x-oss-process=image/format,png" alt="img"></p><p>上图中，根据<code>id</code>查询记录，因为<code>id</code>字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。</p><pre><code>-- 增加一个没有建立索引的字段alter table innodb1 add sex char(1);-- 按sex检索时可选的索引为nullEXPLAIN SELECT * from innodb1 where sex=&#39;男&#39;;</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzE5LzE2OTA0NTk2Zjk1YTdmOTk?x-oss-process=image/format,png" alt="img"></p><blockquote><p>可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（<code>alter table 表名 add index(字段名)</code>），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。</p></blockquote><p>order by</p><p>当我们使用<code>order by</code>将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。</p><p>但是如果我们对该字段建立索引<code>alter table 表名 add index(字段名)</code>，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用<strong>取出索引表某个范围内的索引对应的数据</strong>，而不用像上述那<strong>取出所有数据</strong>进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）</p><p>join</p><blockquote><p>对<code>join</code>语句匹配关系（<code>on</code>）涉及的字段建立索引能够提高效率</p></blockquote><p>索引覆盖</p><p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在<code>select</code>后只写必要的查询字段，以增加索引覆盖的几率。</p><p>这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。</p><h3 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>索引有哪几种类型？</h3><p><strong>主键索引:</strong> 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p><p><strong>唯一索引:</strong> 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p><ul><li><p>  可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column);</code> 创建唯一索引</p></li><li><p>  可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column1,column2);</code> 创建唯一组合索引</p></li></ul><p><strong>普通索引:</strong> 基本的索引类型，没有唯一性的限制，允许为NULL值。</p><ul><li><p>  可以通过<code>ALTER TABLE table_name ADD INDEX index_name (column);</code>创建普通索引</p></li><li><p>  可以通过<code>ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);</code>创建组合索引</p></li></ul><p><strong>全文索引：</strong> 是目前搜索引擎使用的一种关键技术。</p><ul><li>  可以通过<code>ALTER TABLE table_name ADD FULLTEXT (column);</code>创建全文索引</li></ul><h3 id="索引的数据结构（b树，hash）"><a href="#索引的数据结构（b树，hash）" class="headerlink" title="索引的数据结构（b树，hash）"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>索引的数据结构（b树，hash）</h3><p>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有<strong>Hash索引</strong>，<strong>B+树索引</strong>等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p><p>1）B树索引</p><p>mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzI0LzE2NjBjMGYxNGRhY2Y2ZjU?x-oss-process=image/format,png" alt="img"></p><p>查询方式：</p><p>主键索引区:PI(关联保存的时数据的地址)按主键查询,</p><p>普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快</p><p>B+tree性质：</p><p>1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</p><p>2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p>3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</p><p>4.）B+ 树中，数据对象的插入和删除仅在叶节点上进行。</p><p>5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p><p>2）哈希索引</p><p>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzI0LzE2NjBjMGYxNThhNzZmOTQ?x-oss-process=image/format,png" alt="img"></p><h3 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>索引的基本原理</h3><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p><p>索引的原理很简单，就是把无序的数据变成有序的查询</p><ol><li><p> 把创建了索引的列的内容进行排序</p></li><li><p> 对排序结果生成倒排表</p></li><li><p> 在倒排表内容上拼上数据地址链</p></li><li><p> 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</p></li></ol><h3 id="索引算法有哪些？"><a href="#索引算法有哪些？" class="headerlink" title="索引算法有哪些？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>索引算法有哪些？</h3><p>索引算法有 BTree算法和Hash算法</p><p><strong>BTree算法</strong></p><p>BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：</p><pre><code>-- 只要它的查询条件是一个不以通配符开头的常量select * from user where name like &#39;jack%&#39;; -- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： select * from user where name like &#39;%jack&#39;; </code></pre><p><strong>Hash算法</strong></p><p>Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</p><h3 id="索引设计的原则？"><a href="#索引设计的原则？" class="headerlink" title="索引设计的原则？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>索引设计的原则？</h3><ol><li> 适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li><li> 基数较小的类，索引效果较差，没有必要在此列建立索引</li><li> 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li><li> 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li></ol><h3 id="创建索引的原则（重中之重）"><a href="#创建索引的原则（重中之重）" class="headerlink" title="创建索引的原则（重中之重）"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>创建索引的原则（重中之重）</h3><p>索引虽好，但也不是无限制的使用，最好符合一下几个原则</p><p>1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>2）较频繁作为查询条件的字段才去创建索引</p><p>3）更新频繁字段不适合创建索引</p><p>4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</p><p>5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p><p>6）定义有外键的数据列一定要建立索引。</p><p>7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p><p>8）对于定义为text、image和bit的数据类型的列不要建立索引。</p><h3 id="创建索引的三种方式，删除索引"><a href="#创建索引的三种方式，删除索引" class="headerlink" title="创建索引的三种方式，删除索引"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>创建索引的三种方式，删除索引</h3><p>第一种方式：在执行CREATE TABLE时创建索引</p><pre><code>CREATE TABLE user_index2 (    id INT auto_increment PRIMARY KEY,    first_name VARCHAR (16),    last_name VARCHAR (16),    id_card VARCHAR (18),    information text,    KEY name (first_name, last_name),    FULLTEXT KEY (information),    UNIQUE KEY (id_card));</code></pre><p>第二种方式：使用ALTER TABLE命令去增加索引</p><pre><code>ALTER TABLE table_name ADD INDEX index_name (column_list);</code></pre><p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p><p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p><p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p><p>第三种方式：使用CREATE INDEX命令创建</p><pre><code>CREATE INDEX index_name ON table_name (column_list);</code></pre><p>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p><p>删除索引</p><p>根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code></p><pre><code>alter table user_index drop KEY name;alter table user_index drop KEY id_card;alter table user_index drop KEY information;</code></pre><p>删除主键索引：<code>alter table 表名 drop primary key</code>（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzE5LzE2OTA0NTk2YjIxZTIwOWM?x-oss-process=image/format,png" alt="img"></p><p>需要取消自增长再行删除：</p><pre><code>alter table user_index-- 重新定义字段MODIFY id int,drop PRIMARY KEY</code></pre><p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p><h3 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>创建索引时需要注意什么？</h3><ul><li>  非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li><li>  取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li><li>  索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li></ul><h3 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>使用索引查询一定能提高查询的性能吗？为什么</h3><p>通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</p><ul><li>  索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</li><li>  基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li><li>  基于非唯一性索引的检索</li></ul><h3 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>百万级别或以上的数据如何删除</h3><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p><ol><li> 所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li><li> 然后删除其中无用数据（此过程需要不到两分钟）</li><li> 删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li><li> 与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li></ol><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>前缀索引</h3><p>语法：<code>index(field(10))</code>，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</p><p>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p><p>实操的难度：在于前缀截取的长度。</p><p>我们可以利用<code>select count(*)/count(distinct left(password,prefixLen));</code>，通过从调整<code>prefixLen</code>的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前<code>prefixLen</code>个字符几乎能确定唯一一条记录）</p><h3 id="什么是最左前缀原则？什么是最左匹配原则"><a href="#什么是最左前缀原则？什么是最左匹配原则" class="headerlink" title="什么是最左前缀原则？什么是最左匹配原则"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是最左前缀原则？什么是最左匹配原则</h3><ul><li>  顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li><li>  最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li>  =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li></ul><h3 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>B树和B+树的区别</h3><ul><li><p>  在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</p></li><li><p>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</p><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzIxLzE2NWZiNjgyZTc1OWNmMTI?x-oss-process=image/format,png" alt="img"></p></li></ul><h3 id="使用B树的好处"><a href="#使用B树的好处" class="headerlink" title="使用B树的好处"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>使用B树的好处</h3><p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p><h3 id="使用B-树的好处"><a href="#使用B-树的好处" class="headerlink" title="使用B+树的好处"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>使用B+树的好处</h3><p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p><h3 id="Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="Hash索引和B+树所有有什么区别或者说优劣呢?"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>Hash索引和B+树所有有什么区别或者说优劣呢?</h3><p>首先要知道Hash索引和B+树索引的底层实现原理：</p><p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</p><p>那么可以看出他们有以下的不同：</p><ul><li>  hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</li></ul><p>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p><ul><li>  hash索引不支持使用索引进行排序，原理同上。</li><li>  hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。</li><li>  hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</li><li>  hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</li></ul><p>因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。</p><h3 id="数据库为什么使用B-树而不是B树"><a href="#数据库为什么使用B-树而不是B树" class="headerlink" title="数据库为什么使用B+树而不是B树"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>数据库为什么使用B+树而不是B树</h3><ul><li>  B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</li><li>  B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</li><li>  B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li><li>  B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</li><li>  增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</li></ul><h3 id="B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，"><a href="#B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，" class="headerlink" title="B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，</h3><p>在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p><p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p><h3 id="什么是聚簇索引？何时使用聚簇索引与非聚簇索引"><a href="#什么是聚簇索引？何时使用聚簇索引与非聚簇索引" class="headerlink" title="什么是聚簇索引？何时使用聚簇索引与非聚簇索引"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是聚簇索引？何时使用聚簇索引与非聚簇索引</h3><ul><li>  聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li><li>  非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</li></ul><p>澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p><p>何时使用聚簇索引与非聚簇索引</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDE1NDQ5OS1kNTNhNWNlOWNlY2YyMmYzLnBuZw?x-oss-process=image/format,png" alt="img"></p><h3 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>非聚簇索引一定会回表查询吗？</h3><p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</p><p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行<code>select age from employee where age &lt; 20</code>的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p><h3 id="联合索引是什么？为什么需要注意联合索引中的顺序？"><a href="#联合索引是什么？为什么需要注意联合索引中的顺序？" class="headerlink" title="联合索引是什么？为什么需要注意联合索引中的顺序？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>联合索引是什么？为什么需要注意联合索引中的顺序？</h3><p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p><p>具体原因为:</p><p>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p><p>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>事务</h2><h3 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是数据库事务？</h3><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>事务最经典也经常被拿出来说例子就是转账了。</p><p>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><h3 id="事物的四大特性-ACID-介绍一下"><a href="#事物的四大特性-ACID-介绍一下" class="headerlink" title="事物的四大特性(ACID)介绍一下?"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>事物的四大特性(ACID)介绍一下?</h3><p>关系性数据库需要遵循ACID规则，具体内容如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzIwLzE2MzdiMDhiOTg2MTk0NTU?x-oss-process=image/format,png" alt="事务的特性"></p><ol><li> <strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li> <strong>一致性：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li><li> <strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li> <strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><h3 id="什么是脏读？幻读？不可重复读？"><a href="#什么是脏读？幻读？不可重复读？" class="headerlink" title="什么是脏读？幻读？不可重复读？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是脏读？幻读？不可重复读？</h3><ul><li>  脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li><li>  不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li><li>  幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li></ul><h3 id="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"><a href="#什么是事务的隔离级别？MySQL的默认隔离级别是什么？" class="headerlink" title="什么是事务的隔离级别？MySQL的默认隔离级别是什么？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h3><p>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻影读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><p><strong>SQL 标准定义了四个隔离级别：</strong></p><ul><li>  <strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li>  <strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li>  <strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li>  <strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><p>这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</p><p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是*<em>READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 \</em>*REPEATABLE-READ（可重读）**并不会有任何性能损失。</p><p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>锁</h2><h3 id="对MySQL的锁了解吗"><a href="#对MySQL的锁了解吗" class="headerlink" title="对MySQL的锁了解吗"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>对MySQL的锁了解吗</h3><p>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。</p><p>就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。</p><h3 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>隔离级别与锁的关系</h3><p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p><p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p><p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p><p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别<strong>锁定整个范围的键</strong>，并一直持有锁，直到事务完成。</p><h3 id="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"><a href="#按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法" class="headerlink" title="按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</h3><p>在关系型数据库中，可以<strong>按照锁的粒度把数据库锁分</strong>为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p><p><strong>MyISAM和InnoDB存储引擎使用的锁：</strong></p><ul><li>  MyISAM采用表级锁(table-level locking)。</li><li>  InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</li></ul><p>行级锁，表级锁和页级锁对比</p><p><strong>行级锁</strong> 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p><p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p><p><strong>表级锁</strong> 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p><p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p><p><strong>页级锁</strong> 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p><p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p><h3 id="从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了"><a href="#从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了" class="headerlink" title="从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了</h3><p><strong>从锁的类别上来讲</strong>，有共享锁和排他锁。</p><p>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p><p>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p><p>用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。</p><p>锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。</p><p>他们的加锁开销从大到小，并发能力也是从大到小。</p><h3 id="MySQL中InnoDB引擎的行锁是怎么实现的？"><a href="#MySQL中InnoDB引擎的行锁是怎么实现的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是怎么实现的？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>MySQL中InnoDB引擎的行锁是怎么实现的？</h3><p>答：InnoDB是基于索引来完成行锁</p><p>例: select * from tab_with_index where id = 1 for update;</p><p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起</p><h3 id="InnoDB存储引擎的锁的算法有三种"><a href="#InnoDB存储引擎的锁的算法有三种" class="headerlink" title="InnoDB存储引擎的锁的算法有三种"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>InnoDB存储引擎的锁的算法有三种</h3><ul><li>  Record lock：单个行记录上的锁</li><li>  Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li>  Next-key lock：record+gap 锁定一个范围，包含记录本身</li></ul><p><strong>相关知识点：</strong></p><ol><li> innodb对于行的查询使用next-key lock</li><li> Next-locking keying为了解决Phantom Problem幻读问题</li><li> 当查询的索引含有唯一属性时，将next-key lock降级为record key</li><li> Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li><li> 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li></ol><h3 id="什么是死锁？怎么解决？"><a href="#什么是死锁？怎么解决？" class="headerlink" title="什么是死锁？怎么解决？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是死锁？怎么解决？</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><p>常见的解决死锁的方法</p><p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p><p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p><p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p><p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p><h3 id="数据库的乐观锁和悲观锁是什么？怎么实现的？"><a href="#数据库的乐观锁和悲观锁是什么？怎么实现的？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？怎么实现的？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h3><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p><p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p><p><strong>两种锁的使用场景</strong></p><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p><p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>视图</h2><h3 id="为什么要使用视图？什么是视图？"><a href="#为什么要使用视图？什么是视图？" class="headerlink" title="为什么要使用视图？什么是视图？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>为什么要使用视图？什么是视图？</h3><p>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</p><p>视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。</p><h3 id="视图有哪些特点？"><a href="#视图有哪些特点？" class="headerlink" title="视图有哪些特点？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>视图有哪些特点？</h3><p>视图的特点如下:</p><ul><li><p>  视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</p></li><li><p>  视图是由基本表(实表)产生的表(虚表)。</p></li><li><p>  视图的建立和删除不影响基本表。</p></li><li><p>  对视图内容的更新(添加，删除和修改)直接影响基本表。</p></li><li><p>  当视图来自多个基本表时，不允许添加和删除数据。</p></li></ul><p>视图的操作包括创建视图，查看视图，删除视图和修改视图。</p><h3 id="视图的使用场景有哪些？"><a href="#视图的使用场景有哪些？" class="headerlink" title="视图的使用场景有哪些？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>视图的使用场景有哪些？</h3><p>视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。</p><p>下面是视图的常见使用场景：</p><ul><li><p>  重用SQL语句；</p></li><li><p>  简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</p></li><li><p>  使用表的组成部分而不是整个表；</p></li><li><p>  保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</p></li><li><p>  更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</p></li></ul><h3 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>视图的优点</h3><ol><li> 查询简单化。视图能简化用户的操作</li><li> 数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li><li> 逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li></ol><h3 id="视图的缺点"><a href="#视图的缺点" class="headerlink" title="视图的缺点"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>视图的缺点</h3><ol><li><p> 性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</p></li><li><p>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的</p><p> 这些视图有如下特征：1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\SUM\MAX等聚合函数的视图。 4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外）</p></li></ol><h3 id="什么是游标？"><a href="#什么是游标？" class="headerlink" title="什么是游标？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是游标？</h3><p>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</p><h2 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>存储过程与函数</h2><h3 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是存储过程？有哪些优缺点？</h3><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p><p><strong>优点</strong></p><p>1）存储过程是预编译过的，执行效率高。</p><p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p><p>3）安全性高，执行存储过程需要有一定权限的用户。</p><p>4）存储过程可以重复使用，减少数据库开发人员的工作量。</p><p><strong>缺点</strong></p><p>1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</p><p>2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p><p>3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p><p>4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>触发器</h2><h3 id="什么是触发器？触发器的使用场景有哪些？"><a href="#什么是触发器？触发器的使用场景有哪些？" class="headerlink" title="什么是触发器？触发器的使用场景有哪些？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是触发器？触发器的使用场景有哪些？</h3><p>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</p><p>使用场景</p><ul><li>  可以通过数据库中的相关表实现级联更改。</li><li>  实时监控某张表中的某个字段的更改而需要做出相应的处理。</li><li>  例如可以生成某些业务的编号。</li><li>  注意不要滥用，否则会造成数据库及应用程序的维护困难。</li><li>  大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。</li></ul><h3 id="MySQL中都有哪些触发器？"><a href="#MySQL中都有哪些触发器？" class="headerlink" title="MySQL中都有哪些触发器？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>MySQL中都有哪些触发器？</h3><p>在MySQL数据库中有如下六种触发器：</p><ul><li>  Before Insert</li><li>  After Insert</li><li>  Before Update</li><li>  After Update</li><li>  Before Delete</li><li>  After Delete</li></ul><h2 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>常用SQL语句</h2><h3 id="SQL语句主要分为哪几类"><a href="#SQL语句主要分为哪几类" class="headerlink" title="SQL语句主要分为哪几类"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>SQL语句主要分为哪几类</h3><p>数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER</p><p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p><p>数据查询语言DQL（Data Query Language）SELECT</p><p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p><p>数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE</p><p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p><p>数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p><p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p><h3 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>超键、候选键、主键、外键分别是什么？</h3><ul><li>  超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li>  候选键：是最小超键，即没有冗余元素的超键。</li><li>  主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li><li>  外键：在一个表中存在的另一个表的主键称此表的外键。</li></ul><h3 id="SQL-约束有哪几种？"><a href="#SQL-约束有哪几种？" class="headerlink" title="SQL 约束有哪几种？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>SQL 约束有哪几种？</h3><blockquote><p>SQL 约束有哪几种？</p></blockquote><ul><li>  NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li><li>  UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li><li>  PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li><li>  FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li><li>  CHECK: 用于控制字段的值范围。</li></ul><h3 id="六种关联查询"><a href="#六种关联查询" class="headerlink" title="六种关联查询"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>六种关联查询</h3><ul><li>  交叉连接（CROSS JOIN）</li><li>  内连接（INNER JOIN）</li><li>  外连接（LEFT JOIN/RIGHT JOIN）</li><li>  联合查询（UNION与UNION ALL）</li><li>  全连接（FULL JOIN）</li><li>  交叉连接（CROSS JOIN）</li></ul><pre><code>SELECT * FROM A,B(,C)或者SELECT * FROM A CROSS JOIN B (CROSS JOIN C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER JOIN）SELECT * FROM A,B WHERE A.id=B.id或者SELECT * FROM A INNER JOIN B ON A.id=B.id多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN</code></pre><p>内连接分为三类</p><ul><li>  等值连接：ON A.id=B.id</li><li>  不等值连接：ON A.id &gt; B.id</li><li>  自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid</li></ul><p>外连接（LEFT JOIN/RIGHT JOIN）</p><ul><li>  左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN</li><li>  右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</li></ul><p>联合查询（UNION与UNION ALL）</p><pre><code>SELECT * FROM A UNION SELECT * FROM B UNION ...</code></pre><ul><li>  就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并</li><li>  如果使用UNION ALL，不会合并重复的记录行</li><li>  效率 UNION 高于 UNION ALL</li></ul><p>全连接（FULL JOIN）</p><ul><li>  MySQL不支持全连接</li><li>  可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</li></ul><pre><code>SELECT * FROM A LEFT JOIN B ON A.id=B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id=B.id</code></pre><p>表连接面试题</p><p>有2张表，1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录。</p><p>R表</p><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td></tr></tbody></table><p>S表</p><table><thead><tr><th>C</th><th>D</th></tr></thead><tbody><tr><td>c1</td><td>d1</td></tr><tr><td>c2</td><td>d2</td></tr><tr><td>c4</td><td>d3</td></tr></tbody></table><ol><li> 交叉连接(笛卡尔积):</li></ol><p>select r.<code>*</code>,s.<code>*</code> from r,s</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c1</td><td>d1</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td>c1</td><td>d1</td></tr><tr><td>a1</td><td>b1</td><td>c1</td><td>c2</td><td>d2</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td>c2</td><td>d2</td></tr><tr><td>a1</td><td>b1</td><td>c1</td><td>c4</td><td>d3</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c4</td><td>d3</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td>c4</td><td>d3</td></tr></tbody></table><ol start="2"><li><p>内连接结果：</p><p> select r.<code>*</code>,s.<code>*</code> from r inner join s on r.c=s.c</p></li></ol><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr></tbody></table><ol start="3"><li><p>左连接结果：</p><p> select r.<code>*</code>,s.<code>*</code> from r left join s on r.c=s.c</p></li></ol><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td></td><td></td></tr></tbody></table><ol start="4"><li><p>右连接结果：</p><p> select r.<code>*</code>,s.<code>*</code> from r right join s on r.c=s.c</p></li></ol><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>A</td><td>B</td><td>C</td><td>C</td><td>D</td></tr><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td></td><td></td><td></td><td>c4</td><td>d3</td></tr></tbody></table><ol start="5"><li><p>全表连接的结果（MySql不支持，Oracle支持）：</p><p> select r.<code>*</code>,s.<code>*</code> from r full join s on r.c=s.c</p></li></ol><table><thead><tr><th>A</th><th>B</th><th>C</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c1</td><td>c1</td><td>d1</td></tr><tr><td>a2</td><td>b2</td><td>c2</td><td>c2</td><td>d2</td></tr><tr><td>a3</td><td>b3</td><td>c3</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>c4</td><td>d3</td></tr></tbody></table><h3 id="什么是子查询"><a href="#什么是子查询" class="headerlink" title="什么是子查询"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>什么是子查询</h3><ol><li><p> 条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果</p></li><li><p> 嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。</p></li></ol><h3 id="子查询的三种情况"><a href="#子查询的三种情况" class="headerlink" title="子查询的三种情况"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>子查询的三种情况</h3><ol><li> 子查询是单行单列的情况：结果集是一个值，父查询使用：=、 &lt;、 &gt; 等运算符</li></ol><pre><code>-- 查询工资最高的员工是谁？ select  * from employee where salary=(select max(salary) from employee);   </code></pre><ol start="2"><li> 子查询是多行单列的情况：结果集类似于一个数组，父查询使用：in 运算符</li></ol><pre><code>-- 查询工资最高的员工是谁？ select  * from employee where salary=(select max(salary) from employee);    </code></pre><ol start="3"><li> 子查询是多行多列的情况：结果集类似于一张虚拟表，不能用于where条件，用于select子句中做为子表</li></ol><pre><code>-- 1) 查询出2011年以后入职的员工信息-- 2) 查询所有的部门信息，与上面的虚拟表中的信息比对，找出所有部门ID相等的员工。select * from dept d,  (select * from employee where join_date &gt; &#39;2011-1-1&#39;) e where e.dept_id =  d.id;    -- 使用表连接：select d.*, e.* from  dept d inner join employee e on d.id = e.dept_id where e.join_date &gt;  &#39;2011-1-1&#39;  </code></pre><h3 id="mysql中-in-和-exists-区别"><a href="#mysql中-in-和-exists-区别" class="headerlink" title="mysql中 in 和 exists 区别"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>mysql中 in 和 exists 区别</h3><p>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p><ol><li> 如果查询的两个表大小相当，那么用in和exists差别不大。</li><li> 如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</li><li> not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</li></ol><h3 id="varchar与char的区别"><a href="#varchar与char的区别" class="headerlink" title="varchar与char的区别"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>varchar与char的区别</h3><p><strong>char的特点</strong></p><ul><li><p>  char表示定长字符串，长度是固定的；</p></li><li><p>  如果插入数据的长度小于char的固定长度时，则用空格填充；</p></li><li><p>  因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</p></li><li><p>  对于char来说，最多能存放的字符个数为255，和编码无关</p></li></ul><p><strong>varchar的特点</strong></p><ul><li><p>  varchar表示可变长字符串，长度是可变的；</p></li><li><p>  插入的数据是多长，就按照多长来存储；</p></li><li><p>  varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</p></li><li><p>  对于varchar来说，最多能存放的字符个数为65532</p></li></ul><p>总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。</p><h3 id="varchar-50-中50的涵义"><a href="#varchar-50-中50的涵义" class="headerlink" title="varchar(50)中50的涵义"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>varchar(50)中50的涵义</h3><p>最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。</p><h3 id="int-20-中20的涵义"><a href="#int-20-中20的涵义" class="headerlink" title="int(20)中20的涵义"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>int(20)中20的涵义</h3><p>是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；</p><p>不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</p><h3 id="mysql为什么这么设计"><a href="#mysql为什么这么设计" class="headerlink" title="mysql为什么这么设计"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>mysql为什么这么设计</h3><p>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；</p><h3 id="mysql中int-10-和char-10-以及varchar-10-的区别"><a href="#mysql中int-10-和char-10-以及varchar-10-的区别" class="headerlink" title="mysql中int(10)和char(10)以及varchar(10)的区别"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>mysql中int(10)和char(10)以及varchar(10)的区别</h3><ul><li><p>int(10)的10表示显示的数据的长度，不是存储数据的大小；chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。</p><p>  int(10) 10位的数据长度 9999999999，占32个字节，int型4位<br>  char(10) 10位固定字符串，不足补空格 最多10个字符<br>  varchar(10) 10位可变字符串，不足补空格 最多10个字符</p></li><li><p>  char(10)表示存储定长的10个字符，不足10个就用空格补齐，占用更多的存储空间</p></li><li><p>  varchar(10)表示存储10个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符</p></li></ul><h3 id="FLOAT和DOUBLE的区别是什么？"><a href="#FLOAT和DOUBLE的区别是什么？" class="headerlink" title="FLOAT和DOUBLE的区别是什么？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>FLOAT和DOUBLE的区别是什么？</h3><ul><li>  FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。</li><li>  DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。</li></ul><h3 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>drop、delete与truncate的区别</h3><p>三者都表示删除，但是三者有一些差别：</p><table><thead><tr><th align="center"></th><th align="center">Delete</th><th align="center">Truncate</th><th align="center">Drop</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">属于DML</td><td align="center">属于DDL</td><td align="center">属于DDL</td></tr><tr><td align="center">回滚</td><td align="center">可回滚</td><td align="center">不可回滚</td><td align="center">不可回滚</td></tr><tr><td align="center">删除内容</td><td align="center">表结构还在，删除表的全部或者一部分数据行</td><td align="center">表结构还在，删除表中的所有数据</td><td align="center">从数据库中删除表，所有的数据行，索引和权限也会被删除</td></tr><tr><td align="center">删除速度</td><td align="center">删除速度慢，需要逐行删除</td><td align="center">删除速度快</td><td align="center">删除速度最快</td></tr></tbody></table><p>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p><h3 id="UNION与UNION-ALL的区别？"><a href="#UNION与UNION-ALL的区别？" class="headerlink" title="UNION与UNION ALL的区别？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>UNION与UNION ALL的区别？</h3><ul><li>  如果使用UNION ALL，不会合并重复的记录行</li><li>  效率 UNION 高于 UNION ALL</li></ul><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>SQL优化</h2><h3 id="如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？"><a href="#如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？" class="headerlink" title="如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</h3><p>对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，<strong>对于查询语句，最重要的优化方式就是使用索引</strong>。 而<strong>执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20200310171131582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>执行计划包含的信息 <strong>id</strong> 有一组数字组成。表示一个查询中各个子查询的执行顺序;</p><ul><li>  id相同执行顺序由上至下。</li><li>  id不同，id值越大优先级越高，越先被执行。</li><li>  id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。</li></ul><p><strong>select_type</strong> 每个子查询的查询类型，一些常见的查询类型。</p><table><thead><tr><th>id</th><th>select_type</th><th>description</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>不包含任何子查询或union等查询</td></tr><tr><td>2</td><td>PRIMARY</td><td>包含子查询最外层查询就显示为 PRIMARY</td></tr><tr><td>3</td><td>SUBQUERY</td><td>在select或 where字句中包含的查询</td></tr><tr><td>4</td><td>DERIVED</td><td>from字句中包含的查询</td></tr><tr><td>5</td><td>UNION</td><td>出现在union后的查询语句中</td></tr><tr><td>6</td><td>UNION RESULT</td><td>从UNION中获取结果集，例如上文的第三个例子</td></tr></tbody></table><p><strong>table</strong> 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划id <strong>partitions</strong> 表分区、表创建的时候可以指定通过那个列进行表分区。 举个例子：</p><pre><code>create table tmp (    id int unsigned not null AUTO_INCREMENT,    name varchar(255),    PRIMARY KEY (id)) engine = innodbpartition by key (id) partitions 5;</code></pre><p><strong>type</strong>(非常重要，可以看到有没有走索引) 访问类型</p><ul><li>  ALL 扫描全表数据</li><li>  index 遍历索引</li><li>  range 索引范围查找</li><li>  index_subquery 在子查询中使用 ref</li><li>  unique_subquery 在子查询中使用 eq_ref</li><li>  ref_or_null 对Null进行索引的优化的 ref</li><li>  fulltext 使用全文索引</li><li>  ref 使用非唯一索引查找数据</li><li>  eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。</li></ul><p><strong>possible_keys</strong> 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。</p><p><strong>key</strong> 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。</p><p><strong>TIPS</strong>:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中</p><p><strong>key_length</strong> 索引长度</p><p><strong>ref</strong> 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p><p><strong>rows</strong> 返回估算的结果集数目，并不是一个准确的值。</p><p><strong>extra</strong> 的信息非常丰富，常见的有：</p><ol><li> Using index 使用覆盖索引</li><li> Using where 使用了用where子句来过滤结果集</li><li> Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。</li><li> Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册</li></ol><pre><code>【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。 说明： 1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 2） ref 指的是使用普通的索引（normal index）。 3） range 对索引进行范围检索。 反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。</code></pre><h3 id="SQL的生命周期？"><a href="#SQL的生命周期？" class="headerlink" title="SQL的生命周期？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>SQL的生命周期？</h3><ol><li><p> 应用服务器与数据库服务器建立一个连接</p></li><li><p> 数据库进程拿到请求sql</p></li><li><p> 解析并生成执行计划，执行</p></li><li><p> 读取数据到内存并进行逻辑处理</p></li><li><p> 通过步骤一的连接，发送结果到客户端</p></li><li><p>关掉连接，释放资源</p><p> <img src="https://img-blog.csdnimg.cn/20200310170936478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol><h3 id="大表数据查询，怎么优化"><a href="#大表数据查询，怎么优化" class="headerlink" title="大表数据查询，怎么优化"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>大表数据查询，怎么优化</h3><ol><li> 优化shema、sql语句+索引；</li><li> 第二加缓存，memcached, redis；</li><li> 主从复制，读写分离；</li><li> 垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li><li> 水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</li></ol><h3 id="超大分页怎么处理？"><a href="#超大分页怎么处理？" class="headerlink" title="超大分页怎么处理？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>超大分页怎么处理？</h3><p>超大的分页一般从两个方向上来解决.</p><ul><li>  数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于<code>select * from table where age &gt; 20 limit 1000000,10</code>这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为<code>select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</code>.这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以<code>select * from table where id &gt; 1000000 limit 10</code>,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</li><li>  从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li></ul><p>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.</p><p>在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.</p><pre><code>【推荐】利用延迟关联或者子查询优化超多分页场景。 说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 正例：先快速定位需要获取的id段，然后再关联： SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</code></pre><h3 id="mysql-分页"><a href="#mysql-分页" class="headerlink" title="mysql 分页"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>mysql 分页</h3><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)</p><pre><code>mysql&gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 </code></pre><p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</p><pre><code>mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. </code></pre><p>如果只给定一个参数，它表示返回最大的记录行数目：</p><pre><code>mysql&gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行 </code></pre><p>换句话说，LIMIT n 等价于 LIMIT 0,n。</p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>慢查询日志</h3><blockquote><p>用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。</p></blockquote><p>开启慢查询日志</p><p>配置项：<code>slow_query_log</code></p><p>可以使用<code>show variables like ‘slov_query_log’</code>查看是否开启，如果状态值为<code>OFF</code>，可以使用<code>set GLOBAL slow_query_log = on</code>来开启，它会在<code>datadir</code>下产生一个<code>xxx-slow.log</code>的文件。</p><p>设置临界时间</p><p>配置项：<code>long_query_time</code></p><p>查看：<code>show VARIABLES like &#39;long_query_time&#39;</code>，单位秒</p><p>设置：<code>set long_query_time=0.5</code></p><p>实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉</p><p>查看日志，一旦SQL超过了我们设置的临界时间就会被记录到<code>xxx-slow.log</code>中</p><h3 id="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"><a href="#关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？" class="headerlink" title="关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h3><p>在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。</p><p>慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？</p><p>所以优化也是针对这三个方向来的，</p><ul><li>  首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li><li>  分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li><li>  如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li></ul><h3 id="为什么要尽量设定一个主键？"><a href="#为什么要尽量设定一个主键？" class="headerlink" title="为什么要尽量设定一个主键？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>为什么要尽量设定一个主键？</h3><p>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p><h3 id="主键使用自增ID还是UUID？"><a href="#主键使用自增ID还是UUID？" class="headerlink" title="主键使用自增ID还是UUID？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>主键使用自增ID还是UUID？</h3><p>推荐使用自增ID，不要使用UUID。</p><p>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</p><p>总之，在数据量大一些的情况下，用自增主键性能会好一些。</p><p>关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</p><h3 id="字段为什么要求定义为not-null？"><a href="#字段为什么要求定义为not-null？" class="headerlink" title="字段为什么要求定义为not null？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>字段为什么要求定义为not null？</h3><p>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</p><h3 id="如果要存储用户的密码散列，应该使用什么字段进行存储？"><a href="#如果要存储用户的密码散列，应该使用什么字段进行存储？" class="headerlink" title="如果要存储用户的密码散列，应该使用什么字段进行存储？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>如果要存储用户的密码散列，应该使用什么字段进行存储？</h3><p>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</p><h3 id="优化查询过程中的数据访问"><a href="#优化查询过程中的数据访问" class="headerlink" title="优化查询过程中的数据访问"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>优化查询过程中的数据访问</h3><ul><li>  访问数据太多导致查询性能下降</li><li>  确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</li><li>  确认MySQL服务器是否在分析大量不必要的数据行</li><li>  避免犯如下SQL语句错误</li><li>  查询不需要的数据。解决办法：使用limit解决</li><li>  多表关联返回全部列。解决办法：指定列名</li><li>  总是返回全部列。解决办法：避免使用SELECT *</li><li>  重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</li><li>  是否在扫描额外的记录。解决办法：</li><li>  使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：</li><li>  使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</li><li>  改变数据库和表的结构，修改数据表范式</li><li>  重写SQL语句，让优化器可以以更优的方式执行查询。</li></ul><h3 id="优化长难的查询语句"><a href="#优化长难的查询语句" class="headerlink" title="优化长难的查询语句"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>优化长难的查询语句</h3><ul><li>  一个复杂查询还是多个简单查询</li><li>  MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多</li><li>  使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。</li><li>  切分查询</li><li>  将一个大的查询分为多个小的相同的查询</li><li>  一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。</li><li>  分解关联查询，让缓存的效率更高。</li><li>  执行单个查询可以减少锁的竞争。</li><li>  在应用层做关联更容易对数据库进行拆分。</li><li>  查询效率会有大幅提升。</li><li>  较少冗余记录的查询。</li></ul><h3 id="优化特定类型的查询语句"><a href="#优化特定类型的查询语句" class="headerlink" title="优化特定类型的查询语句"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>优化特定类型的查询语句</h3><ul><li>  count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)</li><li>  MyISAM中，没有任何where条件的count(*)非常快。</li><li>  当有where条件时，MyISAM的count统计不一定比其它引擎快。</li><li>  可以使用explain查询近似值，用近似值替代count(*)</li><li>  增加汇总表</li><li>  使用缓存</li></ul><h3 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>优化关联查询</h3><ul><li>  确定ON或者USING子句中是否有索引。</li><li>  确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。</li></ul><h3 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>优化子查询</h3><ul><li>  用关联查询替代</li><li>  优化GROUP BY和DISTINCT</li><li>  这两种查询据可以使用索引来优化，是最有效的优化方法</li><li>  关联查询中，使用标识列分组的效率更高</li><li>  如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。</li><li>  WITH ROLLUP超级聚合，可以挪到应用程序处理</li></ul><h3 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>优化LIMIT分页</h3><ul><li>  LIMIT偏移量大的时候，查询效率较低</li><li>  可以记录上次查询的最大ID，下次查询时直接根据该ID来查询</li></ul><h3 id="优化UNION查询"><a href="#优化UNION查询" class="headerlink" title="优化UNION查询"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>优化UNION查询</h3><ul><li>  UNION ALL的效率高于UNION</li></ul><h3 id="优化WHERE子句"><a href="#优化WHERE子句" class="headerlink" title="优化WHERE子句"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>优化WHERE子句</h3><p>解题方法</p><p>对于此类考题，先说明如何定位低效SQL语句，然后根据SQL语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑以上几个方面，数据访问的问题，长难查询句的问题还是一些特定类型优化的问题，逐一回答。</p><p>SQL语句优化的一些方法？</p><ul><li>  1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li><li>  2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</li></ul><pre><code>select id from t where num is null-- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=</code></pre><ul><li>  3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</li><li>  4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</li></ul><pre><code>select id from t where num=10 or num=20-- 可以这样查询：select id from t where num=10 union all select id from t where num=20</code></pre><ul><li>  5.in 和 not in 也要慎用，否则会导致全表扫描，如：</li></ul><pre><code>select id from t where num in(1,2,3) -- 对于连续的数值，能用 between 就不要用 in 了：select id from t where num between 1 and 3</code></pre><ul><li>  6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</li><li>  7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</li></ul><pre><code>select id from t where num=@num-- 可以改为强制查询使用索引：select id from t with(index(索引名)) where num=@num</code></pre><ul><li>  8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li></ul><pre><code>select id from t where num/2=100-- 应改为:select id from t where num=100*2</code></pre><ul><li>  9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li></ul><pre><code>select id from t where substring(name,1,3)=’abc’-- name以abc开头的id应改为:select id from t where name like ‘abc%’</code></pre><ul><li>  10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li></ul><h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>数据库优化</h2><h3 id="为什么要优化"><a href="#为什么要优化" class="headerlink" title="为什么要优化"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>为什么要优化</h3><ul><li>  系统的吞吐量瓶颈往往出现在数据库的访问速度上</li><li>  随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li><li>  数据是存放在磁盘上的，读写速度无法和内存相比</li></ul><p>优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</p><h3 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>数据库结构优化</h3><p>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</p><p>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p><p><strong>将字段很多的表分解成多个表</strong></p><p>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</p><p>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p><p><strong>增加中间表</strong></p><p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p><p>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</p><p><strong>增加冗余字段</strong></p><p>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</p><p>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p><p><strong>注意：</strong></p><p><strong>冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</strong></p><h3 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h3><p>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</p><p>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</p><p>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</p><p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</p><h3 id="大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？"><a href="#大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？" class="headerlink" title="大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</h3><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><ol><li> <strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</li><li> <strong>读/写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li><li> <strong>缓存：</strong> 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li></ol><p>还有就是通过分库分表的方式进行优化，主要有垂直分表和水平分表</p><ol><li><p><strong>垂直分区：</strong></p><p> <strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p><p> <strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC82LzE2LzE2NDA4NDM1NGJhMmUwZmQ?x-oss-process=image/format,png" alt="img"></p><p> <strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p><p> <strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p><h4 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>垂直分表</h4><p> 把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy90dVNhS2M2U2ZQcjh0NFBaVVFJVUszVHl0aWF3T0VRa2dFZnBCTm4xZkNtdEVhMkRaNTlISFNSaWN2SEIzeU43Yk5LY1hkc3NWZGFNb25TOEFKanY5cFdBLzY0MA?x-oss-process=image/format,png" alt="img"></p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>适用场景</h5><ul><li><p>  1、如果一个表中某些列常用，另外一些列不常用</p></li><li><p>2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>缺点</h5></li><li><p>  有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差</p></li><li><p>  对于应用层来说，逻辑算法增加开发成本</p></li><li><p>  管理冗余列，查询所有数据需要join操作</p></li></ul></li><li><p><strong>水平分区：</strong></p><p> <strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p><p> 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC82LzE2LzE2NDA4NGI3ZTllNDIzZTM?x-oss-process=image/format,png" alt="数据库水平拆分"></p><p> 水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</p><p> 水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨界点Join性能较差，逻辑复杂。</p><p> 《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p><h4 id="水平分表："><a href="#水平分表：" class="headerlink" title="水平分表："></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>水平分表：</h4><p> 表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy90dVNhS2M2U2ZQcjh0NFBaVVFJVUszVHl0aWF3T0VRa2dkQVpyU1Y3M2liMWZkRENYS2M3QUd6Wmhid3FjS0ZVWkpGWThwMFZkVXRPM3JNYzZ2eDFBdzVBLzY0MA?x-oss-process=image/format,png" alt="img"></p><h5 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>适用场景</h5><ul><li><p>  1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。</p></li><li><p>2、需要把数据存放在多个介质上。</p><h5 id="水平切分的缺点"><a href="#水平切分的缺点" class="headerlink" title="水平切分的缺点"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>水平切分的缺点</h5></li><li><p>  1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作</p></li><li><p>  2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</p></li><li><p>*下面补充一下数据库分片的两种常见方案：**</p></li><li><p>  <strong>客户端代理：</strong> <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</p></li><li><p>  <strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</p></li></ul></li></ol><p><strong>分库分表后面临的问题</strong></p><ul><li><p>  <strong>事务支持</strong> 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p></li><li><p><strong>跨库join</strong></p><p>  只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品</p></li><li><p>  <strong>跨节点的count,order by,group by以及聚合函数问题</strong> 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p></li><li><p>  <strong>数据迁移，容量规划，扩容等问题</strong> 来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。</p></li><li><p>  <strong>ID问题</strong></p></li><li><p>  一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由. 一些常见的主键生成策略</p></li></ul><p><strong>UUID</strong> 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 <strong>Twitter的分布式自增ID算法Snowflake</strong> 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</p><ul><li><p>跨分片的排序分页</p><p>  般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p><p>  <img src="https://img-blog.csdnimg.cn/20200310170753848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h3 id="MySQL的复制原理以及流程"><a href="#MySQL的复制原理以及流程" class="headerlink" title="MySQL的复制原理以及流程"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>MySQL的复制原理以及流程</h3><p>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p><p><strong>主从复制的作用</strong></p><ol><li> 主数据库出现问题，可以切换到从数据库。</li><li> 可以进行数据库层面的读写分离。</li><li> 可以在从数据库上进行日常备份。</li></ol><p><strong>MySQL主从复制解决的问题</strong></p><ul><li>  数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li><li>  负载均衡：降低单个服务器的压力</li><li>  高可用和故障切换：帮助应用程序避免单点失败</li><li>  升级测试：可以用更高版本的MySQL作为从库</li></ul><p><strong>MySQL主从复制工作原理</strong></p><ul><li>  在主库上把数据更高记录到二进制日志</li><li>  从库将主库的日志复制到自己的中继日志</li><li>  从库读取中继日志的事件，将其重放到从库数据中</li></ul><p><strong>基本原理流程，3个线程以及之间的关联</strong></p><p><strong>主</strong>：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</p><p><strong>从</strong>：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；</p><p><strong>从</strong>：sql执行线程——执行relay log中的语句；</p><p><strong>复制过程</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzIxLzE2NWZiNjgzMjIyMDViMmU?x-oss-process=image/format,png" alt="img"></p><p>Binary log：主数据库的二进制日志</p><p>Relay log：从服务器的中继日志</p><p>第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</p><p>第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。</p><p>第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</p><h3 id="读写分离有哪些解决方案？"><a href="#读写分离有哪些解决方案？" class="headerlink" title="读写分离有哪些解决方案？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>读写分离有哪些解决方案？</h3><p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求<code>slave</code>不能写只能读（如果对<code>slave</code>执行写操作，那么<code>show slave status</code>将会呈现<code>Slave_SQL_Running=NO</code>，此时你需要按照前面提到的手动同步一下<code>slave</code>）。</p><p><strong>方案一</strong></p><p>使用mysql-proxy代理</p><p>优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用</p><p>缺点：降低性能， 不支持事务</p><p><strong>方案二</strong></p><p>使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。<br>如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的insert/update/delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下DataSourceTransactionManager， 将read-only的事务扔进读库， 其余的有读有写的扔进写库。</p><p><strong>方案三</strong></p><p>使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务.</p><p>缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。</p><h3 id="备份计划，mysqldump以及xtranbackup的实现原理"><a href="#备份计划，mysqldump以及xtranbackup的实现原理" class="headerlink" title="备份计划，mysqldump以及xtranbackup的实现原理"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>备份计划，mysqldump以及xtranbackup的实现原理</h3><p><strong>(1)备份计划</strong></p><p>视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。</p><p>100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。</p><p><strong>(2)备份恢复时间</strong></p><p>物理备份恢复快，逻辑备份恢复慢</p><p>这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考</p><p>20G的2分钟（mysqldump）</p><p>80G的30分钟(mysqldump)</p><p>111G的30分钟（mysqldump)</p><p>288G的3小时（xtra)</p><p>3T的4小时（xtra)</p><p>逻辑导入时间一般是备份时间的5倍以上</p><p><strong>(3)备份恢复失败如何处理</strong></p><p>首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。</p><p><strong>(4)mysqldump和xtrabackup实现原理</strong></p><p>mysqldump</p><p>mysqldump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个事务(START TRANSACTION /*!40100 WITH CONSISTENTSNAPSHOT */)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data=1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务</p><p>Xtrabackup:</p><p>xtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。最后完成 innodb 的备份后，会做一个 flush engine logs 的操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交</p><p>概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢最后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事</p><p>情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。</p><h3 id="数据表损坏的修复方式有哪些？"><a href="#数据表损坏的修复方式有哪些？" class="headerlink" title="数据表损坏的修复方式有哪些？"></a><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>数据表损坏的修复方式有哪些？</h3><p>使用 myisamchk 来修复，具体步骤：</p><ul><li>  1）修复前将mysql服务停止。</li><li>  2）打开命令行方式，然后进入到mysql的/bin目录。</li><li>  3）执行myisamchk –recover 数据库所在路径/*.MYI</li></ul><p>使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。 OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）</p><p>本文转自 <a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-104778621.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187">https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164574504116780274141388&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>top_positive~default-4-104778621.pc_search_result_positive&amp;utm_term=mysql&amp;spm=1018.2226.3001.4187</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;文章目录&quot;&gt;&lt;a href=&quot;#文章目录&quot; class=&quot;headerlink&quot; title=&quot;文章目录&quot;&gt;&lt;/a&gt;文章目录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;about:blank#_37&quot;&gt;数据库基础知识&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="数据库" scheme="https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
    <category term="MySQL面试" scheme="https://ysluckly.github.io/tags/MySQL%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【C语言】动态顺序表 + 文件存储 = 通讯录</title>
    <link href="https://ysluckly.github.io/2022/02/26/undefined/"/>
    <id>https://ysluckly.github.io/2022/02/26/undefined/</id>
    <published>2022-02-26T05:28:26.536Z</published>
    <updated>2022-02-26T05:24:46.420Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>在前面曾用静态、动态顺序表两种方式实现通讯录，但每次运行程序我们都得重新输入，之前输入的成员信息并不会保存，而现实中，通讯录里的信息创建后是永久保存的，除非你删除它，今天我们就来模拟一下如何将数据存储在文件中，当下一次运行时加载一下即可，这种做法更贴合实际。</p></blockquote><span id="more"></span><blockquote><p><strong>程序中会用到与文件操作相关的函数，提前介绍一下：</strong></p><ul><li>fopen 它的函数原型为：FILE*fopen(const char *filename,const char *mode) ，filename:创建文件的名字；mode:允许进入文件的类型;简单来说这个文件的作用就是打开一个文件流；与fclose:关闭文件流配套使用.</li></ul></blockquote><ul><li>perror: 它的函数原型为：void perror(const char * string) ,这是一种报告文件错误的函数；后面包括一个分号和一个空格，然后打印出一条用于解释errno当前错误代码的信息;</li><li>fwrite: 它的函数原型为：size_t fwrite(const void <em>buffer,size_t size,size_t count,FILE</em>stream) ,buffer:数据写入的体格缓冲区；</li></ul><h2 id="通讯录简要功能："><a href="#通讯录简要功能：" class="headerlink" title="通讯录简要功能："></a>通讯录简要功能：</h2><blockquote><ul><li>初始化通讯录</li><li>添加联系人</li><li>查找联系人</li><li>删除联系人</li><li>修改联系人</li><li>按姓名排序</li><li>清空联系人</li><li>联系人列表</li><li>检查容量</li><li>加载文件</li><li>保存文件</li><li>销毁通讯录</li><li>退出</li></ul></blockquote><h2 id="参考代码："><a href="#参考代码：" class="headerlink" title="参考代码："></a>参考代码：</h2><h3 id="Contact-h："><a href="#Contact-h：" class="headerlink" title="Contact.h："></a>Contact.h：</h3><pre><code class="c">/************************************************************                      程序名称：通讯录（静态顺序表）         **                      编译环境：VS2013                     **                      编制日期：2018.5.29                  **                                      -----by Hunter      ************************************************************/#ifndef __CONTACT_H__#define __CONTACT_H__#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;assert.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;enum OPPTION&#123;    EXIT,    ADD,    SEARCH,    DEIETE,    MODIFY,    SORT,    SHOW,    EMPTY&#125;;typedef char datatype;#define MAX_NAME 10#define MAX_SEX 5#define MAX_TEL 11#define MAX_ADDR 30#define MAX_SIZE 1000#define FILE_NAME  &quot;contact.dat&quot;typedef struct PeoInfo&#123;    datatype Name[MAX_NAME];    datatype Sex[MAX_SEX];    int age;    datatype Tel[MAX_TEL];    datatype Addr[MAX_ADDR];&#125;PeoInfo, *pPeoInfo;typedef struct Contact&#123;    pPeoInfo data;    int size;    int capacity;&#125;Contact, *pContact;//初始化通讯录void InitContact(pContact pc);//添加联系人void AddContact(pContact pc);//删除联系人void DeleteContact(pContact pc);//查找联系人int SearchContact(pContact pc);//修改联系人void ModifyContact(pContact pc);//按姓排序void SortContact(pContact pc);//列表联系人void ShowContact(pContact pc);//清空联系人void EmptyContact(pContact pc);//销毁void DestoryContact(pContact pc);//加载void LoadContact(pContact pc);//保存void SaveContact(pContact pc);#endif //__CONTACT_H__</code></pre><h3 id="Contact-c："><a href="#Contact-c：" class="headerlink" title="Contact.c："></a>Contact.c：</h3><pre><code class="c">#define _CRT_SECURE_NO_WARNINGS 1#include &quot;contact.h&quot;//检查扩容void CheckCapacity(pContact pc)&#123;    assert(pc);    pPeoInfo *p = NULL;    if (pc-&gt;size == pc-&gt;capacity)    &#123;        p = (pPeoInfo)realloc(pc-&gt;data, (pc-&gt;capacity + 2)*sizeof(PeoInfo));        if (p != NULL)        &#123;            pc-&gt;data = p;        &#125;        else        &#123;            printf(&quot;\t\t\t增容失败&quot;);            exit(EXIT_FAILURE);        &#125;        pc-&gt;capacity += 2;        printf(&quot;\t\t\t增容成功\n&quot;);    &#125;&#125;//加载void LoadContact(pContact pc)&#123;       int i = 0;    FILE* pfRead = fopen(&quot;contact.dat&quot;, &quot;r&quot;);    PeoInfo tmp = &#123; 0 &#125;;   //创建临时变量保存每次读取的信息    assert(pc);    if (pfRead == NULL)    &#123;        perror(&quot;the file to read&quot;);        exit(EXIT_FAILURE);    &#125;    while (fread(&amp;tmp, sizeof(PeoInfo), 1, pfRead))    &#123;            CheckCapacity(pc);            pc-&gt;data[i] = tmp;            i++;            pc-&gt;size++;    &#125;    fclose(pfRead);    pfRead = NULL;&#125;//保存void SaveContact(pContact pc)&#123;    assert(pc);    FILE *pfwrite = fopen(&quot;contact.dat&quot;, &quot;w&quot;);    int i = 0;    if (pfwrite == NULL)    &#123;        perror(&quot;the file to write&quot;);        exit(EXIT_FAILURE);    &#125;    for (i = 0; i&lt;pc-&gt;size; i++)    &#123;        fwrite(pc-&gt;data+ i, sizeof(PeoInfo), 1, pfwrite);    &#125;    fclose(pfwrite);    pfwrite = NULL;&#125;//初始化通讯录void InitContact(pContact pc)&#123;    assert(pc);    pc-&gt;size = 0;    pc-&gt;capacity = 3;    pc-&gt;data = (pPeoInfo)malloc((pc-&gt;capacity)*sizeof(PeoInfo));    if (pc-&gt;data == NULL)    &#123;        printf(&quot;\t\t\t内存分配失败&quot;);        exit(EXIT_FAILURE);    &#125;    memset(pc-&gt;data, 0, sizeof(pc-&gt;data));    LoadContact(pc);&#125;//添加联系人void AddContact(pContact pc)&#123;    assert(pc);    if (pc-&gt;size == MAX_SIZE)    &#123;        printf(&quot;\t\t\t空间不足&quot;);        return;    &#125;    CheckCapacity(pc);    printf(&quot;\t\t\t请输入姓名:&gt;&quot;);    scanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].Name);    printf(&quot;\t\t\t请输入性别:&gt;&quot;);    scanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].Sex);    printf(&quot;\t\t\t请输入年龄:&gt;&quot;);    scanf(&quot;%d&quot;, &amp;pc-&gt;data[pc-&gt;size].age);    printf(&quot;\t\t\t请输入电话号:&gt;&quot;);    scanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].Tel);    printf(&quot;\t\t\t请输入地址:&gt;&quot;);    scanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].Addr);    pc-&gt;size++;    printf(&quot;\t\t\t添加成功\n&quot;);&#125;//查找联系人int SearchContact(pContact pc)&#123;    char name[MAX_NAME];    int i = 0;    assert(pc);    if (0 == pc-&gt;size)    &#123;        printf(&quot;\t\t\t无此联系人\n&quot;);        return -1;    &#125;    printf(&quot;\t\t\t&quot;);    scanf(&quot;%s&quot;, name);    printf(&quot;\t\t\tName\tSex\tAge\tTel\t\tAddr\n&quot;);    for (i = 0; i &lt; pc-&gt;size; i++)    &#123;        if (0 == strcmp(pc-&gt;data[i].Name, name))        &#123;            printf(&quot;\t\t\t%-5s\t%-5s\t%-5d\t%-12s\t%-15s\n&quot;,                pc-&gt;data[i].Name,                pc-&gt;data[i].Sex,                pc-&gt;data[i].age,                pc-&gt;data[i].Tel,                pc-&gt;data[i].Addr);            return i;        &#125;    &#125;    printf(&quot;\t\t\t无此联系人\n&quot;);    return -1;&#125;//删除联系人void DeleteContact(pContact pc)&#123;    int i = 0;    int num = 0;    assert(pc);    if (0 == pc-&gt;size)    &#123;        printf(&quot;\t\t\t无联系人\n&quot;);        return;    &#125;    num = SearchContact(pc);    if (num != -1)    &#123;        int n = 0;        printf(&quot;\t\t\t确定删除？  1.yes,  2.no:&gt;&quot;);        printf(&quot;\t\t\t&quot;);        scanf(&quot;%d&quot;, &amp;n);        if (1 == n)        &#123;            for (i = num; i &lt; (pc-&gt;size) - 1; i++)            &#123;                pc-&gt;data[i] = pc-&gt;data[i + 1];            &#125;            pc-&gt;size--;            printf(&quot;\t\t\t删除成功\n&quot;);        &#125;        else        &#123;            return;        &#125;    &#125;&#125;//交换void Swap(pPeoInfo *a, pPeoInfo *b)&#123;    pPeoInfo *Tmp;    Tmp = *a;    *a = *b;    *b = Tmp;&#125;//修改联系人void ModifyContact(pContact pc)&#123;    int modify = 0;    assert(pc);    if (0 == pc-&gt;size)    &#123;        printf(&quot;\t\t\t无联系人\n&quot;);        return;    &#125;    modify = SearchContact(pc);    if (modify != -1)    &#123;        int n = 0;        printf(&quot;\t\t\t确认修改？1.yes  2.no:&gt;&quot;);        printf(&quot;\t\t\t&quot;);        scanf(&quot;%d&quot;, &amp;n);        if (1 == n)        &#123;            printf(&quot;\t\t\t请输入姓名:&gt;&quot;);            scanf(&quot;%s&quot;, pc-&gt;data[modify].Name);            printf(&quot;\t\t\t请输入性别:&gt;&quot;);            scanf(&quot;%s&quot;, pc-&gt;data[modify].Sex);            printf(&quot;\t\t\t请输入年龄:&gt;&quot;);            scanf(&quot;%d&quot;, &amp;pc-&gt;data[modify].age);            printf(&quot;\t\t\t请输入电话号:&gt;&quot;);            scanf(&quot;%s&quot;, pc-&gt;data[modify].Tel);            printf(&quot;\t\t\t请输入地址:&gt;&quot;);            scanf(&quot;%s&quot;, pc-&gt;data[modify].Addr);            printf(&quot;\t\t\t修改成功\n&quot;);        &#125;        else        &#123;            return;        &#125;    &#125;&#125;//按姓排序void SortContact(pContact pc)&#123;    int i = 0;    int j = 0;    int flag = 0;    assert(pc);    if (0 == pc-&gt;size)    &#123;        printf(&quot;\t\t\t无联系人\n&quot;);        return;    &#125;    // 冒泡次数    for (i = 0; i &lt; pc-&gt;size - 1; i++)    &#123;        //冒泡排序        for (j = 0; j &lt; pc-&gt;size - i - 1; j++)        &#123;            if (strcmp(pc-&gt;data[j].Name, pc-&gt;data[j + 1].Name)&gt;0)            &#123;                Swap(&amp;pc-&gt;data[j], &amp;pc-&gt;data[j + 1]);                flag = 1;            &#125;        &#125;        if (0 == flag)        &#123;            break;        &#125;    &#125;    printf(&quot;排序成功\n&quot;);&#125;//列表联系人void ShowContact(pContact pc)&#123;    int i = 0;    assert(pc);    if (0 == pc-&gt;size)    &#123;        printf(&quot;\t\t\t无联系人\n&quot;);        return;    &#125;    printf(&quot;\t\t\tName\tSex\tAge\tTel\t\tAddr\n&quot;);    for (i = 0; i &lt; pc-&gt;size; i++)    &#123;        printf(&quot;\t\t\t%-5s\t%-5s\t%-5d\t%-12s\t%-15s\n&quot;,            pc-&gt;data[i].Name,            pc-&gt;data[i].Sex,            pc-&gt;data[i].age,            pc-&gt;data[i].Tel,            pc-&gt;data[i].Addr);    &#125;&#125;//清空联系人void EmptyContact(pContact pc)&#123;    assert(pc);    pc-&gt;size = 0;    printf(&quot;\t\t\t清空成功&quot;);&#125;//销毁通讯录void DestoryContact(pContact pc)&#123;    assert(pc);    SaveContact(pc);    free(pc-&gt;data);    pc-&gt;data = NULL;    pc-&gt;capacity = 0;    pc-&gt;size = 0;    printf(&quot;\t\t\t销毁成功&quot;);&#125;</code></pre><h3 id="test-c："><a href="#test-c：" class="headerlink" title="test.c："></a>test.c：</h3><pre><code class="c">#define _CRT_SECURE_NO_WARNINGS 1#include &quot;contact.h&quot;void meau()&#123;    printf(&quot;\t\t\t******         《通讯录》       ********\n&quot;);    printf(&quot;\t\t\t****************************************\n&quot;);    printf(&quot;\t\t\t****** 1.添加信息       2.查找信息******\n&quot;);    printf(&quot;\t\t\t****** 3.删除信息       4.修改信息******\n&quot;);    printf(&quot;\t\t\t****** 5.按姓排序       6.信息列表******\n&quot;);    printf(&quot;\t\t\t****** 7.清空信息       0.退出    ******\n&quot;);    printf(&quot;\t\t\t****************************************\n&quot;);&#125;void test()&#123;    int input = 0;    Contact pc;    InitContact(&amp;pc);    do    &#123;        meau();        printf(&quot;\t\t\t请选择:&gt;&quot;);        scanf(&quot;%d&quot;, &amp;input);        switch (input)        &#123;        case ADD:            AddContact(&amp;pc);            break;        case SEARCH:            SearchContact(&amp;pc);            break;        case DEIETE:            DeleteContact(&amp;pc);            break;        case MODIFY:            ModifyContact(&amp;pc);            break;        case SORT:            SortContact(&amp;pc);            break;        case SHOW:            ShowContact(&amp;pc);            break;        case EMPTY:            EmptyContact(&amp;pc);            break;        case EXIT:            break;        default:            printf(&quot;\t\t\t输入有误，请重新输入:&gt;&quot;);            break;        &#125;    &#125; while (input);&#125;int main()&#123;    Contact pc;    test();    //销毁通讯录    DestoryContact(&amp;pc);    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h1><blockquote><p>最初的自己是个编程菜鸟，然而通过努力的学习，现在也能逐渐的自己写小程序了，相信这就是一种进步，暂不希望自己能有多强大。只要每一步走的充实，我相信一定会有好的回报，<strong>且行且努力！</strong></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在前面曾用静态、动态顺序表两种方式实现通讯录，但每次运行程序我们都得重新输入，之前输入的成员信息并不会保存，而现实中，通讯录里的信息创建后是永久保存的，除非你删除它，今天我们就来模拟一下如何将数据存储在文件中，当下一次运行时加载一下即可，这种做法更贴合实际。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="C语言" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="通讯录" scheme="https://ysluckly.github.io/tags/%E9%80%9A%E8%AE%AF%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Go Mock (gomock)简明教程</title>
    <link href="https://ysluckly.github.io/2022/02/16/go/"/>
    <id>https://ysluckly.github.io/2022/02/16/go/</id>
    <published>2022-02-16T13:59:10.000Z</published>
    <updated>2022-02-20T13:36:40.177Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114756.jpg" alt="gomock"></p><h2 id="1-gomock-简介"><a href="#1-gomock-简介" class="headerlink" title="1 gomock 简介"></a>1 gomock 简介</h2><p>上一篇文章 <a href="https://geektutu.com/post/quick-go-test.html">Go Test 单元测试简明教程</a> 介绍了 Go 语言中单元测试的常用方法，包括子测试(subtests)、表格驱动测试(table-driven tests)、帮助函数(helpers)、网络测试和基准测试(Benchmark)等。这篇文章介绍一种新的测试方法，mock/stub 测试，当待测试的函数/对象的依赖关系很复杂，并且有些依赖不能直接创建，例如数据库连接、文件I/O等。这种场景就非常适合使用 mock/stub 测试。简单来说，就是用 mock 对象模拟依赖项的行为。</p><blockquote><p>GoMock is a mocking framework for the Go programming language. It integrates well with Go’s built-in testing package, but can be used in other contexts too.</p></blockquote><p><a href="https://github.com/golang/mock">gomock</a> 是官方提供的 mock 框架，同时还提供了 mockgen 工具用来辅助生成测试代码。</p><p>使用如下命令即可安装：</p><pre><code class="bash">go get -u github.com/golang/mock/gomockgo get -u github.com/golang/mock/mockgen</code></pre><h2 id="2-一个简单的-Demo"><a href="#2-一个简单的-Demo" class="headerlink" title="2 一个简单的 Demo"></a>2 一个简单的 Demo</h2><pre><code class="go">// db.gotype DB interface &#123;    Get(key string) (int, error)&#125;func GetFromDB(db DB, key string) int &#123;    if value, err := db.Get(key); err == nil &#123;        return value    &#125;    return -1&#125;</code></pre><p>假设 <code>DB</code> 是代码中负责与数据库交互的部分(在这里用 map 模拟)，测试用例中不能创建真实的数据库连接。这个时候，如果我们需要测试 <code>GetFromDB</code> 这个函数内部的逻辑，就需要 mock 接口 <code>DB</code>。</p><p>第一步：使用 <code>mockgen</code> 生成 <code>db_mock.go</code>。一般传递三个参数。包含需要被mock的接口得到源文件<code>source</code>，生成的目标文件<code>destination</code>，包名<code>package</code>。</p><pre><code class="bash">$ mockgen -source=db.go -destination=db_mock.go -package=main</code></pre><p>第二步：新建 <code>db_test.go</code>，写测试用例。</p><pre><code class="go">func TestGetFromDB(t *testing.T) &#123;    ctrl := gomock.NewController(t)    defer ctrl.Finish() // 断言 DB.Get() 方法是否被调用    m := NewMockDB(ctrl)    m.EXPECT().Get(gomock.Eq(&quot;Tom&quot;)).Return(100, errors.New(&quot;not exist&quot;))    if v := GetFromDB(m, &quot;Tom&quot;); v != -1 &#123;        t.Fatal(&quot;expected -1, but got&quot;, v)    &#125;&#125;</code></pre><ul><li>这个测试用例有2个目的，一是使用 <code>ctrl.Finish()</code> 断言 <code>DB.Get()</code> 被是否被调用，如果没有被调用，后续的 mock 就失去了意义；</li><li>二是测试方法 <code>GetFromDB()</code> 的逻辑是否正确(如果 <code>DB.Get()</code> 返回 error，那么 <code>GetFromDB()</code> 返回 -1)。</li><li><code>NewMockDB()</code> 的定义在 <code>db_mock.go</code> 中，由 mockgen 自动生成。</li></ul><p>最终的代码结构如下：</p><pre><code class="bash">project/    |--db.go    |--db_mock.go // generated by mockgen    |--db_test.go</code></pre><p>执行测试：</p><pre><code class="bash">$ go test . -cover -v=== RUN   TestGetFromDB--- PASS: TestGetFromDB (0.00s)PASScoverage: 81.2% of statementsok      example 0.008s  coverage: 81.2% of statements</code></pre><h2 id="3-打桩-stubs"><a href="#3-打桩-stubs" class="headerlink" title="3 打桩(stubs)"></a>3 打桩(stubs)</h2><p>在上面的例子中，当 <code>Get()</code> 的参数为 Tom，则返回 error，这称之为<code>打桩(stub)</code>，有明确的参数和返回值是最简单打桩方式。除此之外，检测调用次数、调用顺序，动态设置返回值等方式也经常使用。</p><p>3.1 参数(Eq, Any, Not, Nil)</p><pre><code class="go">m.EXPECT().Get(gomock.Eq(&quot;Tom&quot;)).Return(0, errors.New(&quot;not exist&quot;))m.EXPECT().Get(gomock.Any()).Return(630, nil)m.EXPECT().Get(gomock.Not(&quot;Sam&quot;)).Return(0, nil) m.EXPECT().Get(gomock.Nil()).Return(0, errors.New(&quot;nil&quot;)) </code></pre><ul><li><code>Eq(value)</code> 表示与 value 等价的值。</li><li><code>Any()</code> 可以用来表示任意的入参。</li><li><code>Not(value)</code> 用来表示非 value 以外的值。</li><li><code>Nil()</code> 表示 None 值</li></ul><p>3.2 返回值(Return, DoAndReturn)</p><pre><code class="go">m.EXPECT().Get(gomock.Not(&quot;Sam&quot;)).Return(0, nil)m.EXPECT().Get(gomock.Any()).Do(func(key string) &#123;    t.Log(key)&#125;)m.EXPECT().Get(gomock.Any()).DoAndReturn(func(key string) (int, error) &#123;    if key == &quot;Sam&quot; &#123;        return 630, nil    &#125;    return 0, errors.New(&quot;not exist&quot;)&#125;)</code></pre><ul><li><code>Return</code> 返回确定的值</li><li><code>Do</code> Mock 方法被调用时，要执行的操作吗，忽略返回值。</li><li><code>DoAndReturn</code> 可以动态地控制返回值。</li></ul><p>3.3 调用次数(Times)</p><pre><code class="go">func TestGetFromDB(t *testing.T) &#123;    ctrl := gomock.NewController(t)    defer ctrl.Finish()    m := NewMockDB(ctrl)    m.EXPECT().Get(gomock.Not(&quot;Sam&quot;)).Return(0, nil).Times(2)    GetFromDB(m, &quot;ABC&quot;)    GetFromDB(m, &quot;DEF&quot;)&#125;</code></pre><ul><li><code>Times()</code> 断言 Mock 方法被调用的次数。</li><li><code>MaxTimes()</code> 最大次数。</li><li><code>MinTimes()</code> 最小次数。</li><li><code>AnyTimes()</code> 任意次数（包括 0 次）。</li></ul><p>3.4 调用顺序(InOrder)</p><pre><code class="go">func TestGetFromDB(t *testing.T) &#123;    ctrl := gomock.NewController(t)    defer ctrl.Finish() // 断言 DB.Get() 方法是否被调用    m := NewMockDB(ctrl)    o1 := m.EXPECT().Get(gomock.Eq(&quot;Tom&quot;)).Return(0, errors.New(&quot;not exist&quot;))    o2 := m.EXPECT().Get(gomock.Eq(&quot;Sam&quot;)).Return(630, nil)    gomock.InOrder(o1, o2)    GetFromDB(m, &quot;Tom&quot;)    GetFromDB(m, &quot;Sam&quot;)&#125;</code></pre><h2 id="4-如何编写可-mock-的代码"><a href="#4-如何编写可-mock-的代码" class="headerlink" title="4 如何编写可 mock 的代码"></a>4 如何编写可 mock 的代码</h2><p>写可测试的代码与写好测试用例是同等重要的，如何写可 mock 的代码呢？</p><ul><li>mock 作用的是接口，因此将依赖抽象为接口，而不是直接依赖具体的类。</li><li>不直接依赖的实例，而是使用依赖注入降低耦合性。</li></ul><blockquote><p>在软件工程中，依赖注入的意思为，给予调用方它所需要的事物。 “依赖”是指可被方法调用的事物。依赖注入形式下，调用方不再直接指使用“依赖”，取而代之是“注入” 。“注入”是指将“依赖”传递给调用方的过程。在“注入”之后，调用方才会调用该“依赖”。传递依赖给调用方，而不是让让调用方直接获得依赖，这个是该设计的根本需求。<br>– <a href="https://zh.wikipedia.org/zh-cn/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">依赖注入 - Wikipedia</a></p></blockquote><p>如果 <code>GetFromDB()</code> 方法长这个样子</p><pre><code class="go">func GetFromDB(key string) int &#123;    db := NewDB()    if value, err := db.Get(key); err == nil &#123;        return value    &#125;    return -1&#125;</code></pre><p>对 <code>DB</code> 接口的 mock 并不能作用于 <code>GetFromDB()</code> 内部，这样写是没办法进行测试的。那如果将接口 <code>db DB</code> 通过参数传递到 <code>GetFromDB()</code>，那么就可以轻而易举地传入 Mock 对象了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114756.jpg&quot; alt=&quot;gomock&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-gomock-简介&quot;&gt;&lt;a href=&quot;#1-go</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Go语言" scheme="https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
    <category term="单元测试" scheme="https://ysluckly.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    <category term="mock框架" scheme="https://ysluckly.github.io/tags/mock%E6%A1%86%E6%9E%B6/"/>
    
    <category term="stub" scheme="https://ysluckly.github.io/tags/stub/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言简明教程</title>
    <link href="https://ysluckly.github.io/2022/02/16/go/"/>
    <id>https://ysluckly.github.io/2022/02/16/go/</id>
    <published>2022-02-16T13:59:10.000Z</published>
    <updated>2022-02-20T13:35:38.378Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114701.jpg" alt="Golang中文教程"></p><blockquote><p>Go（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。 —— <a href="https://zh.wikipedia.org/wiki/Go">Go - wikipedia.org</a></p></blockquote><h2 id="1-Go-安装"><a href="#1-Go-安装" class="headerlink" title="1 Go 安装"></a>1 Go 安装</h2><p>最新版本下载地址<a href="https://golang.org/dl/">官方下载 golang.org</a>，当前是 1.13.6。如无法访问，可以在 <strong>studygolang.com/dl</strong> 下载</p><p>使用 Linux，可以用如下方式快速安装。</p><pre><code class="bash">$ wget https://studygolang.com/dl/golang/go1.13.6.linux-amd64.tar.gz$ tar -zxvf go1.13.6.linux-amd64.tar.gz$ sudo mv go /usr/local/$ go versiongo version go1.13.6 linux/amd64</code></pre><p>从 <code>Go 1.11</code> 版本开始，Go 提供了 <a href="https://github.com/golang/go/wiki/Modules">Go Modules</a> 的机制，推荐设置以下环境变量，第三方包的下载将通过国内镜像，避免出现官方网址被屏蔽的问题。</p><pre><code class="bash">$ go env -w GOPROXY=https://goproxy.cn,direct</code></pre><p>或在 <code>~/.profile</code> 中设置环境变量</p><pre><code class="bash">export GOPROXY=https://goproxy.cn</code></pre><h2 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2 Hello World"></a>2 Hello World</h2><p>新建一个文件 <code>main.go</code>，写入</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    fmt.Println(&quot;Hello World!&quot;)&#125;</code></pre><p>执行<code>go run main.go</code> 或 <code>go run .</code>，将会输出</p><pre><code class="bash">$ go run .Hello World!</code></pre><blockquote><p>如果强制启用了 Go Modules 机制，即环境变量中设置了 GO111MODULE=on，则需要先初始化模块 go mod init hello<br>否则会报错误：go: cannot find main module; see ‘go help modules’</p></blockquote><p>我们的第一个 Go 程序就完成了，接下来我们逐行来解读这个程序：</p><ul><li>package main：声明了 main.go 所在的包，Go 语言中使用包来组织代码。一般一个文件夹即一个包，包内可以暴露类型或方法供其他包使用。</li><li>import “fmt”：fmt 是 Go 语言的一个标准库/包，用来处理标准输入输出。</li><li>func main：main 函数是整个程序的入口，main 函数所在的包名也必须为 <code>main</code>。</li><li>fmt.Println(“Hello World!”)：调用 fmt 包的 Println 方法，打印出 “Hello World!”</li></ul><p>go run main.go，其实是 2 步：</p><ul><li>go build main.go：编译成二进制可执行程序</li><li>./main：执行该程序</li></ul><h2 id="3-变量与内置数据类型"><a href="#3-变量与内置数据类型" class="headerlink" title="3 变量与内置数据类型"></a>3 变量与内置数据类型</h2><h3 id="3-1-变量-Variable"><a href="#3-1-变量-Variable" class="headerlink" title="3.1 变量(Variable)"></a>3.1 变量(Variable)</h3><p>Go 语言是静态类型的，变量声明时必须明确变量的类型。Go 语言与其他语言显著不同的一个地方在于，Go 语言的类型在变量后面。比如 java 中，声明一个整体一般写成 <code>int a = 1</code>，在 Go 语言中，需要这么写：</p><pre><code class="go">var a int // 如果没有赋值，默认为0var a int = 1 // 声明时赋值var a = 1 // 声明时赋值</code></pre><p><code>var a = 1</code>，因为 1 是 int 类型的，所以赋值时，a 自动被确定为 int 类型，所以类型名可以省略不写，这种方式还有一种更简单的表达：</p><pre><code class="go">a := 1msg := &quot;Hello World!&quot;</code></pre><h3 id="3-2-简单类型"><a href="#3-2-简单类型" class="headerlink" title="3.2 简单类型"></a>3.2 简单类型</h3><p>空值：nil</p><p>整型类型： int(取决于操作系统), int8, int16, int32, int64, uint8, uint16, …</p><p>浮点数类型：float32, float64</p><p>字节类型：byte (等价于uint8)</p><p>字符串类型：string</p><p>布尔值类型：boolean，(true 或 false)</p><pre><code class="go">var a int8 = 10var c1 byte = &#39;a&#39;var b float32 = 12.2var msg = &quot;Hello World&quot;ok := false</code></pre><h3 id="3-3-字符串"><a href="#3-3-字符串" class="headerlink" title="3.3 字符串"></a>3.3 字符串</h3><p>在 Go 语言中，字符串使用 UTF8 编码，UTF8 的好处在于，如果基本是英文，每个字符占 1 byte，和 ASCII 编码是一样的，非常节省空间，如果是中文，一般占3字节。包含中文的字符串的处理方式与纯 ASCII 码构成的字符串有点区别。</p><p>我们看下面的例子：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;reflect&quot;)func main() &#123;    str1 := &quot;Golang&quot;    str2 := &quot;Go语言&quot;    fmt.Println(reflect.TypeOf(str2[2]).Kind()) // uint8    fmt.Println(str1[2], string(str1[2]))       // 108 l    fmt.Printf(&quot;%d %c\n&quot;, str2[2], str2[2])     // 232 è    fmt.Println(&quot;len(str2)：&quot;, len(str2))       // len(str2)： 8&#125;</code></pre><ul><li>reflect.TypeOf().Kind() 可以知道某个变量的类型，我们可以看到，字符串是以 byte 数组形式保存的，类型是 uint8，占1个 byte，打印时需要用 string 进行类型转换，否则打印的是编码值。</li><li>因为字符串是以 byte 数组的形式存储的，所以，<code>str2[2]</code> 的值并不等于<code>语</code>。str2 的长度 <code>len(str2)</code> 也不是 4，而是 8（ Go 占 2 byte，语言占 6 byte）。</li></ul><p>正确的处理方式是将 string 转为 rune 数组</p><pre><code class="go">str2 := &quot;Go语言&quot;runeArr := []rune(str2)fmt.Println(reflect.TypeOf(runeArr[2]).Kind()) // int32fmt.Println(runeArr[2], string(runeArr[2]))    // 35821 语fmt.Println(&quot;len(runeArr)：&quot;, len(runeArr))    // len(runeArr)： 4</code></pre><p>转换成 <code>[]rune</code> 类型后，字符串中的每个字符，无论占多少个字节都用 int32 来表示，因而可以正确处理中文。</p><h3 id="3-4-数组-array-与切片-slice"><a href="#3-4-数组-array-与切片-slice" class="headerlink" title="3.4 数组(array)与切片(slice)"></a>3.4 数组(array)与切片(slice)</h3><p>声明数组</p><pre><code class="go">var arr [5]int     // 一维var arr2 [5][5]int // 二维 </code></pre><p>声明时初始化</p><pre><code class="go">var arr = [5]int&#123;1, 2, 3, 4, 5&#125;// 或 arr := [5]int&#123;1, 2, 3, 4, 5&#125;</code></pre><p>使用 <code>[]</code> 索引/修改数组</p><pre><code class="go">arr := [5]int&#123;1, 2, 3, 4, 5&#125;for i := 0; i &lt; len(arr); i++ &#123;    arr[i] += 100&#125;fmt.Println(arr)  // [101 102 103 104 105]</code></pre><p>数组的长度不能改变，如果想拼接2个数组，或是获取子数组，需要使用切片。切片是数组的抽象。 切片使用数组作为底层结构。切片包含三个组件：容量，长度和指向底层数组的指针,切片可以随时进行扩展</p><p>声明切片：</p><pre><code class="go">slice1 := make([]float32, 0) // 长度为0的切片slice2 := make([]float32, 3, 5) // [0 0 0] 长度为3容量为5的切片fmt.Println(len(slice2), cap(slice2)) // 3 5</code></pre><p>使用切片：</p><pre><code class="go">// 添加元素，切片容量可以根据需要自动扩展slice2 = append(slice2, 1, 2, 3, 4) // [0, 0, 0, 1, 2, 3, 4]fmt.Println(len(slice2), cap(slice2)) // 7 12// 子切片 [start, end)sub1 := slice2[3:] // [1 2 3 4]sub2 := slice2[:3] // [0 0 0]sub3 := slice2[1:4] // [0 0 1]// 合并切片combined := append(sub1, sub2...) // [1, 2, 3, 4, 0, 0, 0]</code></pre><ul><li>声明切片时可以为切片设置容量大小，为切片预分配空间。在实际使用的过程中，如果容量不够，切片容量会自动扩展。</li><li><code>sub2...</code> 是切片解构的写法，将切片解构为 N 个独立的元素。</li></ul><h3 id="3-5-字典-键值对，map"><a href="#3-5-字典-键值对，map" class="headerlink" title="3.5 字典(键值对，map)"></a>3.5 字典(键值对，map)</h3><p>map 类似于 java 的 HashMap，Python的字典(dict)，是一种存储键值对(Key-Value)的数据解构。使用方式和其他语言几乎没有区别。</p><pre><code class="go">// 仅声明m1 := make(map[string]int)// 声明时初始化m2 := map[string]string&#123;    &quot;Sam&quot;: &quot;Male&quot;,    &quot;Alice&quot;: &quot;Female&quot;,&#125;// 赋值/修改m1[&quot;Tom&quot;] = 18</code></pre><h3 id="3-6-指针-pointer"><a href="#3-6-指针-pointer" class="headerlink" title="3.6 指针(pointer)"></a>3.6 指针(pointer)</h3><p>指针即某个值的地址，类型定义时使用符号<code>*</code>，对一个已经存在的变量，使用 <code>&amp;</code> 获取该变量的地址。</p><pre><code class="go">str := &quot;Golang&quot;var p *string = &amp;str // p 是指向 str 的指针*p = &quot;Hello&quot;fmt.Println(str) // Hello 修改了 p，str 的值也发生了改变</code></pre><p>一般来说，指针通常在函数传递参数，或者给某个类型定义新的方法时使用。Go 语言中，参数是按值传递的，如果不使用指针，函数内部将会拷贝一份参数的副本，对参数的修改并不会影响到外部变量的值。如果参数使用指针，对参数的传递将会影响到外部变量。</p><p>例如：</p><pre><code class="go">func add(num int) &#123;    num += 1&#125;func realAdd(num *int) &#123;    *num += 1&#125;func main() &#123;    num := 100    add(num)    fmt.Println(num)  // 100，num 没有变化    realAdd(&amp;num)    fmt.Println(num)  // 101，指针传递，num 被修改&#125;</code></pre><h2 id="4-流程控制-if-for-switch"><a href="#4-流程控制-if-for-switch" class="headerlink" title="4 流程控制(if, for, switch)"></a>4 流程控制(if, for, switch)</h2><h3 id="4-1-条件语句-if-else"><a href="#4-1-条件语句-if-else" class="headerlink" title="4.1 条件语句 if else"></a>4.1 条件语句 if else</h3><pre><code class="go">age := 18if age &lt; 18 &#123;    fmt.Printf(&quot;Kid&quot;)&#125; else &#123;    fmt.Printf(&quot;Adult&quot;)&#125;// 可以简写为：if age := 18; age &lt; 18 &#123;    fmt.Printf(&quot;Kid&quot;)&#125; else &#123;    fmt.Printf(&quot;Adult&quot;)&#125;</code></pre><h3 id="4-2-switch"><a href="#4-2-switch" class="headerlink" title="4.2 switch"></a>4.2 switch</h3><pre><code class="go">type Gender int8const (    MALE   Gender = 1    FEMALE Gender = 2)gender := MALEswitch gender &#123;case FEMALE:    fmt.Println(&quot;female&quot;)case MALE:    fmt.Println(&quot;male&quot;)default:    fmt.Println(&quot;unknown&quot;)&#125;// male</code></pre><ul><li>在这里，使用了<code>type</code> 关键字定义了一个新的类型 Gender。</li><li>使用 const 定义了 MALE 和 FEMALE 2 个常量，Go 语言中没有枚举(enum)的概念，一般可以用常量的方式来模拟枚举。</li><li>和其他语言不同的地方在于，Go 语言的 switch 不需要 break，匹配到某个 case，执行完该 case 定义的行为后，默认不会继续往下执行。如果需要继续往下执行，需要使用 fallthrough，例如：</li></ul><pre><code class="go">switch gender &#123;case FEMALE:    fmt.Println(&quot;female&quot;)    fallthroughcase MALE:    fmt.Println(&quot;male&quot;)    fallthroughdefault:    fmt.Println(&quot;unknown&quot;)&#125;// 输出结果// male// unknown</code></pre><h3 id="4-3-for-循环"><a href="#4-3-for-循环" class="headerlink" title="4.3 for 循环"></a>4.3 for 循环</h3><p>一个简单的累加的例子，break 和 continue 的用法与其他语言没有区别。</p><pre><code class="go">sum := 0for i := 0; i &lt; 10; i++ &#123;    if sum &gt; 50 &#123;        break    &#125;    sum += i&#125;</code></pre><p>对数组(arr)、切片(slice)、字典(map) 使用 for range 遍历：</p><pre><code class="go">nums := []int&#123;10, 20, 30, 40&#125;for i, num := range nums &#123;    fmt.Println(i, num)&#125;// 0 10// 1 20// 2 30// 3 40m2 := map[string]string&#123;    &quot;Sam&quot;:   &quot;Male&quot;,    &quot;Alice&quot;: &quot;Female&quot;,&#125;for key, value := range m2 &#123;    fmt.Println(key, value)&#125;// Sam Male// Alice Female</code></pre><h2 id="5-函数-functions"><a href="#5-函数-functions" class="headerlink" title="5 函数(functions)"></a>5 函数(functions)</h2><h3 id="5-1-参数与返回值"><a href="#5-1-参数与返回值" class="headerlink" title="5.1 参数与返回值"></a>5.1 参数与返回值</h3><p>一个典型的函数定义如下，使用关键字 <code>func</code>，参数可以有多个，返回值也支持有多个。特别地，<code>package main</code> 中的<code>func main()</code> 约定为可执行程序的入口。</p><pre><code class="go">func funcName(param1 Type1, param2 Type2, ...) (return1 Type3, ...) &#123;    // body&#125;</code></pre><p>例如，实现2个数的加法（一个返回值）和除法（多个返回值）：</p><pre><code class="go">func add(num1 int, num2 int) int &#123;    return num1 + num2&#125;func div(num1 int, num2 int) (int, int) &#123;    return num1 / num2, num1 % num2&#125;func main() &#123;    quo, rem := div(100, 17)    fmt.Println(quo, rem)     // 5 15    fmt.Println(add(100, 17)) // 117&#125;</code></pre><p>也可以给返回值命名，简化 return，例如 add 函数可以改写为</p><pre><code class="go">func add(num1 int, num2 int) (ans int) &#123;    ans = num1 + num2    return&#125;</code></pre><h3 id="5-2-错误处理-error-handling"><a href="#5-2-错误处理-error-handling" class="headerlink" title="5.2 错误处理(error handling)"></a>5.2 错误处理(error handling)</h3><p>如果函数实现过程中，如果出现不能处理的错误，可以返回给调用者处理。比如我们调用标准库函数<code>os.Open</code>读取文件，<code>os.Open</code> 有2个返回值，第一个是 <code>*File</code>，第二个是 <code>error</code>， 如果调用成功，error 的值是 nil，如果调用失败，例如文件不存在，我们可以通过 error 知道具体的错误信息。</p><pre><code class="go">import (    &quot;fmt&quot;    &quot;os&quot;)func main() &#123;    _, err := os.Open(&quot;filename.txt&quot;)    if err != nil &#123;        fmt.Println(err)    &#125;&#125;// open filename.txt: no such file or directory</code></pre><p>可以通过 <code>errorw.New</code> 返回自定义的错误</p><pre><code class="go">import (    &quot;errors&quot;    &quot;fmt&quot;)func hello(name string) error &#123;    if len(name) == 0 &#123;        return errors.New(&quot;error: name is null&quot;)    &#125;    fmt.Println(&quot;Hello,&quot;, name)    return nil&#125;func main() &#123;    if err := hello(&quot;&quot;); err != nil &#123;        fmt.Println(err)    &#125;&#125;// error: name is null</code></pre><p>error 往往是能预知的错误，但是也可能出现一些不可预知的错误，例如数组越界，这种错误可能会导致程序非正常退出，在 Go 语言中称之为 panic。</p><pre><code class="go">func get(index int) int &#123;    arr := [3]int&#123;2, 3, 4&#125;    return arr[index]&#125;func main() &#123;    fmt.Println(get(5))    fmt.Println(&quot;finished&quot;)&#125;</code></pre><pre><code class="bash">$ go run .panic: runtime error: index out of range [5] with length 3goroutine 1 [running]:exit status 2</code></pre><p>在 Python、Java 等语言中有 <code>try...catch</code> 机制，在 <code>try</code> 中捕获各种类型的异常，在 <code>catch</code> 中定义异常处理的行为。Go 语言也提供了类似的机制 <code>defer</code> 和 <code>recover</code>。</p><pre><code class="go">func get(index int) (ret int) &#123;    defer func() &#123;        if r := recover(); r != nil &#123;            fmt.Println(&quot;Some error happened!&quot;, r)            ret = -1        &#125;    &#125;()    arr := [3]int&#123;2, 3, 4&#125;    return arr[index]&#125;func main() &#123;    fmt.Println(get(5))    fmt.Println(&quot;finished&quot;)&#125;</code></pre><pre><code class="bash">$ go run .Some error happened! runtime error: index out of range [5] with length 3-1finished</code></pre><ul><li>在 get 函数中，使用 defer 定义了异常处理的函数，在协程退出前，会执行完 defer 挂载的任务。因此如果触发了 panic，控制权就交给了 defer。</li><li>在 defer 的处理逻辑中，使用 recover，使程序恢复正常，并且将返回值设置为 -1，在这里也可以不处理返回值，如果不处理返回值，返回值将被置为默认值 0。</li></ul><h2 id="6-结构体，方法和接口"><a href="#6-结构体，方法和接口" class="headerlink" title="6 结构体，方法和接口"></a>6 结构体，方法和接口</h2><h3 id="6-1-结构体-struct-和方法-methods"><a href="#6-1-结构体-struct-和方法-methods" class="headerlink" title="6.1 结构体(struct) 和方法(methods)"></a>6.1 结构体(struct) 和方法(methods)</h3><p>结构体类似于其他语言中的 class，可以在结构体中定义多个字段，为结构体实现方法，实例化等。接下来我们定义一个结构体 Student，并为 Student 添加 name，age 字段，并实现 <code>hello()</code> 方法。</p><pre><code class="go">type Student struct &#123;    name string    age  int&#125;func (stu *Student) hello(person string) string &#123;    return fmt.Sprintf(&quot;hello %s, I am %s&quot;, person, stu.name)&#125;func main() &#123;    stu := &amp;Student&#123;        name: &quot;Tom&quot;,    &#125;    msg := stu.hello(&quot;Jack&quot;)    fmt.Println(msg) // hello Jack, I am Tom&#125;</code></pre><ul><li>使用 <code>Student&#123;field: value, ...&#125;</code>的形式创建 Student 的实例，字段不需要每个都赋值，没有显性赋值的变量将被赋予默认值，例如 age 将被赋予默认值 0。</li><li>实现方法与实现函数的区别在于，<code>func</code> 和函数名<code>hello</code> 之间，加上该方法对应的实例名 <code>stu</code> 及其类型 <code>*Student</code>，可以通过实例名访问该实例的字段<code>name</code>和其他方法了。</li><li>调用方法通过 <code>实例名.方法名(参数)</code> 的方式。</li></ul><p>除此之外，还可以使用 <code>new</code> 实例化：</p><pre><code class="go">func main() &#123;    stu2 := new(Student)    fmt.Println(stu2.hello(&quot;Alice&quot;)) // hello Alice, I am  , name 被赋予默认值&quot;&quot;&#125;</code></pre><h3 id="6-2-接口-interfaces"><a href="#6-2-接口-interfaces" class="headerlink" title="6.2 接口(interfaces)"></a>6.2 接口(interfaces)</h3><p>一般而言，接口定义了一组方法的集合，接口不能被实例化，一个类型可以实现多个接口。</p><p>举一个简单的例子，定义一个接口 <code>Person</code>和对应的方法 <code>getName()</code> 和 <code>getAge()</code>：</p><pre><code class="go">type Person interface &#123;    getName() string&#125;type Student struct &#123;    name string    age  int&#125;func (stu *Student) getName() string &#123;    return stu.name&#125;type Worker struct &#123;    name   string    gender string&#125;func (w *Worker) getName() string &#123;    return w.name&#125;func main() &#123;    var p Person = &amp;Student&#123;        name: &quot;Tom&quot;,        age:  18,    &#125;    fmt.Println(p.getName()) // Tom&#125;</code></pre><ul><li>Go 语言中，并不需要显式地声明实现了哪一个接口，只需要直接实现该接口对应的方法即可。</li><li>实例化 <code>Student</code>后，强制类型转换为接口类型 Person。</li></ul><p>在上面的例子中，我们在 main 函数中尝试将 Student 实例类型转换为 Person，如果 Student 没有完全实现 Person 的方法，比如我们将 <code>(*Student).getName()</code> 删掉，编译时会出现如下报错信息。</p><pre><code class="bash"> *Student does not implement Person (missing getName method)</code></pre><p>但是删除 <code>(*Worker).getName()</code> 程序并不会报错，因为我们并没有在 main 函数中使用。这种情况下我们如何确保某个类型实现了某个接口的所有方法呢？一般可以使用下面的方法进行检测，如果实现不完整，编译期将会报错。</p><pre><code class="go">var _ Person = (*Student)(nil)var _ Person = (*Worker)(nil)</code></pre><ul><li>将空值 nil 转换为 *Student 类型，再转换为 Person 接口，如果转换失败，说明 Student 并没有实现 Person 接口的所有方法。</li><li>Worker 同上。</li></ul><p>实例可以强制类型转换为接口，接口也可以强制类型转换为实例。</p><pre><code class="go">func main() &#123;    var p Person = &amp;Student&#123;        name: &quot;Tom&quot;,        age:  18,    &#125;    stu := p.(*Student) // 接口转为实例    fmt.Println(stu.getAge())&#125;</code></pre><h3 id="6-3-空接口"><a href="#6-3-空接口" class="headerlink" title="6.3 空接口"></a>6.3 空接口</h3><p>如果定义了一个没有任何方法的空接口，那么这个接口可以表示任意类型。例如</p><pre><code class="go">func main() &#123;    m := make(map[string]interface&#123;&#125;)    m[&quot;name&quot;] = &quot;Tom&quot;    m[&quot;age&quot;] = 18    m[&quot;scores&quot;] = [3]int&#123;98, 99, 85&#125;    fmt.Println(m) // map[age:18 name:Tom scores:[98 99 85]]&#125;</code></pre><h2 id="7-并发编程-goroutine"><a href="#7-并发编程-goroutine" class="headerlink" title="7 并发编程(goroutine)"></a>7 并发编程(goroutine)</h2><h3 id="7-1-sync"><a href="#7-1-sync" class="headerlink" title="7.1 sync"></a>7.1 sync</h3><p>Go 语言提供了 sync 和 channel 两种方式支持协程(goroutine)的并发。</p><p>例如我们希望并发下载 N 个资源，多个并发协程之间不需要通信，那么就可以使用 sync.WaitGroup，等待所有并发协程执行结束。</p><pre><code class="go">import (    &quot;fmt&quot;    &quot;sync&quot;    &quot;time&quot;)var wg sync.WaitGroupfunc download(url string) &#123;    fmt.Println(&quot;start to download&quot;, url)    time.Sleep(time.Second) // 模拟耗时操作    wg.Done()&#125;func main() &#123;    for i := 0; i &lt; 3; i++ &#123;        wg.Add(1)        go download(&quot;a.com/&quot; + string(i+&#39;0&#39;))    &#125;    wg.Wait()    fmt.Println(&quot;Done!&quot;)&#125;</code></pre><ul><li>wg.Add(1)：为 wg 添加一个计数，wg.Done()，减去一个计数。</li><li>go download()：启动新的协程并发执行 download 函数。</li><li>wg.Wait()：等待所有的协程执行结束。</li></ul><pre><code class="bash">$  time go run .start to download a.com/2start to download a.com/0start to download a.com/1Done!real    0m1.563s</code></pre><p>可以看到串行需要 3s 的下载操作，并发后，只需要 1s。</p><h3 id="7-2-channel"><a href="#7-2-channel" class="headerlink" title="7.2 channel"></a>7.2 channel</h3><pre><code class="go">var ch = make(chan string, 10) // 创建大小为 10 的缓冲信道func download(url string) &#123;    fmt.Println(&quot;start to download&quot;, url)    time.Sleep(time.Second)    ch &lt;- url // 将 url 发送给信道&#125;func main() &#123;    for i := 0; i &lt; 3; i++ &#123;        go download(&quot;a.com/&quot; + string(i+&#39;0&#39;))    &#125;    for i := 0; i &lt; 3; i++ &#123;        msg := &lt;-ch // 等待信道返回消息。        fmt.Println(&quot;finish&quot;, msg)    &#125;    fmt.Println(&quot;Done!&quot;)&#125;</code></pre><p>使用 channel 信道，可以在协程之间传递消息。阻塞等待并发协程返回消息。</p><pre><code class="bash">$ time go run .start to download a.com/2start to download a.com/0start to download a.com/1finish a.com/2finish a.com/1finish a.com/0Done!real    0m1.528s</code></pre><h2 id="8-单元测试-unit-test"><a href="#8-单元测试-unit-test" class="headerlink" title="8 单元测试(unit test)"></a>8 单元测试(unit test)</h2><p>假设我们希望测试 package main 下 <code>calc.go</code> 中的函数，要只需要新建 <code>calc_test.go</code> 文件，在<code>calc_test.go</code>中新建测试用例即可。</p><pre><code class="go">// calc.gopackage mainfunc add(num1 int, num2 int) int &#123;    return num1 + num2&#125;</code></pre><pre><code class="go">// calc_test.gopackage mainimport &quot;testing&quot;func TestAdd(t *testing.T) &#123;    if ans := add(1, 2); ans != 3 &#123;        t.Error(&quot;add(1, 2) should be equal to 3&quot;)    &#125;&#125;</code></pre><p>运行 <code>go test</code>，将自动运行当前 package 下的所有测试用例，如果需要查看详细的信息，可以添加<code>-v</code>参数。</p><pre><code class="bash">$ go test -v=== RUN   TestAdd--- PASS: TestAdd (0.00s)PASSok      example 0.040s</code></pre><h2 id="9-包-Package-和模块-Modules"><a href="#9-包-Package-和模块-Modules" class="headerlink" title="9 包(Package)和模块(Modules)"></a>9 包(Package)和模块(Modules)</h2><h3 id="9-1-Package"><a href="#9-1-Package" class="headerlink" title="9.1 Package"></a>9.1 Package</h3><p>一般来说，一个文件夹可以作为 package，同一个 package 内部变量、类型、方法等定义可以相互看到。</p><p>比如我们新建一个文件 <code>calc.go</code>， <code>main.go</code> 平级，分别定义 add 和 main 方法。</p><pre><code class="go">// calc.gopackage mainfunc add(num1 int, num2 int) int &#123;    return num1 + num2&#125;</code></pre><pre><code class="go">// main.gopackage mainimport &quot;fmt&quot;func main() &#123;    fmt.Println(add(3, 5)) // 8&#125;</code></pre><p>运行 <code>go run main.go</code>，会报错，add 未定义：</p><pre><code class="bash">./main.go:6:14: undefined: add</code></pre><p>因为 <code>go run main.go</code> 仅编译 main.go 一个文件，所以命令需要换成 </p><pre><code class="bash">$ go run main.go calc.go8</code></pre><p>或 </p><pre><code class="bash">$ go run .8</code></pre><p>Go 语言也有 Public 和 Private 的概念，粒度是包。如果类型/接口/方法/函数/字段的首字母大写，则是 Public 的，对其他 package 可见，如果首字母小写，则是 Private 的，对其他 package 不可见。</p><h3 id="9-2-Modules"><a href="#9-2-Modules" class="headerlink" title="9.2 Modules"></a>9.2 Modules</h3><p><a href="https://github.com/golang/go/wiki/Modules">Go Modules</a> 是 Go 1.11 版本之后引入的，Go 1.11 之前使用 $GOPATH 机制。Go Modules 可以算作是较为完善的包管理工具。同时支持代理，国内也能享受高速的第三方包镜像服务。接下来简单介绍 <code>go mod</code> 的使用。Go Modules 在 1.13 版本仍是可选使用的，环境变量 GO111MODULE 的值默认为 AUTO，强制使用 Go Modules 进行依赖管理，可以将 GO111MODULE 设置为 ON。</p><p>在一个空文件夹下，初始化一个 Module</p><pre><code class="bash">$ go mod init examplego: creating new go.mod: module example</code></pre><p>此时，在当前文件夹下生成了<code>go.mod</code>，这个文件记录当前模块的模块名以及所有依赖包的版本。</p><p>接着，我们在当前目录下新建文件 <code>main.go</code>，添加如下代码：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;rsc.io/quote&quot;)func main() &#123;    fmt.Println(quote.Hello())  // Ahoy, world!&#125;</code></pre><p>运行 <code>go run .</code>，将会自动触发第三方包 <code>rsc.io/quote</code>的下载，具体的版本信息也记录在了<code>go.mod</code>中：</p><pre><code class="bash">module examplego 1.13require rsc.io/quote v3.1.0+incompatible</code></pre><p>我们在当前目录，添加一个子 package calc，代码目录如下：</p><pre><code class="bash">demo/   |--calc/      |--calc.go   |--main.go</code></pre><p>在 <code>calc.go</code> 中写入</p><pre><code class="go">package calcfunc Add(num1 int, num2 int) int &#123;    return num1 + num2&#125;</code></pre><p>在 package main 中如何使用 package cal 中的 Add 函数呢？<code>import 模块名/子目录名</code> 即可，修改后的 main 函数如下：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;example/calc&quot;    &quot;rsc.io/quote&quot;)func main() &#123;    fmt.Println(quote.Hello())    fmt.Println(calc.Add(10, 3))&#125;</code></pre><pre><code class="bash">$ go run .Ahoy, world!13</code></pre><h2 id="附-参考"><a href="#附-参考" class="headerlink" title="附 参考"></a>附 参考</h2><ul><li><a href="https://golang.org/">golang 官方文档 - golang.org</a></li><li><a href="https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md">goproxy.cn 文档 - github.com</a></li><li><a href="https://github.com/golang/go/wiki/Modules">Go Modules - github.com</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114701.jpg&quot; alt=&quot;Golang中文教程&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Go（又称Golang）是Go</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Go语言" scheme="https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Go语言程序设计" scheme="https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Go语言教程中文版" scheme="https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%E4%B8%AD%E6%96%87%E7%89%88/"/>
    
  </entry>
  
  <entry>
    <title>Go Mmap 文件内存映射简明教程</title>
    <link href="https://ysluckly.github.io/2022/02/11/go/"/>
    <id>https://ysluckly.github.io/2022/02/11/go/</id>
    <published>2022-02-11T13:59:10.000Z</published>
    <updated>2022-02-20T13:36:11.469Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114728.jpg" alt="golang mmap"></p><h2 id="1-mmap-简介"><a href="#1-mmap-简介" class="headerlink" title="1 mmap 简介"></a>1 mmap 简介</h2><blockquote><p>In computing, mmap is a POSIX-compliant Unix system call that maps files or devices into memory. It is a method of memory-mapped file I/O.<br>– <a href="https://en.wikipedia.org/wiki/Mmap">mmap - wikipedia.org</a></p></blockquote><p>简单理解，mmap 是一种将文件/设备映射到内存的方法，实现文件的磁盘地址和进程虚拟地址空间中的一段虚拟地址的一一映射关系。也就是说，可以在某个进程中通过操作这一段映射的内存，实现对文件的读写等操作。修改了这一段内存的内容，文件对应位置的内容也会同步修改，而读取这一段内存的内容，相当于读取文件对应位置的内容。</p><p>mmap 另一个非常重要的特性是：减少内存的拷贝次数。在 linux 系统中，文件的读写操作通常通过 read 和 write 这两个系统调用来实现，这个过程会产生频繁的内存拷贝。比如 read 函数就涉及了 2 次内存拷贝：</p><ul><li><ol><li>操作系统读取磁盘文件到页缓存；</li></ol></li><li><ol start="2"><li>从页缓存将数据拷贝到 read 传递的 buf 中(例如进程中创建的byte数组)。</li></ol></li></ul><p>mmap 只需要一次拷贝。即操作系统读取磁盘文件到页缓存，进程内部直接通过指针方式修改映射的内存。因此 mmap 特别适合读写频繁的场景，既减少了内存拷贝次数，提高效率，又简化了操作。KV数据库 <a href="https://github.com/etcd-io/bbolt">bbolt</a> 就使用了这个方法持久化数据。</p><h2 id="2-标准库-mmap"><a href="#2-标准库-mmap" class="headerlink" title="2 标准库 mmap"></a>2 标准库 mmap</h2><p>Go 语言标准库 <a href="https://godoc.org/golang.org/x/exp/mmap">golang.org/x/exp/mmap</a> 仅实现了 read 操作，后续能否支持 write 操作未知。使用场景非常有限。看一个简单的例子：</p><p>从第4个byte开始，读取 tmp.txt 2个byte的内容。</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;golang.org/x/exp/mmap&quot;)func main() &#123;    at, _ := mmap.Open(&quot;./tmp.txt&quot;)    buff := make([]byte, 2)    _, _ = at.ReadAt(buff, 4)    _ = at.Close()    fmt.Println(string(buff))&#125;</code></pre><pre><code class="bash">$ echo &quot;abcdefg&quot; &gt; tmp.txt$ go run .ef</code></pre><p>如果使用 <code>os.File</code> 操作，代码几乎是一样的，<code>os.File</code> 还支持写操作 <code>WriteAt</code>：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;os&quot;)func main() &#123;    f, _ := os.OpenFile(&quot;tmp.txt&quot;, os.O_CREATE|os.O_RDWR, 0644)    _, _ = f.WriteAt([]byte(&quot;abcdefg&quot;), 0)    buff := make([]byte, 2)    _, _ = f.ReadAt(buff, 4)    _ = f.Close()    fmt.Println(string(buff))&#125;</code></pre><h2 id="3-mmap-linux"><a href="#3-mmap-linux" class="headerlink" title="3 mmap(linux)"></a>3 mmap(linux)</h2><p>如果要支持 write 操作，那么就需要直接调用 mmap 的系统调用来实现了。Linux 和 Windows 都支持 mmap，但接口有所不同。对于 linux 系统，mmap 方法定义如下：</p><pre><code class="go">func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, err error)</code></pre><p>每个参数的含义分别是：</p><pre><code class="go">- fd：待映射的文件描述符。- offset：映射到内存区域的起始位置，0 表示由内核指定内存地址。- length：要映射的内存区域的大小。- prot：内存保护标志位，可以通过或运算符`|`组合    - PROT_EXEC  // 页内容可以被执行    - PROT_READ  // 页内容可以被读取    - PROT_WRITE // 页可以被写入    - PROT_NONE  // 页不可访问- flags：映射对象的类型，常用的是以下两类    - MAP_SHARED  // 共享映射，写入数据会复制回文件, 与映射该文件的其他进程共享。    - MAP_PRIVATE // 建立一个写入时拷贝的私有映射，写入数据不影响原文件。</code></pre><p>首先定义2个常量和数据类型Demo：</p><pre><code class="go">const defaultMaxFileSize = 1 &lt;&lt; 30        // 假设文件最大为 1Gconst defaultMemMapSize = 128 * (1 &lt;&lt; 20) // 假设映射的内存大小为 128Mtype Demo struct &#123;    file    *os.File    data    *[defaultMaxFileSize]byte    dataRef []byte&#125;func _assert(condition bool, msg string, v ...interface&#123;&#125;) &#123;    if !condition &#123;        panic(fmt.Sprintf(msg, v...))    &#125;&#125;</code></pre><ul><li>内存有换页机制，映射的物理内存可以远小于文件。</li><li>Demo结构体由3个字段构成，file 即文件描述符，data 是映射内存的起始地址，dataRef 用于后续取消映射。</li></ul><p>定义 mmap, grow, ummap 三个方法：</p><pre><code class="go">func (demo *Demo) mmap() &#123;    b, err := syscall.Mmap(int(demo.file.Fd()), 0, defaultMemMapSize, syscall.PROT_WRITE|syscall.PROT_READ, syscall.MAP_SHARED)    _assert(err == nil, &quot;failed to mmap&quot;, err)    demo.dataRef = b    demo.data = (*[defaultMaxFileSize]byte)(unsafe.Pointer(&amp;b[0]))&#125;func (demo *Demo) grow(size int64) &#123;    if info, _ := demo.file.Stat(); info.Size() &gt;= size &#123;        return    &#125;    _assert(demo.file.Truncate(size) == nil, &quot;failed to truncate&quot;)&#125;func (demo *Demo) munmap() &#123;    _assert(syscall.Munmap(demo.dataRef) == nil, &quot;failed to munmap&quot;)    demo.data = nil    demo.dataRef = nil&#125;</code></pre><ul><li>mmap 传入的内存保护标志位为 <code>syscall.PROT_WRITE|syscall.PROT_READ</code>，即可读可写，映射类型为 <code>syscall.MAP_SHARED</code>，即对内存的修改会同步到文件。</li><li><code>syscall.Mmap</code> 返回的是一个切片对象，需要从该切片中获取到内存的起始地址，并转换为可操作的 byte 数组，byte数组的长度为 <code>defaultMaxFileSize</code>。</li><li>grow 用于修改文件的大小，Linux 不允许操作超过文件大小之外的内存地址。例如文件大小为 4K，可访问的地址是<code>data[0~4095]</code>，如果访问 <code>data[10000]</code> 会报错。</li><li>munmap 用于取消映射。</li></ul><p>在文件中写入 <code>hello, geektutu!</code></p><pre><code class="go">func main() &#123;    _ = os.Remove(&quot;tmp.txt&quot;)    f, _ := os.OpenFile(&quot;tmp.txt&quot;, os.O_CREATE|os.O_RDWR, 0644)    demo := &amp;Demo&#123;file: f&#125;    demo.grow(1)    demo.mmap()    defer demo.munmap()    msg := &quot;hello geektutu!&quot;    demo.grow(int64(len(msg) * 2))    for i, v := range msg &#123;        demo.data[2*i] = byte(v)        demo.data[2*i+1] = byte(&#39; &#39;)    &#125;&#125;</code></pre><ul><li>在调用 <code>mmap</code> 之前，调用了 <code>grow(1)</code>，因为在 <code>mmap</code> 中使用 <code>&amp;b[0]</code> 获取到映射内存的起始地址，所以文件大小至少为 1 byte。</li><li>接下来，便是通过直接操作 <code>demo.data</code>，修改文件内容了。</li></ul><p>运行：</p><pre><code class="bash">$ go run .$ cat tmp.txth e l l o   g e e k t u t u !</code></pre><h2 id="4-mmap-Windows"><a href="#4-mmap-Windows" class="headerlink" title="4 mmap(Windows)"></a>4 mmap(Windows)</h2><p>相对于 Linux，Windows 上 mmap 的使用要复杂一些。</p><pre><code class="go">func (demo *Demo) mmap() &#123;    h, err := syscall.CreateFileMapping(syscall.Handle(demo.file.Fd()), nil, syscall.PAGE_READWRITE, 0, defaultMemMapSize, nil)    _assert(h != 0, &quot;failed to map&quot;, err)    addr, err := syscall.MapViewOfFile(h, syscall.FILE_MAP_WRITE, 0, 0, uintptr(defaultMemMapSize))    _assert(addr != 0, &quot;MapViewOfFile failed&quot;, err)    err = syscall.CloseHandle(syscall.Handle(h));    _assert(err == nil, &quot;CloseHandle failed&quot;)    // Convert to a byte array.    demo.data = (*[defaultMaxFileSize]byte)(unsafe.Pointer(addr))&#125;func (demo *Demo) munmap() &#123;    addr := (uintptr)(unsafe.Pointer(&amp;demo.data[0]))    _assert(syscall.UnmapViewOfFile(addr) == nil, &quot;failed to munmap&quot;)&#125;</code></pre><ul><li>需要 <code>CreateFileMapping</code> 和 <code>MapViewOfFile</code> 两步才能完成内存映射。<code>MapViewOfFile</code> 返回映射成功的内存地址，因此可以直接将该地址转换成 byte 数组。</li><li>Windows 对文件的大小没有要求，直接操作内存<code>data</code>，文件大小会自动发生改变。</li></ul><p>使用时无需关注文件的大小。</p><pre><code class="go">func main() &#123;    _ = os.Remove(&quot;tmp.txt&quot;)    f, _ := os.OpenFile(&quot;tmp.txt&quot;, os.O_CREATE|os.O_RDWR, 0644)    demo := &amp;Demo&#123;file: f&#125;    demo.mmap()    defer demo.munmap()    msg := &quot;hello geektutu!&quot;    for i, v := range msg &#123;        demo.data[2*i] = byte(v)        demo.data[2*i+1] = byte(&#39; &#39;)    &#125;&#125;</code></pre><pre><code class="go">$ go run .$ cat .\tmp.txth e l l o   g e e k t u t u !</code></pre><h2 id="附-参考"><a href="#附-参考" class="headerlink" title="附 参考"></a>附 参考</h2><ul><li><a href="https://github.com/edsrzf/mmap-go">edsrzf/mmap-go - github.com</a></li><li><a href="https://golang.org/pkg/syscall/">golang 官方文档 syscall - golang.org</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114728.jpg&quot; alt=&quot;golang mmap&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-mmap-简介&quot;&gt;&lt;a href=&quot;#1</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="golang" scheme="https://ysluckly.github.io/tags/golang/"/>
    
    <category term="mmap" scheme="https://ysluckly.github.io/tags/mmap/"/>
    
    <category term="memory mapping" scheme="https://ysluckly.github.io/tags/memory-mapping/"/>
    
    <category term="windows" scheme="https://ysluckly.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Go全栈面试题（5）-网络编程面试题</title>
    <link href="https://ysluckly.github.io/2022/02/03/golang/"/>
    <id>https://ysluckly.github.io/2022/02/03/golang/</id>
    <published>2022-02-03T07:29:32.000Z</published>
    <updated>2022-02-26T05:52:02.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络面试题"><a href="#网络面试题" class="headerlink" title="网络面试题"></a><a href="https://blog.csdn.net/yang731227/article/details/90637577"></a>网络面试题</h1><h2 id="说一下五层协议"><a href="#说一下五层协议" class="headerlink" title="说一下五层协议"></a><a href="https://blog.csdn.net/yang731227/article/details/90637577"></a>说一下五层协议</h2><ul><li><p>  <strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</p></li><li><p>  <strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</p></li><li><p>  <strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</p></li><li><p>  <strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p></li><li><p>  <strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p></li></ul><h2 id="ISO七层模型中表示层和会话层功能是什么？"><a href="#ISO七层模型中表示层和会话层功能是什么？" class="headerlink" title="ISO七层模型中表示层和会话层功能是什么？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637577"></a>ISO七层模型中表示层和会话层功能是什么？</h2><ul><li><p>  <strong>表示层</strong> ：数据压缩、加密以及数据描述。这使得应用程序不必担心在各台主机中表示/存储的内部格式（二进制、ASCII，比如乱码）不同的问题。</p></li><li><p>  <strong>会话层</strong> ：建立会话，如session认证、断点续传。通信的应用程序之间建立、维护和释放面向用户的连接。通信的应用程序之间建立会话，需要传输层建立1个或多个连接。（…后台运行的木马，netstat -n）</p></li><li><p>  说明：五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p></li></ul><h2 id="数据在各层之间的传递过程是怎么样的？"><a href="#数据在各层之间的传递过程是怎么样的？" class="headerlink" title="数据在各层之间的传递过程是怎么样的？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637577"></a>数据在各层之间的传递过程是怎么样的？</h2><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p><ol><li> 路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。</li><li> 交换机只有下面两层协议</li></ol><p><img src="https://www.github.com/Clown95/StroyBack/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1557998586831.png"></p><h2 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a><a href="https://blog.csdn.net/yang731227/article/details/90637577"></a>TCP/IP四层模型</h2><p>它只有四层，相当于五层协议中<strong>数据链路层和物理层合并为网络接口层</strong>。</p><p>现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p><img src="https://www.github.com/Clown95/StroyBack/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1557998595514.png"><br>TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。</p><p><img src="https://www.github.com/Clown95/StroyBack/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1557998604507.png"></p><h2 id="TCP-和-UDP-有什么区别-适用场景？"><a href="#TCP-和-UDP-有什么区别-适用场景？" class="headerlink" title="TCP 和 UDP 有什么区别,适用场景？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637577"></a>TCP 和 UDP 有什么区别,适用场景？</h2><ul><li><p>  TCP 是面向连接的，UDP 是面向无连接的；故 TCP 需要建立连接和断开连接，UDP 不需要。</p></li><li><p>  TCP 是流协议，UDP 是数据包协议；故 TCP 数据没有大小限制，UDP 数据报有大小限制（UDP 协议本身限制、数据链路层的 MTU、缓存区大小）。</p></li><li><p>  TCP 是可靠协议，UDP 是不可靠协议；故 TCP 会处理数据丢包重发以及乱序等情况，UDP 则不会处理。</p></li></ul><p><code>UDP 的特点及使用场景</code>:</p><p>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务，随时都可以发送数据，处理简单且高效，经常用于以下场景：</p><p>包总量较小的通信（DNS、SNMP）</p><p>视频、音频等多媒体通信（即时通信）</p><p>广播通信</p><p><code>TCP 的特点及使用场景</code>:</p><p>相对于 UDP，TCP 实现了数据传输过程中的各种控制，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p><p>在对可靠性要求较高的情况下，可以使用 TCP，即不考虑 UDP 的时候，都可以选择 TCP。</p><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a><a href="https://blog.csdn.net/yang731227/article/details/90637577"></a>TCP三次握手</h2><p><img src="https://www.github.com/Clown95/StroyBack/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1557998685963.png"></p><p><strong>假设 A 为客户端，B 为服务器端。</strong></p><ul><li>  首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>  A 向 B 发送连接请求报文段，SYN=1，ACK=0，选择一个初始的序号 seq = x。</li><li>  B 收到连接请求报文段，如果同意建立连接，则向 A 发送连接确认报文段，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 seq = y。</li><li>  A 收到 B 的连接确认报文段后，还要向 B 发出确认，确认号为 ack = y+1，序号为 seq = x+1。</li><li>  A 的 TCP 通知上层应用进程，连接已经建立。</li><li>  B 收到 A 的确认后，连接建立。</li><li>  B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立。</li></ul><h2 id="为什么TCP连接需要三次握手，两次不可以吗，为什么？"><a href="#为什么TCP连接需要三次握手，两次不可以吗，为什么？" class="headerlink" title="为什么TCP连接需要三次握手，两次不可以吗，为什么？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637577"></a>为什么TCP连接需要三次握手，两次不可以吗，为什么？</h2><p><strong>为了防止已失效的连接请求报文段突然又传送到了服务端，占用服务器资源。 （假设主机A为客户端，主机B为服务器端）</strong></p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a><a href="https://blog.csdn.net/yang731227/article/details/90637577"></a>四次挥手</h2><p><img src="https://www.github.com/Clown95/StroyBack/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1558076126352.png"></p><p>数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP连接。</p><ul><li>  A 把连接释放报文段首部的 FIN = 1，其序号 seq = u，等待 B 的确认。</li><li>  B 发出确认，确认号 ack = u+1，而这个报文段自己的序号 seq = v。（TCP 服务器进程通知高层应用进程）。</li><li>  从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。A 不能向 B 发送数据；B 若发送数据，A 仍要接收。</li><li>  当 B 不再需要连接时，发送连接释放请求报文段，FIN=1。</li><li>  A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（2*2 = 4 mins）时间后释放连接。</li><li>  B 收到 A 的确认后释放连接。</li></ul><h2 id="四次挥手的原因？"><a href="#四次挥手的原因？" class="headerlink" title="四次挥手的原因？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637577"></a>四次挥手的原因？</h2><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><h2 id="如何保证可靠传输？"><a href="#如何保证可靠传输？" class="headerlink" title="如何保证可靠传输？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637577"></a>如何保证可靠传输？</h2><ul><li>  应用数据被分割成TCP认为最适合发送的数据块。</li><li>  <strong>超时重传</strong>：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li><li>  TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li>  <strong>校验和</strong>：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。</li><li>  TCP的接收端会丢弃重复的数据。</li><li>  <strong>流量控制</strong>：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的我数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li><li>  <strong>拥塞控制</strong>：当网络拥塞时，减少数据的发送。</li></ul><h2 id="如何区分流量控制和拥塞控制-？"><a href="#如何区分流量控制和拥塞控制-？" class="headerlink" title="如何区分流量控制和拥塞控制 ？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637577"></a>如何区分流量控制和拥塞控制 ？</h2><ul><li><p>  拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</p></li><li><p>  拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</p></li><li><p>  流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制。</p></li><li><p>  流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p></li><li><p>  流量控制属于通信双方协商；拥塞控制涉及通信链路全局。</p></li><li><p>  流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</p></li><li><p>  实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。</p></li></ul><h2 id="HTTP状态都代表什么？"><a href="#HTTP状态都代表什么？" class="headerlink" title="HTTP状态都代表什么？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637577"></a>HTTP状态都代表什么？</h2><p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table><thead><tr><th>状态码</th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><h2 id="GET和POST的区别？"><a href="#GET和POST的区别？" class="headerlink" title="GET和POST的区别？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637577"></a>GET和POST的区别？</h2><ul><li>  GET 被强制服务器支持</li><li>  浏览器对URL的长度有限制，所以GET请求不能代替POST请求发送大量数据</li><li>  GET请求发送数据更小</li><li>  GET请求是不安全的</li><li>GET请求是幂等的<ul><li>  幂等的意味着对同一URL的多个请求应该返回同样的结果</li></ul></li><li>  POST请求不能被缓存</li><li>POST请求相对GET请求是「安全」的<ul><li>  这里安全的含义仅仅是指是非修改信息</li></ul></li><li>GET用于信息获取，而且是安全的和幂等的.<ul><li>  所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</li></ul></li><li>  POST是用于修改服务器上的资源的请求</li><li>  发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ul><p><strong>引申：说完原理性的问题，我们从表面上来看看GET和POST的区别：</strong></p><ul><li>  GET是从服务器上获取数据，POST是向服务器传送数据。 GET和 POST只是一种传递数据的方式，GET也可以把数据传到服务器，他们的本质都是发送请求和接收结果。只是组织格式和数据量上面有差别，http协议里面有介绍</li><li>  GET是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。POST是通过HTTP POST机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。 因为GET设计成传输小数据，而且最好是不修改服务器的数据，所以浏览器一般都在地址栏里面可以看到，但POST一般都用来传递大数据，或比较隐私的数据，所以在地址栏看不到，能不能看到不是协议规定，是浏览器规定的。</li><li>  对于GET方式，服务器端用Request.QueryString获取变量的值，对于POST方式，服务器端用Request.Form获取提交的数据。 没明白，怎么获得变量和你的服务器有关，和GET或POST无关，服务器都对这些请求做了封装</li><li>  GET传送的数据量较小，不能大于2KB。POST传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。 POST基本没有限制，我想大家都上传过文件，都是用POST方式的。只不过要修改form里面的那个type参数</li><li>  GET安全性非常低，POST安全性较高。 如果没有加密，他们安全级别都是一样的，随便一个监听器都可以把所有的数据监听到。</li></ul><h2 id="如何理解HTTP协议是无状态的"><a href="#如何理解HTTP协议是无状态的" class="headerlink" title="如何理解HTTP协议是无状态的?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637577"></a>如何理解HTTP协议是无状态的?</h2><p>HTTP协议是无状态的（stateless），指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。<br>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。</p><p>缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p><h2 id="Cookie-与-Session-选择"><a href="#Cookie-与-Session-选择" class="headerlink" title="Cookie 与 Session 选择"></a><a href="https://blog.csdn.net/yang731227/article/details/90637577"></a>Cookie 与 Session 选择</h2><ul><li>  Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session；</li><li>  Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>  对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li></ul><h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637577"></a>HTTP和HTTPS的区别?</h2><ul><li>  http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。</li><li>  https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。</li><li>  https协议需要到ca申请证书，一般免费证书很少，需要交费。</li><li>  http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议</li><li>  http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。</li><li>  http的连接很简单,是无状态的</li><li>  HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全</li></ul><p>本文转自 <a href="https://blog.csdn.net/yang731227/article/details/90637577">https://blog.csdn.net/yang731227/article/details/90637577</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络面试题&quot;&gt;&lt;a href=&quot;#网络面试题&quot; class=&quot;headerlink&quot; title=&quot;网络面试题&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn.net/yang731227/article/details/90637577&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="网络编程" scheme="https://ysluckly.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="面试题" scheme="https://ysluckly.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Go语言练习题</title>
    <link href="https://ysluckly.github.io/2022/02/02/golang/"/>
    <id>https://ysluckly.github.io/2022/02/02/golang/</id>
    <published>2022-02-02T07:29:32.000Z</published>
    <updated>2022-02-26T05:51:18.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go基础编程"><a href="#Go基础编程" class="headerlink" title="Go基础编程"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>Go基础编程</h1><h2 id="Go初体验"><a href="#Go初体验" class="headerlink" title="Go初体验"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>Go初体验</h2><ol><li><p> 熟悉go的编译环境已经编译过程，根据<code>Hello World</code>输出，拓展打印出自我介绍。</p></li><li><p> 查询资料了解go语言的特点并简单的叙述。</p></li><li><p> 一个包是否可以在一个源文件里面多次引用？</p></li></ol><h2 id="基础结构和类型"><a href="#基础结构和类型" class="headerlink" title="基础结构和类型"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>基础结构和类型</h2><ol><li> 以下变量名有哪些是不合法的?</li></ol><blockquote><p>1a、abc、a&amp;b 、年龄、 var、bool 、public、a2 、2#、a2_1、f unction、class、new</p></blockquote><ol start="2"><li> 以下变量声明哪些条款是正确的？</li></ol><pre><code>    var i =1    var i int    var i = int    i := 1    i = 1</code></pre><ol start="3"><li> 阅读以下代码，写出输出结果。</li></ol><pre><code>package mainimport &quot;fmt&quot;func main()&#123;    var a int =10    fmt.Println(a)    &#123;        a:=9        fmt.Println(a)    &#125;    fmt.Println(a)&#125;</code></pre><ol start="4"><li><p> 编程实现：使用<code>itoa</code>和<code>const</code>，定义一周的数值，如Monday=1 ，Tuesday=2，依次类推Sunday=7。</p></li><li><p> 编程实现：实现字符串”123”和整数123之间的互转，并格式化输出他们转换后的类型和值。</p></li><li><p> 编程实现：使用类型别名，让go语言支持中文关键字，如 <code>int</code>可以用<code>整数型</code>替代。</p></li></ol><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>输入输出</h2><ol><li><p> 编程实现：声明一组变量:姓名(Name)，年龄(Age)，籍贯(From)，专业(Major),从控制台接收内容并赋值给这些变量，最后输出这些变量的值。</p></li><li><p> 简述内置的print和println函数与fmt和log标准库包中相应的打印函数有什么区别？</p></li><li><p> 以下代码，输出结果会出现什么问题？如何解决？</p></li></ol><pre><code>func main() &#123;    for i := 0; i &lt; 5; i++ &#123;        fmt.Println(&quot;请输入一个字符&quot;)        var  code byte        fmt.Scanf(&quot;%c&quot;,&amp;code)        fmt.Println(code)    &#125;&#125;</code></pre><h2 id="表达式与运算符"><a href="#表达式与运算符" class="headerlink" title="表达式与运算符"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>表达式与运算符</h2><ol><li><p> 不依靠程序计算 <code>(1+6)/2*4^2+10%3&lt;&lt;2</code>的值</p></li><li><p> 写出下面代码输出的内容(%4b是4位二进制)。</p></li></ol><pre><code>const(    read byte=1 &lt;&lt; iota    write    exec    freeze)func main()&#123;    a:=read|write|freeze    b:=read|freeze|exec    c:= a &amp;^b    fmt.Printf(&quot;%4b &amp;^ %4b= %04b\n&quot;, a, b, c)&#125;</code></pre><ol start="3"><li><p> 编程实现：现有一个四位数, 计算它每位数的和、每位数的乘积 ，并用乘积除以和，输出它们的结果。</p></li><li><p> 什么是byte？什么是rune？ 如何将<code>[]byte</code>和<code>[]rune</code>类型的值转换为字符串？</p></li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>数组</h2><ol><li> 以下不能正确定义数组和赋初值的语句是</li></ol><pre><code>var a=[5]int&#123;1,2,3,4,5&#125;var b=[...]int&#123;1,2,3,4,5&#125;var c[5]int=&#123;1,2,3,4,5&#125;var d=[5]int(2: 4,4:61&#125;</code></pre><ol start="2"><li><p> 编程实现：有一个长度为5的int数组，初始化该数组并计算平均值。</p></li><li><p> 执行以下代码将会出现什么样的结果？怎么让它正确运行？</p></li></ol><pre><code> var arr []int arr[0] =1 fmt.Println(arr[0])</code></pre><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>切片</h2><ol><li> 关于整型切片的初始化，下面正确的有哪些？</li></ol><pre><code>s := make([]int)&#123;1,2,3,4&#125;s := make([]int, 0)s := make([]int, 5, 10)s := []int&#123;1, 2, 3, 4, 5&#125;</code></pre><ol start="2"><li><p>编程实现：花样体操比赛，6个评委打分，运动员的成绩去掉一个最高分，去掉一个最低分，剩下的4个分数的平均分就是最后得分，要求：<br> （1）请把最高分，最低分的评委。（需要考虑存在多个最低分和最高分的情况）<br> （2）找出最佳评委和最差评委。最佳评委是最后得分差距最小，最差评委最后得分差距最大。</p></li><li><p> 编程实现：切片的升序排序，反转，搜索功能。</p></li><li><p> 请简述切片和数组的区别。</p></li></ol><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>Map</h2><ol><li><p> 编程实现：现有字典map1的键是string型，值是int型，初始化为[psw1:123 psw2:456 psw3:789]，要求删除键值对psw2:456，增加键值对psw4:135。</p></li><li><p> 编程实现：实现一个函数,计算字符串的单词的个数，它应该返回一个包含字符串中单词个数的map。</p></li><li><p> 为什么映射元素不可被取地址？</p></li></ol><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>struct</h2><ol><li><p> 编程实现：实现一个同学录，建立学生信息的结构体Student，每个学生的信息包括姓名()、性别、年龄。实现学生信息的添加、修改、删除、查询等功能。</p></li><li><p> go语言中哪些类型的值可以被取地址，哪些不可以被取地址？</p></li><li><p> 罗列出哪些类型不支持比较？</p></li><li><p> 下面的变量a和b相等吗？变量c和d相等吗？</p></li></ol><pre><code>    a := struct&#123;&#125;&#123;&#125;    b := struct&#123;&#125;&#123;&#125;    c := [10]struct&#123;&#125;&#123;&#125;    d := [10]struct&#123;&#125;&#123;&#125;</code></pre><ol start="5"><li><p> 为什么两个nil值有时候会不相等？</p></li><li><p> 简述go语言中make和new的区别。</p></li><li><p> 哪些类型是值类型，那些是引用类型?</p></li><li><p> 以下代码有什么问题，说明原因并修改代码得到预期结果。</p></li></ol><pre><code>type student struct &#123;    Name string    Age  int&#125;func main() &#123;    m := make(map[string]*student)    stus := []student&#123;        &#123;Name: &quot;zhou&quot;, Age: 24&#125;,        &#123;Name: &quot;li&quot;, Age: 23&#125;,        &#123;Name: &quot;wang&quot;, Age: 22&#125;,    &#125;    for _, stu := range stus &#123;        m[stu.Name] = &amp;stu    &#125;    fmt.Println(m)&#125;</code></pre><h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>指针类型</h2><ol><li> 通过指针变量 p 访问其成员变量 name，下面语法正确的哪些？</li></ol><pre><code>p.name(*p).name(&amp;p).namep-&gt;name</code></pre><ol start="2"><li> 填写A行和B行的空白，以确保打印输出为“foo”</li></ol><pre><code>package maintype S struct &#123;    m string&#125;func f() *S &#123;    return __ //A&#125;func main() &#123;    p := __    //B    print(p.m) //print &quot;foo&quot;&#125;</code></pre><ol start="3"><li> 执行以下代码时将打印什么？</li></ol><pre><code>func main() &#123;    s := &quot;123&quot;    ps := &amp;s    b := []byte(*ps)    pb := &amp;b    s += &quot;4&quot;    *ps += &quot;5&quot;    b[1] = &#39;0&#39;    println(*ps,&quot; &quot;,string(*pb))&#125;</code></pre><ol start="4"><li> 解释为什么下面的打印输出是333，并修改A行以确保打印012。</li></ol><pre><code>package mainconst N = 3func main() &#123;    m := make(map[int]*int)    for i := 0; i &lt; N; i++ &#123;        m[i] = &amp;i //A    &#125;    for _, v := range m &#123;        print(*v)    &#125;&#125;</code></pre><ol start="5"><li> 函数返回局部变量的指针是否安全？</li></ol><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>流程控制</h2><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>条件判断</h3><ol><li><p> 编程实现：从控制台输入学生的成绩并判断等级，0-59 不及格，60-79 良好 ，80-100 优秀，使用if 和switch两种方法实现。</p></li><li><p> 编程实现：从键盘接收一个整数，求奖金提成，规则：低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%；高于100万元时，超过100万元的部分按1%提成从键盘输入当月利润，求应发放奖金总数？</p></li><li><p> 编程实现：输入一个字符，判断它如果是小写字母输出其对应的大写字母；如果是大写字母输出其对应的小写字母；如果是数字输出数字本身；如果是空格输出“SPACE”；如果不是上述情况输出“Other”。(可用ASCII码判断)</p></li><li><p> 下面的代码将会输出什么？</p></li></ol><pre><code>package mainimport &quot;fmt&quot;func False() bool &#123;    return false&#125;func main() &#123;    switch False() &#123;    case true:        fmt.Println(&quot;true&quot;)    case false:        fmt.Println(&quot;false&quot;)    &#125;&#125;</code></pre><ol start="5"><li> switch流程控制代码块中的case表达式能重复吗？</li></ol><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>循环结构</h3><ol><li><p> 编程实现：从键盘输入字符串str，使用for range语句遍历该字符串中的每一个字符，并打印输出。</p></li><li><p> 执行以下代码时将打印什么？</p></li></ol><pre><code>package mainimport (    &quot;fmt&quot;)func main() &#123;    s := []int&#123;1, 2, 3&#125;    ss := s[1:]    ss = append(ss, 4)    for _, v := range ss &#123;        v += 10    &#125;    for i := range ss &#123;        ss[i] += 10    &#125;    fmt.Println(s)&#125;</code></pre><ol start="3"><li><p> 编程实现：FizzBuzz是英国学校里常玩的游戏，从1数到100，如果遇见了3的倍数要说Fizz，如果遇见了5的倍数要说Buzz，如果既是3的倍数又是5的倍数要说FizzBuzz。编写一个程序，按游戏要求打印数字1-100。</p></li><li><p> 编程实现：打印出所有的“水仙花数”,所谓“水仙花数”是指一个三位数,其各位数字立方和等于该数本身。例如,153是一个水仙花数,因为153=13+53+33。</p></li><li><p> 编程实现：完成一个猜数字小游戏，要求：当用户输入的数字大于随机数时候，提示用户输入数字大了，反之提示用户数字小了，当用户在5次内都没有猜对，打印正确结果。并且额外添加成绩判定功能，当用户一次猜对结果，评定为S ，当用户在2-3次内猜对结果，评定为A,当用户在4-5次内猜对结果，评定为B, 一次都没有猜中，评定为C。</p></li><li><p> 编程实现：求 5X+2Y+Z=50 的所有非负整数解。</p></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>函数</h2><ol><li><p> 编程实现：已知三角形三边a、b、c,编写函数求三角形面积公式area(),求三角形面积。(三角形面积公式为area=√s(s-a)(s-b)(s-c),s为周长一半)。</p></li><li><p>编程实现：两种匿名函数，要求:<br> (1)函数一，可以传参任意数量的int变量，计算这些参数的和并返回给某个变量。<br> (2)函数二，传参int类型切片，计算切片内元素的和并返给某个变量。</p></li><li><p> 编程实现：完成函数fac()，使用递归调用计算n的阶乘。</p></li><li><p> 编程实现：函数FindInt()，功能：实现从一个指定位置找出字节切片中的整型数字，并返回该整数和下一个数的索引数的索引位置。（提示：使用ASCII码判断）</p></li><li><p> 以下代码,最终打印的结果是什么？</p></li></ol><pre><code>package mainimport &quot;fmt&quot;func main() &#123;    defer fmt.Println(1)    defer fmt.Println(2)    fmt.Println(3)    defer fmt.Println(4)&#125;</code></pre><ol start="6"><li><p> 简述当多个包中含有init()函数，它的执行顺序是什么？</p></li><li><p> 假设声明x并且未声明y，则下面哪些声明是正确的？</p></li></ol><pre><code>x, _ := f()x, _ = f()x, y := f()x, y = f()</code></pre><ol start="8"><li><p> 简要描述go中的main和init函数的区别。</p></li><li><p> 简述下闭包的生命周期和作用范围。</p></li></ol><h2 id="go面向对象"><a href="#go面向对象" class="headerlink" title="go面向对象"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>go面向对象</h2><ol><li><p> go语言是一个面向对象语言吗？</p></li><li><p>编程实现：定义一个People结构体，具有姓名(name)、年龄(age)、性别（Sex）等属性。要求：<br> （1）封装set() 和get()函数,主要功能是设置Person对象属性和得到Person对象的属性，访问权限设置为私有<br> （2）封装Show()函数，主要功能是打印Person对象信息，访问权限设置为公共。</p></li><li><p> 编程实现：定义 Student结构体，继承上题的People结构体,并添加学号和专业等属性。并且设置Student的 set()、get()和Show()函数。</p></li><li><p> 编程实现：定义一个任意类型键值对的Map,初始化并打印该Map,使用空接口 interface{}定义键值对数据类型。</p></li><li><p> 编程实现：有一批图书,每本书有书名(name)、作者( author)、书号(isdn)、出版日期(date)4项数据,希望既可以通过书名查询,也可以使用作者或书号来查询图书。编写方法来实现此功能,如果查到,打印出此书的书名、作者、书号和出版日期信息。如果查不到此书,则打印出“无此书”。</p></li><li><p> 对任意的非指针和非接口定义类型T，为什么类型*T的方法集总是类型T的方法集的超集，但是反之却不然？</p></li><li><p> 以下代码编译能否通过？为什么？</p></li></ol><pre><code>package mainimport (    &quot;fmt&quot;)type People interface &#123;    Speak(string) string&#125;type Stduent struct&#123;&#125;func (stu *Stduent) Speak(think string) (talk string) &#123;    if think == &quot;good&quot; &#123;        talk = &quot;You are a good boy&quot;    &#125; else &#123;        talk = &quot;hi&quot;    &#125;    return&#125;func main() &#123;    var peo People = Stduent&#123;&#125;    think := &quot;good&quot;    fmt.Println(peo.Speak(think))&#125;</code></pre><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>类型断言</h2><ol><li> 下面的代码是否能够正确运行？如果不能请修改代码。</li></ol><pre><code>package mainimport &quot;fmt&quot;func echoArray(a interface&#123;&#125;)&#123;　　for _,v:=range a&#123;　　　　fmt.Print(v,&quot; &quot;)　　&#125;　　fmt.Println()　　return&#125;func main()&#123;　　a:=[]int&#123;2,1,3,5,4&#125;　　echoArray(a)&#125;</code></pre><ol start="2"><li> 定义一个容量为8的空接口 Slice,并进行初始化,然后使用 Comma-ok断言推断,Slice中各元素的数据类型。</li></ol><h1 id="Go软件工程"><a href="#Go软件工程" class="headerlink" title="Go软件工程"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>Go软件工程</h1><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>异常处理</h2><ol><li> 执行以下代码时将打印什么？</li></ol><pre><code>package mainfunc f1() &#123;    defer println(&quot;f1-begin&quot;)    f2()    defer println(&quot;f1-end&quot;)&#125;func f2() &#123;    defer println(&quot;f2-begin&quot;)    f3()    defer println(&quot;f2-end&quot;)&#125;func f3() &#123;    defer println(&quot;f3-begin&quot;)    panic(0)    defer println(&quot;f3-end&quot;)&#125;func main() &#123;    f1()&#125;</code></pre><ol start="2"><li> 执行以下代码时将打印什么？退出代码是什么?</li></ol><pre><code>package mainimport &quot;log&quot;func f() &#123;    defer func() &#123;        if r := recover() r != nil &#123;            log.Printf(&quot;recover:%#v&quot;, r)        &#125;    &#125;()    panic(1)    panic(2)&#125;func main() &#123;    f()&#125;</code></pre><ol start="3"><li><p> 使用panic 和 recover机制编写一个检测用户账号合法性的程序，比如用户中不能出现空格，不能出现非法字符，比如‘，’、’#’、’!’等。</p></li><li><p>关于异常设计，下面说法正确的是（）<br> A. 在程序开发阶段，坚持速错，让程序异常崩溃<br> B. 在程序部署后，应恢复异常避免程序终止<br> C. 一切皆错误，不用进行异常设计<br> D. 对于不应该出现的分支，使用异常处理</p></li><li><p> 罗列出在go语言中哪些行为会触发异常，不少于3种。</p></li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>测试</h2><ol><li><p> 每个测试文件必须以什么结尾？每个测试文件必须导入什么包？功能测试函数必须以什么开头？</p></li><li><p> 要执行压力测试需要带上什么参数？</p></li><li><p> 在压力测试用例中,要在循环体内使用什么?以使测试可以正常的运行。</p></li></ol><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>标准库</h2><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>字符串操作</h3><ol><li><p> 使用go语言实现网络流传价值一个亿Python的AI代码。</p></li><li><p> 通过键盘输入英文字符串,并统计字符串中的英文字母的个数,同时输出字符串字节长度.</p></li></ol><h3 id="时间与日期"><a href="#时间与日期" class="headerlink" title="时间与日期"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>时间与日期</h3><ol><li><p> 有字符串”2020-10-1 22:00:00”,要求：把该字符串解析为Time格式，并计算和今天的时差。（注意时区）</p></li><li><p> 函数调用time.Sleep(d)和数据通道接收&lt;-time.After(d)操作之间有何区别？</p></li></ol><h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>flag</h3><ol><li> 填写A行和B行的空白，解析ip和port的终端参数，默认值为0.0.0.0和8000。</li></ol><pre><code>package mainimport &quot;flag&quot;import &quot;fmt&quot;var ip stringvar port intfunc init() &#123;    // A    // B&#125;func main() &#123;    flag.Parse()    fmt.Printf(&quot;%s:%d&quot;, ip, port)&#125;</code></pre><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>文件操作</h3><ol><li><p> 使用Flag包，从控制台接收参数，完成文件的创建，写入，读取，删除 ，拷贝等操作。</p></li><li><p> 编程实现：使用Go语言动态打印歌词，假设有以下类似lrc歌词文件，读取lrc文件，根据<code>[]</code>里面的时间动态的输出歌词。</p></li></ol><pre><code>[00:00.00]青花瓷 - 周杰伦[00:20.89]素胚勾勒出青花笔锋浓转淡[00:25.58]瓶身描绘的牡丹一如你初妆[00:29.96]冉冉檀香透过窗心事我了然[00:34.43]宣纸上 走笔至此搁一半[00:38.99]釉色渲染仕女图韵味被私藏[00:43.33]而你嫣然的一笑如含苞待放[00:47.80]你的美一缕飘散[00:50.27]去到我去不了的地方[00:56.40]天青色等烟雨 而我在等你[01:00.43]炊烟袅袅升起 隔江千万里[01:05.34]在瓶底书汉隶仿前朝的飘逸[01:09.37]就当我为遇见你伏笔</code></pre><h2 id="JSON解析"><a href="#JSON解析" class="headerlink" title="JSON解析"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>JSON解析</h2><ol><li> 假设我们有如下一个结构体student，及其一个实例对象st,现在我们需要把这个结构体的一个对象st转换为JSON格式。</li></ol><pre><code>type Student struct &#123;    StuID   string    Name    string    Age     int    Classes []string    money   float32&#125;st := &amp;Student &#123;    &quot;Go0001&quot;    &quot;Xiao Ming&quot;,    20,    []string&#123;&quot;Math&quot;, &quot;English&quot;, &quot;Chinese&quot;&#125;,     99.99,&#125;</code></pre><ol start="2"><li> 编程实现：根据现有的Api ( <a href="https://www.sojson.com/blog/305.html">https://www.sojson.com/blog/305.html</a> ），制作天气预报表,表格打印可以使用<code>github.com/modood/table</code> 库</li></ol><blockquote><p>注意因为接口有访问限制，如果你不太熟悉，建议把json返回信息先保存在文本中测试</p></blockquote><pre><code>查询的城市：北京┌────────────────┬─────────┬────────────────┬────────────────┬────────┬─────┬───────────┬────────┬────────┬──────────────────────────────────────┐│ Date           │ Sunrise │ High           │ Low            │ Sunset │ Aqi │ Fx        │ Fl     │ Type   │ Notice                               │├────────────────┼─────────┼────────────────┼────────────────┼────────┼─────┼───────────┼────────┼────────┼──────────────────────────────────────┤│ 28日星期一     │ 04:51   │ 高温 30.0℃     │ 低温 16.0℃     │ 19:33  │ 51  │ 西北风    │ 4-5级  │ 晴     │ 愿你拥有比阳光明媚的心情             ││ 29日星期二     │ 04:50   │ 高温 30.0℃     │ 低温 16.0℃     │ 19:34  │ 49  │ 西风      │ &lt;3级   │ 多云   │ 阴晴之间，谨防紫外线侵扰             ││ 30日星期三     │ 04:50   │ 高温 33.0℃     │ 低温 19.0℃     │ 19:34  │ 39  │ 西南风    │ &lt;3级   │ 晴     │ 愿你拥有比阳光明媚的心情             ││ 31日星期四     │ 04:49   │ 高温 34.0℃     │ 低温 20.0℃     │ 19:35  │ 41  │ 西南风    │ &lt;3级   │ 晴     │ 愿你拥有比阳光明媚的心情             ││ 01日星期五     │ 04:49   │ 高温 35.0℃     │ 低温 20.0℃     │ 19:36  │ 74  │ 西南风    │ &lt;3级   │ 晴     │ 愿你拥有比阳光明媚的心情             │└────────────────┴─────────┴────────────────┴────────────────┴────────┴─────┴───────────┴────────┴────────┴──────────────────────────────────────</code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>正则表达式</h2><ol><li> 编程实现：使用正则表达式提取以下文本中的 邮箱账号 手机号 和网址</li></ol><pre><code>qq1234@qq.com|1802188880$http:\\wwww.baidu.com</code></pre><ol start="2"><li> 编程实现：实现一个简单的爬虫程序，爬取百度<code>go语言</code>关键字的搜索结果，使用正则表达式获取每个结果的超链接地址。</li></ol><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>反射</h2><ol><li> 编程实现：List是个切片类型(List := make([]interface{},3)，现有以下的数据，要求使用反射筛选出各类型的数据。</li></ol><pre><code>List[0] =&quot;123&quot;List[1] =13579List[2] =20.2List[3] =Person&#123;&quot;小明&quot;,18&#125;</code></pre><ol start="2"><li><p> 编程实现：每个学生的信息包括学号(num)、姓名(name)、性别(sex)、成绩( score),请定义学生信息结构体对象 student,并初始化。最后要求使用反射原理修改学生基本信息,并输出修改后的结果。</p></li><li><p> 解释为什么打印输出是<code>false</code>？修改A行以确保打印输出<code>true</code>。</p></li></ol><pre><code>package mainimport (    &quot;fmt&quot;    &quot;reflect&quot;)type S struct &#123;    a, b, c string&#125;func main() &#123;    x := interface&#123;&#125;(&amp;S&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;)    y := interface&#123;&#125;(&amp;S&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;)    fmt.Println( x == y) //A&#125;</code></pre><h2 id="go并发与通信"><a href="#go并发与通信" class="headerlink" title="go并发与通信"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>go并发与通信</h2><h3 id="协程goroutine"><a href="#协程goroutine" class="headerlink" title="协程goroutine"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>协程goroutine</h3><ol><li><p> 简述 线程和协程之间的区别。</p></li><li><p> 编程实现：协程交替执行,使其能顺序输出1-20的自然数。</p></li><li><p> 如何限制goroutine的创建数量？</p></li><li><p> 如何等待所有goroutine的退出？</p></li><li><p> goroutine是怎么样调度的？</p></li></ol><h3 id="通道channel"><a href="#通道channel" class="headerlink" title="通道channel"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>通道channel</h3><ol><li><p> 编程实现：使用channel实现斐波那契数列。</p></li><li><p> 编程实现：使用for循环10次，打印出计数器i的值，要求：main调用的函数是一个goroutine并且使用channel通讯，不用关心goroutine是如何停止的。</p></li><li><p> 编程实现：对上面一题进行拓展，使用两个channel和select，另一个channel用于状态判断，实程序正常运行。</p></li><li><p> select可以用于什么?</p></li><li><p> 无缓冲和缓冲通道之间有什么区别？</p></li><li><p>关于channel的特性，下面说法正确的是（）<br> A. 给一个 nil channel 发送数据，造成永远阻塞<br> B. 从一个 nil channel 接收数据，造成永远阻塞<br> C. 给一个已经关闭的 channel 发送数据，引起 panic<br> D. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值<br> E. 无缓冲的channel和有缓冲的channel都是非同步的<br> F. 无缓冲的channel是同步的，而有缓冲的channel是非同步的</p></li><li><p> goroutine的泄漏怎么处理？</p></li></ol><h3 id="锁与同步"><a href="#锁与同步" class="headerlink" title="锁与同步"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>锁与同步</h3><ol><li> 执行以下代码时将打印什么？并解决问题以确保<code>len（m）</code>打印为10。</li></ol><pre><code>package mainimport (    &quot;sync&quot;)const N = 10func main() &#123;    m := make(map[int]int)    wg := &amp;sync.WaitGroup&#123;&#125;    mu := &amp;sync.Mutex&#123;&#125;    wg.Add(N)    for i := 0; i &lt; N; i++ &#123;        go func() &#123;            defer wg.Done()            mu.Lock()            m[i] = i            mu.Unlock()        &#125;()    &#125;    wg.Wait()    println(len(m))&#125;</code></pre><ol start="2"><li> 编程实现：使用读写锁实现一个安全Map,下面代码是安全Map的实现，要求：实现这个Map的 存储操作 获取操作 删除操作 遍历Map</li></ol><pre><code>type SynchronizedMap struct &#123;    rw *sync.RWMutex    data map[interface&#123;&#125;]interface&#123;&#125;&#125;</code></pre><ol start="3"><li> 如何实现消息队列（多生产者，多消费者）？</li></ol><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a><a href="https://blog.csdn.net/yang731227/article/details/90637411"></a>原子操作</h3><ol><li><p> 编程实现：使用add原子操作来并发地递增一个int32值。创建1000个新协程。每个新协程将整数n的值增加1。 原子操作保证这1000个新协程之间不会发生数据竞争，最终程序打印1000。</p></li><li><p> 什么是乐观锁？什么是悲观锁？各自的应用场景是什么?</p></li><li><p> 赋值是原子操作吗？</p></li><li><p> 64位整数值的地址是否能保证总是64位对齐的，以便可以被安全地原子访问？</p></li></ol><p>本文转自 <a href="https://blog.csdn.net/yang731227/article/details/90637411">https://blog.csdn.net/yang731227/article/details/90637411</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go基础编程&quot;&gt;&lt;a href=&quot;#Go基础编程&quot; class=&quot;headerlink&quot; title=&quot;Go基础编程&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn.net/yang731227/article/details/90637411&quot;&gt;</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Go总结" scheme="https://ysluckly.github.io/tags/Go%E6%80%BB%E7%BB%93/"/>
    
    <category term="Go练习题" scheme="https://ysluckly.github.io/tags/Go%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>休闲娱乐-小游戏</title>
    <link href="https://ysluckly.github.io/2022/02/02/gamesh/"/>
    <id>https://ysluckly.github.io/2022/02/02/gamesh/</id>
    <published>2022-02-01T17:00:10.000Z</published>
    <updated>2022-02-20T13:54:25.410Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>休闲小游戏是小游戏的一种。一般都是在看技术博客累的时候玩的，后来发展成网页游戏。并成为网络游戏集，并加以利用加入网络等元素，可以和网友进行比拼，使得休闲小游戏得以发展。</p></blockquote><h4 id="①、2048-小游戏-点击进入…"><a href="#①、2048-小游戏-点击进入…" class="headerlink" title="①、2048-小游戏 | 点击进入…"></a>①、2048-小游戏 | <a href="https://ysluckly.github.io/games/2048/index.html">点击进入…</a></h4><h4 id="②、五子棋-小游戏-点击进入…"><a href="#②、五子棋-小游戏-点击进入…" class="headerlink" title="②、五子棋- 小游戏 | 点击进入…"></a>②、五子棋- 小游戏 | <a href="https://ysluckly.github.io/games/gobang/index.html">点击进入…</a></h4><h4 id="③、圈小猫-小游戏-点击进入…"><a href="#③、圈小猫-小游戏-点击进入…" class="headerlink" title="③、圈小猫-小游戏 | 点击进入…"></a>③、圈小猫-小游戏 | <a href="https://ysluckly.github.io/games/cat/index.html">点击进入…</a></h4><h4 id="④、3D元素周期表-小游戏-点击进入…"><a href="#④、3D元素周期表-小游戏-点击进入…" class="headerlink" title="④、3D元素周期表-小游戏 | 点击进入…"></a>④、3D元素周期表-小游戏 | <a href="https://ysluckly.github.io/games/element/index.html">点击进入…</a></h4><h4 id="⑤、弹钢琴-小游戏-点击进入…"><a href="#⑤、弹钢琴-小游戏-点击进入…" class="headerlink" title="⑤、弹钢琴-小游戏 | 点击进入…"></a>⑤、弹钢琴-小游戏 | <a href="https://ysluckly.github.io/games/piano/index.html">点击进入…</a></h4><h4 id="⑥、吃豆人-小游戏-点击进入…"><a href="#⑥、吃豆人-小游戏-点击进入…" class="headerlink" title="⑥、吃豆人-小游戏 | 点击进入…"></a>⑥、吃豆人-小游戏 | <a href="https://ysluckly.github.io/games/PacMan/index.html">点击进入…</a></h4>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;休闲小游戏是小游戏的一种。一般都是在看技术博客累的时候玩的，后来发展成网页游戏。并成为网络游戏集，并加以利用加入网络等元素，可以和网友进行比拼，使得休闲小游戏得以发展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;①、2048-小游戏-点击</summary>
      
    
    
    
    <category term="工具" scheme="https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="game" scheme="https://ysluckly.github.io/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>Go全栈面试题（4）-数据库面试题</title>
    <link href="https://ysluckly.github.io/2022/02/01/mysql/"/>
    <id>https://ysluckly.github.io/2022/02/01/mysql/</id>
    <published>2022-02-01T07:29:32.000Z</published>
    <updated>2022-02-26T05:49:38.710Z</updated>
    
    <content type="html"><![CDATA[<p>===================================================================</p><h3 id="数据库MySQL面试题"><a href="#数据库MySQL面试题" class="headerlink" title="数据库MySQL面试题"></a>数据库MySQL面试题</h3><hr><h3 id="MySQL的数据类型"><a href="#MySQL的数据类型" class="headerlink" title="MySQL的数据类型"></a>MySQL的数据类型</h3><ol><li> 整型</li></ol><table><thead><tr><th>类型</th><th>存储</th><th>存储</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td></td><td>byte</td><td>bit</td><td>signed</td><td>signed</td></tr><tr><td>TINYINT</td><td>1</td><td>8</td><td>-27 = -128</td><td>27-1 = 127</td></tr><tr><td>SMALLINT</td><td>2</td><td>16</td><td></td><td></td></tr><tr><td>MEDIUMINT</td><td>3</td><td>24</td><td></td><td></td></tr><tr><td>INT</td><td>4</td><td>32</td><td>-231 = -2147483648</td><td>231-1 = 2147483647</td></tr><tr><td>BIGINT</td><td>8</td><td>64</td><td></td><td></td></tr></tbody></table><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p><p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。<br>2. 浮点数</p><p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p><p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p><ol start="3"><li> 字符串</li></ol><p>MySQL中主要有 CHAR 和 VARCHAR 两种字符串类型，一种是定长的，一种是变长的。</p><p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p><p>VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。</p><ol start="4"><li> 时间和日期</li></ol><p>MySQL中提供了两种相似的日期时间类型：DATATIME 和 TIMESTAMP。</p><ul><li>  DATATIME</li></ul><p>能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p><p>它与时区无关。</p><p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATATIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p><ul><li>  TIMESTAMP</li></ul><p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。</p><p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p><p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p><p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p><p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p><h3 id="MySQL中utf8和utf8mb4区别"><a href="#MySQL中utf8和utf8mb4区别" class="headerlink" title="MySQL中utf8和utf8mb4区别?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>MySQL中utf8和utf8mb4区别?</h3><p>MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。好在utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。当然，为了节省空间，一般情况下使用utf8也就可以了。</p><p>MySQL支持的 utf8 编码最大字符长度为 3 字节，如果遇到 4 字节的宽字符就会插入异常了。三个字节的 UTF-8 最大能编码的 Unicode 字符是 0xffff，也就是 Unicode 中的基本多文种平面(BMP)。任何不在基本多文本平面的 Unicode字符，都无法使用 MySQL 的 utf8 字符集存储。包括 Emoji 表情(Emoji 是一种特殊的 Unicode 编码，常见于 ios 和 android 手机上)，和很多不常用的汉字，以及任何新增的 Unicode 字符等等。</p><p>MySQL 中保存 4 字节长度的 UTF-8 字符，需要使用 utf8mb4 字符集，但只有 5.5.3 版本以后的才支持(查看版本： select version()?。我觉得，为了获取更好的兼容性，应该总是使用 utf8mb4 而非 utf8. 对于 CHAR 类型数据，utf8mb4 会多消耗一些空间，根据 MySQL 官方建议，使用 VARCHAR 替代 CHAR。</p><h3 id="MySQL和redis区别是什么？"><a href="#MySQL和redis区别是什么？" class="headerlink" title="MySQL和redis区别是什么？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>MySQL和redis区别是什么？</h3><ul><li>  MySQL和redis的数据库类型</li></ul><p>MySQL是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢。</p><p>redis是NOSQL，即非关系型数据库，也是缓存数据库，即将数据存储在缓存中，缓存的读取速度快，能够大大的提高运行效率，但是保存时间有限。</p><ul><li>  MySQL的运行机制</li></ul><p>MySQL作为持久化存储的关系型数据库，相对薄弱的地方在于每次请求访问数据库时，都存在着I/O操作，如果反复频繁的访问数据库。第一：会在反复链接数据库上花费大量时间，从而导致运行效率过慢；第二：反复的访问数据库也会导致数据库的负载过高，那么此时缓存的概念就衍生了出来。</p><ul><li>  缓存</li></ul><p>缓存就是数据交换的缓冲区（cache），当浏览器执行请求时，首先会对在缓存中进行查找，如果存在，就获取；否则就访问数据库。</p><p>缓存的好处就是读取速度快。</p><ul><li>  redis数据库</li></ul><p>redis数据库就是一款缓存数据库，用于存储使用频繁的数据，这样减少访问数据库的次数，提高运行效率。</p><ul><li>  redis和MySQL的区别总结</li></ul><p>（1）类型上</p><p>从类型上来说，MySQL是关系型数据库，redis是缓存数据库</p><p>（2）作用上</p><p>MySQL用于持久化的存储数据到硬盘，功能强大，但是速度较慢</p><p>redis用于存储使用较为频繁的数据到缓存中，读取速度快</p><p>（3）需求上</p><p>MySQL和redis因为需求的不同，一般都是配合使用。</p><h3 id="MySQL高可用方案有哪些"><a href="#MySQL高可用方案有哪些" class="headerlink" title="MySQL高可用方案有哪些?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>MySQL高可用方案有哪些?</h3><p>MySQL高可用方案包括:</p><ol><li> 主从复制方案</li></ol><p>这是MySQL自身提供的一种高可用解决方案，数据同步方法采用的是MySQL replication技术。MySQL replication就是从服务器到主服务器拉取二进制日志文件，然后再将日志文件解析成相应的SQL在从服务器上重新执行一遍主服务器的操作，通过这种方式保证数据的一致性。为了达到更高的可用性，在实际的应用环境中，一般都是采用MySQL replication技术配合高可用集群软件keepalived来实现自动failover，这种方式可以实现95.000%的SLA。</p><ol start="2"><li> MMM/MHA高可用方案</li></ol><p>MMM提供了MySQL主主复制配置的监控、故障转移和管理的一套可伸缩的脚本套件。在MMM高可用方案中，典型的应用是双主多从架构，通过MySQL replication技术可以实现两个服务器互为主从，且在任何时候只有一个节点可以被写入，避免了多点写入的数据冲突。同时，当可写的主节点故障时，MMM套件可以立刻监控到，然后将服务自动切换到另一个主节点，继续提供服务，从而实现MySQL的高可用。</p><ol start="3"><li> Heartbeat/SAN高可用方案</li></ol><p>在这个方案中，处理failover的方式是高可用集群软件Heartbeat，它监控和管理各个节点间连接的网络，并监控集群服务，当节点出现故障或者服务不可用时，自动在其他节点启动集群服务。在数据共享方面，通过SAN（Storage Area Network）存储来共享数据，这种方案可以实现99.990%的SLA。</p><ol start="4"><li> Heartbeat/DRBD高可用方案</li></ol><p>这个方案处理failover的方式上依旧采用Heartbeat，不同的是，在数据共享方面，采用了基于块级别的数据同步软件DRBD来实现。DRBD是一个用软件实现的、无共享的、服务器之间镜像块设备内容的存储复制解决方案。和SAN网络不同，它并不共享存储，而是通过服务器之间的网络复制数据。</p><ol start="5"><li> NDB CLUSTER高可用方案</li></ol><p>国内用NDB集群的公司非常少，貌似有些银行有用。NDB集群不需要依赖第三方组件，全部都使用官方组件，能保证数据的一致性，某个数据节点挂掉，其他数据节点依然可以提供服务，管理节点需要做冗余以防挂掉。缺点是：管理和配置都很复杂，而且某些SQL语句例如join语句需要避免。</p><h3 id="MySQL并发一致性问题"><a href="#MySQL并发一致性问题" class="headerlink" title="MySQL并发一致性问题"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>MySQL并发一致性问题</h3><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h4 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>丢失修改</h4><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。<br><img src="https://www.github.com/Clown95/StroyBack/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1558080090977.png"></p><h4 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>读脏数据</h4><p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。<br><img src="https://www.github.com/Clown95/StroyBack/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1558080115260.png"></p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>不可重复读</h4><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。<br><img src="https://www.github.com/Clown95/StroyBack/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1558080125009.png"></p><h4 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>幻影读</h4><p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><p><img src="https://www.github.com/Clown95/StroyBack/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1558080139434.png"></p><hr><p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p><h3 id="MySQL中乐观锁和悲观锁-原理、区别"><a href="#MySQL中乐观锁和悲观锁-原理、区别" class="headerlink" title="MySQL中乐观锁和悲观锁 原理、区别?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>MySQL中乐观锁和悲观锁 原理、区别?</h3><p>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p><p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p><p>乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。</p><p>乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，然后按照如下方式实现：</p><pre><code>1. SELECT data AS old_data, version AS old_version FROM …;2. 根据获取的数据进行业务操作，得到new_data和new_version3. UPDATE SET data = new_data, version = new_version WHERE version = old_versionif (updated row &gt; 0) &#123;    // 乐观锁获取成功，操作完成&#125; else &#123;    // 乐观锁获取失败，回滚并重试&#125;</code></pre><p>乐观锁是否在事务中其实都是无所谓的，其底层机制是这样：在数据库内部update同一行的时候是不允许并发的，即数据库每次执行一条update语句时会获取被update行的写锁，直到这一行被成功更新后才释放。因此在业务操作进行前获取需要锁的数据的当前版本号，然后实际更新数据时再次对比版本号确认与之前获取的相同，并更新版本号，即可确认这之间没有发生并发的修改。如果更新失败即可认为老版本的数据已经被并发修改掉而不存在了，此时认为获取锁失败，需要回滚整个业务操作并可根据需要重试整个过程。</p><p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p><h3 id="什么是MySQL事务？"><a href="#什么是MySQL事务？" class="headerlink" title="什么是MySQL事务？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>什么是MySQL事务？</h3><p>事务是一组原子性的sql命令或者说是一个独立的工作单元,如果数据库引擎能够成功的对数据库应用该组的全部sql语句,那么就执行该组命令如果其中有任何一条语句因为崩溃或者其它原因无法执行,那么该组中所有的sql语句都不会执行,如果没有显示启动事务,数据库会根据autocommit的值.默认每条sql操作都会自动提交。</p><ol><li>原子性（Atomicity）<br> 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</li></ol><p>回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><ol start="2"><li><p>一致性（Consistency）<br> 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p></li><li><p>隔离性（Isolation）<br> 一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p></li><li><p>持久性（Durability）<br> 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。使用重做日志来保证持久性。</p></li></ol><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p><ul><li>  只有满足一致性，事务的执行结果才是正确的。</li><li>  在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>  在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对数据库崩溃的情况。<br>  <img src="https://www.github.com/Clown95/StroyBack/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1558183001169.png"></li></ul><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p><h3 id="什么是-Next-Key-Locks？"><a href="#什么是-Next-Key-Locks？" class="headerlink" title="什么是 Next-Key Locks？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>什么是 Next-Key Locks？</h3><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p><p>MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p><ul><li>Record Locks<br>  锁定一个记录上的索引，而不是记录本身。</li></ul><p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p><ul><li>Gap Locks<br>  锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</li></ul><pre><code>SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;</code></pre><ul><li>Next-Key Locks<br>  它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</li></ul><pre><code>(negative infinity, 10](10, 11](11, 13](13, 20](20, positive infinity)</code></pre><h3 id="ISAM是什么？"><a href="#ISAM是什么？" class="headerlink" title="ISAM是什么？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>ISAM是什么？</h3><p>MySQL 5.5 版本之前的默认存储引擎，在 <code>5.0</code> 以前最大表存储空间最大 <code>4G</code>，<code>5.0</code> 以后最大 <code>256TB</code>。</p><p>Myisam 存储引擎由 <code>.myd</code>（数据）和 <code>.myi</code>（索引文件）组成，<code>.frm</code>文件存储表结构（所以存储引擎都有）</p><p><strong>特性</strong></p><ul><li>  并发性和锁级别 （对于读写混合的操作不好，为表级锁，写入和读互斥）</li><li>  表损坏修复</li><li>  Myisam 表支持的索引类型（全文索引）</li><li>  Myisam 支持表压缩（压缩后，此表为只读，不可以写入。使用 myisampack 压缩）</li></ul><p><strong>应用场景</strong></p><ul><li>  没有事务</li><li>  只读类应用（插入不频繁，查询非常频繁）</li><li>  空间类应用（唯一支持空间函数的引擎）</li><li>  做很多 count 的计算</li></ul><h3 id="InnoDB是什么？"><a href="#InnoDB是什么？" class="headerlink" title="InnoDB是什么？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>InnoDB是什么？</h3><p>MySQL 5.5 及之后版本的默认存储引擎</p><p><strong>特性</strong></p><ul><li>  InnoDB为事务性存储引擎</li><li>  完全支持事物的 ACID 特性</li><li>  Redo log （实现事务的持久性） 和 Undo log（为了实现事务的原子性，存储未完成事务log，用于回滚）</li><li>  InnoDB支持行级锁</li><li>  行级锁可以最大程度的支持并发</li><li>  行级锁是由存储引擎层实现的</li></ul><p><strong>应用场景</strong></p><ul><li>  可靠性要求比较高，或者要求事务</li><li>  表更新和查询都相当的频繁，并且行锁定的机会比较大的情况。</li></ul><h3 id="MyISAM和InnoDB引擎的区别"><a href="#MyISAM和InnoDB引擎的区别" class="headerlink" title="MyISAM和InnoDB引擎的区别?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>MyISAM和InnoDB引擎的区别?</h3><p>两者之间的区别：</p><ul><li>  MyISAM 不支持外键，而 InnoDB 支持</li><li>  MyISAM 是非事务安全型的，而 InnoDB 是事务安全型的。</li><li>  MyISAM 锁的粒度是表级，而 InnoDB 支持行级锁定。</li><li>  MyISAM 支持全文类型索引，而 InnoDB 不支持全文索引。</li><li>  MyISAM 相对简单，所以在效率上要优于 InnoDB，小型应用可以考虑使用 MyISAM。</li><li>  MyISAM 表是保存成文件的形式，在跨平台的数据转移中使用 MyISAM 存储会省去不少的麻烦。</li><li>  InnoDB 表比 MyISAM 表更安全，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。</li></ul><p>应用场景：</p><ul><li>  MyISAM 管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的 SELECT 查询，那么 MyISAM 是更好的选择。</li><li>InnoDB 用于事务处理应用程序，具有众多特性，包括 ACID 事务支持。如果应用中需要执行大量的 INSERT<br>  或 UPDATE 操作，则应该使用 InnoDB，这样可以提高多用户并发操作的性能。</li></ul><h3 id="MySQL如何支持事务？"><a href="#MySQL如何支持事务？" class="headerlink" title="MySQL如何支持事务？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>MySQL如何支持事务？</h3><p>MYSQL的事务处理主要有两种方法</p><ol><li> 用begin,rollback,commit来实现</li></ol><ul><li>  begin开始一个事务</li><li>  rollback事务回滚</li><li>  commit 事务确认</li></ul><ol start="2"><li> 直接用set来改变MySQL的自动提交模式</li></ol><ul><li>  MySQL默认是自动提交的，也就是你提交一个query，就直接执行！可以通过</li><li>  set autocommit = 0 禁止自动提交</li><li>set autocommit = 1 开启自动提交<br>  来实现事务的处理</li></ul><h3 id="MySQL索引使用场景"><a href="#MySQL索引使用场景" class="headerlink" title="MySQL索引使用场景"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>MySQL索引使用场景</h3><p>在什么情况下使用索引</p><ul><li>  通常为了快速查找匹配WHERE条件的行。</li><li>  通常为了从考虑的条件中消除行。</li><li>  如果表有一个multiple-column索引，任何一个索引的最左前缀可以通过使用优化器来查找行。</li><li>  查询中与其它表关联的字，字段常常建立了外键关系</li><li>  查询中统计或分组统计的字段</li></ul><pre><code>select max(hbs_bh) from zl_yhjbqkselect qc_bh,count(*) from zl_yhjbqk group by qc_bh</code></pre><h3 id="主键、外键和索引的区别"><a href="#主键、外键和索引的区别" class="headerlink" title="主键、外键和索引的区别"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>主键、外键和索引的区别</h3><table><thead><tr><th></th><th>定义</th><th>作用</th><th>个数</th></tr></thead><tbody><tr><td><strong>主键</strong></td><td>唯一标识一条记录，不能有重复的，不允许为空</td><td>用来保证数据完整性</td><td>主键只能有一个</td></tr><tr><td><strong>外键</strong></td><td>表的外键是另一表的主键，外键可以有重复的，可以是空值</td><td>用来和其他表建立联系用的</td><td>一个表可以有多个外键</td></tr><tr><td><strong>索引</strong></td><td>该字段没有重复值，但可以有一个空值</td><td>是提高查询排序的速度</td><td>一个表可以有多个惟一索引</td></tr></tbody></table><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>Redis</h2><h3 id="Redis的数据结构有哪些，以及实现场景"><a href="#Redis的数据结构有哪些，以及实现场景" class="headerlink" title="Redis的数据结构有哪些，以及实现场景?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>Redis的数据结构有哪些，以及实现场景?</h3><p>Redis的数据结构有五种:</p><ul><li>  string 字符串</li></ul><p>String 数据结构是简单的 key-value 类型，value 不仅可以是 String，也可以是数字（当数字类型用 Long 可以表示的时候encoding 就是整型，其他都存储在 sdshdr 当做字符串）。使用 Strings 类型，可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受 Redis 的定时持久化（可以选择 RDB 模式或者 AOF 模式），操作日志及 Replication 等功能。</p><p>除了提供与 Memcached 一样的 get、set、incr、decr 等操作外，Redis 还提供了下面一些操作：</p><ol><li> LEN niushuai：O(1)获取字符串长度.</li><li> APPEND niushuai redis：往字符串 append 内容，而且采用智能分配内存（每次2倍）.</li><li> 设置和获取字符串的某一段内容.</li><li> 设置及获取字符串的某一位（bit）.</li><li> 批量设置一系列字符串的内容.</li><li> 原子计数器.</li><li> GETSET 命令的妙用，请于清空旧值的同时设置一个新值，配合原子计数器使用.</li></ol><ul><li>  Hash 字典</li></ul><p>在 Memcached 中，我们经常将一些结构化的信息打包成 hashmap，在客户端序列化后存储为一个字符串的值（一般是 JSON 格式），比如用户的昵称、年龄、性别、积分等。这时候在需要修改其中某一项时，通常需要将字符串（JSON）取出来，然后进行反序列化，修改某一项的值，再序列化成字符串（JSON）存储回去。简单修改一个属性就干这么多事情，消耗必定是很大的，也不适用于一些可能并发操作的场合（比如两个并发的操作都需要修改积分）。而 Redis 的 Hash 结构可以使你像在数据库中 Update 一个属性一样只修改某一项属性值。</p><p>Hash可以用来存储、读取、修改用户属性。</p><ul><li>  List 列表</li></ul><p>List 说白了就是链表（redis 使用双端链表实现的 List），相信学过数据结构知识的人都应该能理解其结构。使用 List 结构，我们可以轻松地实现最新消息排行等功能（比如新浪微博的 TimeLine ）。List 的另一个应用就是消息队列，可以利用 List 的 *PUSH 操作，将任务存在 List 中，然后工作线程再用 POP 操作将任务取出进行执行。</p><p>Redis 还提供了操作 List 中某一段元素的 API，你可以直接查询，删除 List 中某一段的元素。</p><p>List 列表应用:</p><ol><li> 微博 TimeLine.</li><li> 消息队列.</li></ol><ul><li>  Set 集合</li></ul><p>Set 就是一个集合，集合的概念就是一堆不重复值的组合。利用 Redis 提供的 Set 数据结构，可以存储一些集合性的数据。比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。因为 Redis 非常人性化的为集合提供了求交集、并集、差集等操作，那么就可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。</p><p>Set 集合应用:</p><ol><li> 共同好友、二度好友</li><li> 利用唯一性，可以统计访问网站的所有独立 IP.</li><li> 好友推荐的时候，根据 tag 求交集，大于某个 threshold 就可以推荐.</li></ol><ul><li>  Sorted Set有序集合</li></ul><p>和Sets相比，Sorted Sets是将 Set 中的元素增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，比如一个存储全班同学成绩的 Sorted Sets，其集合 value 可以是同学的学号，而 score 就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用 Sorted Sets 来做带权重的队列，比如普通消息的 score 为1，重要消息的 score 为2，然后工作线程可以选择按 score 的倒序来获取工作任务。让重要的任务优先执行。</p><p>Sorted Set有序集合应用:</p><p>1.带有权重的元素，比如一个游戏的用户得分排行榜.<br>2.比较复杂的数据结构，一般用到的场景不算太多.</p><p>Redis 其他功能使用场景:</p><ul><li>  订阅-发布系统</li></ul><p>Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在 Redis 中，你可以设定对某一个 key 值进行消息发布及消息订阅，当一个 key 值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p><ul><li>  事务——Transactions</li></ul><p>谁说 NoSQL 都不支持事务，虽然 Redis 的 Transactions 提供的并不是严格的 ACID 的事务（比如一串用 EXEC 提交执行的命令，在执行中服务器宕机，那么会有一部分命令执行了，剩下的没执行），但是这个 Transactions 还是提供了基本的命令打包执行的功能（在服务器不出问题的情况下，可以保证一连串的命令是顺序在一起执行的，中间有会有其它客户端命令插进来执行）。Redis 还提供了一个 Watch 功能，你可以对一个 key 进行 Watch，然后再执行 Transactions，在这过程中，如果这个 Watched 的值进行了修改，那么这个 Transactions 会发现并拒绝执行。</p><h3 id="Redis分布式锁是什么回事？"><a href="#Redis分布式锁是什么回事？" class="headerlink" title="Redis分布式锁是什么回事？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>Redis分布式锁是什么回事？</h3><p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p><p>如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？这个锁就永远得不到释放了。</p><p>如何解决？set指令有非常复杂的参数，可以同时把setnx和expire合成一条指令来用。</p><h3 id="Redis异步队列是怎么用的？"><a href="#Redis异步队列是怎么用的？" class="headerlink" title="Redis异步队列是怎么用的？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>Redis异步队列是怎么用的？</h3><p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p><p>如果不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。</p><p>如何生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。</p><p>pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。</p><p>redis如何实现延时队列？使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。</p><h3 id="Redis如何做持久化的？"><a href="#Redis如何做持久化的？" class="headerlink" title="Redis如何做持久化的？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>Redis如何做持久化的？</h3><p>bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，优先使用aof来恢复内存的状态，如果没有aof日志，就会使用rdb文件来恢复。</p><p>aof文件过大恢复时间过长怎么办？Redis会定期做aof重写，压缩aof文件日志大小。Redis4.0之后有了混合持久化的功能，将bgsave的全量和aof的增量做了融合处理，这样既保证了恢复的效率又兼顾了数据的安全性。</p><h3 id="在大规模数据中，如何找出有固定前缀的key？"><a href="#在大规模数据中，如何找出有固定前缀的key？" class="headerlink" title="在大规模数据中，如何找出有固定前缀的key？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>在大规模数据中，如何找出有固定前缀的key？</h3><p>使用keys指令可以扫出指定模式的key列表。</p><p>如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？redis有一个关键的特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><h4 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h4><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p><h3 id="Pipeline有什么好处，为什么要用pipeline？"><a href="#Pipeline有什么好处，为什么要用pipeline？" class="headerlink" title="Pipeline有什么好处，为什么要用pipeline？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>Pipeline有什么好处，为什么要用pipeline？</h3><p>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p><h3 id="Redis的同步机制是什么？"><a href="#Redis的同步机制是什么？" class="headerlink" title="Redis的同步机制是什么？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>Redis的同步机制是什么？</h3><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p><h3 id="Redis集群原理是什么？"><a href="#Redis集群原理是什么？" class="headerlink" title="Redis集群原理是什么？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>Redis集群原理是什么？</h3><p>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。</p><p>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p><h3 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>如何解决 Redis 的并发竞争 Key 问题?</h3><p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p><p>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p><p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p><p>在实践中，当然是从以可靠性为主。所以首推Zookeeper。</p><h3 id="为什么要用-redis-为什么要用缓存"><a href="#为什么要用-redis-为什么要用缓存" class="headerlink" title="为什么要用 redis/为什么要用缓存?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>为什么要用 redis/为什么要用缓存?</h3><p>主要从“高性能”和“高并发”这两点来看待这个问题。</p><ul><li><p>高性能：<br>  假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p></li><li><p>高并发：<br>  直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p></li></ul><h3 id="为什么要用-redis-而不用-map-做缓存"><a href="#为什么要用-redis-而不用-map-做缓存" class="headerlink" title="为什么要用 redis 而不用 map 做缓存?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>为什么要用 redis 而不用 map 做缓存?</h3><p>缓存分为本地缓存和分布式缓存。以 go为例，使用自带的 map实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着程序的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p><p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</p><h3 id="如何优化Redis查询性能？"><a href="#如何优化Redis查询性能？" class="headerlink" title="如何优化Redis查询性能？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>如何优化Redis查询性能？</h3><ol><li> 使用 Explain 进行分析</li></ol><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p><p>字段有：</p><ul><li>  select_type : 查询类型，有简单查询、联合查询、子查询等</li><li>  key : 使用的索引</li><li>  rows : 扫描的行数</li></ul><pre><code>mysql&gt; explain select * from user_info where id = 3\G*************************** 1. row ***************************           id: 3  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><ol start="2"><li> 优化数据访问</li></ol><p>减少请求的数据量:</p><ul><li>  只返回必要的列</li></ul><p>最好不要使用 SELECT * 语句。</p><ul><li>  只返回必要的行</li></ul><p>使用 WHERE 语句进行查询过滤，有时候也需要使用 LIMIT 语句来限制返回的数据。</p><ul><li>  缓存重复查询的数据</li></ul><p>使用缓存可以避免在数据库中进行查询，特别要查询的数据经常被重复查询，缓存可以带来的查询性能提升将会是非常明显的。</p><ul><li>  减少服务器端扫描的行数</li></ul><p>对于查询来说，其中最有效的方式是使用索引来覆盖查询。</p><ol start="3"><li> 重构查询方式</li></ol><ul><li>  切分大查询</li></ul><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><pre><code>DELEFT FROM info WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);</code></pre><pre><code>rows_affected = 0do &#123;    rows_affected = do_query(    &quot;DELETE FROM info WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)&#125; while rows_affected &gt; 0</code></pre><ul><li><p>分解大连接查询<br>  将一个大连接查询（JOIN）分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有：</p></li><li><p>  让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</p></li><li><p>  分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</p></li><li><p>  减少锁竞争；</p></li><li><p>  在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可扩展。</p></li><li><p>  查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</p></li></ul><h3 id="如何最大限度地降低死锁？"><a href="#如何最大限度地降低死锁？" class="headerlink" title="如何最大限度地降低死锁？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637558"></a>如何最大限度地降低死锁？</h3><ul><li>  按同一顺序访问对象</li><li>  避免事务中的用户交互</li><li>  保持事务简短并在一个批处理中</li><li>  使用低隔离级别</li><li>  使用绑定连接</li></ul><p>本文转自 <a href="https://blog.csdn.net/yang731227/article/details/90637558">https://blog.csdn.net/yang731227/article/details/90637558</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;===================================================================&lt;/p&gt;
&lt;h3 id=&quot;数据库MySQL面试题&quot;&gt;&lt;a href=&quot;#数据库MySQL面试题&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="面试题" scheme="https://ysluckly.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="MySQL总结" scheme="https://ysluckly.github.io/tags/MySQL%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 有这一篇就够（呕心狂敲37k字，只为博君一点赞！！！）</title>
    <link href="https://ysluckly.github.io/2022/01/31/mysql/"/>
    <id>https://ysluckly.github.io/2022/01/31/mysql/</id>
    <published>2022-01-31T07:29:32.000Z</published>
    <updated>2022-02-25T15:57:17.872Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul><li>  <a href="about:blank#_5">前言</a></li><li>  <a href="about:blank#SQL_9">一、SQL简述</a></li><li><ul><li><a href="about:blank#1SQL_10">1.SQL的概述</a><ul><li>  <a href="about:blank#2SQL_12">2.SQL的优点</a></li><li>  <a href="about:blank#3SQL_16">3.SQL的分类</a></li></ul></li></ul></li><li>  <a href="about:blank#_25">二、数据库的三大范式</a></li><li>  <a href="about:blank#_29">三、数据库的数据类型</a></li><li><ul><li><a href="about:blank#1_31">1.整数类型</a><ul><li>  <a href="about:blank#2_40">2.浮点数类型和定点数类型</a></li><li>  <a href="about:blank#3_49">3.字符串类型</a></li><li>  <a href="about:blank#4_60">4.字符串类型</a></li><li>  <a href="about:blank#5_68">5.日期与时间类型</a></li><li><ul><li><a href="about:blank#51_YEAR_77">5.1 YEAR类型</a><ul><li>  <a href="about:blank#52_TIME_83">5.2 TIME类型</a></li><li>  <a href="about:blank#53_DATETIME_88">5.3 DATETIME类型</a></li><li>  <a href="about:blank#54_TIMESTAMP_94">5.4 TIMESTAMP类型</a></li></ul></li></ul></li><li>  <a href="about:blank#6_99">6.二进制类型</a></li></ul></li></ul></li><li>  <a href="about:blank#_107">四、数据库、数据表的基本操作</a></li><li><ul><li><a href="about:blank#1_108">1.数据库的基本操作</a><ul><li>  <a href="about:blank#2_157">2.数据表的基本操作</a></li><li><ul><li><a href="about:blank#21__169">2.1 创建数据表</a><ul><li>  <a href="about:blank#22__181">2.2 查看数据表</a></li><li>  <a href="about:blank#23__200">2.3 修改数据表</a></li><li>  <a href="about:blank#24__233">2.4 删除数据表</a></li></ul></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#_247">五、数据表的约束</a></li><li><ul><li><a href="about:blank#1_257">1.主键约束</a><ul><li>  <a href="about:blank#2_284">2.非空约束</a></li><li>  <a href="about:blank#3_299">3.默认值约束</a></li><li>  <a href="about:blank#5_315">5.唯一性约束</a></li><li>  <a href="about:blank#6_330">6.外键约束</a></li><li><ul><li><a href="about:blank#61__360">6.1 数据一致性概念</a><ul><li>  <a href="about:blank#62__362">6.2 删除外键</a></li><li>  <a href="about:blank#63__375">6.3 关于外键约束需要注意的细节</a></li></ul></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#_379">六、数据表插入数据</a></li><li><ul><li><a href="about:blank#1__389">1. 为表中所有字段插入数据</a><ul><li>  <a href="about:blank#2__401">2. 为表中指定字段插入数据</a></li><li>  <a href="about:blank#3__408">3. 同时插入多条记录</a></li></ul></li></ul></li><li>  <a href="about:blank#_421">七、更新数据</a></li><li><ul><li><a href="about:blank#1_UPDATE_423">1. UPDATE基本语法</a><ul><li>  <a href="about:blank#2_UPDATE_428">2. UPDATE更新部分数据</a></li><li>  <a href="about:blank#3_UPDATE_435">3. UPDATE更新全部数据</a></li></ul></li></ul></li><li>  <a href="about:blank#_442">八、删除数据</a></li><li><ul><li><a href="about:blank#1_DELETE_457">1. DELETE基本语法</a><ul><li>  <a href="about:blank#2_DELETE_462">2. DELETE删除部分数据</a></li><li>  <a href="about:blank#3_DELETE_469">3. DELETE删除全部数据</a></li><li>  <a href="about:blank#4_TRUNCATEDETELE_476">4. TRUNCATE和DETELE的区别</a></li></ul></li></ul></li><li>  <a href="about:blank#MySQL_481">九、MySQL数据表简单查询</a></li><li><ul><li><a href="about:blank#1_482">1.简单查询概述</a><ul><li>  <a href="about:blank#2_512">2.查询所有字段（方法不唯一只是举例）</a></li><li>  <a href="about:blank#3sidsname_519">3.查询指定字段（sid、sname）</a></li><li>  <a href="about:blank#4_526">4.常数的查询</a></li><li>  <a href="about:blank#5_535">5.从查询结果中过滤重复数据</a></li><li>  <a href="about:blank#6_545">6.算术运算符（举例加运算符）</a></li></ul></li></ul></li><li>  <a href="about:blank#_554">十、函数</a></li><li><ul><li><a href="about:blank#1_583">1.聚合函数</a><ul><li><ul><li><a href="about:blank#11count_588">1.1、count（）</a><ul><li>  <a href="about:blank#12max_598">1.2、max（）</a></li><li>  <a href="about:blank#13min_609">1.3、min（）</a></li><li>  <a href="about:blank#14sum_620">1.4、sum（）</a></li><li>  <a href="about:blank#15avg_630">1.5、avg（）</a></li></ul></li></ul></li><li>  <a href="about:blank#2_640">2.其他常用函数</a></li><li><ul><li><a href="about:blank#21_642">2.1、时间函数</a><ul><li>  <a href="about:blank#22_660">2.2、字符串函数</a></li><li>  <a href="about:blank#23_670">2.3、数学函数</a></li></ul></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#_680">十一、条件查询</a></li><li><ul><li><a href="about:blank#1_712">1.使用关系运算符查询</a><ul><li>  <a href="about:blank#2IN_731">2.使用IN关键字查询</a></li><li>  <a href="about:blank#3BETWEEN_AND_748">3.使用BETWEEN AND关键字查询</a></li><li>  <a href="about:blank#4_764">4.使用空值查询</a></li><li>  <a href="about:blank#5AND_774">5.使用AND关键字查询</a></li><li>  <a href="about:blank#6OR_783">6.使用OR关键字查询</a></li><li>  <a href="about:blank#7LIKE_792">7.使用LIKE关键字查询</a></li><li><ul><li><a href="about:blank#71__794">7.1 普通字符串</a><ul><li>  <a href="about:blank#72__802">7.2 含有%通配的字符串</a></li><li>  <a href="about:blank#73___825">7.3 含有_通配的字符串</a></li></ul></li></ul></li><li>  <a href="about:blank#8LIMIT_842">8.使用LIMIT限制查询结果的数量</a></li><li>  <a href="about:blank#9GROUP_BY_851">9.使用GROUP BY进行分组查询</a></li><li><ul><li><a href="about:blank#91_GROUP_BY_880">9.1 GROUP BY和聚合函数一起使用</a><ul><li>  <a href="about:blank#92_GROUP_BYHAVING_896">9.2 GROUP BY和聚合函数以及HAVING一起使用</a></li></ul></li></ul></li><li>  <a href="about:blank#10ORDER_BY_904">10.使用ORDER BY对查询结果排序</a></li></ul></li></ul></li><li>  <a href="about:blank#_928">十二、别名设置</a></li><li><ul><li><a href="about:blank#1_931">1.为表取别名</a><ul><li>  <a href="about:blank#2_942">2.为字段取别名</a></li></ul></li></ul></li><li>  <a href="about:blank#_954">十三、表的关联关系</a></li><li><ul><li><a href="about:blank#1_993">1.关联查询</a><ul><li>  <a href="about:blank#2_1000">2.关于关联关系的删除数据</a></li></ul></li></ul></li><li>  <a href="about:blank#_1009">十四、多表连接查询</a></li><li><ul><li><a href="about:blank#1_1010">1.交叉连接查询</a><ul><li>  <a href="about:blank#2_1018">2.内连接查询</a></li><li>  <a href="about:blank#3_1067">3.外连接查询</a></li><li><ul><li><a href="about:blank#31__1117">3.1 左（外）连接查询</a><ul><li>  <a href="about:blank#32__1129">3.2 右（外）连接查询</a></li></ul></li></ul></li></ul></li></ul></li><li>  <a href="about:blank#_1142">十五、子查询</a></li><li><ul><li><a href="about:blank#1_1181">1.带比较运算符的子查询</a><ul><li>  <a href="about:blank#2EXISTS_1195">2.带EXISTS关键字的子查询</a></li><li>  <a href="about:blank#3ANY_1203">3.带ANY关键字的子查询</a></li><li>  <a href="about:blank#4ALL_1213">4.带ALL关键字的子查询</a></li></ul></li></ul></li><li>  <a href="about:blank#_1224">总结</a></li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>前言</h1><p>知识无底，学海无涯，到今天进入MySQL的学习4天了，知识点虽然简单，但是比较多，所以写一篇博客将MySQL的基础写出来，方便自己以后查找，还有就是分享给大家。</p><h1 id="一、SQL简述"><a href="#一、SQL简述" class="headerlink" title="一、SQL简述"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>一、SQL简述</h1><h2 id="1-SQL的概述"><a href="#1-SQL的概述" class="headerlink" title="1.SQL的概述"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.SQL的概述</h2><p>Structure Query Language(结构化查询语言)简称SQL，它被美国国家标准局(ANSI)确定为关系型数据库语言的美国标准，后被国际化标准组织(ISO)采纳为关系数据库语言的国际标准。数据库管理系统可以通过SQL管理数据库；定义和操作数据，维护数据的完整性和安全性。</p><h2 id="2-SQL的优点"><a href="#2-SQL的优点" class="headerlink" title="2.SQL的优点"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.SQL的优点</h2><p>1、简单易学，具有很强的操作性<br>2、绝大多数重要的数据库管理系统均支持SQL<br>3、高度非过程化；用SQL操作数据库时大部分的工作由DBMS自动完成</p><h2 id="3-SQL的分类"><a href="#3-SQL的分类" class="headerlink" title="3.SQL的分类"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3.SQL的分类</h2><p>1、DDL(Data Definition Language) 数据定义语言，用来操作数据库、表、列等； 常用语句：CREATE、 ALTER、DROP<br>2、DML(Data Manipulation Language) 数据操作语言，用来操作数据库中表里的数据；常用语句：INSERT、 UPDATE、 DELETE<br>3、DCL(Data Control Language) 数据控制语言，用来操作访问权限和安全级别； 常用语句：GRANT、DENY<br>4、DQL(Data Query Language) 数据查询语言，用来查询数据 常用语句：SELECT</p><h1 id="二、数据库的三大范式"><a href="#二、数据库的三大范式" class="headerlink" title="二、数据库的三大范式"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>二、数据库的三大范式</h1><p>1、第一范式(1NF)是指数据库表的每一列都是不可分割的基本数据线；也就是说：每列的值具有原子性，不可再分割。<br>2、第二范式(2NF)是在第一范式(1NF)的基础上建立起来得，满足第二范式(2NF)必须先满足第一范式(1NF)。如果表是单主键，那么主键以外的列必须完全依赖于主键；如果表是复合主键，那么主键以外的列必须完全依赖于主键，不能仅依赖主键的一部分。<br>3、第三范式(3NF)是在第二范式的基础上建立起来的，即满足第三范式必须要先满足第二范式。第三范式(3NF)要求：表中的非主键列必须和主键直接相关而不能间接相关；也就是说：非主键列之间不能相关依赖。</p><h1 id="三、数据库的数据类型"><a href="#三、数据库的数据类型" class="headerlink" title="三、数据库的数据类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>三、数据库的数据类型</h1><p>使用MySQL数据库存储数据时，不同的数据类型决定了 MySQL存储数据方式的不同。为此，MySQL数据库提供了多种数据类型，其中包括整数类型、浮点数类型、定点 数类型、日期和时间类型、字符串类型、二进制…等等数据类型。</p><h2 id="1-整数类型"><a href="#1-整数类型" class="headerlink" title="1.整数类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.整数类型</h2><p>根据数值取值范围的不同MySQL 中的整数类型可分为5种，分别是TINYINT、SMALUNT、MEDIUMINT、INT和 BIGINT。下图列举了 MySQL不同整数类型所对应的字节大小和取值范围而最常用的为INT类型的，</p><table><thead><tr><th>数据类型</th><th>字节数</th><th>无符号数的取值范围</th><th>有符号数的取值范围</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>0~255</td><td>-128~127</td></tr><tr><td>SMALLINT</td><td>2</td><td>0~65535</td><td>-32768~32768</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>0~16777215</td><td>-8388608~8388608</td></tr><tr><td>INT</td><td>4</td><td>0~4294967295</td><td>-2147483648~ 2147483648</td></tr><tr><td>BIGINT</td><td>8</td><td>0~18446744073709551615</td><td>-9223372036854775808~9223372036854775808</td></tr></tbody></table><h2 id="2-浮点数类型和定点数类型"><a href="#2-浮点数类型和定点数类型" class="headerlink" title="2.浮点数类型和定点数类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.浮点数类型和定点数类型</h2><p>在MySQL数据库中使用浮点数和定点数来存储小数。浮点数的类型有两种：单精度浮点数类型（FLOAT)和双精度浮点数类型（DOUBLE)。而定点数类型只有一种即DECIMAL类型。下图列举了 MySQL中浮点数和定点数类型所对应的字节大小及其取值范围：</p><table><thead><tr><th>数据类型</th><th>字节数</th><th>有符号的取值范围</th><th>无符号的取值范围</th></tr></thead><tbody><tr><td>FLOAT</td><td>4</td><td>-3.402823466E+38~-1.175494351E-38</td><td>0和1.175494351E-38~3.402823466E+38</td></tr><tr><td>DOUBLE</td><td>8</td><td>-1.7976931348623157E+308~2.2250738585072014E-308</td><td>0和2.2250738585072014E-308~1.7976931348623157E+308</td></tr><tr><td>DECIMAL（M,D）</td><td>M+2</td><td>-1.7976931348623157E+308~2.2250738585072014E-308</td><td>0和2.2250738585072014E-308~1.7976931348623157E+308</td></tr></tbody></table><p>从上图中可以看出：DECIMAL类型的取值范围与DOUBLE类型相同。但是，请注意：DECIMAL类型的有效取值范围是由M和D决定的。其中，M表示的是数据的长 度，D表示的是小数点后的长度。比如，将数据类型为DECIMAL(6,2)的数据6.5243 插人数据库后显示的结果为6.52</p><h2 id="3-字符串类型"><a href="#3-字符串类型" class="headerlink" title="3.字符串类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3.字符串类型</h2><p>在MySQL中常用CHAR 和 VARCHAR 表示字符串。两者不同的是：VARCHAR存储可变长度的字符串。<br><strong>当数据为CHAR(M)类型时，不管插入值的长度是实际是多少它所占用的存储空间都是M个字节；而VARCHAR(M)所对应的数据所占用的字节数为实际长度加1</strong></p><table><thead><tr><th>插入值</th><th>CHAR(3)</th><th>存储需求</th><th>VARCHAR(3)</th><th>存储需求</th></tr></thead><tbody><tr><td>‘’</td><td>‘’</td><td>3个字节</td><td>‘’</td><td>1个字节</td></tr><tr><td>‘a’</td><td>‘a’</td><td>3个字节</td><td>‘a’</td><td>2个字节</td></tr><tr><td>‘ab’</td><td>‘ab’</td><td>3个字节</td><td>‘ab’</td><td>3个字节</td></tr><tr><td>‘abc’</td><td>‘ab’</td><td>3个字节</td><td>‘abc’</td><td>4个字节</td></tr><tr><td>‘abcd’</td><td>‘ab’</td><td>3个字节</td><td>‘abc’</td><td>4字节</td></tr></tbody></table><h2 id="4-字符串类型"><a href="#4-字符串类型" class="headerlink" title="4.字符串类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>4.字符串类型</h2><p>文本类型用于表示大文本数据，例如，文章内容、评论、详情等，它的类型分为如下4种：</p><table><thead><tr><th>数据类型</th><th>储存范围</th></tr></thead><tbody><tr><td>TINYTEXT</td><td>0~255字节</td></tr><tr><td>TEXT</td><td>0~65535字节</td></tr><tr><td>MEDIUMTEXT</td><td>0~16777215字节</td></tr><tr><td>LONGTEXT</td><td>0~4294967295字节</td></tr></tbody></table><h2 id="5-日期与时间类型"><a href="#5-日期与时间类型" class="headerlink" title="5.日期与时间类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>5.日期与时间类型</h2><p>MySQL提供的表示日期和时间的数据类型分别是 ：YEAR、DATE、TIME、DATETIME 和 TIMESTAMP。下图列举了日期和时间数据类型所对应的字节数、取值范围、日期格式以及零值：</p><table><thead><tr><th>数据类型</th><th>字节数</th><th>取值范围</th><th>日期格式</th><th>零值</th></tr></thead><tbody><tr><td>YEAR</td><td>1</td><td>1901~2155</td><td>YYYY</td><td>0000</td></tr><tr><td>DATE</td><td>4</td><td>1000-01-01~9999-12-31</td><td>YYYY-MM-DD</td><td>0000-00-00</td></tr><tr><td>TIME</td><td>3</td><td>-838：59：59~ 838：59：59</td><td>HH:MM:SS</td><td>00:00:00</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00~9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>0000-00-00 00:00:00</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:01~2038-01-19 03:14:07</td><td>YYYY-MM-DD HH:MM:SS</td><td>0000-00-00 00:00:00</td></tr></tbody></table><h3 id="5-1-YEAR类型"><a href="#5-1-YEAR类型" class="headerlink" title="5.1 YEAR类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>5.1 YEAR类型</h3><p>YEAR类型用于表示年份，在MySQL中，可以使用以下三种格式指定YEAR类型 的值。<br>1、使用4位字符串或数字表示，范围为’1901’—‘2155’或1901—2155。例如，输人 ‘2019’或2019插人到数据库中的值均为2019。<br>2、使用两位字符串表示，范围为’00’—‘99’。其中，‘00’—‘69’范围的值会被转换为 2000—2069范围的YEAR值，‘70’—‘99’范围的值会被转换为1970—1999范围的YEAR 值。例如，输人’19’插人到数据库中的值为2019。<br>3、使用两位数字表示，范围为1—99。其中，1—69范围的值会被转换为2001— 2069范围的YEAR值，70—99范围的值会被转换为1970—1999范围的YEAR值。例 如，输人19插入到数据库中的值为2019。<br><strong>请注意：当使用YEAR类型时，一定要区分’0’和0。因为字符串格式的’0’表示的YEAR值是2000而数字格式的0表示的YEAR值是0000。</strong></p><h3 id="5-2-TIME类型"><a href="#5-2-TIME类型" class="headerlink" title="5.2 TIME类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>5.2 TIME类型</h3><p>TIME类型用于表示时间值，它的显示形式一般为HH:MM:SS，其中，HH表示小时， MM表示分,SS表示秒。在MySQL中，可以使用以下3种格式指定TIME类型的值。<br>1、以’D HH:MM:SS’字符串格式表示。其中，D表示日可取0—34之间的值, 插人数据时，小时的值等于(DX24+HH)。例如，输入’2 11:30:50’插人数据库中的日期为59:30:50。<br>2、以’HHMMSS’字符串格式或者HHMMSS数字格式表示。 例如，输人’115454’或115454,插入数据库中的日期为11:54:54<br>3、使用CURRENT_TIME或NOW()输人当前系统时间。</p><h3 id="5-3-DATETIME类型"><a href="#5-3-DATETIME类型" class="headerlink" title="5.3 DATETIME类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>5.3 DATETIME类型</h3><p>DATETIME类型用于表示日期和时间，它的显示形式为’YYYY-MM-DD HH: MM:SS’，其中，YYYY表示年，MM表示月，DD表示日，HH表示小时，MM表示分，SS 表示秒。在MySQL中，可以使用以下4种格式指定DATETIME类型的值。<br>以’YYYY-MM-DD HH:MM:SS’或者’YYYYMMDDHHMMSS’字符串格式表示的日期和时间，取值范围为’1000-01-01 00:00:00’—‘9999-12-3 23:59:59’。例如，输人’2019-01-22 09:01:23’或 ‘20140122_0_90123’插人数据库中的 DATETIME 值都为 2019-01-22 09:01:23。<br>1、以’YY-MM-DD HH:MM:SS’或者’YYMMDDHHMMSS’字符串格式表示的日期和时间，其中YY表示年，取值范围为’00’—‘99’。与DATE类型中的YY相同，‘00’— ‘69’范围的值会被转换为2000—2069范围的值，‘70’—‘99’范围的值会被转换为1970—1999范围的值。<br>2、以YYYYMMDDHHMMSS或者YYMMDDHHMMSS数字格式表示的日期 和时间。例如，插入20190122090123或者190122090123,插人数据库中的DATETIME值都 为 2019-01-22 09:01:23。<br>3、使用NOW来输人当前系统的日期和时间。</p><h3 id="5-4-TIMESTAMP类型"><a href="#5-4-TIMESTAMP类型" class="headerlink" title="5.4 TIMESTAMP类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>5.4 TIMESTAMP类型</h3><p>TIMESTAMP类型用于表示日期和时间，它的显示形式与DATETIME相同但取值范围比DATETIME小。在此，介绍几种TIMESTAMP类型与DATATIME类型不同的形式：<br>1、使用CURRENT_TIMESTAMP输人系统当前日期和时间。<br>2、输人NULL时系统会输人系统当前日期和时间。<br>3、无任何输人时系统会输入系统当前日期和时间。</p><h2 id="6-二进制类型"><a href="#6-二进制类型" class="headerlink" title="6.二进制类型"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>6.二进制类型</h2><p>在MySQL中常用BLOB存储二进制类型的数据，例如：图片、PDF文档等。BLOB类型分为如下四种：</p><table><thead><tr><th>数据类型</th><th>储存范围</th></tr></thead><tbody><tr><td>TINYBLOB</td><td>0~255字节</td></tr><tr><td>BLOB</td><td>0~65535字节</td></tr><tr><td>MEDIUMBLOB</td><td>0~16777215字节</td></tr><tr><td>LONGBLOB</td><td>0~4294967295字节</td></tr></tbody></table><h1 id="四、数据库、数据表的基本操作"><a href="#四、数据库、数据表的基本操作" class="headerlink" title="四、数据库、数据表的基本操作"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>四、数据库、数据表的基本操作</h1><h2 id="1-数据库的基本操作"><a href="#1-数据库的基本操作" class="headerlink" title="1.数据库的基本操作"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.数据库的基本操作</h2><p>MySQL安装完成后，要想将数据存储到数据库的表中，首先要创建一个数据库。创 建数据库就是在数据库系统中划分一块空间存储数据，语法如下：</p><pre><code>create database 数据库名称;</code></pre><p>创建一个叫db1的数据库MySQL命令：</p><pre><code>-- 创建一个叫db1的数据库show create database db1;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/2021030312520741.png" alt="在这里插入图片描述"><br>创建数据库后查看该数据库基本信息MySQL命令：</p><pre><code>show create database db1;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303125330974.png" alt="在这里插入图片描述"><br>删除数据库MySQL命令：</p><pre><code>drop database db1;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303125647454.png" alt="在这里插入图片描述"><br>查询出MySQL中所有的数据库MySQL命令：</p><pre><code>show databases;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303125940965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>将数据库的字符集修改为gbk MySQL命令：</p><pre><code>alter database db1 character set gbk;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303130330527.png" alt="在这里插入图片描述"><br>切换数据库 MySQL命令：</p><pre><code>use db1;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303130451230.png" alt="在这里插入图片描述"><br>查看当前使用的数据库 MySQL命令：</p><pre><code>select database();</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303130616683.png" alt="在这里插入图片描述"></p><h2 id="2-数据表的基本操作"><a href="#2-数据表的基本操作" class="headerlink" title="2.数据表的基本操作"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.数据表的基本操作</h2><p>数据库创建成功后可在该数据库中创建数据表(简称为表)存储数据。请注意：在操作数据表之前应使用“USE 数据库名;”指定操作是在哪个数据库中进行先关操作，否则会抛出“No database selected”错误。<br>语法如下：</p><pre><code> create table 表名(         字段1 字段类型,         字段2 字段类型,         …         字段n 字段类型);</code></pre><h3 id="2-1-创建数据表"><a href="#2-1-创建数据表" class="headerlink" title="2.1 创建数据表"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.1 创建数据表</h3><p>示例：创建学生表 MySQL命令：</p><pre><code> create table student( id int, name varchar(20), gender varchar(10), birthday date );</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303140044367.png" alt="在这里插入图片描述"></p><h3 id="2-2-查看数据表"><a href="#2-2-查看数据表" class="headerlink" title="2.2 查看数据表"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.2 查看数据表</h3><p>示例：查看当前数据库中所有表 MySQL命令：</p><pre><code>show tables;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303144745383.png" alt="在这里插入图片描述"><br>示例：查表的基本信息 MySQL命令：</p><pre><code>show create table student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303144940575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>示例：查看表的字段信息 MySQL命令：</p><pre><code>desc student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303145223522.png" alt="在这里插入图片描述"></p><h3 id="2-3-修改数据表"><a href="#2-3-修改数据表" class="headerlink" title="2.3 修改数据表"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.3 修改数据表</h3><p>有时，希望对表中的某些信息进行修改，例如：修改表名、修改字段名、修改字段 数据类型…等等。在MySQL中使用alter table修改数据表.<br>示例：修改表名 MySQL命令：</p><pre><code>alter table student rename to stu;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303145645914.png" alt="在这里插入图片描述"><br>示例：修改字段名 MySQL命令：</p><pre><code>alter table stu change name sname varchar(10);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303150127793.png" alt="在这里插入图片描述"><br>示例：修改字段数据类型 MySQL命令：</p><pre><code>alter table stu modify sname int;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303150426652.png" alt="在这里插入图片描述"><br>示例：增加字段 MySQL命令：</p><pre><code>alter table stu add address varchar(50);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303150757176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>示例：删除字段 MySQL命令：</p><pre><code>alter table stu drop address;</code></pre><p>运行效果展示：</p><p><img src="https://img-blog.csdnimg.cn/20210303151816445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-4-删除数据表"><a href="#2-4-删除数据表" class="headerlink" title="2.4 删除数据表"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.4 删除数据表</h3><p>语法：</p><pre><code>drop table 表名;</code></pre><p>示例：删除数据表 MySQL命令：</p><pre><code>drop table stu;</code></pre><p>运行效果展示：</p><p><img src="https://img-blog.csdnimg.cn/20210303152039101.png" alt="在这里插入图片描述"></p><h1 id="五、数据表的约束"><a href="#五、数据表的约束" class="headerlink" title="五、数据表的约束"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>五、数据表的约束</h1><p>为防止错误的数据被插入到数据表，MySQL中定义了一些维护数据库完整性的规则；这些规则常称为表的约束。常见约束如下：</p><table><thead><tr><th>约束条件</th><th>说明</th></tr></thead><tbody><tr><td>PRIMARY KEY</td><td>主键约束用于唯一标识对应的记录</td></tr><tr><td>FOREIGN KEY</td><td>外键约束</td></tr><tr><td>NOT NULL</td><td>非空约束</td></tr><tr><td>UNIQUE</td><td>唯一性约束</td></tr><tr><td>DEFAULT</td><td>默认值约束，用于设置字段的默认值</td></tr></tbody></table><p>以上五种约束条件针对表中字段进行限制从而保证数据表中数据的正确性和唯一性。换句话说，表的约束实际上就是表中数据的限制条件。</p><h2 id="1-主键约束"><a href="#1-主键约束" class="headerlink" title="1.主键约束"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.主键约束</h2><p>主键约束即primary key用于唯一的标识表中的每一行。被标识为主键的数据在表中是唯一的且其值不能为空。这点类似于我们每个人都有一个身份证号，并且这个身份证号是唯一的。<br>主键约束基本语法：</p><pre><code>字段名 数据类型 primary key;</code></pre><p><strong>设置主键约束(primary key)的第一种方式</strong><br>示例：MySQL命令：</p><pre><code>create table student(id int primary key,name varchar(20));</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303161028430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>设置主键约束(primary key)的第二·种方式</strong><br>示例：MySQL命令：</p><pre><code>create table student01(id intname varchar(20),primary key(id));</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303173104926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-非空约束"><a href="#2-非空约束" class="headerlink" title="2.非空约束"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.非空约束</h2><p>非空约束即 NOT NULL指的是字段的值不能为空，基本的语法格式如下所示：</p><pre><code>字段名 数据类型 NOT NULL;</code></pre><p>示例：MySQL命令：</p><pre><code>create table student02(id intname varchar(20) not null);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/2021030317340097.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-默认值约束"><a href="#3-默认值约束" class="headerlink" title="3.默认值约束"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3.默认值约束</h2><p>默认值约束即DEFAULT用于给数据表中的字段指定默认值，即当在表中插入一条新记录时若未给该字段赋值，那么，数据库系统会自动为这个字段插人默认值；其基本的语法格式如下所示：</p><pre><code>字段名 数据类型 DEFAULT 默认值；</code></pre><p>示例：MySQL命令：</p><pre><code>create table student03(id int,name varchar(20),gender varchar(10) default &#39;male&#39;);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303173835546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5-唯一性约束"><a href="#5-唯一性约束" class="headerlink" title="5.唯一性约束"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>5.唯一性约束</h2><p>唯一性约束即UNIQUE用于保证数据表中字段的唯一性，即表中字段的值不能重复出现，其基本的语法格式如下所示：</p><pre><code>字段名 数据类型 UNIQUE;</code></pre><p>示例：MySQL命令：</p><pre><code>create table student04(id int,name varchar(20) unique);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303174216204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="6-外键约束"><a href="#6-外键约束" class="headerlink" title="6.外键约束"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>6.外键约束</h2><p>外键约束即FOREIGN KEY常用于多张表之间的约束。基本语法如下：</p><pre><code>-- 在创建数据表时语法如下：CONSTRAINT 外键名 FOREIGN KEY (从表外键字段) REFERENCES 主表 (主键字段)-- 将创建数据表创号后语法如下：ALTER TABLE 从表名 ADD CONSTRAINT 外键名 FOREIGN KEY (从表外键字段) REFERENCES 主表 (主键字段);</code></pre><p>示例：创建一个学生表 MySQL命令：</p><pre><code>create table student05(id int primary key,name varchar(20));</code></pre><p>示例：创建一个班级表 MySQL命令：</p><pre><code>create table class(classid int primary key,studentid int);</code></pre><p>示例：学生表作为主表，班级表作为副表设置外键， MySQL命令：</p><pre><code>alter table class add constraint fk_class_studentid foreign key(studentid) references student05(id);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303180124470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="6-1-数据一致性概念"><a href="#6-1-数据一致性概念" class="headerlink" title="6.1 数据一致性概念"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>6.1 数据一致性概念</h3><p>大家知道：建立外键是为了保证数据的完整和统一性。但是，如果主表中的数据被删除或修改从表中对应的数据该怎么办呢？很明显，从表中对应的数据也应该被删除，否则数据库中会存在很多无意义的垃圾数据。</p><h3 id="6-2-删除外键"><a href="#6-2-删除外键" class="headerlink" title="6.2 删除外键"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>6.2 删除外键</h3><p>语法如下：</p><pre><code>alter table 从表名 drop foreign key 外键名；</code></pre><p>示例：删除外键 MySQL命令：</p><pre><code>alter table class drop foreign key fk_class_studentid;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303180554954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>外键的那个字段不在了证明删除成功了</p><h3 id="6-3-关于外键约束需要注意的细节"><a href="#6-3-关于外键约束需要注意的细节" class="headerlink" title="6.3 关于外键约束需要注意的细节"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>6.3 关于外键约束需要注意的细节</h3><p>1、从表里的外键通常为主表的主键<br>2、从表里外键的数据类型必须与主表中主键的数据类型一致<br>3、主表发生变化时应注意主表与从表的数据一致性问题</p><h1 id="六、数据表插入数据"><a href="#六、数据表插入数据" class="headerlink" title="六、数据表插入数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>六、数据表插入数据</h1><p>在MySQL通过INSERT语句向数据表中插入数据。在此，我们先准备一张学生表，代码如下：</p><pre><code> create table student( id int, name varchar(30), age int, gender varchar(30) );</code></pre><h2 id="1-为表中所有字段插入数据"><a href="#1-为表中所有字段插入数据" class="headerlink" title="1. 为表中所有字段插入数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1. 为表中所有字段插入数据</h2><p>每个字段与其值是严格一一对应的。也就是说：每个值、值的顺序、值的类型必须与对应的字段相匹配。但是，各字段也无须与其在表中定义的顺序一致，它们只要与 VALUES中值的顺序一致即可。<br>语法如下：</p><pre><code>INSERT INTO 表名（字段名1,字段名2,...) VALUES (值 1,值 2,...);</code></pre><p>示例：向学生表中插入一条学生信息 MySQL命令：</p><pre><code>insert into student (id,name,age,gender) values (1,&#39;bob&#39;,16,&#39;male&#39;);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/2021030318190944.png" alt="在这里插入图片描述"></p><h2 id="2-为表中指定字段插入数据"><a href="#2-为表中指定字段插入数据" class="headerlink" title="2. 为表中指定字段插入数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2. 为表中指定字段插入数据</h2><p>语法如下：</p><pre><code>INSERT INTO 表名（字段名1,字段名2,...) VALUES (值 1,值 2,...);</code></pre><p>插入数据的方法基本和为表中所有字段插入数据，一样，只是需要插入的字段由你自己指定</p><h2 id="3-同时插入多条记录"><a href="#3-同时插入多条记录" class="headerlink" title="3. 同时插入多条记录"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3. 同时插入多条记录</h2><p>语法如下：</p><pre><code>INSERT INTO 表名 [(字段名1,字段名2,...)]VALUES (值 1,值 2,…),(值 1,值 2,…),...;</code></pre><p>在该方式中：(字段名1,字段名2,…)是可选的，它用于指定插人的字段名；(值 1,值 2,…),(值 1,值 2,…)表示要插人的记录，该记录可有多条并且每条记录之间用逗号隔开。<br>示例：向学生表中插入多条学生信息 MySQL命令：</p><pre><code>insert into student (id,name,age,gender) values (2,&#39;lucy&#39;,17,&#39;female&#39;),(3,&#39;jack&#39;,19,&#39;male&#39;),(4,&#39;tom&#39;,18,&#39;male&#39;);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303182837401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="七、更新数据"><a href="#七、更新数据" class="headerlink" title="七、更新数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>七、更新数据</h1><p>在MySQL通过UPDATE语句更新数据表中的数据。在此，我们将就用六中的student学生表</p><h2 id="1-UPDATE基本语法"><a href="#1-UPDATE基本语法" class="headerlink" title="1. UPDATE基本语法"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1. UPDATE基本语法</h2><pre><code>UPDATE 表名 SET 字段名1=值1[,字段名2 =值2,…] [WHERE 条件表达式];</code></pre><p>在该语法中：字段名1、字段名2…用于指定要更新的字段名称；值1、值 2…用于表示字段的新数据；WHERE 条件表达式 是可选的，它用于指定更新数据需要满足的条件</p><h2 id="2-UPDATE更新部分数据"><a href="#2-UPDATE更新部分数据" class="headerlink" title="2. UPDATE更新部分数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2. UPDATE更新部分数据</h2><p>示例：将name为tom的记录的age设置为20并将其gender设置为female MySQL命令：</p><pre><code>update student set age=20,gender=&#39;female&#39; where name=&#39;tom&#39;;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/2021030318372031.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-UPDATE更新全部数据"><a href="#3-UPDATE更新全部数据" class="headerlink" title="3. UPDATE更新全部数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3. UPDATE更新全部数据</h2><p>示例：将所有记录的age设置为18 MySQL命令：</p><pre><code>update student set age=18;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/2021030318401177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="八、删除数据"><a href="#八、删除数据" class="headerlink" title="八、删除数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>八、删除数据</h1><p>在MySQL通过DELETE语句删除数据表中的数据。在此，我们先准备一张数据表，代码如下：</p><pre><code>-- 创建学生表 create table student( id int, name varchar(30), age int, gender varchar(30) ); -- 插入数据 insert into student (id,name,age,gender) values (2,&#39;lucy&#39;,17,&#39;female&#39;),(3,&#39;jack&#39;,19,&#39;male&#39;),(4,&#39;tom&#39;,18,&#39;male&#39;),(5,&#39;sal&#39;,19,&#39;female&#39;),(6,&#39;sun&#39;,20,&#39;male&#39;),(7,&#39;sad&#39;,13,&#39;female&#39;),(8,&#39;sam&#39;,14,&#39;male&#39;);</code></pre><h2 id="1-DELETE基本语法"><a href="#1-DELETE基本语法" class="headerlink" title="1. DELETE基本语法"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1. DELETE基本语法</h2><p>在该语法中：表名用于指定要执行删除操作的表；[WHERE 条件表达式]为可选参数用于指定删除的条件。</p><pre><code>DELETE FROM 表名 [WHERE 条件表达式];</code></pre><h2 id="2-DELETE删除部分数据"><a href="#2-DELETE删除部分数据" class="headerlink" title="2. DELETE删除部分数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2. DELETE删除部分数据</h2><p>示例：删除age等于14的所有记录 MySQL命令：</p><pre><code>delete from student where age=14;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303185050926.png" alt="在这里插入图片描述"></p><h2 id="3-DELETE删除全部数据"><a href="#3-DELETE删除全部数据" class="headerlink" title="3. DELETE删除全部数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3. DELETE删除全部数据</h2><p>示例：删除student表中的所有记录 MySQL命令：</p><pre><code>delete from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210303185424760.png" alt="在这里插入图片描述"></p><h2 id="4-TRUNCATE和DETELE的区别"><a href="#4-TRUNCATE和DETELE的区别" class="headerlink" title="4. TRUNCATE和DETELE的区别"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>4. TRUNCATE和DETELE的区别</h2><p>TRUNCATE和DETELE都能实现删除表中的所有数据的功能，但两者也是有区别的：<br>1、DELETE语句后可跟WHERE子句，可通过指定WHERE子句中的条件表达式只删除满足条件的部分记录；但是，TRUNCATE语句只能用于删除表中的所有记录。<br>2、使用TRUNCATE语句删除表中的数据后，再次向表中添加记录时自动增加字段的默认初始值重新由1开始；使用DELETE语句删除表中所有记录后，再次向表中添加记录时自动增加字段的值为删除时该字段的最大值加1<br>3、DELETE语句是DML语句，TRUNCATE语句通常被认为是DDL语句</p><h1 id="九、MySQL数据表简单查询"><a href="#九、MySQL数据表简单查询" class="headerlink" title="九、MySQL数据表简单查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>九、MySQL数据表简单查询</h1><h2 id="1-简单查询概述"><a href="#1-简单查询概述" class="headerlink" title="1.简单查询概述"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.简单查询概述</h2><p>简单查询即不含where的select语句。在此，我们讲解简单查询中最常用的两种查询：查询所有字段和查询指定字段。<br>在此，先准备测试数据，代码如下：</p><pre><code>-- 创建数据库DROP DATABASE IF EXISTS mydb;CREATE DATABASE mydb;USE mydb;-- 创建student表CREATE TABLE student (    sid CHAR(6),    sname VARCHAR(50),    age INT,    gender VARCHAR(50) DEFAULT &#39;male&#39;);-- 向student表插入数据INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1001&#39;, &#39;lili&#39;, 14, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1002&#39;, &#39;wang&#39;, 15, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1003&#39;, &#39;tywd&#39;, 16, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1004&#39;, &#39;hfgs&#39;, 17, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1005&#39;, &#39;qwer&#39;, 18, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1006&#39;, &#39;zxsd&#39;, 19, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1007&#39;, &#39;hjop&#39;, 16, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1008&#39;, &#39;tyop&#39;, 15, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1009&#39;, &#39;nhmk&#39;, 13, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1010&#39;, &#39;xdfv&#39;, 17, &#39;female&#39;);</code></pre><h2 id="2-查询所有字段（方法不唯一只是举例）"><a href="#2-查询所有字段（方法不唯一只是举例）" class="headerlink" title="2.查询所有字段（方法不唯一只是举例）"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.查询所有字段（方法不唯一只是举例）</h2><p>查询所有字段 MySQL命令：</p><pre><code>select * from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302183927761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-查询指定字段（sid、sname）"><a href="#3-查询指定字段（sid、sname）" class="headerlink" title="3.查询指定字段（sid、sname）"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3.查询指定字段（sid、sname）</h2><p>查询指定字段（sid、sname） MySQL命令：</p><pre><code>select sid,sname from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302184506628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-常数的查询"><a href="#4-常数的查询" class="headerlink" title="4.常数的查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>4.常数的查询</h2><p>在SELECT中除了书写列名，还可以书写常数。可以用于标记<br>常数的查询日期标记 MySQL命令：</p><pre><code>select sid,sname,&#39;2021-03-02&#39; from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302185049215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5-从查询结果中过滤重复数据"><a href="#5-从查询结果中过滤重复数据" class="headerlink" title="5.从查询结果中过滤重复数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>5.从查询结果中过滤重复数据</h2><p>在使用DISTINCT 时需要注意：<br><strong>在SELECT查询语句中DISTINCT关键字只能用在第一个所查列名之前。</strong><br>MySQL命令：</p><pre><code>select distinct gender from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302185517964.png" alt="在这里插入图片描述"></p><h2 id="6-算术运算符（举例加运算符）"><a href="#6-算术运算符（举例加运算符）" class="headerlink" title="6.算术运算符（举例加运算符）"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>6.算术运算符（举例加运算符）</h2><p>在SELECT查询语句中还可以使用加减乘除运算符。<br>查询学生10年后的年龄 MySQL命令：</p><pre><code> select sname,age+10 from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302185922370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="十、函数"><a href="#十、函数" class="headerlink" title="十、函数"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>十、函数</h1><p>在此，先准备测试数据，代码如下：</p><pre><code>-- 创建数据库DROP DATABASE IF EXISTS mydb;CREATE DATABASE mydb;USE mydb;-- 创建student表CREATE TABLE student (    sid CHAR(6),    sname VARCHAR(50),    age INT,    gender VARCHAR(50) DEFAULT &#39;male&#39;);-- 向student表插入数据INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1001&#39;, &#39;lili&#39;, 14, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1002&#39;, &#39;wang&#39;, 15, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1003&#39;, &#39;tywd&#39;, 16, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1004&#39;, &#39;hfgs&#39;, 17, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1005&#39;, &#39;qwer&#39;, 18, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1006&#39;, &#39;zxsd&#39;, 19, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1007&#39;, &#39;hjop&#39;, 16, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1008&#39;, &#39;tyop&#39;, 15, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1009&#39;, &#39;nhmk&#39;, 13, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1010&#39;, &#39;xdfv&#39;, 17, &#39;female&#39;);</code></pre><h2 id="1-聚合函数"><a href="#1-聚合函数" class="headerlink" title="1.聚合函数"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.聚合函数</h2><p>在开发中，我们常常有类似的需求：统计某个字段的最大值、最小值、 平均值等等。为此，MySQL中提供了聚合函数来实现这些功能。所谓聚合，就是将多行汇总成一行；其实，所有的聚合函数均如此——输入多行，输出一行。聚合函数具有自动滤空的功能，若某一个值为NULL，那么会自动将其过滤使其不参与运算。<br><strong>聚合函数使用规则：</strong><br>只有SELECT子句和HAVING子句、ORDER BY子句中能够使用聚合函数。例如，在WHERE子句中使用聚合函数是错误的。<br>接下来，我们学习常用聚合函数。</p><h3 id="1-1、count（）"><a href="#1-1、count（）" class="headerlink" title="1.1、count（）"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.1、count（）</h3><p>统计表中数据的行数或者统计指定列其值不为NULL的数据个数<br><em>查询有多少该表中有多少人</em><br>MySQL命令：</p><pre><code>select count(*) from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302190940321.png" alt="在这里插入图片描述"></p><h3 id="1-2、max（）"><a href="#1-2、max（）" class="headerlink" title="1.2、max（）"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.2、max（）</h3><p>计算指定列的最大值，如果指定列是字符串类型则使用字符串排序运算</p><p><em>查询该学生表中年纪最大的学生</em><br>MySQL命令：</p><pre><code>select max(age) from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210304164639342.png" alt="在这里插入图片描述"></p><h3 id="1-3、min（）"><a href="#1-3、min（）" class="headerlink" title="1.3、min（）"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.3、min（）</h3><p>计算指定列的最小值，如果指定列是字符串类型则使用字符串排序运算</p><p>查询该学生表中年纪最小的学生 MySQL命令：</p><pre><code>select sname,min(age) from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302191531189.png" alt="在这里插入图片描述"></p><h3 id="1-4、sum（）"><a href="#1-4、sum（）" class="headerlink" title="1.4、sum（）"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.4、sum（）</h3><p>计算指定列的数值和，如果指定列类型不是数值类型则计算结果为0<br>查询该学生表中年纪的总和 MySQL命令：</p><pre><code>select sum(age) from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302192155981.png" alt="在这里插入图片描述"></p><h3 id="1-5、avg（）"><a href="#1-5、avg（）" class="headerlink" title="1.5、avg（）"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.5、avg（）</h3><p>计算指定列的平均值，如果指定列类型不是数值类型则计算结果为</p><p>查询该学生表中年纪的平均数 MySQL命令：</p><pre><code>select avg(age) from student;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302192048399.png" alt="在这里插入图片描述"></p><h2 id="2-其他常用函数"><a href="#2-其他常用函数" class="headerlink" title="2.其他常用函数"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.其他常用函数</h2><p>这里我就不一一举例了，基本混个眼熟，以后用到再细说</p><h3 id="2-1、时间函数"><a href="#2-1、时间函数" class="headerlink" title="2.1、时间函数"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.1、时间函数</h3><pre><code>SELECT NOW();SELECT DAY (NOW());SELECT DATE (NOW());SELECT TIME (NOW());SELECT YEAR (NOW());SELECT MONTH (NOW());SELECT CURRENT_DATE();SELECT CURRENT_TIME();SELECT CURRENT_TIMESTAMP();SELECT ADDTIME(&#39;14:23:12&#39;,&#39;01:02:01&#39;);SELECT DATE_ADD(NOW(),INTERVAL 1 DAY);SELECT DATE_ADD(NOW(),INTERVAL 1 MONTH);SELECT DATE_SUB(NOW(),INTERVAL 1 DAY);SELECT DATE_SUB(NOW(),INTERVAL 1 MONTH);SELECT DATEDIFF(&#39;2019-07-22&#39;,&#39;2019-05-05&#39;);</code></pre><h3 id="2-2、字符串函数"><a href="#2-2、字符串函数" class="headerlink" title="2.2、字符串函数"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.2、字符串函数</h3><pre><code>--连接函数SELECT CONCAT ()--SELECT INSTR ();--统计长度SELECT LENGTH();</code></pre><h3 id="2-3、数学函数"><a href="#2-3、数学函数" class="headerlink" title="2.3、数学函数"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.3、数学函数</h3><pre><code>-- 绝对值SELECT ABS(-136);-- 向下取整SELECT FLOOR(3.14);-- 向上取整SELECT CEILING(3.14);</code></pre><h1 id="十一、条件查询"><a href="#十一、条件查询" class="headerlink" title="十一、条件查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>十一、条件查询</h1><p>数据库中存有大量数据，我们可根据需求获取指定的数据。此时，我们可在查询语句中通过WHERE子句指定查询条件对查询结果进行过滤。<br>在开始学习条件查询之前，我们先准备测试数据，代码如下：</p><pre><code>-- 创建数据库DROP DATABASE IF EXISTS mydb;CREATE DATABASE mydb;USE mydb;-- 创建student表CREATE TABLE student (    sid CHAR(6),    sname VARCHAR(50),    age INT,    gender VARCHAR(50) DEFAULT &#39;male&#39;);-- 向student表插入数据INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1001&#39;, &#39;lili&#39;, 14, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1002&#39;, &#39;wang&#39;, 15, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1003&#39;, &#39;tywd&#39;, 16, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1004&#39;, &#39;hfgs&#39;, 17, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1005&#39;, &#39;qwer&#39;, 18, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1006&#39;, &#39;zxsd&#39;, 19, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1007&#39;, &#39;hjop&#39;, 16, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1008&#39;, &#39;tyop&#39;, 15, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1009&#39;, &#39;nhmk&#39;, 13, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1010&#39;, &#39;xdfv&#39;, 17, &#39;female&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1012&#39;, &#39;lili&#39;, 14, &#39;male&#39;);INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1013&#39;, &#39;wang&#39;, 15, &#39;female&#39;);</code></pre><h2 id="1-使用关系运算符查询"><a href="#1-使用关系运算符查询" class="headerlink" title="1.使用关系运算符查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.使用关系运算符查询</h2><p>在WHERE中可使用关系运算符进行条件查询，常用的关系运算符如下所示：</p><table><thead><tr><th>关系运算符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr></tbody></table><p>查询年龄等于或大于17的学生的信息 MySQL命令：</p><pre><code>select * from student where age&gt;=17;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302194156529.png" alt="在这里插入图片描述"></p><h2 id="2-使用IN关键字查询"><a href="#2-使用IN关键字查询" class="headerlink" title="2.使用IN关键字查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.使用IN关键字查询</h2><p>IN关键字用于判断某个字段的值是否在指定集合中。如果字段的值恰好在指定的集合中，则将字段所在的记录将査询出来。</p><p>查询sid为S_1002和S_1003的学生信息 MySQL命令：</p><pre><code>select * from student where sid in (&#39;S_1002&#39;,&#39;S_1003&#39;);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302195114401.png" alt="在这里插入图片描述"><br>查询sid为S_1001以外的学生的信息 MySQL命令：</p><pre><code>select * from student where sid not in (&#39;S_1001&#39;);</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302195321878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-使用BETWEEN-AND关键字查询"><a href="#3-使用BETWEEN-AND关键字查询" class="headerlink" title="3.使用BETWEEN AND关键字查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3.使用BETWEEN AND关键字查询</h2><p>BETWEEN AND用于判断某个字段的值是否在指定的范围之内。如果字段的值在指定范围内，则将所在的记录将查询出来<br>查询15到18岁的学生信息 MySQL命令：</p><pre><code>select * from student where age between 15 and 18;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/2021030219575915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查询不是15到18岁的学生信息 MySQL命令：</p><pre><code>select * from student where age not between 15 and 18;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302195913168.png" alt="在这里插入图片描述"></p><h2 id="4-使用空值查询"><a href="#4-使用空值查询" class="headerlink" title="4.使用空值查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>4.使用空值查询</h2><p>在MySQL中，使用 IS NULL关键字判断字段的值是否为空值。请注意：空值NULL不同于0，也不同于空字符串<br><strong>由于student表没有空值就不演示查询空值的了</strong><br>查询sname不为空值的学生信息 MySQL命令：</p><pre><code>select * from student where sname is not null;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302201810965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5-使用AND关键字查询"><a href="#5-使用AND关键字查询" class="headerlink" title="5.使用AND关键字查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>5.使用AND关键字查询</h2><p>在MySQL中可使用AND关键字可以连接两个或者多个查询条件。<br>查询年纪大于15且性别为male的学生信息 MySQL命令：</p><pre><code>select * from student where age&gt;15 and gender=&#39;male&#39;;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302202328945.png" alt="在这里插入图片描述"></p><h2 id="6-使用OR关键字查询"><a href="#6-使用OR关键字查询" class="headerlink" title="6.使用OR关键字查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>6.使用OR关键字查询</h2><p>在使用SELECT语句查询数据时可使用OR关键字连接多个査询条件。在使用OR关键字时，只要记录满足其中任意一个条件就会被查询出来<br>查询年纪大于15或者性别为male的学生信息 MySQL命令：</p><pre><code>select * from student where age&gt;15 or gender=&#39;male&#39;;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302202642783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="7-使用LIKE关键字查询"><a href="#7-使用LIKE关键字查询" class="headerlink" title="7.使用LIKE关键字查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>7.使用LIKE关键字查询</h2><p>MySQL中可使用LIKE关键字可以判断两个字符串是否相匹配</p><h3 id="7-1-普通字符串"><a href="#7-1-普通字符串" class="headerlink" title="7.1 普通字符串"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>7.1 普通字符串</h3><p>查询sname中与wang匹配的学生信息 MySQL命令：</p><pre><code>select * from student where sname like &#39;wang&#39;;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/202103022030077.png" alt="在这里插入图片描述"></p><h3 id="7-2-含有-通配的字符串"><a href="#7-2-含有-通配的字符串" class="headerlink" title="7.2 含有%通配的字符串"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>7.2 含有%通配的字符串</h3><p>%用于匹配任意长度的字符串。例如，字符串“a%”匹配以字符a开始任意长度的字符串<br>查询学生姓名以li开始的记录 MySQL命令：</p><pre><code>select * from student where sname like &#39;li%&#39;;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302203419987.png" alt="在这里插入图片描述"><br>查询学生姓名以g结尾的记录 MySQL命令：</p><pre><code>select * from student where sname like &#39;%g&#39;;</code></pre><p>运行效果展示：<br><img src="https://img-blog.csdnimg.cn/20210302203654189.png" alt="在这里插入图片描述"><br>查询学生姓名包含s的记录 MySQL命令：</p><pre><code>select * from student where sname like &#39;%s%&#39;;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210302203828429.png" alt="在这里插入图片描述"></p><h3 id="7-3-含有-通配的字符串"><a href="#7-3-含有-通配的字符串" class="headerlink" title="7.3 含有_通配的字符串"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>7.3 含有_通配的字符串</h3><p>下划线通配符只匹配单个字符，如果要匹配多个字符，需要连续使用多个下划线通配符。例如，字符串“ab_”匹配以字符串“ab”开始长度为3的字符串，如abc、abp等等；字符串“a__d”匹配在字符“a”和“d”之间包含两个字符的字符串，如”abcd”、”atud”等等。<br>查询学生姓名以zx开头且长度为4的记录 MySQL命令：</p><pre><code>select * from student where sname like &#39;zx__&#39;;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210302204051494.png" alt="在这里插入图片描述"></p><p>查询学生姓名以g结尾且长度为4的记录 MySQL命令：</p><pre><code>select * from student where sname like &#39;___g&#39;;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210302204240798.png" alt="在这里插入图片描述"></p><h2 id="8-使用LIMIT限制查询结果的数量"><a href="#8-使用LIMIT限制查询结果的数量" class="headerlink" title="8.使用LIMIT限制查询结果的数量"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>8.使用LIMIT限制查询结果的数量</h2><p>当执行查询数据时可能会返回很多条记录，而用户需要的数据可能只是其中的一条或者几条<br>查询学生表中年纪最小的3位同学 MySQL命令：</p><pre><code>select * from student order by age asc limit 3;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210302204847986.png" alt="在这里插入图片描述"></p><h2 id="9-使用GROUP-BY进行分组查询"><a href="#9-使用GROUP-BY进行分组查询" class="headerlink" title="9.使用GROUP BY进行分组查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>9.使用GROUP BY进行分组查询</h2><p>GROUP BY 子句可像切蛋糕一样将表中的数据进行分组，再进行查询等操作。换言之，可通俗地理解为：通过GROUP BY将原来的表拆分成了几张小表。<br>接下来，我们通过一个例子开始学习GROUP BY，代码如下</p><pre><code>-- 创建数据库DROP DATABASE IF EXISTS mydb;CREATE DATABASE mydb;USE mydb;-- 创建员工表CREATE TABLE employee (    id int,    name varchar(50),    salary int,    departmentnumber int);-- 向员工表中插入数据INSERT INTO employee values(1,&#39;tome&#39;,2000,1001); INSERT INTO employee values(2,&#39;lucy&#39;,9000,1002); INSERT INTO employee values(3,&#39;joke&#39;,5000,1003); INSERT INTO employee values(4,&#39;wang&#39;,3000,1004); INSERT INTO employee values(5,&#39;chen&#39;,3000,1001); INSERT INTO employee values(6,&#39;yukt&#39;,7000,1002); INSERT INTO employee values(7,&#39;rett&#39;,6000,1003); INSERT INTO employee values(8,&#39;mujk&#39;,4000,1004); INSERT INTO employee values(9,&#39;poik&#39;,3000,1001);</code></pre><h3 id="9-1-GROUP-BY和聚合函数一起使用"><a href="#9-1-GROUP-BY和聚合函数一起使用" class="headerlink" title="9.1 GROUP BY和聚合函数一起使用"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>9.1 GROUP BY和聚合函数一起使用</h3><p>统计各部门员工个数 MySQL命令：</p><pre><code>select count(*), departmentnumber from employee group by departmentnumber;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/2021030220555769.png" alt="在这里插入图片描述"><br>统计部门编号大于1001的各部门员工个数 MySQL命令：</p><pre><code>select count(*), departmentnumber from employee where departmentnumber&gt;1001 group by departmentnumber;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210302210134682.png" alt="在这里插入图片描述"></p><h3 id="9-2-GROUP-BY和聚合函数以及HAVING一起使用"><a href="#9-2-GROUP-BY和聚合函数以及HAVING一起使用" class="headerlink" title="9.2 GROUP BY和聚合函数以及HAVING一起使用"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>9.2 GROUP BY和聚合函数以及HAVING一起使用</h3><p>统计工资总和大于8000的部门 MySQL命令：</p><pre><code>select sum(salary),departmentnumber from employee group by departmentnumber having sum(salary)&gt;8000;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210302210627962.png" alt="在这里插入图片描述"></p><h2 id="10-使用ORDER-BY对查询结果排序"><a href="#10-使用ORDER-BY对查询结果排序" class="headerlink" title="10.使用ORDER BY对查询结果排序"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>10.使用ORDER BY对查询结果排序</h2><p>从表中査询出来的数据可能是无序的或者其排列顺序不是我们期望的。为此，我们可以使用ORDER BY对查询结果进行排序<br>其语法格式如下所示：</p><pre><code>SELECT 字段名1,字段名2,…FROM 表名ORDER BY 字段名1 [ASC 丨 DESC],字段名2 [ASC | DESC];</code></pre><p>在该语法中：字段名1、字段名2是查询结果排序的依据；参数 ASC表示按照升序排序，DESC表示按照降序排序；默认情况下，按照ASC方式排序。通常情况下，ORDER BY子句位于整个SELECT语句的末尾。<br>查询所有学生并按照年纪大小升序排列 MySQL命令：</p><pre><code>select * from student order by age asc;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/2021030221134859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>查询所有学生并按照年纪大小降序排列 MySQL命令：</p><pre><code>select * from student order by age desc;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210302211454223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="十二、别名设置"><a href="#十二、别名设置" class="headerlink" title="十二、别名设置"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>十二、别名设置</h1><p>在査询数据时可为表和字段取別名，该别名代替表和字段的原名参与查询操作。<br><strong>操作的表事先已准备</strong></p><h2 id="1-为表取别名"><a href="#1-为表取别名" class="headerlink" title="1.为表取别名"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.为表取别名</h2><p>在查询操作时，假若表名很长使用起来就不太方便，此时可为表取一个別名，用该别名来代替表的名称。语法格式如下所示：</p><pre><code>SELECT * FROM 表名 [AS] 表的别名 WHERE .... ;</code></pre><p>将student改为stu查询整表 MySQL命令：</p><pre><code>select * from student as stu;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210303192155711.png" alt="在这里插入图片描述"></p><h2 id="2-为字段取别名"><a href="#2-为字段取别名" class="headerlink" title="2.为字段取别名"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.为字段取别名</h2><p>在查询操作时，假若字段名很长使用起来就不太方便，此时可该字段取一个別名，用该别名来代替字段的名称。语法格式如下所示：</p><pre><code>SELECT 字段名1 [AS] 别名1 , 字段名2 [AS] 别名2 , ... FROM 表名 WHERE ... ;</code></pre><p>将student中的name取别名为“姓名” 查询整表 MySQL命令：</p><pre><code>select name as &#39;姓名&#39;,id from student;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/2021030319253113.png" alt="在这里插入图片描述"></p><h1 id="十三、表的关联关系"><a href="#十三、表的关联关系" class="headerlink" title="十三、表的关联关系"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>十三、表的关联关系</h1><p>在实际开发中数据表之间存在着各种关联关系。在此，介绍MySQL中数据表的三种关联关系。<br><strong>多对一</strong><br>多对一(亦称为一对多)是数据表中最常见的一种关系。例如：员工与部门之间的关系，一个部门可以有多个员工；而一个员工不能属于多个部门只属于某个部门。在多对一的表关系 中，应将外键建在多的一方否则会造成数据的冗余。<br><strong>多对多</strong><br>多对多是数据表中常见的一种关系。例如：学生与老师之间的关系，一个学生可以有多个老师而且一个老师有多个学生。通常情况下，为了实现这种关系需要定义一张中间表(亦称为连接表)该表会存在两个外键分别参照老师表和学生表。<br><strong>一对一</strong><br>在开发过程中，一对一的关联关系在数据库中并不常见；因为以这种方式存储的信息通常会放在同一张表中。<br>接下来，我们来学习在一对多的关联关系中如果添加和删除数据。先准备一些测试数据，代码如下：</p><pre><code>DROP TABLE IF EXISTS student;DROP TABLE IF EXISTS class;-- 创建班级表CREATE TABLE class(    cid int(4) NOT NULL PRIMARY KEY,    cname varchar(30) );-- 创建学生表CREATE TABLE student(    sid int(8) NOT NULL PRIMARY KEY,    sname varchar(30),    classid int(8) NOT NULL);-- 为学生表添加外键约束ALTER TABLE student ADD CONSTRAINT fk_student_classid FOREIGN KEY(classid) REFERENCES class(cid);-- 向班级表插入数据INSERT INTO class(cid,cname)VALUES(1,&#39;Java&#39;);INSERT INTO class(cid,cname)VALUES(2,&#39;Python&#39;);-- 向学生表插入数据INSERT INTO student(sid,sname,classid)VALUES(1,&#39;tome&#39;,1);INSERT INTO student(sid,sname,classid)VALUES(2,&#39;lucy&#39;,1);INSERT INTO student(sid,sname,classid)VALUES(3,&#39;lili&#39;,2);INSERT INTO student(sid,sname,classid)VALUES(4,&#39;domi&#39;,2);</code></pre><h2 id="1-关联查询"><a href="#1-关联查询" class="headerlink" title="1.关联查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.关联查询</h2><p>查询Java班的所有学生 MySQL命令：</p><pre><code>select * from student where classid=(select cid from class where cname=&#39;Java&#39;);</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/2021030319330865.png" alt="在这里插入图片描述"></p><h2 id="2-关于关联关系的删除数据"><a href="#2-关于关联关系的删除数据" class="headerlink" title="2.关于关联关系的删除数据"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.关于关联关系的删除数据</h2><p>请从班级表中删除Java班级。在此，请注意：班级表和学生表之间存在关联关系；要删除Java班级，应该先删除学生表中与该班相关联的学生。否则，假若先删除Java班那么学生表中的cid就失去了关联<br>删除Java班 MySQL命令：</p><pre><code>delete from student where classid=(select cid from class where cname=&#39;Java&#39;);delete from class where cname=&#39;Java&#39;;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/2021030319415767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="十四、多表连接查询"><a href="#十四、多表连接查询" class="headerlink" title="十四、多表连接查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>十四、多表连接查询</h1><h2 id="1-交叉连接查询"><a href="#1-交叉连接查询" class="headerlink" title="1.交叉连接查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.交叉连接查询</h2><p>交叉连接返回的结果是被连接的两个表中所有数据行的笛卡儿积；比如：集合A={a,b}，集合B={0,1,2}，则集合A和B的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)}。所以，交叉连接也被称为笛卡尔连接，其语法格式如下：</p><pre><code>SELECT * FROM 表1 CROSS JOIN 表2;</code></pre><p>在该语法中：CROSS JOIN用于连接两个要查询的表，通过该语句可以查询两个表中所有的数据组合。<br><strong>由于这个交叉连接查询在实际运用中没有任何意义，所以只做为了解即可</strong></p><h2 id="2-内连接查询"><a href="#2-内连接查询" class="headerlink" title="2.内连接查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.内连接查询</h2><p>内连接(Inner Join)又称简单连接或自然连接，是一种非常常见的连接查询。内连接使用比较运算符对两个表中的数据进行比较并列出与连接条件匹配的数据行，组合成新的 记录。也就是说在内连接查询中只有满足条件的记录才能出现在查询结果中。其语法格式如下：</p><pre><code>SELECT 查询字段1,查询字段2, ... FROM 表1 [INNER] JOIN 表2 ON 表1.关系字段=表2.关系字段</code></pre><p>在该语法中：INNER JOIN用于连接两个表，ON来指定连接条件；其中INNER可以省略。</p><p>准备数据，代码如下：</p><pre><code>-- 若存在数据库mydb则删除DROP DATABASE IF EXISTS mydb;-- 创建数据库mydbCREATE DATABASE mydb;-- 选择数据库mydbUSE mydb;-- 创建部门表CREATE TABLE department(  did int (4) NOT NULL PRIMARY KEY,   dname varchar(20));-- 创建员工表CREATE TABLE employee (  eid int (4) NOT NULL PRIMARY KEY,   ename varchar (20),   eage int (2),   departmentid int (4) NOT NULL);-- 向部门表插入数据INSERT INTO department VALUES(1001,&#39;财务部&#39;);INSERT INTO department VALUES(1002,&#39;技术部&#39;);INSERT INTO department VALUES(1003,&#39;行政部&#39;);INSERT INTO department VALUES(1004,&#39;生活部&#39;);-- 向员工表插入数据INSERT INTO employee VALUES(1,&#39;张三&#39;,19,1003);INSERT INTO employee VALUES(2,&#39;李四&#39;,18,1002);INSERT INTO employee VALUES(3,&#39;王五&#39;,20,1001);INSERT INTO employee VALUES(4,&#39;赵六&#39;,20,1004);</code></pre><p>查询员工姓名及其所属部门名称 MySQL命令：</p><pre><code>select employee.ename,department.dname from department inner join employee on department.did=employee.departmentid;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/2021030320040897.png" alt="在这里插入图片描述"></p><h2 id="3-外连接查询"><a href="#3-外连接查询" class="headerlink" title="3.外连接查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3.外连接查询</h2><p>在使用内连接查询时我们发现：返回的结果只包含符合查询条件和连接条件的数据。但是，有时还需要在返回查询结果中不仅包含符合条件的数据，而且还包括左表、右表或两个表中的所有数据，此时我们就需要使用外连接查询。外连接又分为左(外)连接和右(外)连接。其语法格式如下：</p><pre><code>SELECT 查询字段1,查询字段2, ... FROM 表1 LEFT | RIGHT [OUTER] JOIN 表2 ON 表1.关系字段=表2.关系字段 WHERE 条件</code></pre><p>由此可见，外连接的语法格式和内连接非常相似，只不过使用的是LEFT [OUTER] JOIN、RIGHT [OUTER] JOIN关键字。其中，关键字左边的表被称为左表，关键字右边的表被称为右表；OUTER可以省略。<br>在使用左(外)连接和右(外)连接查询时，查询结果是不一致的，具体如下：<br><strong>1、LEFT [OUTER] JOIN 左(外)连接：返回包括左表中的所有记录和右表中符合连接条件的记录。<br>2、RIGHT [OUTER] JOIN 右(外)连接：返回包括右表中的所有记录和左表中符合连接条件的记录。</strong></p><p>先准备数据，代码如下：</p><pre><code>-- 若存在数据库mydb则删除DROP DATABASE IF EXISTS mydb;-- 创建数据库mydbCREATE DATABASE mydb;-- 选择数据库mydbUSE mydb;-- 创建班级表CREATE TABLE class(  cid int (4) NOT NULL PRIMARY KEY,   cname varchar(20));-- 创建学生表CREATE TABLE student (  sid int (4) NOT NULL PRIMARY KEY,   sname varchar (20),   sage int (2),   classid int (4) NOT NULL);-- 向班级表插入数据INSERT INTO class VALUES(1001,&#39;Java&#39;);INSERT INTO class VALUES(1002,&#39;C++&#39;);INSERT INTO class VALUES(1003,&#39;Python&#39;);INSERT INTO class VALUES(1004,&#39;PHP&#39;);-- 向学生表插入数据INSERT INTO student VALUES(1,&#39;张三&#39;,20,1001);INSERT INTO student VALUES(2,&#39;李四&#39;,21,1002);INSERT INTO student VALUES(3,&#39;王五&#39;,24,1002);INSERT INTO student VALUES(4,&#39;赵六&#39;,23,1003);INSERT INTO student VALUES(5,&#39;Jack&#39;,22,1009);</code></pre><p><em>准备这组数据有一定的特点，为的是让大家直观的看出左连接与右连接的不同之处<br>1、班级编号为1004的PHP班级没有学生<br>2、学号为5的学生王跃跃班级编号为1009，该班级编号并不在班级表中</em></p><h3 id="3-1-左（外）连接查询"><a href="#3-1-左（外）连接查询" class="headerlink" title="3.1 左（外）连接查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3.1 左（外）连接查询</h3><p>左(外)连接的结果包括LEFT JOIN子句中指定的左表的所有记录，以及所有满足连接条件的记录。如果左表的某条记录在右表中不存在则在右表中显示为空。<br>查询每个班的班级ID、班级名称及该班的所有学生的名字 MySQL命令：</p><pre><code>select class.cid,class.cname,student.sname from class left outer join student on class.cid=student.classid;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210303201647123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>展示结果分析：<br>1、分别找出Java班、C++班、Python班的学生<br>2、右表的王跃跃不满足查询条件故其没有出现在查询结果中<br>3、虽然左表的PHP班没有学生，但是任然显示了PHP的信息；但是，它对应的学生名字为NULL</p><h3 id="3-2-右（外）连接查询"><a href="#3-2-右（外）连接查询" class="headerlink" title="3.2 右（外）连接查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3.2 右（外）连接查询</h3><p>右(外)连接的结果包括RIGHT JOIN子句中指定的右表的所有记录，以及所有满足连接条件的记录。如果右表的某条记录在左表中没有匹配，则左表将返回空值。<br>查询每个班的班级ID、班级名称及该班的所有学生的名字 MySQL命令：</p><pre><code>select class.cid,class.cname,student.sname from class right outer join student on class.cid=student.classid;</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210303202037216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>展示结果分析：<br>1、分别找出Java班、C++班、Python班的学生<br>2、左表的PHP班不满足查询条件故其没有出现在查询结果中<br>3、虽然右表的jack没有对应班级，但是任然显示王跃跃的信息；但是，它对应的班级以及班级编号均为NULL</p><h1 id="十五、子查询"><a href="#十五、子查询" class="headerlink" title="十五、子查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>十五、子查询</h1><p>子查询是指一个查询语句嵌套在另一个查询语句内部的查询；该查询语句可以嵌套在一个 SELECT、SELECT…INTO、INSERT…INTO等语句中。在执行查询时，首先会执行子查询中的语句，再将返回的结果作为外层查询的过滤条件。在子査询中通常可以使用比较运算符和IN、EXISTS、ANY、ALL等关键字。</p><p>准备数据，代码如下：</p><pre><code>DROP TABLE IF EXISTS student;DROP TABLE IF EXISTS class;-- 创建班级表CREATE TABLE class(  cid int (4) NOT NULL PRIMARY KEY,   cname varchar(20));-- 创建学生表CREATE TABLE student (  sid int (4) NOT NULL PRIMARY KEY,   sname varchar (20),   sage int (2),   classid int (4) NOT NULL);-- 向班级表插入数据INSERT INTO class VALUES(1001,&#39;Java&#39;);INSERT INTO class VALUES(1002,&#39;C++&#39;);INSERT INTO class VALUES(1003,&#39;Python&#39;);INSERT INTO class VALUES(1004,&#39;PHP&#39;);INSERT INTO class VALUES(1005,&#39;Android&#39;);-- 向学生表插入数据INSERT INTO student VALUES(1,&#39;张三&#39;,20,1001);INSERT INTO student VALUES(2,&#39;李四&#39;,21,1002);INSERT INTO student VALUES(3,&#39;王五&#39;,24,1003);INSERT INTO student VALUES(4,&#39;赵六&#39;,23,1004);INSERT INTO student VALUES(5,&#39;小明&#39;,21,1001);INSERT INTO student VALUES(6,&#39;小红&#39;,26,1001);INSERT INTO student VALUES(7,&#39;小亮&#39;,27,1002);</code></pre><h2 id="1-带比较运算符的子查询"><a href="#1-带比较运算符的子查询" class="headerlink" title="1.带比较运算符的子查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>1.带比较运算符的子查询</h2><p>比较运算符前面我们提到过得，就是&gt;、&lt;、=、&gt;=、&lt;=、!=等<br>查询张三同学所在班级的信息 MySQL命令：</p><pre><code>select * from class where cid=(select classid from student where sname=&#39;张三&#39;);</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/2021030320275492.png" alt="在这里插入图片描述"><br>查询比张三同学所在班级编号还大的班级的信息 MySQL命令：</p><pre><code>select * from class where cid&gt;(select classid from student where sname=&#39;张三&#39;);</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210303203231622.png" alt="在这里插入图片描述"></p><h2 id="2-带EXISTS关键字的子查询"><a href="#2-带EXISTS关键字的子查询" class="headerlink" title="2.带EXISTS关键字的子查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>2.带EXISTS关键字的子查询</h2><p>EXISTS关键字后面的参数可以是任意一个子查询， 它不产生任何数据只返回TRUE或FALSE。当返回值为TRUE时外层查询才会 执行<br>假如王五同学在学生表中则从班级表查询所有班级信息 MySQL命令：</p><pre><code>select * from class where exists (select * from student where sname=&#39;王五&#39;);</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210303203707252.png" alt="在这里插入图片描述"></p><h2 id="3-带ANY关键字的子查询"><a href="#3-带ANY关键字的子查询" class="headerlink" title="3.带ANY关键字的子查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>3.带ANY关键字的子查询</h2><p>ANY关键字表示满足其中任意一个条件就返回一个结果作为外层查询条件。</p><p>查询比任一学生所属班级号还大的班级编号 MySQL命令：</p><pre><code>select * from class where cid &gt; any (select classid from student);</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210303204057530.png" alt="在这里插入图片描述"></p><h2 id="4-带ALL关键字的子查询"><a href="#4-带ALL关键字的子查询" class="headerlink" title="4.带ALL关键字的子查询"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>4.带ALL关键字的子查询</h2><p>ALL关键字与ANY有点类似，只不过带ALL关键字的子査询返回的结果需同时满足所有内层査询条件。</p><p>查询比所有学生所属班级号还大的班级编号 MySQL命令：</p><pre><code>select * from class where cid &gt; all (select classid from student);</code></pre><p>运行效果展示<br><img src="https://img-blog.csdnimg.cn/20210303204447489.png" alt="在这里插入图片描述"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187"></a>总结</h1><p><strong>重要</strong>（从关键字分析）：<br><strong>查询语句的书写顺序和执行顺序</strong><br>select ===&gt; from ===&gt; where ===&gt; group by ===&gt; having ===&gt; order by ===&gt; limit<br><strong>查询语句的执行顺序</strong><br>from ===&gt; where ===&gt; group by ===&gt; having ===&gt; select ===&gt; order by ===&gt; limi</p><p>基于复习，乐于分享 所以有了这篇文章！！！<br><img src="https://img-blog.csdnimg.cn/20210303204835945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg1MTk0NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>本文转自 <a href="https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164574504116780274141388&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114287877.pc_search_result_positive&utm_term=mysql&spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164574504116780274141388&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<del>all</del>top_positive~default-1-114287877.pc_search_result_positive&amp;utm_term=mysql&amp;spm=1018.2226.3001.4187</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;文章目录&quot;&gt;&lt;a href=&quot;#文章目录&quot; class=&quot;headerlink&quot; title=&quot;文章目录&quot;&gt;&lt;/a&gt;文章目录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;  &lt;a href=&quot;about:blank#_5&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;  &lt;a href=&quot;ab</summary>
      
    
    
    
    <category term="数据库" scheme="https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
    <category term="MySQL总结" scheme="https://ysluckly.github.io/tags/MySQL%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【Go项目】模拟网站登录并爬虫</title>
    <link href="https://ysluckly.github.io/2022/01/19/golang/"/>
    <id>https://ysluckly.github.io/2022/01/19/golang/</id>
    <published>2022-01-19T07:29:32.000Z</published>
    <updated>2022-02-26T06:01:46.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="title-Go语言模拟网站登录并爬虫"><a href="#title-Go语言模拟网站登录并爬虫" class="headerlink" title="title: Go语言模拟网站登录并爬虫  "></a><a href="https://blog.csdn.net/yang731227/article/details/83900422"></a>title: Go语言模拟网站登录并爬虫  </h2><p>想要学习爬虫的朋友知道，有时候我们需要爬的网站必须登录，才能获取到数据，那么我们该怎么模拟登录呢？</p><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a><a href="https://blog.csdn.net/yang731227/article/details/83900422"></a>需求</h1><p>我们登录上网站，并且选择应用管理。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93czEuc2luYWltZy5jbi9tdzY5MC81ZmU3OTEwNmx5MWZ4MXZpN3Noc3BqMjE3cTE0YW43dS5qcGc?x-oss-process=image/format,png"></p><p>我们现在需要爬取我们账号下的所有APP信息，根据签名期限，来计算APP剩余的时间（小时）。</p><h1 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a><a href="https://blog.csdn.net/yang731227/article/details/83900422"></a>获取cookie</h1><p>1.打开 <a href="https://866w.cn/">https://866w.cn</a> 登录上网站<br>2.按F12（不考虑IE浏览器），我这里使用的Chrome, 我们选择Network，再次刷新下网页</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93czEuc2luYWltZy5jbi9tdzY5MC81ZmU3OTEwNmx5MWZ4MXZoNDY3YW5qMjEwYzEyc2sxbS5qcGc?x-oss-process=image/format,png"><br>3. 通过截图我们可以看到 我们等会爬虫的页面是</p><blockquote><p><a href="https://866w.cn/index.php/home">https://866w.cn/index.php/home</a></p></blockquote><ol start="4"><li> 我先复制下我们的cookie</li></ol><pre><code>var cookie string =&quot;in_userid=1; in_username=xxxxxqq.com; in_userpassword=xxxxx; in_adminid=3; in_adminname=xxxxxqq.com; in_adminpassword=xxxxx; in_permission=1%2C2%2C3%2C4%2C5%2C6&quot;</code></pre><p>为了安全起见我把部分信息使用xxxx进行替换。</p><h1 id="查看html-信息"><a href="#查看html-信息" class="headerlink" title="查看html 信息"></a><a href="https://blog.csdn.net/yang731227/article/details/83900422"></a>查看html 信息</h1><pre><code>&lt;div class=&quot;card app card-ios&quot;&gt;&lt;i class=&quot;type-icon icon-apple&quot;&gt;&lt;/i&gt;&lt;div class=&quot;type-mark&quot;&gt;&lt;/div&gt;&lt;a class=&quot;appicon&quot; href=&quot;/index.php/each_app/38&quot;&gt;&lt;img class=&quot;icon ng-isolate-scope&quot; width=&quot;100&quot; height=&quot;100&quot; src=&quot;https://866w.cn/data/attachment/91541742353-1.png?v=1541750743&quot; onerror=&quot;this.src=&#39;/static/app/iOS.png&#39;&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;p class=&quot;appname&quot;&gt;&lt;i class=&quot;icon-owner&quot;&gt;&lt;/i&gt;&lt;span class=&quot;ng-binding&quot;&gt;鹿鼎娱乐&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;签名期限：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;a href=&quot;/index.php/sign_app/38&quot;&gt;2018-12-10 13:49:16&lt;/a&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;应用平台：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;iOS&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;应用标识：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;com.baochi.bc&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;最新版本：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;1.0（Build 1891）&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;div class=&quot;action&quot;&gt;&lt;a class=&quot;ng-binding&quot; href=&quot;/index.php/profile_app/38&quot;&gt;&lt;i class=&quot;icon-pen&quot;&gt;&lt;/i&gt; 管理&lt;/a&gt;&lt;a href=&quot;https://866w.cn/app.php/38&quot; target=&quot;_blank&quot; class=&quot;ng-binding&quot;&gt;&lt;i class=&quot;icon-eye&quot;&gt;&lt;/i&gt; 预览&lt;/a&gt;&lt;button class=&quot;btn btn-remove ng-scope&quot; onclick=&quot;del_app(38, 1)&quot;&gt;&lt;i class=&quot;icon icon-trash&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>通过上面的代码我们可以看到 我们的app信息都在类为 <code>card app card-ios</code> 的div块里面, 并且我们的主要信息都在<code>&lt;span class=&quot;ng-binding&quot;&gt;xxxxx&lt;/span&gt;</code>包含着</p><h1 id="制作正则表达式"><a href="#制作正则表达式" class="headerlink" title="制作正则表达式"></a><a href="https://blog.csdn.net/yang731227/article/details/83900422"></a>制作正则表达式</h1><p>当然我这个正则表达式只是为了偷懒，所有需要爬去的信息都是使用<code>(.*?)</code>来获取，我这个肯定不是好的方案，你可以自己去尝试写一个正则表达式。</p><p>这里我定义一个 Reg变量，保存正则表达式。</p><pre><code>Reg := `&lt;div class=&quot;card app card-ios&quot;&gt;(.*?)&lt;span class=&quot;ng-binding&quot;&gt;(.*?)&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;签名期限：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;应用平台：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;iOS&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;应用标识：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;(.*?)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;最新版本：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;(.*?)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;(.*?)&lt;/div&gt;</code></pre><h1 id="反爬虫"><a href="#反爬虫" class="headerlink" title="反爬虫"></a><a href="https://blog.csdn.net/yang731227/article/details/83900422"></a>反爬虫</h1><p>有的时候一些网站会有一些反爬虫机制，判断你是人工访问，还是机器访问，判断的原则,就是识别<code>user-agent</code> ,这里我们定义一个字符串切片，来保存不同浏览器的<code>user-agent</code>。当然有得网站还有IP访问限制，你可以使用代理解决，这里我们就不讨论这种情况了。</p><ul><li>  user-agent 数组</li></ul><pre><code>var userAgentList = []string&#123;&quot;Mozilla/5.0 (compatible, MSIE 10.0, Windows NT, DigExt)&quot;,    &quot;Mozilla/4.0 (compatible, MSIE 7.0, Windows NT 5.1, 360SE)&quot;,    &quot;Mozilla/4.0 (compatible, MSIE 8.0, Windows NT 6.0, Trident/4.0)&quot;,    &quot;Mozilla/5.0 (compatible, MSIE 9.0, Windows NT 6.1, Trident/5.0,&quot;,    &quot;Opera/9.80 (Windows NT 6.1, U, en) Presto/2.8.131 Version/11.11&quot;,    &quot;Mozilla/4.0 (compatible, MSIE 7.0, Windows NT 5.1, TencentTraveler 4.0)&quot;,    &quot;Mozilla/5.0 (Windows, U, Windows NT 6.1, en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&quot;,    &quot;Mozilla/5.0 (Macintosh, Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&quot;,    &quot;Mozilla/5.0 (Macintosh, U, Intel Mac OS X 10_6_8, en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&quot;,    &quot;Mozilla/5.0 (Linux, U, Android 3.0, en-us, Xoom Build/HRI39) AppleWebKit/534.13 (KHTML, like Gecko) Version/4.0 Safari/534.13&quot;,    &quot;Mozilla/5.0 (iPad, U, CPU OS 4_3_3 like Mac OS X, en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5&quot;,    &quot;Mozilla/4.0 (compatible, MSIE 7.0, Windows NT 5.1, Trident/4.0, SE 2.X MetaSr 1.0, SE 2.X MetaSr 1.0, .NET CLR 2.0.50727, SE 2.X MetaSr 1.0)&quot;,    &quot;Mozilla/5.0 (iPhone, U, CPU iPhone OS 4_3_3 like Mac OS X, en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5&quot;,    &quot;MQQBrowser/26 Mozilla/5.0 (Linux, U, Android 2.3.7, zh-cn, MB200 Build/GRJ22, CyanogenMod-7) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1&quot;&#125;</code></pre><ul><li>  随机获取user-agent</li></ul><p>上面我们存储了不同的浏览器user-agent, 现在我们还需要一个函数来随机调用它们。</p><pre><code>func GetRandomUserAgent() string &#123;    r := rand.New(rand.NewSource(time.Now().UnixNano()))    return userAgentList[r.Intn(len(userAgentList))]&#125;</code></pre><h1 id="模拟登录并获取html代码"><a href="#模拟登录并获取html代码" class="headerlink" title="模拟登录并获取html代码"></a><a href="https://blog.csdn.net/yang731227/article/details/83900422"></a>模拟登录并获取html代码</h1><p>现在我们开始进入重点，有了cookie我们怎么才能模拟登录，并且怎么才能获取网站的信息。</p><pre><code>func getUrlRespHtml() string &#123;    url := &quot;https://866w.cn/index.php/home&quot;    client := &amp;http.Client&#123;&#125;    req, err := http.NewRequest(&quot;GET&quot;, url, nil)    if err!=nil    &#123;        fmt.Println(&quot;获取地址错误&quot;)    &#125;    req.Header.Set(&quot;Cookie&quot;, cookie)    req.Header.Add(&quot;Agent&quot;,GetRandomUserAgent() )    resp, err := client.Do(req)    if err!=nil &#123;        fmt.Println(&quot;登录错误&quot;)    &#125;    resp_byte, err := ioutil.ReadAll(resp.Body)    defer resp.Body.Close()    respHtml := string(resp_byte)    return respHtml&#125;</code></pre><h2 id="使用正则表达式筛选信息"><a href="#使用正则表达式筛选信息" class="headerlink" title="使用正则表达式筛选信息"></a><a href="https://blog.csdn.net/yang731227/article/details/83900422"></a>使用正则表达式筛选信息</h2><p>当然我们获取了网站的html 代码也不行，html的信息太多，我们需要对它进行筛选，我们需要获取应用名称、签名期限、应用标识、最新版本 等信息，并且我们还需要根据签名期限来计算剩余时间。</p><pre><code>func Initialize() &#123;    reader := getUrlRespHtml()    Reg := `&lt;div class=&quot;card app card-ios&quot;&gt;(.*?)&lt;span class=&quot;ng-binding&quot;&gt;(.*?)&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;签名期限：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;应用平台：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;iOS&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;应用标识：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;(.*?)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;最新版本：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;(.*?)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;(.*?)&lt;/div&gt;`    rp1 := regexp.MustCompile(Reg)    heads := rp1.FindAllStringSubmatch(reader, -1)    timeLayout := &quot;2006-01-02 15:04:05&quot;   //转化所需模板    loc, _ := time.LoadLocation(&quot;Local&quot;)    for _, v := range heads &#123;        theTime, _ := time.ParseInLocation(timeLayout, v[4], loc) //使用模板在对应时区转化为time.time类型        TimeNow := time.Now()        left := theTime.Sub(TimeNow)        appHours := int(left.Hours())        fmt.Printf(&quot;应用名称：%s \n到期时间: %s\n剩余时间 :%s小时\n应用标识:%s\n应用版本:%s\n &quot;,v[2],v[4],strconv.Itoa(appHours),v[5],v[6])        fmt.Println()    &#125;&#125;</code></pre><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a><a href="https://blog.csdn.net/yang731227/article/details/83900422"></a>运行</h1><pre><code>func main()  &#123;    Initialize()&#125;</code></pre><p>我们可以查看到运行结果。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93czEuc2luYWltZy5jbi9tdzY5MC81ZmU3OTEwNmx5MWZ4MXd5aHB3YTJqMjBkeTB6d2p5NC5qcGc?x-oss-process=image/format,png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://blog.csdn.net/yang731227/article/details/83900422"></a>总结</h1><p>到此我们的教程已经结束，你可以自己根据你的需求来添加文本保存，或者其他啥的功能。如果你对正则表达式比较头疼，你也可以选择一些go的爬虫框架。</p><p>本文转自 <a href="https://blog.csdn.net/yang731227/article/details/83900422">https://blog.csdn.net/yang731227/article/details/83900422</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;title-Go语言模拟网站登录并爬虫&quot;&gt;&lt;a href=&quot;#title-Go语言模拟网站登录并爬虫&quot; class=&quot;headerlink&quot; title=&quot;title: Go语言模拟网站登录并爬虫  &quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="爬虫" scheme="https://ysluckly.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Go全栈面试题（3）-微服务面试题</title>
    <link href="https://ysluckly.github.io/2022/01/19/golang/"/>
    <id>https://ysluckly.github.io/2022/01/19/golang/</id>
    <published>2022-01-19T07:29:32.000Z</published>
    <updated>2022-02-26T06:00:37.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微服务面试题"><a href="#微服务面试题" class="headerlink" title="微服务面试题"></a><a href="https://blog.csdn.net/yang731227/article/details/90637535"></a>微服务面试题</h1><h2 id="Http-get跟head"><a href="#Http-get跟head" class="headerlink" title="Http get跟head"></a><a href="https://blog.csdn.net/yang731227/article/details/90637535"></a>Http get跟head</h2><p>get:获取由Request-URI标识的任何信息(以实体的形式)，如果Request-URI引用某个数据处理过程，则应该以它产生的数据作为在响应中的实体，而不是该过程的源代码文本，除非该过程碰巧输出该文本。</p><p>head: 除了服务器不能在响应中返回消息体，HEAD方法与GET相同。用来获取暗示实体的元信息，而不需要传输实体本身。常用于测试超文本链接的有效性、可用性和最近的修改。</p><h2 id="说一下中间件原理"><a href="#说一下中间件原理" class="headerlink" title="说一下中间件原理"></a><a href="https://blog.csdn.net/yang731227/article/details/90637535"></a>说一下中间件原理</h2><p>中间件（middleware）是基础软件的一大类，属于可复用软件的范畴。中间件处于操作系统软件与用户的应用软件的中间。中间件在操作系统、网络和数据库之上，应用软件的下层，总的作用是为处于自己上层的应用软件提供运行与开发的环境，帮助用户灵活、高效地开发和集成复杂的应用软件<br>IDC的定义是：中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，管理计算资源和网络通信。</p><p>中间件解决的问题是：</p><p>在中间件产生以前，应用软件直接使用操作系统、网络协议和数据库等开发，这些都是计算机最底层的东西，越底层越复杂，开发者不得不面临许多很棘手的问题，如操作系统的多样性，繁杂的网络程序设计、管理，复杂多变的网络环境，数据分散处理带来的不一致性问题、性能和效率、安全，等等。这些与用户的业务没有直接关系，但又必须解决，耗费了大量有限的时间和精力。于是，有人提出能不能将应用软件所要面临的共性问题进行提炼、抽象，在操作系统之上再形成一个可复用的部分，供成千上万的应用软件重复使用。这一技术思想最终构成了中间件这类的软件。中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担。</p><h2 id="用过原生的http包吗？"><a href="#用过原生的http包吗？" class="headerlink" title="用过原生的http包吗？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637535"></a>用过原生的http包吗？</h2><p>Golang中http包中处理 HTTP 请求主要跟两个东西相关：ServeMux 和 Handler。</p><p>ServrMux 本质上是一个 HTTP 请求路由器（或者叫多路复用器，Multiplexor）。它把收到的请求与一组预先定义的 URL 路径列表做对比，然后在匹配到路径的时候调用关联的处理器（Handler）。</p><p>处理器（Handler）负责输出HTTP响应的头和正文。任何满足了http.Handler接口的对象都可作为一个处理器。通俗的说，对象只要有个如下签名的ServeHTTP方法即可：</p><pre><code>ServeHTTP(http.ResponseWriter, *http.Request)</code></pre><p>Go 语言的 HTTP 包自带了几个函数用作常用处理器，比如FileServer，NotFoundHandler 和 RedirectHandler。</p><p>应用示例:</p><pre><code>package mainimport (    &quot;log&quot;    &quot;net/http&quot;)func main() &#123;    mux := http.NewServeMux()    rh := http.RedirectHandler(&quot;http://www.baidu.com&quot;, 307)    mux.Handle(&quot;/foo&quot;, rh)    log.Println(&quot;Listening...&quot;)    http.ListenAndServe(&quot;:3000&quot;, mux)&#125;</code></pre><p>在这个应用示例中,首先在 main 函数中我们只用了 http.NewServeMux 函数来创建一个空的 ServeMux。<br>然后我们使用 http.RedirectHandler 函数创建了一个新的处理器，这个处理器会对收到的所有请求，都执行307重定向操作到 <code>http://www.baidu.com</code>。<br>接下来我们使用 ServeMux.Handle 函数将处理器注册到新创建的 ServeMux，所以它在 URL 路径/foo 上收到所有的请求都交给这个处理器。<br>最后我们创建了一个新的服务器，并通过 http.ListenAndServe 函数监听所有进入的请求，通过传递刚才创建的 ServeMux来为请求去匹配对应处理器。<br>在浏览器中访问 <code>http://localhost:3000/foo</code>，你应该能发现请求已经成功的重定向了。</p><p>此刻你应该能注意到一些有意思的事情：ListenAndServer 的函数签名是 ListenAndServe(addr string, handler Handler) ，但是第二个参数我们传递的是个 ServeMux。</p><p>通过这个例子我们就可以知道,net/http包在编写golang web应用中有很重要的作用，它主要提供了基于HTTP协议进行工作的client实现和server实现，可用于编写HTTP服务端和客户端。</p><h2 id="grpc遵循什么协议？"><a href="#grpc遵循什么协议？" class="headerlink" title="grpc遵循什么协议？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637535"></a>grpc遵循什么协议？</h2><p>grpc是由Google主导开发的RPC框架，使用HTTP/2协议并用ProtoBuf作为序列化工具。gRPC是动态代理的模式实现的，客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法。和传统的REST不同的是gRPC使用了静态路径，从而提高性能，另外开发者不用了解各种底层网络协议，不用去拼REST风格的动态URL，用一些格式化的错误码代替了HTTP的状态码，不用管各种的HTTP状态码，开发者开发效率比较高。客户端可以充分利用高级流和链接功能，从而有助于节省带宽、降低的TCP链接次数、节省CPU使用.</p><h2 id="grpc内部原理是什么？"><a href="#grpc内部原理是什么？" class="headerlink" title="grpc内部原理是什么？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637535"></a>grpc内部原理是什么？</h2><p>gRPC 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。gRPC 默认使用 protocol buffers，这是 Google 开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如 JSON）.</p><h2 id="client如何实现长连接"><a href="#client如何实现长连接" class="headerlink" title="client如何实现长连接?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637535"></a>client如何实现长连接?</h2><ul><li>  使用http keep-alvie</li><li>  使用HeartBeat心跳包</li></ul><h2 id="微服务架构是什么样子的"><a href="#微服务架构是什么样子的" class="headerlink" title="微服务架构是什么样子的?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637535"></a>微服务架构是什么样子的?</h2><p>通常传统的项目体积庞大，需求、设计、开发、测试、部署流程固定。新功能需要在原项目上做修改。</p><p>但是微服务可以看做是对大项目的拆分，是在快速迭代更新上线的需求下产生的。新的功能模块会发布成新的服务组件，与其他已发布的服务组件一同协作。<br>服务内部有多个生产者和消费者，通常以http rest的方式调用，服务总体以一个（或几个）服务的形式呈现给客户使用。</p><p>微服务架构是一种思想对微服务架构我们没有一个明确的定义，但简单来说微服务架构是：</p><p>采用一组服务的方式来构建一个应用，服务独立部署在不同的进程中，不同服务通过一些轻量级交互机制来通信，例如 RPC、HTTP 等，服务可独立扩展伸缩，每个服务定义了明确的边界，不同的服务甚至可以采用不同的编程语言来实现，由独立的团队来维护。</p><p>Golang的微服务框架<a href="https://gokit.io/">kit</a>中有详细的微服务的例子,可以参考学习.</p><p>微服务架构设计包括：</p><ol><li> 服务熔断降级限流机制 熔断降级的概念(Rate Limiter 限流器,Circuit breaker 断路器).</li><li> 框架调用方式解耦方式 Kit 或 Istio 或 Micro 服务发现(consul zookeeper kubeneters etcd ) RPC调用框架.</li><li> 链路监控,zipkin和prometheus.</li><li> 多级缓存.</li><li> 网关 (kong gateway).</li><li> Docker部署管理 Kubenetters.</li><li> 自动集成部署 CI/CD 实践.</li><li> 自动扩容机制规则.</li><li> 压测 优化.</li><li> Trasport 数据传输(序列化和反序列化).</li><li> Logging 日志.</li><li> Metrics 指针对每个请求信息的仪表盘化.</li></ol><p><img src="https://www.github.com/Clown95/StroyBack/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1558062683597.png"></p><h2 id="微服务有什么优点？"><a href="#微服务有什么优点？" class="headerlink" title="微服务有什么优点？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637535"></a>微服务有什么优点？</h2><ul><li>  解耦——系统中的服务在很大程度上是解耦的。因此，整个应用程序可以很容易地构建、修改和伸缩</li><li>  组件化——微服务被视为独立的组件，可以很容易地替换和升级</li><li>  业务功能——微服务非常简单，只关注一个功能</li><li>  自治——开发人员和团队可以彼此独立工作，从而提高速度</li><li>  持续交付——通过软件创建、测试和批准的系统自动化，允许频繁地发布软件</li><li>  责任——微服务不关注应用程序作为项目。相反，他们将应用程序视为自己负责的产品</li><li>  分散治理——重点是为正确的工作使用正确的工具。这意味着没有标准化的模式或任何技术模式。开发人员可以自由选择最有用的工具来解决他们的问题</li><li>  敏捷——微服务支持敏捷开发。任何新特性都可以快速开发并再次丢弃</li></ul><p><img src="https://www.github.com/Clown95/StroyBack/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1558062724457.png"></p><h2 id="在使用微服务架构时，您面临的挑战是什么？"><a href="#在使用微服务架构时，您面临的挑战是什么？" class="headerlink" title="在使用微服务架构时，您面临的挑战是什么？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637535"></a>在使用微服务架构时，您面临的挑战是什么？</h2><p>开发一些较小的微服务听起来很容易，但开发它们时经常遇到的挑战如下。</p><ul><li>  自动化组件：难自动化，因为有许多较小的组件。因此，对于每个组件我们必须遵循Build，Deploy和Monitor的各个阶段。</li><li>  易感性：将大量组件维护在一起变得难以部署，维护，监控和识别问题。它需要在所有组件周围具有很好的感知能力。</li><li>  配置管理：在不同的环境中维护组件的配置有时会变得很困难。</li><li>  调试：很难找出每个服务的错误。维护集中的日志记录和仪表板来调试问题是非常重要的。</li></ul><h2 id="SOA和微服务架构之间的主要区别是什么？"><a href="#SOA和微服务架构之间的主要区别是什么？" class="headerlink" title="SOA和微服务架构之间的主要区别是什么？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637535"></a>SOA和微服务架构之间的主要区别是什么？</h2><p>SOA和微服务之间的主要区别如下：</p><table><thead><tr><th>SOA</th><th>微服务</th></tr></thead><tbody><tr><td>遵循“ 尽可能多的共享 ”架构方法</td><td>遵循“ 尽可能少分享 ”的架构方法</td></tr><tr><td>重要性在于 业务功能 重用</td><td>重要性在于“ 有界背景 ” 的概念</td></tr><tr><td>他们有 共同的 治理 和标准</td><td>他们专注于 人们的 合作 和其他选择的自由</td></tr><tr><td>使用 企业服务总线（ESB） 进行通信</td><td>简单的消息系统</td></tr><tr><td>它们支持 多种消息协议</td><td>他们使用 轻量级协议 ，如 HTTP / REST 等。</td></tr><tr><td>多线程， 有更多的开销来处理I / O</td><td>单线程 通常使用Event Loop功能进行非锁定I / O处理</td></tr><tr><td>最大化应用程序服务可重用性</td><td>专注于 解耦</td></tr><tr><td>传统的关系数据库 更常用</td><td>现代 关系数据库 更常用</td></tr><tr><td>系统的变化需要修改整体</td><td>系统的变化是创造一种新的服务</td></tr><tr><td>DevOps / Continuous Delivery正在变得流行，但还不是主流</td><td>专注于DevOps /持续交付</td></tr></tbody></table><h2 id="微服务之间是如何通信的呢？"><a href="#微服务之间是如何通信的呢？" class="headerlink" title="微服务之间是如何通信的呢？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637535"></a>微服务之间是如何通信的呢？</h2><ul><li>  REST over HTTP(S)</li><li>  通过Message Broker进行消息传递</li><li>  RPC (跨语言或单语言)</li></ul><p><strong>REST over HTTP(S)</strong><br>自Roy Fielding提出RESTful架构自提出以来，一直都是备受欢迎的方案，特别是在Web应用的开发中。Fielding提出的约束虽然不是标准，但在声明我们的API为RESTful之前，应该始终遵循这些约束。<br>HTTP上有各种各样的REST，因为没有强制执行的标准。开发人员可以自由选择以JSON、XML或某种自定义格式形成请求有效负载。<br>REST over HTTP（S）仅意味着使用REST架构风格并通过HTTP（S）发送请求。</p><p><strong>通过Message Broker进行消息传递</strong><br>该选项基本上通过将微服务连接到集中消息总线来工作，并且服务之间的所有通信都通过backbone发送消息来完成。</p><p><strong>RPC (跨语言或单语言)</strong><br>远程过程调用在分布式系统中并不新鲜，它通过在网络上的另一个设备上执行函数/方法/过程来工作。</p><h2 id="什么是微服务熔断-什么是服务降级"><a href="#什么是微服务熔断-什么是服务降级" class="headerlink" title="什么是微服务熔断?什么是服务降级?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637535"></a>什么是微服务熔断?什么是服务降级?</h2><p>微服务的熔断与降级，当然熔断与降级并不是一个概念，只是很多时候会一起实现了：</p><ul><li><p>服务熔断<br>  一般是某个服务故障或异常引起，类似“保险丝”，当某个异常被触发，直接熔断整个服务，而不是等到此服务超时。</p></li><li><p>服务降级<br>  降级是在客户端，与服务端无关。<br>  降级，从整体负荷考虑，某个服务熔断后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，这样，虽然服务水平下降，但可用，比直接挂掉要好。</p></li></ul><h2 id="你能否给出关于REST和微服务的要点？"><a href="#你能否给出关于REST和微服务的要点？" class="headerlink" title="你能否给出关于REST和微服务的要点？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637535"></a>你能否给出关于REST和微服务的要点？</h2><ul><li><p>REST<br>  虽然您可以通过多种方式实现微服务，但REST over HTTP是实现微服务的一种方式。REST还可用于其他应用程序，如Web应用程序，API设计和MVC应用程序，以提供业务数据。</p></li><li><p>微服务<br>  微服务是一种体系结构，其中系统的所有组件都被放入单独的组件中，这些组件可以单独构建，部署和扩展。微服务的某些原则和最佳实践有助于构建弹性应用程序。</p></li></ul><p>简而言之，您可以说REST是构建微服务的媒介。</p><h2 id="Etcd怎么实现分布式锁"><a href="#Etcd怎么实现分布式锁" class="headerlink" title="Etcd怎么实现分布式锁?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637535"></a>Etcd怎么实现分布式锁?</h2><p>首先思考下Etcd是什么？可能很多人第一反应可能是一个键值存储仓库，却没有重视官方定义的后半句，用于配置共享和服务发现。</p><pre><code>A highly-available key value store for shared configuration and service discovery.</code></pre><p>实际上，etcd 作为一个受到 ZooKeeper 与 doozer 启发而催生的项目，除了拥有与之类似的功能外，更专注于以下四点。</p><ul><li>  简单：基于 HTTP+JSON 的 API 让你用 curl 就可以轻松使用。</li><li>  安全：可选 SSL 客户认证机制。</li><li>  快速：每个实例每秒支持一千次写操作。</li><li>  可信：使用 Raft 算法充分实现了分布式。</li></ul><p>但是这里我们主要讲述Etcd如何实现分布式锁?</p><p>因为 Etcd 使用 Raft 算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。</p><ul><li><p>  保持独占即所有获取锁的用户最终只有一个可以得到。etcd 为此提供了一套实现分布式锁原子操作 CAS（CompareAndSwap）的 API。通过设置prevExist值，可以保证在多个节点同时去创建某个目录时，只有一个成功。而创建成功的用户就可以认为是获得了锁。</p></li><li><p>  控制时序，即所有想要获得锁的用户都会被安排执行，但是获得锁的顺序也是全局唯一的，同时决定了执行顺序。etcd 为此也提供了一套 API（自动创建有序键），对一个目录建值时指定为POST动作，这样 etcd 会自动在目录下生成一个当前最大的值为键，存储这个新的值（客户端编号）。同时还可以使用 API 按顺序列出所有当前目录下的键值。此时这些键的值就是客户端的时序，而这些键中存储的值可以是代表客户端的编号。</p></li></ul><p>在这里Ectd实现分布式锁基本实现原理为：</p><ol><li> 在ectd系统里创建一个key</li><li> 如果创建失败，key存在，则监听该key的变化事件，直到该key被删除，回到1</li><li> 如果创建成功，则认为我获得了锁</li></ol><p>应用示例:</p><pre><code>package etcdsyncimport (    &quot;fmt&quot;    &quot;io&quot;    &quot;os&quot;    &quot;sync&quot;    &quot;time&quot;    &quot;github.com/coreos/etcd/client&quot;    &quot;github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context&quot;)const (    defaultTTL = 60    defaultTry = 3    deleteAction = &quot;delete&quot;    expireAction = &quot;expire&quot;)// A Mutex is a mutual exclusion lock which is distributed across a cluster.type Mutex struct &#123;    key    string    id     string // The identity of the caller    client client.Client    kapi   client.KeysAPI    ctx    context.Context    ttl    time.Duration    mutex  *sync.Mutex    logger io.Writer&#125;// New creates a Mutex with the given key which must be the same// across the cluster nodes.// machines are the ectd cluster addressesfunc New(key string, ttl int, machines []string) *Mutex &#123;    cfg := client.Config&#123;        Endpoints:               machines,        Transport:               client.DefaultTransport,        HeaderTimeoutPerRequest: time.Second,    &#125;    c, err := client.New(cfg)    if err != nil &#123;        return nil    &#125;    hostname, err := os.Hostname()    if err != nil &#123;        return nil    &#125;    if len(key) == 0 || len(machines) == 0 &#123;        return nil    &#125;    if key[0] != &#39;/&#39; &#123;        key = &quot;/&quot; + key    &#125;    if ttl &lt; 1 &#123;        ttl = defaultTTL    &#125;    return &amp;Mutex&#123;        key:    key,        id:     fmt.Sprintf(&quot;%v-%v-%v&quot;, hostname, os.Getpid(), time.Now().Format(&quot;20060102-15:04:05.999999999&quot;)),        client: c,        kapi:   client.NewKeysAPI(c),        ctx: context.TODO(),        ttl: time.Second * time.Duration(ttl),        mutex:  new(sync.Mutex),    &#125;&#125;// Lock locks m.// If the lock is already in use, the calling goroutine// blocks until the mutex is available.func (m *Mutex) Lock() (err error) &#123;    m.mutex.Lock()    for try := 1; try &lt;= defaultTry; try++ &#123;        if m.lock() == nil &#123;            return nil        &#125;        m.debug(&quot;Lock node %v ERROR %v&quot;, m.key, err)        if try &lt; defaultTry &#123;            m.debug(&quot;Try to lock node %v again&quot;, m.key, err)        &#125;    &#125;    return err&#125;func (m *Mutex) lock() (err error) &#123;    m.debug(&quot;Trying to create a node : key=%v&quot;, m.key)    setOptions := &amp;client.SetOptions&#123;        PrevExist:client.PrevNoExist,        TTL:      m.ttl,    &#125;    resp, err := m.kapi.Set(m.ctx, m.key, m.id, setOptions)    if err == nil &#123;        m.debug(&quot;Create node %v OK [%q]&quot;, m.key, resp)        return nil    &#125;    m.debug(&quot;Create node %v failed [%v]&quot;, m.key, err)    e, ok := err.(client.Error)    if !ok &#123;        return err    &#125;    if e.Code != client.ErrorCodeNodeExist &#123;        return err    &#125;    // Get the already node&#39;s value.    resp, err = m.kapi.Get(m.ctx, m.key, nil)    if err != nil &#123;        return err    &#125;    m.debug(&quot;Get node %v OK&quot;, m.key)    watcherOptions := &amp;client.WatcherOptions&#123;        AfterIndex : resp.Index,        Recursive:false,    &#125;    watcher := m.kapi.Watcher(m.key, watcherOptions)    for &#123;        m.debug(&quot;Watching %v ...&quot;, m.key)        resp, err = watcher.Next(m.ctx)        if err != nil &#123;            return err        &#125;        m.debug(&quot;Received an event : %q&quot;, resp)        if resp.Action == deleteAction || resp.Action == expireAction &#123;            return nil        &#125;    &#125;&#125;// Unlock unlocks m.// It is a run-time error if m is not locked on entry to Unlock.//// A locked Mutex is not associated with a particular goroutine.// It is allowed for one goroutine to lock a Mutex and then// arrange for another goroutine to unlock it.func (m *Mutex) Unlock() (err error) &#123;    defer m.mutex.Unlock()    for i := 1; i &lt;= defaultTry; i++ &#123;        var resp *client.Response        resp, err = m.kapi.Delete(m.ctx, m.key, nil)        if err == nil &#123;            m.debug(&quot;Delete %v OK&quot;, m.key)            return nil        &#125;        m.debug(&quot;Delete %v falied: %q&quot;, m.key, resp)        e, ok := err.(client.Error)        if ok &amp;&amp; e.Code == client.ErrorCodeKeyNotFound &#123;            return nil        &#125;    &#125;    return err&#125;func (m *Mutex) debug(format string, v ...interface&#123;&#125;) &#123;    if m.logger != nil &#123;        m.logger.Write([]byte(m.id))        m.logger.Write([]byte(&quot; &quot;))        m.logger.Write([]byte(fmt.Sprintf(format, v...)))        m.logger.Write([]byte(&quot;\n&quot;))    &#125;&#125;func (m *Mutex) SetDebugLogger(w io.Writer) &#123;    m.logger = w&#125;</code></pre><p>其实类似的实现有很多，但目前都已经过时，使用的都是被官方标记为deprecated的项目。且大部分接口都不如上述代码简单。 使用上，跟Golang官方sync包的Mutex接口非常类似，先New()，然后调用Lock()，使用完后调用Unlock()，就三个接口，就是这么简单。示例代码如下：</p><pre><code>package mainimport (    &quot;github.com/zieckey/etcdsync&quot;    &quot;log&quot;)func main() &#123;    //etcdsync.SetDebug(true)    log.SetFlags(log.Ldate|log.Ltime|log.Lshortfile)    m := etcdsync.New(&quot;/etcdsync&quot;, &quot;123&quot;, []string&#123;&quot;http://127.0.0.1:2379&quot;&#125;)    if m == nil &#123;        log.Printf(&quot;etcdsync.NewMutex failed&quot;)    &#125;    err := m.Lock()    if err != nil &#123;        log.Printf(&quot;etcdsync.Lock failed&quot;)    &#125; else &#123;        log.Printf(&quot;etcdsync.Lock OK&quot;)    &#125;    log.Printf(&quot;Get the lock. Do something here.&quot;)    err = m.Unlock()    if err != nil &#123;        log.Printf(&quot;etcdsync.Unlock failed&quot;)    &#125; else &#123;        log.Printf(&quot;etcdsync.Unlock OK&quot;)    &#125;&#125;</code></pre><h2 id="负载均衡原理是什么"><a href="#负载均衡原理是什么" class="headerlink" title="负载均衡原理是什么?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637535"></a>负载均衡原理是什么?</h2><p>负载均衡Load Balance）是高可用网络基础架构的关键组件，通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。负载均衡，其核心就是网络流量分发，分很多维度。</p><p>负载均衡（Load Balance）通常是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p><p>负载均衡是建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p><p>通过一个例子详细介绍:</p><ul><li>  没有负载均衡 web 架构</li></ul><p><img src="https://www.github.com/Clown95/StroyBack/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1557904490146.png"></p><p>在这里用户是直连到 web 服务器，如果这个服务器宕机了，那么用户自然也就没办法访问了。<br>另外，如果同时有很多用户试图访问服务器，超过了其能处理的极限，就会出现加载速度缓慢或根本无法连接的情况。</p><p>而通过在后端引入一个负载均衡器和至少一个额外的 web 服务器，可以缓解这个故障。<br>通常情况下，所有的后端服务器会保证提供相同的内容，以便用户无论哪个服务器响应，都能收到一致的内容。</p><ul><li>  有负载均衡 web 架构</li></ul><p><img src="https://www.github.com/Clown95/StroyBack/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1557904509759.png"></p><p>用户访问负载均衡器，再由负载均衡器将请求转发给后端服务器。在这种情况下，单点故障现在转移到负载均衡器上了。<br>这里又可以通过引入第二个负载均衡器来缓解。</p><p>那么负载均衡器的工作方式是什么样的呢,负载均衡器又可以处理什么样的请求？</p><p>负载均衡器的管理员能主要为下面四种主要类型的请求设置转发规则：</p><ul><li>  HTTP (七层)</li><li>  HTTPS (七层)</li><li>  TCP (四层)</li><li>  UDP (四层)</li></ul><p>负载均衡器如何选择要转发的后端服务器？</p><p>负载均衡器一般根据两个因素来决定要将请求转发到哪个服务器。首先，确保所选择的服务器能够对请求做出响应，然后根据预先配置的规则从健康服务器池（healthy pool）中进行选择。</p><p>因为，负载均衡器应当只选择能正常做出响应的后端服务器，因此就需要有一种判断后端服务器是否健康的方法。为了监视后台服务器的运行状况，运行状态检查服务会定期尝试使用转发规则定义的协议和端口去连接后端服务器。<br>如果，服务器无法通过健康检查，就会从池中剔除，保证流量不会被转发到该服务器，直到其再次通过健康检查为止。</p><p>负载均衡算法</p><p>负载均衡算法决定了后端的哪些健康服务器会被选中。 其中常用的算法包括：</p><ul><li>  Round Robin（轮询）：为第一个请求选择列表中的第一个服务器，然后按顺序向下移动列表直到结尾，然后循环。</li><li>  Least Connections（最小连接）：优先选择连接数最少的服务器，在普遍会话较长的情况下推荐使用。</li><li>  Source：根据请求源的 IP 的散列（hash）来选择要转发的服务器。这种方式可以一定程度上保证特定用户能连接到相同的服务器。</li></ul><p>如果你的应用需要处理状态而要求用户能连接到和之前相同的服务器。可以通过 Source 算法基于客户端的 IP 信息创建关联，或者使用粘性会话（sticky sessions）。</p><p>除此之外，想要解决负载均衡器的单点故障问题，可以将第二个负载均衡器连接到第一个上，从而形成一个集群。</p><p>本文转自 <a href="https://blog.csdn.net/yang731227/article/details/90637535">https://blog.csdn.net/yang731227/article/details/90637535</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微服务面试题&quot;&gt;&lt;a href=&quot;#微服务面试题&quot; class=&quot;headerlink&quot; title=&quot;微服务面试题&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn.net/yang731227/article/details/90637535&quot;&gt;</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Go面试" scheme="https://ysluckly.github.io/tags/Go%E9%9D%A2%E8%AF%95/"/>
    
    <category term="微服务" scheme="https://ysluckly.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Go WebAssembly (Wasm) 简明教程</title>
    <link href="https://ysluckly.github.io/2022/01/17/go/"/>
    <id>https://ysluckly.github.io/2022/01/17/go/</id>
    <published>2022-01-17T13:59:10.000Z</published>
    <updated>2022-02-20T13:38:38.925Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919113247.jpg" alt="Golang WebAssembly"></p><h2 id="1-WebAssembly-简介"><a href="#1-WebAssembly-简介" class="headerlink" title="1 WebAssembly 简介"></a>1 WebAssembly 简介</h2><blockquote><p>WebAssembly是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如C / C ++等语言提供一个编译目标，以便它们可以在Web上运行。它也被设计为可以与JavaScript共存，允许两者一起工作。  —— <a href="https://developer.mozilla.org/zh-CN/docs/WebAssembly">MDN web docs - mozilla.org</a></p></blockquote><p>从 MDN 的介绍中，我们可以得出几个结论：</p><ul><li>1）WebAssembly 是一种二进制编码格式，而不是一门新的语言。</li><li><ol start="2"><li>WebAssembly 不是为了取代 JavaScript，而是一种补充（至少现阶段是这样），结合 WebAssembly 的性能优势，很大可能集中在对性能要求高（例如游戏，AI），或是对交互体验要求高（例如移动端）的场景。</li></ol></li><li>3）C/C++ 等语言可以编译 WebAssembly 的目标文件，也就是说，其他语言可以通过编译器支持，而写出能够在浏览器前端运行的代码。</li></ul><p>Go 语言在 1.11 版本(2018年8月) 加入了对 WebAssembly (Wasm) 的原生支持，使用 Go 语言开发 WebAssembly 相关的应用变得更加地简单。Go 语言的内建支持是 Go 语言进军前端的一个重要的里程碑。在这之前，如果想使用 Go 语言开发前端，需要使用 <a href="https://github.com/gopherjs/gopherjs">GopherJS</a>，GopherJS 是一个编译器，可以将 Go 语言转换成可以在浏览器中运行的 JavaScript 代码。新版本的 Go 则直接将 Go 代码编译为 wasm 二进制文件，而不再需要转为 JavaScript 代码。更巧的是，实现 GopherJS 和在 Go 语言中内建支持 WebAssembly 的是同一拨人。</p><p>Go 语言实现的函数可以直接导出供 JavaScript 代码调用，同时，Go 语言内置了 <a href="https://github.com/golang/go/tree/master/src/syscall/js">syscall/js</a> 包，可以在 Go 语言中直接调用 JavaScript 函数，包括对 DOM 树的操作。</p><h2 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2 Hello World"></a>2 Hello World</h2><p>如果对 Go 语言不熟悉，推荐 <a href="https://geektutu.com/post/quick-golang.html">Go 语言简明教程</a>，一篇文章快速入门。</p><p>接下来，我们使用 Go 语言实现一个最简单的程序，在网页上弹出 <code>Hello World</code>。</p><p>第一步，新建文件 main.go，使用 js.Global().get(‘alert’) 获取全局的 alert 对象，通过 Invoke 方法调用。等价于在 js 中调用 <code>window.alert(&quot;Hello World&quot;)</code>。</p><pre><code class="go">// main.gopackage mainimport &quot;syscall/js&quot;func main() &#123;    alert := js.Global().Get(&quot;alert&quot;)    alert.Invoke(&quot;Hello World!&quot;)&#125;</code></pre><p>第二步，将 main.go 编译为 static/main.wasm</p><blockquote><p>如果启用了 <code>GO MODULES</code>，则需要使用 go mod init 初始化模块，或设置 GO111MODULE=auto。</p></blockquote><pre><code class="bash">$ GOOS=js GOARCH=wasm go build -o static/main.wasm</code></pre><p>第三步，拷贝 wasm_exec.js (JavaScript 支持文件，加载 wasm 文件时需要) 到 static 文件夹</p><pre><code class="bash">$ cp &quot;$(go env GOROOT)/misc/wasm/wasm_exec.js&quot; static</code></pre><p>第四步，创建 index.html，引用 <code>static/main.wasm</code> 和 <code>static/wasm_exec.js</code>。</p><pre><code class="html">&lt;html&gt;&lt;script src=&quot;static/wasm_exec.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    const go = new Go();    WebAssembly.instantiateStreaming(fetch(&quot;static/main.wasm&quot;), go.importObject)        .then((result) =&gt; go.run(result.instance));&lt;/script&gt;&lt;/html&gt;</code></pre><p>第五步，使用 goexec 启动 Web 服务</p><blockquote><p>如果没有安装 goexec，可用 <code>go get -u github.com/shurcooL/goexec</code> 安装，需要将 $GOBIN 或 $GOPATH/bin 加入环境变量</p></blockquote><p>当前的目录结构如下：</p><pre><code class="bash">demo/   |--static/      |--wasm_exec.js      |--main.wasm   |--main.go   |--index.html</code></pre><pre><code class="bash">$ goexec &#39;http.ListenAndServe(`:9999`, http.FileServer(http.Dir(`.`)))&#39;</code></pre><p>浏览器访问 localhost:9999，则会有一个弹出窗口，上面写着 *Hello World!*。</p><p><img src="quick-go-wasm/hello_world.png" alt="go wasm hello world demo"></p><p>为了避免每次编译都需要输入繁琐的命令，可将这个过程写在 <code>Makefile</code> 中</p><pre><code class="makefile">all: static/main.wasm static/wasm_exec.js    goexec &#39;http.ListenAndServe(`:9999`, http.FileServer(http.Dir(`.`)))&#39;static/wasm_exec.js:    cp &quot;$(shell go env GOROOT)/misc/wasm/wasm_exec.js&quot; staticstatic/main.wasm : main.go    GO111MODULE=auto GOOS=js GOARCH=wasm go build -o static/main.wasm .</code></pre><p>这样一个敲一下 make 就够了，代码已经上传到 <a href="https://github.com/geektutu/7days-golang/tree/master/demo-wasm">7days-golang - github.com</a>。</p><h2 id="3-注册函数-Register-Functions"><a href="#3-注册函数-Register-Functions" class="headerlink" title="3 注册函数(Register Functions)"></a>3 注册函数(Register Functions)</h2><p>在 Go 语言中调用 JavaScript 函数是一方面，另一方面，如果仅仅是使用 WebAssembly 替代性能要求高的模块，那么就需要注册函数，以便其他 JavaScript 代码调用。</p><p>假设我们需要注册一个计算斐波那契数列的函数，可以这么实现。</p><pre><code class="go">// main.gopackage mainimport &quot;syscall/js&quot;func fib(i int) int &#123;    if i == 0 || i == 1 &#123;        return 1    &#125;    return fib(i-1) + fib(i-2)&#125;func fibFunc(this js.Value, args []js.Value) interface&#123;&#125; &#123;    return js.ValueOf(fib(args[0].Int()))&#125;func main() &#123;    done := make(chan int, 0)    js.Global().Set(&quot;fibFunc&quot;, js.FuncOf(fibFunc))    &lt;-done&#125;</code></pre><ul><li>fib 是一个普通的 Go 函数，通过递归计算第 i 个斐波那契数，接收一个 int 入参，返回值也是 int。</li><li>定义了 fibFunc 函数，为 fib 函数套了一个壳，从 args[0] 获取入参，计算结果用 js.ValueOf 包装，并返回。</li><li>使用 js.Global().Set() 方法，将注册函数 fibFunc 到全局，以便在浏览器中能够调用。</li></ul><p><code>js.Value</code> 可以将 Js 的值转换为 Go 的值，比如 args[0].Int()，则是转换为 Go 语言中的整型。<code>js.ValueOf</code>，则用来将 Go 的值，转换为 Js 的值。另外，注册函数的时候，使用 js.FuncOf 将函数转换为 <code>Func</code> 类型，只有 Func 类型的函数，才能在 JavaScript 中调用。可以认为这是 Go 与 JavaScript 之间的接口/约定。</p><p><code>js.Func()</code> 接受一个函数类型作为其参数，该函数的定义必须是：</p><pre><code class="go">func(this Value, args []Value) interface&#123;&#125;// this 即 JavaScript 中的 this// args 是在 JavaScript 中调用该函数的参数列表。// 返回值需用 js.ValueOf 映射成 JavaScript 的值</code></pre><p>在 main 函数中，创建了信道(chan) done，阻塞主协程(goroutine)。fibFunc 如果在 JavaScript 中被调用，会开启一个新的子协程执行。</p><blockquote><p>A wrapped function triggered during a call from Go to JavaScript gets executed on the same goroutine. A wrapped function triggered by JavaScript’s event loop gets executed on an extra goroutine.  —— <a href="https://golang.org/pkg/syscall/js/#FuncOf">FuncOf - golang.org</a></p></blockquote><p>接下来，修改之前的 index.html，在其中添加一个输入框(num)，一个按钮(btn) 和一个文本框(ans，用来显示计算结果)，并给按钮添加了一个点击事件，调用 fibFunc，并将计算结果显示在文本框(ans)中。</p><pre><code class="html">&lt;html&gt;...&lt;body&gt;    &lt;input id=&quot;num&quot; type=&quot;number&quot; /&gt;    &lt;button id=&quot;btn&quot; onclick=&quot;ans.innerHTML=fibFunc(num.value * 1)&quot;&gt;Click&lt;/button&gt;    &lt;p id=&quot;ans&quot;&gt;1&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>使用之前的命令重新编译 main.go，并在 9999 端口启动 Web 服务，如果我们已经将命令写在 Makefile 中了，只需要运行 <code>make</code> 即可。</p><p>接下来访问 localhost:9999，可以看到如下效果。输入一个数字，点击<code>Click</code>，计算结果显示在输入框下方。</p><p><img src="quick-go-wasm/register_functions.png" alt="register functions demo"></p><h2 id="4-操作-DOM"><a href="#4-操作-DOM" class="headerlink" title="4 操作 DOM"></a>4 操作 DOM</h2><p>在上一个例子中，仅仅是注册了全局函数 fibFunc，事件注册，调用，对 DOM 元素的操作都是在 HTML<br>中通过原生的 JavaScript 函数实现的。这些事情，能不能全部在 Go 语言中完成呢？答案可以。</p><p>首先修改 index.html，删除事件注册部分和 对 DOM 元素的操作部分。</p><pre><code class="html">&lt;html&gt;...&lt;body&gt;    &lt;input id=&quot;num&quot; type=&quot;number&quot; /&gt;    &lt;button id=&quot;btn&quot;&gt;Click&lt;/button&gt;    &lt;p id=&quot;ans&quot;&gt;1&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>修改 main.go：</p><pre><code class="go">package mainimport (    &quot;strconv&quot;    &quot;syscall/js&quot;)func fib(i int) int &#123;    if i == 0 || i == 1 &#123;        return 1    &#125;    return fib(i-1) + fib(i-2)&#125;var (    document = js.Global().Get(&quot;document&quot;)    numEle   = document.Call(&quot;getElementById&quot;, &quot;num&quot;)    ansEle   = document.Call(&quot;getElementById&quot;, &quot;ans&quot;)    btnEle   = js.Global().Get(&quot;btn&quot;))func fibFunc(this js.Value, args []js.Value) interface&#123;&#125; &#123;    v := numEle.Get(&quot;value&quot;)    if num, err := strconv.Atoi(v.String()); err == nil &#123;        ansEle.Set(&quot;innerHTML&quot;, js.ValueOf(fib(num)))    &#125;    return nil&#125;func main() &#123;    done := make(chan int, 0)    btnEle.Call(&quot;addEventListener&quot;, &quot;click&quot;, js.FuncOf(fibFunc))    &lt;-done&#125;</code></pre><ul><li>通过 <code>js.Global().Get(&quot;btn&quot;)</code> 或 <code>document.Call(&quot;getElementById&quot;, &quot;num&quot;)</code> 两种方式获取到 DOM 元素。</li><li>btnEle 调用 <code>addEventListener</code> 为 btn 绑定点击事件 fibFunc。</li><li>在 fibFunc 中使用 <code>numEle.Get(&quot;value&quot;)</code> 获取到 numEle 的值（字符串），转为整型并调用 fib 计算出结果。</li><li>ansEle 调用 <code>Set(&quot;innerHTML&quot;, ...)</code> 渲染计算结果。</li></ul><p>重新编译 main.go，访问 localhost:9999，效果与之前是一致的。</p><h2 id="5-回调函数-Callback-Functions"><a href="#5-回调函数-Callback-Functions" class="headerlink" title="5 回调函数(Callback Functions)"></a>5 回调函数(Callback Functions)</h2><p>在 JavaScript 中，异步+回调是非常常见的，比如请求一个 Restful API，注册一个回调函数，待数据获取到，再执行回调函数的逻辑，这个期间程序可以继续做其他的事情。Go 语言可以通过协程实现异步。</p><p>假设 fib 的计算非常耗时，那么可以启动注册一个回调函数，待 fib 计算完成后，再把计算结果显示出来。</p><p>我们先修改 main.go，使得 fibFunc 支持传入回调函数。</p><pre><code class="go">package mainimport (    &quot;syscall/js&quot;    &quot;time&quot;)func fib(i int) int &#123;    if i == 0 || i == 1 &#123;        return 1    &#125;    return fib(i-1) + fib(i-2)&#125;func fibFunc(this js.Value, args []js.Value) interface&#123;&#125; &#123;    callback := args[len(args)-1]    go func() &#123;        time.Sleep(3 * time.Second)        v := fib(args[0].Int())        callback.Invoke(v)    &#125;()    js.Global().Get(&quot;ans&quot;).Set(&quot;innerHTML&quot;, &quot;Waiting 3s...&quot;)    return nil&#125;func main() &#123;    done := make(chan int, 0)    js.Global().Set(&quot;fibFunc&quot;, js.FuncOf(fibFunc))    &lt;-done&#125;</code></pre><ul><li>假设调用 fibFunc 时，回调函数作为最后一个参数，那么通过 args[len(args)-1] 便可以获取到该函数。这与其他类型参数的传递并无区别。</li><li>使用 <code>go func()</code> 启动子协程，调用 fib 计算结果，计算结束后，调用回调函数 <code>callback</code>，并将计算结果传递给回调函数，使用 time.Sleep() 模拟 3s 的耗时操作。</li><li>计算结果出来前，先在界面上显示 <code>Waiting 3s...</code></li></ul><p>接下来我们修改 index.html，为按钮添加点击事件，调用 fibFunc</p><pre><code class="html">&lt;html&gt;...&lt;body&gt;    &lt;input id=&quot;num&quot; type=&quot;number&quot; /&gt;    &lt;button id=&quot;btn&quot; onclick=&quot;fibFunc(num.value * 1, (v)=&gt; ans.innerHTML=v)&quot;&gt;Click&lt;/button&gt;    &lt;p id=&quot;ans&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>为 btn 注册了点击事件，第一个参数是待计算的数字，从 num 输入框获取。</li><li>第二个参数是一个回调函数，将参数 v 显示在 ans 文本框中。</li></ul><p>接下来，重新编译 main.go，访问 localhost:9999，随便输入一个数字，点击 Click。页面会先显示 <code>Waiting 3s...</code>，3s过后显示计算结果。</p><p><img src="quick-go-wasm/callback.png" alt="go wasm callback demo"></p><h2 id="6-进一步的尝试"><a href="#6-进一步的尝试" class="headerlink" title="6 进一步的尝试"></a>6 进一步的尝试</h2><h3 id="6-1-工具框架"><a href="#6-1-工具框架" class="headerlink" title="6.1 工具框架"></a>6.1 工具框架</h3><ul><li>WebAssembly 的二进制分析工具 <a href="https://wasdk.github.io/wasmcodeexplorer/">WebAssembly Code Explorer</a></li><li>使用NodeJs 或浏览器测试 Go Wasm 代码 <a href="https://github.com/golang/go/wiki/WebAssembly#executing-webassembly-with-nodejs">Github Wiki</a></li><li>借鉴 Vue 实现的 Golang WebAssembly 前端框架 <a href="https://www.vugu.org/doc/start">Vugu</a>，完全使用 Go，不用写任何的 JavaScript 代码。</li></ul><h3 id="6-2-Demo-项目"><a href="#6-2-Demo-项目" class="headerlink" title="6.2 Demo/项目"></a>6.2 Demo/项目</h3><ul><li>使用 Go Assembly 前端渲染的一些<a href="https://stdiopt.github.io/gowasm-experiments/">例子</a></li><li><a href="https://github.com/dave/jsgo">jsgo</a> 这个项目汇聚一些小而精的项目，包括 <a href="https://jsgo.io/hajimehoshi/ebiten/examples/2048">2048</a>，<a href="https://jsgo.io/hajimehoshi/ebiten/examples/blocks">俄罗斯方块</a>等游戏，还有证明 Go 可以完整开发前端项目的 <a href="https://jsgo.io/dave/todomvc">TodoMVC</a></li></ul><h3 id="6-3-相关文档"><a href="#6-3-相关文档" class="headerlink" title="6.3 相关文档"></a>6.3 相关文档</h3><ul><li><a href="https://golang.org/pkg/syscall/js">syscall/js 官方文档 - golang.org</a></li><li><a href="https://github.com/golang/go/wiki/WebAssembly">Go WebAssembly 官方文档 - github.com</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919113247.jpg&quot; alt=&quot;Golang WebAssembly&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-WebAssembly-简</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Go WebAssembly" scheme="https://ysluckly.github.io/tags/Go-WebAssembly/"/>
    
    <category term="wasm" scheme="https://ysluckly.github.io/tags/wasm/"/>
    
    <category term="gopherjs" scheme="https://ysluckly.github.io/tags/gopherjs/"/>
    
  </entry>
  
  <entry>
    <title>Go Protobuf 简明教程</title>
    <link href="https://ysluckly.github.io/2022/01/16/go/"/>
    <id>https://ysluckly.github.io/2022/01/16/go/</id>
    <published>2022-01-16T13:59:10.000Z</published>
    <updated>2022-02-20T13:37:12.952Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114831.jpg" alt="Golang Protocol Buffers"></p><h2 id="1-Protocol-Buffers-简介"><a href="#1-Protocol-Buffers-简介" class="headerlink" title="1 Protocol Buffers 简介"></a>1 Protocol Buffers 简介</h2><p>protobuf 即 Protocol Buffers，是一种轻便高效的结构化数据存储格式，与语言、平台无关，可扩展可序列化。protobuf 性能和效率大幅度优于 JSON、XML 等其他的结构化数据格式。protobuf 是以二进制方式存储的，占用空间小，但也带来了可读性差的缺点。protobuf 在通信协议和数据存储等领域应用广泛。例如著名的分布式缓存工具 <a href="https://memcached.org/">Memcached</a> 的 Go 语言版本<a href="https://github.com/golang/groupcache">groupcache</a> 就使用了 protobuf 作为其 RPC 数据格式。</p><p>Protobuf 在 <code>.proto</code> 定义需要处理的结构化数据，可以通过 <code>protoc</code> 工具，将 <code>.proto</code> 文件转换为 C、C++、Golang、Java、Python 等多种语言的代码，兼容性好，易于使用。</p><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h2><h3 id="2-1-protoc"><a href="#2-1-protoc" class="headerlink" title="2.1 protoc"></a>2.1 protoc</h3><p>从 <a href="https://github.com/protocolbuffers/protobuf/releases">Protobuf Releases</a> 下载最先版本的发布包安装。如果是 Ubuntu，可以按照如下步骤操作（以3.11.2为例）。</p><pre><code class="bash"># 下载安装包$ wget https://github.com/protocolbuffers/protobuf/releases/download/v3.11.2/protoc-3.11.2-linux-x86_64.zip# 解压到 /usr/local 目录下$ sudo 7z x protoc-3.11.2-linux-x86_64.zip -o/usr/local</code></pre><p>如果不想安装在 /usr/local 目录下，可以解压到其他的其他，并把解压路径下的 bin 目录 加入到环境变量即可。</p><p>如果能正常显示版本，则表示安装成功。</p><pre><code class="bash">$ protoc --versionlibprotoc 3.11.2</code></pre><h3 id="2-2-protoc-gen-go"><a href="#2-2-protoc-gen-go" class="headerlink" title="2.2 protoc-gen-go"></a>2.2 protoc-gen-go</h3><p>我们需要在 Golang 中使用 protobuf，还需要安装 protoc-gen-go，这个工具用来将 <code>.proto</code> 文件转换为 Golang 代码。</p><pre><code class="bash">go get -u github.com/golang/protobuf/protoc-gen-go</code></pre><p>protoc-gen-go 将自动安装到 <code>$GOPATH/bin</code> 目录下，也需要将这个目录加入到环境变量中。</p><h2 id="3-定义消息类型"><a href="#3-定义消息类型" class="headerlink" title="3 定义消息类型"></a>3 定义消息类型</h2><p>接下来，我们创建一个非常简单的示例，<code>student.proto</code></p><pre><code class="go">syntax = &quot;proto3&quot;;package main;// this is a commentmessage Student &#123;  string name = 1;  bool male = 2;  repeated int32 scores = 3;&#125;</code></pre><p>在当前目录下执行：</p><pre><code class="bash">$ protoc --go_out=. *.proto$ lsstudent.pb.go  student.proto</code></pre><p>即是，将该目录下的所有的 .proto 文件转换为 Go 代码，我们可以看到该目录下多出了一个 Go 文件 <em>student.pb.go</em>。这个文件内部定义了一个结构体 Student，以及相关的方法：</p><pre><code class="go">type Student struct &#123;    Name string `protobuf:&quot;bytes,1,opt,name=name,proto3&quot; json:&quot;name,omitempty&quot;`    Male bool `protobuf:&quot;varint,2,opt,name=male,proto3&quot; json:&quot;male,omitempty&quot;`    Scores []int32 `protobuf:&quot;varint,3,rep,packed,name=scores,proto3&quot; json:&quot;scores,omitempty&quot;`    ...&#125;</code></pre><p>逐行解读<code>student.proto</code></p><ul><li>protobuf 有2个版本，默认版本是 proto2，如果需要 proto3，则需要在非空非注释第一行使用 <code>syntax = &quot;proto3&quot;</code> 标明版本。</li><li><code>package</code>，即包名声明符是可选的，用来防止不同的消息类型有命名冲突。</li><li>消息类型 使用 <code>message</code> 关键字定义，Student 是类型名，name, male, scores 是该类型的 3 个字段，类型分别为 string, bool 和 []int32。字段可以是标量类型，也可以是合成类型。</li><li>每个字段的修饰符默认是 singular，一般省略不写，<code>repeated</code> 表示字段可重复，即用来表示 Go 语言中的数组类型。</li><li>每个字符 <code>=</code>后面的数字称为标识符，每个字段都需要提供一个唯一的标识符。标识符用来在消息的二进制格式中识别各个字段，一旦使用就不能够再改变，标识符的取值范围为 [1, 2^29 - 1] 。</li><li>.proto 文件可以写注释，单行注释 <code>//</code>，多行注释 <code>/* ... */</code></li><li>一个 .proto 文件中可以写多个消息类型，即对应多个结构体(struct)。</li></ul><p>接下来，就可以在项目代码中直接使用了，以下是一个非常简单的例子，即证明被序列化的和反序列化后的实例，包含相同的数据。</p><pre><code class="go">package mainimport (    &quot;log&quot;    &quot;github.com/golang/protobuf/proto&quot;)func main() &#123;    test := &amp;Student&#123;        Name: &quot;geektutu&quot;,        Male:  true,        Scores: []int32&#123;98, 85, 88&#125;,    &#125;    data, err := proto.Marshal(test)    if err != nil &#123;        log.Fatal(&quot;marshaling error: &quot;, err)    &#125;    newTest := &amp;Student&#123;&#125;    err = proto.Unmarshal(data, newTest)    if err != nil &#123;        log.Fatal(&quot;unmarshaling error: &quot;, err)    &#125;    // Now test and newTest contain the same data.    if test.GetName() != newTest.GetName() &#123;        log.Fatalf(&quot;data mismatch %q != %q&quot;, test.GetName(), newTest.GetName())    &#125;&#125;</code></pre><ul><li>保留字段(Reserved Field)</li></ul><p>更新消息类型时，可能会将某些字段/标识符删除。这些被删掉的字段/标识符可能被重新使用，如果加载老版本的数据时，可能会造成数据冲突，在升级时，可以将这些字段/标识符保留(reserved)，这样就不会被重新使用了，protoc 会检查。</p><pre><code class="go">message Foo &#123;  reserved 2, 15, 9 to 11;  reserved &quot;foo&quot;, &quot;bar&quot;;&#125;</code></pre><h2 id="4-字段类型"><a href="#4-字段类型" class="headerlink" title="4 字段类型"></a>4 字段类型</h2><h3 id="4-1-标量类型-Scalar"><a href="#4-1-标量类型-Scalar" class="headerlink" title="4.1 标量类型(Scalar)"></a>4.1 标量类型(Scalar)</h3><table><thead><tr><th>proto类型</th><th>go类型</th><th>备注</th><th>proto类型</th><th>go类型</th><th>备注</th></tr></thead><tbody><tr><td>double</td><td>float64</td><td></td><td>float</td><td>float32</td><td></td></tr><tr><td>int32</td><td>int32</td><td></td><td>int64</td><td>int64</td><td></td></tr><tr><td>uint32</td><td>uint32</td><td></td><td>uint64</td><td>uint64</td><td></td></tr><tr><td>sint32</td><td>int32</td><td>适合负数</td><td>sint64</td><td>int64</td><td>适合负数</td></tr><tr><td>fixed32</td><td>uint32</td><td>固长编码，适合大于2^28的值</td><td>fixed64</td><td>uint64</td><td>固长编码，适合大于2^56的值</td></tr><tr><td>sfixed32</td><td>int32</td><td>固长编码</td><td>sfixed64</td><td>int64</td><td>固长编码</td></tr><tr><td>bool</td><td>bool</td><td></td><td>string</td><td>string</td><td>UTF8 编码，长度不超过 2^32</td></tr><tr><td>bytes</td><td>[]byte</td><td>任意字节序列，长度不超过 2^32</td><td></td><td></td><td></td></tr></tbody></table><p>标量类型如果没有被赋值，则不会被序列化，解析时，会赋予默认值。</p><ul><li>strings：空字符串</li><li>bytes：空序列</li><li>bools：false</li><li>数值类型：0</li></ul><h3 id="4-2-枚举-Enumerations"><a href="#4-2-枚举-Enumerations" class="headerlink" title="4.2 枚举(Enumerations)"></a>4.2 枚举(Enumerations)</h3><p>枚举类型适用于提供一组预定义的值，选择其中一个。例如我们将性别定义为枚举类型。</p><pre><code class="go">message Student &#123;  string name = 1;  enum Gender &#123;    FEMALE = 0;    MALE = 1;  &#125;  Gender gender = 2;  repeated int32 scores = 3;&#125;</code></pre><ul><li>枚举类型的第一个选项的标识符必须是0，这也是枚举类型的默认值。</li><li>别名（Alias），允许为不同的枚举值赋予相同的标识符，称之为别名，需要打开<code>allow_alias</code>选项。</li></ul><pre><code class="go">message EnumAllowAlias &#123;  enum Status &#123;    option allow_alias = true;    UNKOWN = 0;    STARTED = 1;    RUNNING = 1;  &#125;&#125;</code></pre><h3 id="4-3-使用其他消息类型"><a href="#4-3-使用其他消息类型" class="headerlink" title="4.3 使用其他消息类型"></a>4.3 使用其他消息类型</h3><p><code>Result</code>是另一个消息类型，在 SearchReponse 作为一个消息字段类型使用。</p><pre><code class="go">message SearchResponse &#123;  repeated Result results = 1; &#125;message Result &#123;  string url = 1;  string title = 2;  repeated string snippets = 3;&#125;</code></pre><p>嵌套写也是支持的：</p><pre><code class="go">message SearchResponse &#123;  message Result &#123;    string url = 1;    string title = 2;    repeated string snippets = 3;  &#125;  repeated Result results = 1;&#125;</code></pre><p>如果定义在其他文件中，可以导入其他消息类型来使用：</p><pre><code class="go">import &quot;myproject/other_protos.proto&quot;;</code></pre><h3 id="4-4-任意类型-Any"><a href="#4-4-任意类型-Any" class="headerlink" title="4.4 任意类型(Any)"></a>4.4 任意类型(Any)</h3><p>Any 可以表示不在 .proto 中定义任意的内置类型。</p><pre><code class="go">import &quot;google/protobuf/any.proto&quot;;message ErrorStatus &#123;  string message = 1;  repeated google.protobuf.Any details = 2;&#125;</code></pre><h3 id="4-5-oneof"><a href="#4-5-oneof" class="headerlink" title="4.5 oneof"></a>4.5 oneof</h3><pre><code class="go">message SampleMessage &#123;  oneof test_oneof &#123;    string name = 4;    SubMessage sub_message = 9;  &#125;&#125;</code></pre><h3 id="4-6-map"><a href="#4-6-map" class="headerlink" title="4.6 map"></a>4.6 map</h3><pre><code class="go">message MapRequest &#123;  map&lt;string, int32&gt; points = 1;&#125;</code></pre><h2 id="5-定义服务-Services"><a href="#5-定义服务-Services" class="headerlink" title="5 定义服务(Services)"></a>5 定义服务(Services)</h2><p>如果消息类型是用来远程通信的(Remote Procedure Call, RPC)，可以在 .proto 文件中定义 RPC 服务接口。例如我们定义了一个名为 SearchService 的 RPC 服务，提供了 <code>Search</code> 接口，入参是 <code>SearchRequest</code> 类型，返回类型是 <code>SearchResponse</code></p><pre><code class="go">service SearchService &#123;  rpc Search (SearchRequest) returns (SearchResponse);&#125;</code></pre><p>官方仓库也提供了一个<a href="https://github.com/protocolbuffers/protobuf/blob/master/docs/third_party.md">插件列表</a>，帮助开发基于 Protocol Buffer 的 RPC 服务。</p><h2 id="6-protoc-其他参数"><a href="#6-protoc-其他参数" class="headerlink" title="6 protoc 其他参数"></a>6 protoc 其他参数</h2><p>命令行使用方法</p><pre><code class="bash">protoc --proto_path=IMPORT_PATH --&lt;lang&gt;_out=DST_DIR path/to/file.proto</code></pre><ul><li><code>--proto_path=IMPORT_PATH</code>：可以在 .proto 文件中 import 其他的 .proto 文件，proto_path 即用来指定其他 .proto 文件的查找目录。如果没有引入其他的 .proto 文件，该参数可以省略。</li><li><code>--&lt;lang&gt;_out=DST_DIR</code>：指定生成代码的目标文件夹，例如 –go_out=. 即生成 GO 代码在当前文件夹，另外支持 cpp/java/python/ruby/objc/csharp/php 等语言</li></ul><h2 id="7-推荐风格"><a href="#7-推荐风格" class="headerlink" title="7 推荐风格"></a>7 推荐风格</h2><ul><li><p>文件(Files)</p><ul><li>文件名使用小写下划线的命名风格，例如 lower_snake_case.proto</li><li>每行不超过 80 字符</li><li>使用 2 个空格缩进</li></ul></li><li><p>包(Packages)</p><ul><li>包名应该和目录结构对应，例如文件在<code>my/package/</code>目录下，包名应为 <code>my.package</code></li></ul></li><li><p>消息和字段(Messages &amp; Fields)</p><ul><li>消息名使用首字母大写驼峰风格(CamelCase)，例如<code>message StudentRequest &#123; ... &#125;</code></li><li>字段名使用小写下划线的风格，例如 <code>string status_code = 1</code></li><li>枚举类型，枚举名使用首字母大写驼峰风格，例如 <code>enum FooBar</code>，枚举值使用全大写下划线隔开的风格(CAPITALS_WITH_UNDERSCORES )，例如 FOO_DEFAULT=1</li></ul></li><li><p>服务(Services) </p><ul><li>RPC 服务名和方法名，均使用首字母大写驼峰风格，例如<code>service FooService&#123; rpc GetSomething() &#125;</code></li></ul></li></ul><h2 id="附：参考"><a href="#附：参考" class="headerlink" title="附：参考"></a>附：参考</h2><ol><li><a href="https://github.com/protocolbuffers/protobuf">protobuf 代码仓库 - github.com</a></li><li><a href="https://github.com/golang/protobuf">golang protobuf 代码仓库 - github.com</a></li><li><a href="https://en.wikipedia.org/wiki/Remote_procedure_call">Remote procedure call 远程过程调用 - wikipedia.org</a></li><li><a href="https://github.com/golang/groupcache">Groupcache Go语言版 memcached - github.com</a></li><li><a href="https://developers.google.com/protocol-buffers/docs/proto3">Language Guide (proto3) 官方指南 - google.com</a></li><li><a href="https://developers.google.com/protocol-buffers/docs/style">Proto Style Guide 代码风格指南 - google.com</a></li><li><a href="https://github.com/protocolbuffers/protobuf/blob/master/docs/third_party.md">Protocol Buffer 插件列表 - github.com</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919114831.jpg&quot; alt=&quot;Golang Protocol Buffers&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-Protocol</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Protocol Buffers" scheme="https://ysluckly.github.io/tags/Protocol-Buffers/"/>
    
    <category term="Protobuf" scheme="https://ysluckly.github.io/tags/Protobuf/"/>
    
    <category term="Golang" scheme="https://ysluckly.github.io/tags/Golang/"/>
    
    <category term="RPC" scheme="https://ysluckly.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Go RPC &amp; TLS 鉴权简明教程</title>
    <link href="https://ysluckly.github.io/2022/01/16/go/"/>
    <id>https://ysluckly.github.io/2022/01/16/go/</id>
    <published>2022-01-16T13:59:10.000Z</published>
    <updated>2022-02-20T13:37:43.335Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了 Go 语言远程过程调用(Remote Procedure Call, RPC)的使用方式，示例基于 Golang 标准库 net/rpc，同时介绍了如何基于 TLS/SSL 实现服务器端和客户端的单向鉴权、双向鉴权。</p><h2 id="1-RPC-简介"><a href="#1-RPC-简介" class="headerlink" title="1 RPC 简介"></a>1 RPC 简介</h2><blockquote><p>远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。RPC是一种服务器-客户端（Client/Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。<br>– <a href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8">远程过程调用 - Wikipedia.org</a></p></blockquote><p>划重点：<strong>程序员就像调用本地程序一样，无需关注细节</strong></p><p>RPC 协议假定某种传输协议(TCP, UDP)存在，为通信程序之间携带信息数据。使用 RPC 协议，无需关注底层网络技术协议，调用远程方法就像在调用本地方法一样。</p><p>RPC 流程：</p><p><img src="quick-go-rpc/rpc-procedure.jpg" alt="RPC PROCEDURE"></p><p>RPC 模型是一个典型的客户端-服务器模型(Client-Server, CS)，相比于调用本地的接口，RPC 还需要知道的是服务器端的地址信息。本地调用，好比两个人面对面说话，而 RPC 好比打电话，需要知道对方的电话号码，但是并不需要关心语音是怎么编码，如何传输，又如何解码的。</p><p>接下来我们将展示如何将一个简单的本地调用的程序一步步地改造一个 RPC 服务。</p><p>示例使用 Go 语言，RPC 使用 Golang 提供的<code>net/rpc</code> 标准库</p><h2 id="2-一个简单的计算二次方的程序"><a href="#2-一个简单的计算二次方的程序" class="headerlink" title="2 一个简单的计算二次方的程序"></a>2 一个简单的计算二次方的程序</h2><p>不考虑 RPC 调用，仅考虑本地调用的场景，程序实现如下：</p><pre><code class="go">// main.gopackage mainimport &quot;log&quot;type Result struct &#123;    Num, Ans int&#125;type Cal intfunc (cal *Cal) Square(num int) *Result &#123;    return &amp;Result&#123;        Num: num,        Ans: num * num,    &#125;&#125;func main() &#123;    cal := new(Cal)    result := cal.Square(12)    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)&#125;</code></pre><p>在这个20行的程序中，我们做了以下几件事：</p><ul><li><code>Cal</code> 结构体，提供了 Square 方法，用于计算传入参数 num 的 二次方。</li><li><code>Result</code> 结构体，包含 Num 和 Ans 两个字段，Ans 是计算后的值，Num 是待计算的值。</li><li><code>main</code> 函数，测试我们实现的 Square 方法。</li></ul><p>运行 main.go，将会输出</p><pre><code class="go">$ go run main.go2020/01/13 20:27:08 12^2 = 144</code></pre><h2 id="3-RPC-需要满足什么条件"><a href="#3-RPC-需要满足什么条件" class="headerlink" title="3 RPC 需要满足什么条件"></a>3 RPC 需要满足什么条件</h2><p>虽然说，远程过程调用并不需要我们关心如何编解码，如何通信，但是最基本的，如果一个方法需要支持远程过程调用，需要满足一定的约束和规范。不同 RPC 框架的约束和规范是不同的，如果使用 Golang 的标准库 <code>net/rpc</code>，方法需要长这个样子：</p><pre><code class="go">func (t *T) MethodName(argType T1, replyType *T2) error</code></pre><p>即需要满足以下 5 个条件：</p><ul><li><ol><li>方法类型（T）是导出的（首字母大写） </li></ol></li><li><ol start="2"><li>方法名（MethodName）是导出的</li></ol></li><li><ol start="3"><li>方法有2个参数(argType T1, replyType *T2)，均为导出/内置类型</li></ol></li><li><ol start="4"><li>方法的第2个参数一个指针(replyType *T2)</li></ol></li><li><ol start="5"><li>方法的返回值类型是 error</li></ol></li></ul><p><code>net/rpc</code> 对参数个数的限制比较严格，仅能有2个，第一个参数是调用者提供的请求参数，第二个参数是返回给调用者的响应参数，也就是说，服务端需要将计算结果写在第二个参数中。如果调用过程中发生错误，会返回 error 给调用者。</p><p>接下来，我们改造下 Square 函数，以满足上述 5 个条件。</p><pre><code class="go">func (cal *Cal) Square(num int, result *Result) error &#123;    result.Num = num    result.Ans = num * num    return nil&#125;func main() &#123;    cal := new(Cal)    var result Result    cal.Square(11, &amp;result)    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)&#125;</code></pre><ul><li>Cal 和 Square 均为导出类型，满足条件 1) 和 2) </li><li>2 个参数，<code>num int</code> 为内置类型，<code>result *Result</code> 为导出类型，满足条件 3)</li><li>第2个参数 <code>result *Result</code> 是一个指针，满足条件 4) </li><li>返回值类型是 error，满足条件 5)</li></ul><p>至此，方法 Cal.Square 满足了 RPC 调用的5个条件。</p><h2 id="4-RPC-服务与调用"><a href="#4-RPC-服务与调用" class="headerlink" title="4 RPC 服务与调用"></a>4 RPC 服务与调用</h2><h3 id="4-1-基于HTTP，启动-RPC-服务"><a href="#4-1-基于HTTP，启动-RPC-服务" class="headerlink" title="4.1 基于HTTP，启动 RPC 服务"></a>4.1 基于HTTP，启动 RPC 服务</h3><p>RPC 是一个典型的客户端-服务器(Client-Server, CS) 架构模型，很显然，需要将 Cal.Square 方法放在服务端。服务端需要提供一个套接字服务，处理客户端发送的请求。通常可以基于 HTTP 协议，监听一个端口，等待 HTTP 请求。</p><p>接下来我们新建一个文件夹 server，将 Cal.Square 方法移动到 server/main.go 中，并在 main 函数中启动 RPC 服务。</p><pre><code class="go">// server/main.gopackage mainimport (    &quot;log&quot;    &quot;net&quot;    &quot;net/http&quot;    &quot;net/rpc&quot;)type Result struct &#123;    Num, Ans int&#125;type Cal intfunc (cal *Cal) Square(num int, result *Result) error &#123;    result.Num = num    result.Ans = num * num    return nil&#125;func main() &#123;    rpc.Register(new(Cal))    rpc.HandleHTTP()    log.Printf(&quot;Serving RPC server on port %d&quot;, 1234)    if err := http.ListenAndServe(&quot;:1234&quot;, nil); err != nil &#123;        log.Fatal(&quot;Error serving: &quot;, err)    &#125;&#125;</code></pre><ul><li>使用 <code>rpc.Register</code>，发布 Cal 中满足 RPC 注册条件的方法（Cal.Square）</li><li>使用 <code>rpc.HandleHTTP</code> 注册用于处理 RPC 消息的 HTTP Handler</li><li>使用 <code>http.ListenAndServe</code> 监听 1234 端口，等待 RPC 请求。</li></ul><p>我们在 server 目录下，执行</p><pre><code class="bash">$ go run main.go2020/01/13 20:59:22 Serving RPC server on port 1234</code></pre><p>此时，RPC 服务已经启动，等待客户端的调用。</p><h3 id="4-2-实现客户端"><a href="#4-2-实现客户端" class="headerlink" title="4.2 实现客户端"></a>4.2 实现客户端</h3><p>我们在 client 目录中新建文件 client/main.go，创建 HTTP 客户端，调用 Cal.Square 方法。</p><pre><code class="go">// client/main.gopackage mainimport (    &quot;log&quot;    &quot;net/rpc&quot;)type Result struct &#123;    Num, Ans int&#125;func main() &#123;    client, _ := rpc.DialHTTP(&quot;tcp&quot;, &quot;localhost:1234&quot;)    var result Result    if err := client.Call(&quot;Cal.Square&quot;, 12, &amp;result); err != nil &#123;        log.Fatal(&quot;Failed to call Cal.Square. &quot;, err)    &#125;    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)&#125;</code></pre><p>在客户端的实现中，因为要用到 Result 类型，简单起见，我们拷贝了 <code>Result</code> 的定义。</p><ul><li>使用 <code>rpc.DialHTTP</code> 创建了 HTTP 客户端 client，并且创建了与 localhost:1234 的链接，1234 恰好是 RPC 服务监听的端口。</li><li>使用 <code>rpc.Call</code> 调用远程方法，第1个参数是方法名 Cal.Square，后两个参数与 Cal.Square 的定义的参数相对应。</li></ul><p>我们在 client 目录下，执行</p><pre><code class="bash">2020/01/13 21:17:45 12^2 = 144</code></pre><p>如果能够返回计算的结果，说明调用成功。</p><h3 id="4-3-异步调用"><a href="#4-3-异步调用" class="headerlink" title="4.3 异步调用"></a>4.3 异步调用</h3><p><code>client.Call</code> 是同步调用的方式，会阻塞当前的程序，直到结果返回。如果有异步调用的需求，可以考虑使用<code>client.Go</code>，如下</p><pre><code class="go">func main() &#123;    client, _ := rpc.DialHTTP(&quot;tcp&quot;, &quot;localhost:1234&quot;)    var result Result    asyncCall := client.Go(&quot;Cal.Square&quot;, 12, &amp;result, nil)    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)    &lt;-asyncCall.Done    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)&#125;</code></pre><p>执行结果如下：</p><pre><code>2020/01/13 21:34:26 0^2 = 02020/01/13 21:34:26 12^2 = 144</code></pre><p>因为 <code>client.Go</code> 是异步调用，因此第一次打印 result，result 没有被赋值。而通过调用 <code>&lt;-asyncCall.Done</code>，阻塞当前程序直到 RPC 调用结束，因此第二次打印 result 时，能够看到正确的赋值。</p><h2 id="5-证书鉴权-TLS-SSL"><a href="#5-证书鉴权-TLS-SSL" class="headerlink" title="5 证书鉴权(TLS/SSL)"></a>5 证书鉴权(TLS/SSL)</h2><h3 id="5-1-客户端对服务器端鉴权"><a href="#5-1-客户端对服务器端鉴权" class="headerlink" title="5.1 客户端对服务器端鉴权"></a>5.1 客户端对服务器端鉴权</h3><p>HTTP 协议默认是不加密的，我们可以使用证书来保证通信过程的安全。</p><p>生成私钥和自签名的证书，并将  server.key 权限设置为只读，保证私钥的安全。</p><pre><code class="bash"># 生成私钥openssl genrsa -out server.key 2048# 生成证书openssl req -new -x509 -key server.key -out server.crt -days 3650# 只读权限chmod 400 server.key</code></pre><p>执行完，当前文件夹下多出了 server.crt 和 server.key 2 个文件。</p><p>服务器端可以使用生成的 server.crt 和 server.key 文件启动 TLS 的端口监听。</p><pre><code class="go">// server/main.goimport (    &quot;crypto/tls&quot;    &quot;log&quot;    &quot;net/rpc&quot;)func main() &#123;    rpc.Register(new(Cal))    cert, _ := tls.LoadX509KeyPair(&quot;server.crt&quot;, &quot;server.key&quot;)    config := &amp;tls.Config&#123;        Certificates: []tls.Certificate&#123;cert&#125;,    &#125;    listener, _ := tls.Listen(&quot;tcp&quot;, &quot;:1234&quot;, config)    log.Printf(&quot;Serving RPC server on port %d&quot;, 1234)    for &#123;        conn, _ := listener.Accept()        defer conn.Close()        go rpc.ServeConn(conn)    &#125;&#125;</code></pre><p>客户端也需要做相应的修改，使用 <code>tls.Dial</code> 代替 <code>rpc.DialHTTP</code> 连接服务端，如果客户端不需要对服务端鉴权，那么可以设置 <code>InsecureSkipVerify:true</code>，即可跳过对服务端的鉴权，例如：</p><pre><code class="go">// client/main.goimport (    &quot;crypto/tls&quot;    &quot;log&quot;    &quot;net/rpc&quot;)func main() &#123;    config := &amp;tls.Config&#123;        InsecureSkipVerify: true,    &#125;    conn, _ := tls.Dial(&quot;tcp&quot;, &quot;localhost:1234&quot;, config)    defer conn.Close()    client := rpc.NewClient(conn)    var result Result    if err := client.Call(&quot;Cal.Square&quot;, 12, &amp;result); err != nil &#123;        log.Fatal(&quot;Failed to call Cal.Square. &quot;, err)    &#125;    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)&#125;</code></pre><p>如果需要对服务器端鉴权，那么需要将服务端的证书添加到信任证书池中，如下：</p><pre><code class="go">// client/main.gofunc main() &#123;    certPool := x509.NewCertPool()    certBytes, err := ioutil.ReadFile(&quot;../server/server.crt&quot;)    if err != nil &#123;        log.Fatal(&quot;Failed to read server.crt&quot;)    &#125;    certPool.AppendCertsFromPEM(certBytes)    config := &amp;tls.Config&#123;        RootCAs: certPool,    &#125;    conn, _ := tls.Dial(&quot;tcp&quot;, &quot;localhost:1234&quot;, config)    defer conn.Close()    client := rpc.NewClient(conn)    var result Result    if err := client.Call(&quot;Cal.Square&quot;, 12, &amp;result); err != nil &#123;        log.Fatal(&quot;Failed to call Cal.Square. &quot;, err)    &#125;    log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans)&#125;</code></pre><h3 id="5-2-服务器端对客户端的鉴权"><a href="#5-2-服务器端对客户端的鉴权" class="headerlink" title="5.2 服务器端对客户端的鉴权"></a>5.2 服务器端对客户端的鉴权</h3><p>服务器端对客户端的鉴权是类似的，核心在于 <code>tls.Config</code> 的配置：</p><ul><li>把对方的证书添加到自己的信任证书池 <code>RootCAs</code>(客户端配置)，<code>ClientCAs</code>(服务器端配置) 中。</li><li>创建链接时，配置自己的证书 <code>Certificates</code>。</li></ul><p>客户端的 config 作如下修改：</p><pre><code class="go">// client/main.gocert, _ := tls.LoadX509KeyPair(&quot;client.crt&quot;, &quot;client.key&quot;)certPool := x509.NewCertPool()certBytes, _ := ioutil.ReadFile(&quot;../server/server.crt&quot;)certPool.AppendCertsFromPEM(certBytes)config := &amp;tls.Config&#123;    Certificates: []tls.Certificate&#123;cert&#125;,    RootCAs: certPool,&#125;</code></pre><p>服务器端的 config 作如下修改：</p><pre><code class="go">// server/main.gocert, _ := tls.LoadX509KeyPair(&quot;server.crt&quot;, &quot;server.key&quot;)certPool := x509.NewCertPool()certBytes, _ := ioutil.ReadFile(&quot;../client/client.crt&quot;)certPool.AppendCertsFromPEM(certBytes)config := &amp;tls.Config&#123;    Certificates: []tls.Certificate&#123;cert&#125;,    ClientAuth:   tls.RequireAndVerifyClientCert,    ClientCAs:    certPool,&#125;</code></pre><h2 id="附：参考"><a href="#附：参考" class="headerlink" title="附：参考"></a>附：参考</h2><ol><li><a href="https://golang.org/pkg/net/rpc/">Golang net/rpc 官方文档 - golang.org</a></li><li><a href="https://github.com/denji/golang-tls">Golang TLS 配置 - github.com</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文介绍了 Go 语言远程过程调用(Remote Procedure Call, RPC)的使用方式，示例基于 Golang 标准库 net/rpc，同时介绍了如何基于 TLS/SSL 实现服务器端和客户端的单向鉴权、双向鉴权。&lt;/p&gt;
&lt;h2 id=&quot;1-RPC-简介&quot;&gt;</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Golang" scheme="https://ysluckly.github.io/tags/Golang/"/>
    
    <category term="RPC" scheme="https://ysluckly.github.io/tags/RPC/"/>
    
    <category term="TLS" scheme="https://ysluckly.github.io/tags/TLS/"/>
    
    <category term="证书" scheme="https://ysluckly.github.io/tags/%E8%AF%81%E4%B9%A6/"/>
    
    <category term="鉴权" scheme="https://ysluckly.github.io/tags/%E9%89%B4%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Go Test 单元测试简明教程</title>
    <link href="https://ysluckly.github.io/2022/01/16/go/"/>
    <id>https://ysluckly.github.io/2022/01/16/go/</id>
    <published>2022-01-16T13:59:10.000Z</published>
    <updated>2022-02-20T13:38:12.755Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919113329.jpg" alt="golang test"></p><h2 id="1-如何写好单元测试"><a href="#1-如何写好单元测试" class="headerlink" title="1 如何写好单元测试"></a>1 如何写好单元测试</h2><p>单元测试(Unit Tests, UT) 是一个优秀项目不可或缺的一部分，特别是在一些频繁变动和多人合作开发的项目中尤为重要。你或多或少都会有因为自己的提交，导致应用挂掉或服务宕机的经历。如果这个时候你的修改导致测试用例失败，你再重新审视自己的修改，发现之前的修改还有一些特殊场景没有包含，恭喜你减少了一次上库失误。也会有这样的情况，项目很大，启动环境很复杂，你优化了一个函数的性能，或是添加了某个新的特性，如果部署在正式环境上之后再进行测试，成本太高。对于这种场景，几个小小的测试用例或许就能够覆盖大部分的测试场景。而且在开发过程中，效率最高的莫过于所见即所得了，单元测试也能够帮助你做到这一点，试想一下，假如你一口气写完一千行代码，debug 的过程也不会轻松，如果在这个过程中，对于一些逻辑较为复杂的函数，同时添加一些测试用例，即时确保正确性，最后集成的时候，会是另外一番体验。</p><p>如何写好单元测试呢？</p><p>首先，学会写测试用例。比如如何测试单个函数/方法；比如如何做基准测试；比如如何写出简洁精炼的测试代码；再比如遇到数据库访问等的方法调用时，如何 <code>mock</code>。</p><p>然后，写可测试的代码。<code>高内聚，低耦合</code>是软件工程的原则，同样，对测试而言，函数/方法写法不同，测试难度也是不一样的。职责单一，参数类型简单，与其他函数耦合度低的函数往往更容易测试。我们经常会说，“这种代码没法测试”，这种时候，就得思考函数的写法可不可以改得更好一些。为了代码可测试而重构是值得的。</p><p>接下来将介绍如何使用 Go 语言的标准库 <code>testing</code> 进行单元测试。</p><h2 id="2-一个简单例子"><a href="#2-一个简单例子" class="headerlink" title="2 一个简单例子"></a>2 一个简单例子</h2><p>Go 语言推荐测试文件和源代码文件放在一块，测试文件以 <code>_test.go</code> 结尾。比如，当前 package 有 <code>calc.go</code> 一个文件，我们想测试 <code>calc.go</code> 中的 <code>Add</code> 和 <code>Mul</code> 函数，那么应该新建 <code>calc_test.go</code> 作为测试文件。</p><pre><code class="bash">example/   |--calc.go   |--calc_test.go</code></pre><p>假如 <code>calc.go</code> 的代码如下：</p><pre><code class="go">package mainfunc Add(a int, b int) int &#123;    return a + b&#125;func Mul(a int, b int) int &#123;    return a * b&#125;</code></pre><p>那么 <code>calc_test.go</code> 中的测试用例可以这么写：</p><pre><code class="go">package mainimport &quot;testing&quot;func TestAdd(t *testing.T) &#123;    if ans := Add(1, 2); ans != 3 &#123;        t.Errorf(&quot;1 + 2 expected be 3, but %d got&quot;, ans)    &#125;    if ans := Add(-10, -20); ans != -30 &#123;        t.Errorf(&quot;-10 + -20 expected be -30, but %d got&quot;, ans)    &#125;&#125;</code></pre><ul><li>测试用例名称一般命名为 <code>Test</code> 加上待测试的方法名。</li><li>测试用的参数有且只有一个，在这里是 <code>t *testing.T</code>。</li><li>基准测试(benchmark)的参数是 <code>*testing.B</code>，TestMain 的参数是 <code>*testing.M</code> 类型。</li></ul><p>运行 <code>go test</code>，该 package 下所有的测试用例都会被执行。</p><pre><code class="bash">$ go testok      example 0.009s</code></pre><p>或 <code>go test -v</code>，<code>-v</code> 参数会显示每个用例的测试结果，另外 <code>-cover</code> 参数可以查看覆盖率。</p><pre><code class="bash">$ go test -v=== RUN   TestAdd--- PASS: TestAdd (0.00s)=== RUN   TestMul--- PASS: TestMul (0.00s)PASSok      example 0.007s</code></pre><p>如果只想运行其中的一个用例，例如 <code>TestAdd</code>，可以用 <code>-run</code> 参数指定，该参数支持通配符 <code>*</code>，和部分正则表达式，例如 <code>^</code>、<code>$</code>。</p><pre><code class="bash">$ go test -run TestAdd -v=== RUN   TestAdd--- PASS: TestAdd (0.00s)PASSok      example 0.007s</code></pre><h2 id="3-子测试-Subtests"><a href="#3-子测试-Subtests" class="headerlink" title="3 子测试(Subtests)"></a>3 子测试(Subtests)</h2><p>子测试是 Go 语言内置支持的，可以在某个测试用例中，根据测试场景使用 <code>t.Run</code>创建不同的子测试用例：</p><pre><code class="go">// calc_test.gofunc TestMul(t *testing.T) &#123;    t.Run(&quot;pos&quot;, func(t *testing.T) &#123;        if Mul(2, 3) != 6 &#123;            t.Fatal(&quot;fail&quot;)        &#125;    &#125;)    t.Run(&quot;neg&quot;, func(t *testing.T) &#123;        if Mul(2, -3) != -6 &#123;            t.Fatal(&quot;fail&quot;)        &#125;    &#125;)&#125;</code></pre><ul><li>之前的例子测试失败时使用 <code>t.Error/t.Errorf</code>，这个例子中使用 <code>t.Fatal/t.Fatalf</code>，区别在于前者遇错不停，还会继续执行其他的测试用例，后者遇错即停。</li></ul><p>运行某个测试用例的子测试：</p><pre><code class="bash">$ go test -run TestMul/pos -v=== RUN   TestMul=== RUN   TestMul/pos--- PASS: TestMul (0.00s)    --- PASS: TestMul/pos (0.00s)PASSok      example 0.008s</code></pre><p>对于多个子测试的场景，更推荐如下的写法(table-driven tests)：</p><pre><code class="go">//  calc_test.gofunc TestMul(t *testing.T) &#123;    cases := []struct &#123;        Name           string        A, B, Expected int    &#125;&#123;        &#123;&quot;pos&quot;, 2, 3, 6&#125;,        &#123;&quot;neg&quot;, 2, -3, -6&#125;,        &#123;&quot;zero&quot;, 2, 0, 0&#125;,    &#125;    for _, c := range cases &#123;        t.Run(c.Name, func(t *testing.T) &#123;            if ans := Mul(c.A, c.B); ans != c.Expected &#123;                t.Fatalf(&quot;%d * %d expected %d, but %d got&quot;,                    c.A, c.B, c.Expected, ans)            &#125;        &#125;)    &#125;&#125;</code></pre><p>所有用例的数据组织在切片 <code>cases</code> 中，看起来就像一张表，借助循环创建子测试。这样写的好处有：</p><ul><li>新增用例非常简单，只需给 cases 新增一条测试数据即可。</li><li>测试代码可读性好，直观地能够看到每个子测试的参数和期待的返回值。</li><li>用例失败时，报错信息的格式比较统一，测试报告易于阅读。</li></ul><p>如果数据量较大，或是一些二进制数据，推荐使用相对路径从文件中读取。</p><h2 id="4-帮助函数-helpers"><a href="#4-帮助函数-helpers" class="headerlink" title="4 帮助函数(helpers)"></a>4 帮助函数(helpers)</h2><p>对一些重复的逻辑，抽取出来作为公共的帮助函数(helpers)，可以增加测试代码的可读性和可维护性。 借助帮助函数，可以让测试用例的主逻辑看起来更清晰。</p><p>例如，我们可以将创建子测试的逻辑抽取出来：</p><pre><code class="go">// calc_test.gopackage mainimport &quot;testing&quot;type calcCase struct&#123; A, B, Expected int &#125;func createMulTestCase(t *testing.T, c *calcCase) &#123;    // t.Helper()    if ans := Mul(c.A, c.B); ans != c.Expected &#123;        t.Fatalf(&quot;%d * %d expected %d, but %d got&quot;,            c.A, c.B, c.Expected, ans)    &#125;&#125;func TestMul(t *testing.T) &#123;    createMulTestCase(t, &amp;calcCase&#123;2, 3, 6&#125;)    createMulTestCase(t, &amp;calcCase&#123;2, -3, -6&#125;)    createMulTestCase(t, &amp;calcCase&#123;2, 0, 1&#125;) // wrong case&#125;</code></pre><p>在这里，我们故意创建了一个错误的测试用例，运行 <code>go test</code>，用例失败，会报告错误发生的文件和行号信息：</p><pre><code class="bash">$ go test--- FAIL: TestMul (0.00s)    calc_test.go:11: 2 * 0 expected 1, but 0 gotFAILexit status 1FAIL    example 0.007s</code></pre><p>可以看到，错误发生在第11行，也就是帮助函数 <code>createMulTestCase</code> 内部。18, 19, 20行都调用了该方法，我们第一时间并不能够确定是哪一行发生了错误。有些帮助函数还可能在不同的函数中被调用，报错信息都在同一处，不方便问题定位。因此，Go 语言在 1.9 版本中引入了 <code>t.Helper()</code>，用于标注该函数是帮助函数，报错时将输出帮助函数调用者的信息，而不是帮助函数的内部信息。</p><p>修改 <code>createMulTestCase</code>，调用 <code>t.Helper()</code></p><pre><code class="go">func createMulTestCase(c *calcCase, t *testing.T) &#123;    t.Helper()    t.Run(c.Name, func(t *testing.T) &#123;        if ans := Mul(c.A, c.B); ans != c.Expected &#123;            t.Fatalf(&quot;%d * %d expected %d, but %d got&quot;,                c.A, c.B, c.Expected, ans)        &#125;    &#125;)&#125;</code></pre><p>运行 <code>go test</code>，报错信息如下，可以非常清晰地知道，错误发生在第 20 行。</p><pre><code class="bash">$ go test--- FAIL: TestMul (0.00s)    calc_test.go:20: 2 * 0 expected 1, but 0 gotFAILexit status 1FAIL    example 0.006s</code></pre><p>关于 <code>helper</code> 函数的 2 个建议：</p><ul><li>不要返回错误， 帮助函数内部直接使用 <code>t.Error</code> 或 <code>t.Fatal</code> 即可，在用例主逻辑中不会因为太多的错误处理代码，影响可读性。</li><li>调用 <code>t.Helper()</code> 让报错信息更准确，有助于定位。</li></ul><h2 id="5-setup-和-teardown"><a href="#5-setup-和-teardown" class="headerlink" title="5 setup 和 teardown"></a>5 setup 和 teardown</h2><p>如果在同一个测试文件中，每一个测试用例运行前后的逻辑是相同的，一般会写在 setup 和 teardown 函数中。例如执行前需要实例化待测试的对象，如果这个对象比较复杂，很适合将这一部分逻辑提取出来；执行后，可能会做一些资源回收类的工作，例如关闭网络连接，释放文件等。标准库 <code>testing</code> 提供了这样的机制：</p><pre><code class="go">func setup() &#123;    fmt.Println(&quot;Before all tests&quot;)&#125;func teardown() &#123;    fmt.Println(&quot;After all tests&quot;)&#125;func Test1(t *testing.T) &#123;    fmt.Println(&quot;I&#39;m test1&quot;)&#125;func Test2(t *testing.T) &#123;    fmt.Println(&quot;I&#39;m test2&quot;)&#125;func TestMain(m *testing.M) &#123;    setup()    code := m.Run()    teardown()    os.Exit(code)&#125;</code></pre><ul><li>在这个测试文件中，包含有2个测试用例，<code>Test1</code> 和 <code>Test2</code>。</li><li>如果测试文件中包含函数 <code>TestMain</code>，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。</li><li>调用 <code>m.Run()</code> 触发所有测试用例的执行，并使用 <code>os.Exit()</code> 处理返回的状态码，如果不为0，说明有用例失败。</li><li>因此可以在调用 <code>m.Run()</code> 前后做一些额外的准备(setup)和回收(teardown)工作。</li></ul><p>执行 <code>go test</code>，将会输出</p><pre><code class="bash">$ go testBefore all testsI&#39;m test1I&#39;m test2PASSAfter all testsok      example 0.006s</code></pre><h2 id="6-网络测试-Network"><a href="#6-网络测试-Network" class="headerlink" title="6 网络测试(Network)"></a>6 网络测试(Network)</h2><h3 id="6-1-TCP-HTTP"><a href="#6-1-TCP-HTTP" class="headerlink" title="6.1 TCP/HTTP"></a>6.1 TCP/HTTP</h3><p>假设需要测试某个 API 接口的 handler 能够正常工作，例如 helloHandler </p><pre><code class="go">func helloHandler(w http.ResponseWriter, r *http.Request) &#123;    w.Write([]byte(&quot;hello world&quot;))&#125;</code></pre><p>那我们可以创建真实的网络连接进行测试：</p><pre><code class="go">// test codeimport (    &quot;io/ioutil&quot;    &quot;net&quot;    &quot;net/http&quot;    &quot;testing&quot;)func handleError(t *testing.T, err error) &#123;    t.Helper()    if err != nil &#123;        t.Fatal(&quot;failed&quot;, err)    &#125;&#125;func TestConn(t *testing.T) &#123;    ln, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:0&quot;)    handleError(t, err)    defer ln.Close()    http.HandleFunc(&quot;/hello&quot;, helloHandler)    go http.Serve(ln, nil)    resp, err := http.Get(&quot;http://&quot; + ln.Addr().String() + &quot;/hello&quot;)    handleError(t, err)    defer resp.Body.Close()    body, err := ioutil.ReadAll(resp.Body)    handleError(t, err)    if string(body) != &quot;hello world&quot; &#123;        t.Fatal(&quot;expected hello world, but got&quot;, string(body))    &#125;&#125;</code></pre><ul><li><code>net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:0&quot;)</code>：监听一个未被占用的端口，并返回 Listener。</li><li>调用 <code>http.Serve(ln, nil)</code> 启动 http 服务。</li><li>使用 <code>http.Get</code> 发起一个 Get 请求，检查返回值是否正确。</li><li>尽量不对 <code>http</code> 和 <code>net</code> 库使用 mock，这样可以覆盖较为真实的场景。</li></ul><h3 id="6-2-httptest"><a href="#6-2-httptest" class="headerlink" title="6.2 httptest"></a>6.2 httptest</h3><p>针对 http 开发的场景，使用标准库 <code>net/http/httptest</code> 进行测试更为高效。</p><p>上述的测试用例改写如下：</p><pre><code class="go">// test codeimport (    &quot;io/ioutil&quot;    &quot;net/http&quot;    &quot;net/http/httptest&quot;    &quot;testing&quot;)func TestConn(t *testing.T) &#123;    req := httptest.NewRequest(&quot;GET&quot;, &quot;http://example.com/foo&quot;, nil)    w := httptest.NewRecorder()    helloHandler(w, req)    bytes, _ := ioutil.ReadAll(w.Result().Body)    if string(bytes) != &quot;hello world&quot; &#123;        t.Fatal(&quot;expected hello world, but got&quot;, string(bytes))    &#125;&#125;</code></pre><p>使用 httptest 模拟请求对象(req)和响应对象(w)，达到了相同的目的。</p><h2 id="7-Benchmark-基准测试"><a href="#7-Benchmark-基准测试" class="headerlink" title="7 Benchmark 基准测试"></a>7 Benchmark 基准测试</h2><p>基准测试用例的定义如下：</p><pre><code class="go">func BenchmarkName(b *testing.B)&#123;    // ...&#125;</code></pre><ul><li>函数名必须以 <code>Benchmark</code> 开头，后面一般跟待测试的函数名</li><li>参数为 <code>b *testing.B</code>。</li><li>执行基准测试时，需要添加 <code>-bench</code> 参数。</li></ul><p>例如：</p><pre><code class="go">func BenchmarkHello(b *testing.B) &#123;    for i := 0; i &lt; b.N; i++ &#123;        fmt.Sprintf(&quot;hello&quot;)    &#125;&#125;</code></pre><pre><code class="bash">$ go test -benchmem -bench ....BenchmarkHello-16   15991854   71.6 ns/op   5 B/op   1 allocs/op...</code></pre><p>基准测试报告每一列值对应的含义如下：</p><pre><code class="go">type BenchmarkResult struct &#123;    N         int           // 迭代次数    T         time.Duration // 基准测试花费的时间    Bytes     int64         // 一次迭代处理的字节数    MemAllocs uint64        // 总的分配内存的次数    MemBytes  uint64        // 总的分配内存的字节数&#125;</code></pre><p>如果在运行前基准测试需要一些耗时的配置，则可以使用 <code>b.ResetTimer()</code> 先重置定时器，例如：</p><pre><code class="go">func BenchmarkHello(b *testing.B) &#123;    ... // 耗时操作    b.ResetTimer()    for i := 0; i &lt; b.N; i++ &#123;        fmt.Sprintf(&quot;hello&quot;)    &#125;&#125;</code></pre><p>使用 <code>RunParallel</code> 测试并发性能</p><pre><code class="go">func BenchmarkParallel(b *testing.B) &#123;    templ := template.Must(template.New(&quot;test&quot;).Parse(&quot;Hello, &#123;&#123;.&#125;&#125;!&quot;))    b.RunParallel(func(pb *testing.PB) &#123;        var buf bytes.Buffer        for pb.Next() &#123;            // 所有 goroutine 一起，循环一共执行 b.N 次            buf.Reset()            templ.Execute(&amp;buf, &quot;World&quot;)        &#125;    &#125;)&#125;</code></pre><pre><code class="bash">$ go test -benchmem -bench ....BenchmarkParallel-16   3325430     375 ns/op   272 B/op   8 allocs/op...</code></pre><h2 id="附-参考"><a href="#附-参考" class="headerlink" title="附 参考"></a>附 参考</h2><ul><li><a href="https://geektutu.com/post/quick-gomock.html">Go Mock (gomock) 简明教程</a></li><li><a href="https://golang.org/pkg/testing/">testing - golang.org</a></li><li><a href="https://about.sourcegraph.com/go/advanced-testing-in-go">Advanced Testing in Go - sourcegraph.com</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/ysluckly/ImageHost/living/20210919113329.jpg&quot; alt=&quot;golang test&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-如何写好单元测试&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="golang test" scheme="https://ysluckly.github.io/tags/golang-test/"/>
    
    <category term="unit tests" scheme="https://ysluckly.github.io/tags/unit-tests/"/>
    
    <category term="golang testing" scheme="https://ysluckly.github.io/tags/golang-testing/"/>
    
  </entry>
  
  <entry>
    <title>Go库之goquery</title>
    <link href="https://ysluckly.github.io/2022/01/09/golang/"/>
    <id>https://ysluckly.github.io/2022/01/09/golang/</id>
    <published>2022-01-09T07:29:32.000Z</published>
    <updated>2022-02-26T05:59:30.761Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考 飞雪无痕 的 《golang goquery selector(选择器) 示例大全》</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><a href="https://blog.csdn.net/yang731227/article/details/89338745"></a>概述</h1><p>相信很多小伙伴对爬虫有着很大的兴趣,今天我们就来说下go语言的爬虫利器<code>goquery</code>，有使用过<code>jquery</code>的小伙伴是不是看着这个很眼熟？goquery类似jquery，它是jquery的go版本实现，使用它，可以很方便的对HTML进行处理。</p><p>goquery是基于 Go net/htm包和css选择器库 cascadia。由于net/htm解析器返回的是DOM节点,而不是完整的DOM树,因此, jQuery的状态操作函数没有实现(像height(), css(), detach)</p><blockquote><p>注意：goquery只支持utf-8编码，其他编码需要转换。</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzE3MjgzMTgwLTc3NWVhNDZhODkxMTI5MDguanBn?x-oss-process=image/format,png" alt="image"></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a><a href="https://blog.csdn.net/yang731227/article/details/89338745"></a>安装</h1><p>在终端输入命令安装goquery。</p><blockquote><p>go get github.com/PuerkitoBio/goquery</p></blockquote><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a><a href="https://blog.csdn.net/yang731227/article/details/89338745"></a>简单使用</h1><p>我们首先通过一个小例子来介绍goqery。</p><pre><code>func main() &#123;    html := `&lt;html&gt;            &lt;body&gt;                &lt;h1 id=&quot;title&quot;&gt;春晓&lt;/h1&gt;                &lt;p class=&quot;content1&quot;&gt;                春眠不觉晓，                处处闻啼鸟。                夜来风雨声，                花落知多少。                &lt;/p&gt;            &lt;/body&gt;            &lt;/html&gt;            `dom,err:=goquery.NewDocumentFromReader(strings.NewReader(html))    if err!=nil&#123;        log.Fatalln(err)    &#125;    dom.Find(&quot;p&quot;).Each(func(i int, selection *goquery.Selection) &#123;        fmt.Println(selection.Text())    &#125;)&#125;</code></pre><p>得到结果：</p><pre><code>                春眠不觉晓，                处处闻啼鸟。                夜来风雨声，                花落知多少。</code></pre><p><code>NewDocumentFromReader()</code> 返回了一个*Document和error。Document代表一个将要被操作的HTML文档。</p><p><code>Find()</code>是获取当前匹配元素集中每个元素的子代，参数是<code>x选择器</code> ，它返回一个包含这些匹配元素的新选择对象。在例子中我们使用的是元素选择器<code>P</code>，它会帮我们匹配出所有的<code>p标签</code> 。</p><p><code>Each()</code> 是迭代器，它会循环遍历选择的节点，它的参数是一个匿名函数，匿名函数拥有2个参数，一个是元素的<code>索引位置</code>，还有一个就是<code>选择的结果集</code>匹配到的内容都在它的里面。</p><p><code>Text()</code> 则是获取匹配元素集中的文本内容。</p><h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a><a href="https://blog.csdn.net/yang731227/article/details/89338745"></a>选择器</h1><p>上面的例子中，我们使用了<code>元素选择器</code>,goquery跟jquery一样都支持很多选择器，我们简单的介绍下常用的选择器：</p><ol><li>基于HTML Element 元素的选择器<br> 就是基于a,p等这些HTML的基本元素进行选择。</li></ol><p>使用方法 ：使用语法为 <code>dom.Find(&quot;p&quot;)</code>，匹配文档中所有的p标签。</p><ol start="2"><li>ID 选择器<br> ID选择器是我们使用最频繁的，假如我们有2个p元素，其实我们只需要其中的一个，那么我们只需要给这个标记一个唯一的id即可，这样我们就可以使用id选择器，精确定位了。</li></ol><p>使用方法 ：id选择器以<code>#</code>开头，紧跟着元素id的值，使用语法为<br><code>dom.Find(&quot;#title&quot;)</code> ，匹配文档中所有的 id=title的内容</p><p>如果多个标签的ID都是title，我们可以指定某一个标签,如<code>dom.Find(&quot;p#title&quot;)</code></p><ol start="3"><li> Class选择器</li></ol><p>类选择跟ID选择器一样都是使用很频繁的，我们可以通过类选择器快速筛选到需要的内容。</p><p>使用方法 ： id选择器以<code>.</code>开头，紧跟着元素class的值，使用语法为<code>dom.Find(&quot;.content1&quot;)</code>，匹配文档中所有的 id=title的元素。</p><p>类选择权器跟ID选择器一样,也可以指定某一个标签<code>dom.Find(&quot;div.content1&quot;)</code></p><ol start="4"><li> 属性选择器</li></ol><p>一个HTML元素都有自己的属性以及属性值，所以我们也可以通过属性和值筛选元素。</p><p>使用方法 ：我们可以通过元素的属性和属性值来筛选数据，使用语法为<code>dom.Find(&quot;p[class=content1]</code>，匹配文档中所有的 p标签的class属性是content1的元素。</p><p>当然我们这里以class属性为例，还可以用其他属性，比如href等很多，自定义属性也是可以的。</p><p>刚刚我们使用的是<code>完全相等</code>的匹配方式，属性选择器还要很多匹配方式。</p><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>Find(“div[my]“)</td><td>筛选含有my属性的div元素</td></tr><tr><td>Find(“div[my=zh]“)</td><td>筛选my属性为zh的div元素</td></tr><tr><td>Find(“div[my!=zh]“)</td><td>筛选my属性不等于zh的div元素</td></tr><tr><td>Find(“div[my¦=zh]“)</td><td>筛选my属性为zh或者zh-开头的div元素</td></tr><tr><td>Find(“div[my*=zh]“)</td><td>筛选my属性包含zh这个字符串的div元素</td></tr><tr><td>Find(“div[my~=zh]“)</td><td>筛选my属性包含zh这个单词的div元素，单词以空格分开的</td></tr><tr><td>Find(“div[my$=zh]“)</td><td>筛选my属性以zh结尾的div元素，区分大小写</td></tr><tr><td>Find(“div[my^=zh]“)</td><td>筛选my属性以zh开头的div元素，区分大小写</td></tr></tbody></table><ol start="5"><li> parent &gt; child选择器</li></ol><p>筛选出某个元素下的子元素。</p><p>使用方法：使用<code>&gt;</code>符号连接，使用语法 <code>dom.Find(&quot;div&gt;p&quot;)</code> ， 筛选div标签下的p标签</p><ol start="6"><li> element + next 相邻选择器</li></ol><p>如果要筛选的元素没有规律，但是该元素的上一个元素有规律，我们就可以使用这种下一个相邻选择器来进行选择。</p><p>如：</p><pre><code>&lt;div&gt;&lt;p my=&quot;a&quot;&gt;a&lt;/p&gt;&lt;p&gt;b&lt;/p&gt;&lt;p&gt;c&lt;/p&gt;&lt;div&gt;</code></pre><p>我想筛选出<code>b</code>所在的标签</p><p>使用方法：<code>dom.Find(&quot;p[my=a]+p&quot;)</code>筛选出p标签属性my的值为a的相邻p标签。</p><ol start="7"><li> element~next 兄弟选择器</li></ol><p>有时候我们需要筛选同一父元素下，不相邻的标签，可以使用兄弟选择器</p><p>比如我想筛选出 b 和c 所在标签<br>使用方法：<code>dom.Find(&quot;p[my=a]~p&quot;)</code>，筛选出p标签属性my的值为a的兄弟p标签。</p><h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a><a href="https://blog.csdn.net/yang731227/article/details/89338745"></a>过滤器</h1><p>有时候我们选择出来的结果，并不是我们心目中的最优结果，我们希望对其进行过滤。</p><ol><li> :contains过滤器</li></ol><p>筛选出的元素要包含指定的文本，比如我想筛选出包含a的p标签</p><p>使用方法：<code>dom.Find(&quot;p:contains(a)&quot;)</code>，筛选出内容包含a的p标签</p><p>Find(“:has(selector)”)和contains差不多，只不过这个是包含的是元素节点。</p><p>此外还有Find(“:empty”)表示筛选出的元素都不能有子元素（包括文本元素），只筛选那些不包含任何子元素的元素。</p><ol start="2"><li>:first-child过滤器 和:first-of-type过滤器<br> 筛选出的元素要是他们的父元素的第一个子元素，如果不是，则不会被筛选出来。</li></ol><p>使用方法：语法为Find(“p:first-child”)，筛选出第一个p标签</p><p>:first-child选择器限制的比较死，必须得是第一个子元素，如果该元素前有其他在前面，就不能用:first-child了，这时候:first-of-type就派上用场了，它要求只要是这个类型的第一个就可以。</p><ol start="3"><li><p>:last-child 和:last-of-type过滤器<br> 这两个正好和上面的:first-child、:first-of-type相反</p></li><li><p> :nth-child(n) 过滤器</p></li></ol><p>筛选出的元素是其父元素的第n个元素，n以1开始。所以我们可以知道:first-child和:nth-child(1)是相等的。通过指定n，我们就很灵活的筛选出我们需要的元素。</p><ol start="5"><li> :nth-of-type(n) 过滤器</li></ol><p>:nth-of-type(n)和 :nth-child(n) 类似，只不过它表示的是同类型元素的第n个,所以:nth-of-type(1) 和 :first-of-type是相等的。</p><ol start="6"><li> :nth-last-child(n) 和:nth-last-of-type(n) 过滤器</li></ol><p>这两个和上面的类似，只不过是倒序开始计算的，最后一个元素被当成了第一个</p><ol start="7"><li> :only-child 过滤器 和 :only-of-type 过滤器</li></ol><p>筛选出父元素中，只有它自己的一个的元素。</p><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a><a href="https://blog.csdn.net/yang731227/article/details/89338745"></a>常用方法</h1><ol><li> 类似函数的位置操作</li></ol><ul><li>  Find(selection) *Selection //根据选择器查找节点集</li><li>  Eq(index int) *Selection //根据索引获取某个节点集</li><li>  First() *Selection //获取第一个子节点集</li><li>  Last() *Selection //获取最后一个子节点集</li><li>  Next() *Selection //获取下一个兄弟节点集</li><li>  NextAll() *Selection //获取后面所有兄弟节点集</li><li>  Prev() *Selection //前一个兄弟节点集</li><li>  Get(index int) *html.Node //根据索引获取一个节点</li><li>  Index() int //返回选择对象中第一个元素的位置</li><li>  Slice(start, end int) *Selection //根据起始位置获取子节点集</li></ul><ol start="2"><li> 循环遍历选择的节点</li></ol><ul><li><p>  Each(f func(int, *Selection)) *Selection //遍历</p></li><li><p>  EachWithBreak(f func(int, *Selection) bool) *Selection //可中断遍历</p></li><li><p>  Map(f func(int, *Selection) string) (result []string) //返回字符串数组</p></li></ul><ol start="3"><li> 检测或获取节点属性值</li></ol><ul><li><p>  Attr(), RemoveAttr(), SetAttr() //获取，移除，设置属性的值</p></li><li><p>  AddClass(), HasClass(), RemoveClass(), ToggleClass()</p></li><li><p>  Html() //获取该节点的html</p></li><li><p>  Length() //返回该Selection的元素个数</p></li><li><p>  Text() //获取该节点的文本值</p></li></ul><ol start="4"><li> 在文档树之间来回跳转（常用的查找节点方法）</li></ol><ul><li><p>  Children() //返回selection中各个节点下的孩子节点</p></li><li><p>  Contents() //获取当前节点下的所有节点</p></li><li><p>  Find() //查找获取当前匹配的元素</p></li><li><p>  Next() //下一个元素</p></li><li><p>  Prev() //上一个元素</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://blog.csdn.net/yang731227/article/details/89338745"></a>总结</h1><p>goquery 是解析HTML网页必备的利器，在爬虫抓取网页的过程中，灵活的使用goquery不同的选择器，可以让我们的抓取工作事半功倍，大大提升爬虫的效率。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzE3MjgzMTgwLWRiYzNlZWQyZGQ3NDJlZDAuanBn?x-oss-process=image/format,png" alt="image"></p><p>本文转自 <a href="https://blog.csdn.net/yang731227/article/details/89338745">https://blog.csdn.net/yang731227/article/details/89338745</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文参考 飞雪无痕 的 《golang goquery selector(选择器) 示例大全》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Go爬虫" scheme="https://ysluckly.github.io/tags/Go%E7%88%AC%E8%99%AB/"/>
    
    <category term="goquery" scheme="https://ysluckly.github.io/tags/goquery/"/>
    
  </entry>
  
  <entry>
    <title>【Go项目】爬取CSDN文章保存本地</title>
    <link href="https://ysluckly.github.io/2022/01/08/golang/"/>
    <id>https://ysluckly.github.io/2022/01/08/golang/</id>
    <published>2022-01-08T07:29:32.000Z</published>
    <updated>2022-02-26T05:58:30.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a><a href="https://blog.csdn.net/yang731227/article/details/103098189"></a>背景</h1><p>我一直想把在CSDN上面发布的文章保存到本地，然后迁移到简书上，但是CSDN比较闭塞的就是不提供迁移接口。所以我只能寻找第三方工具，但是发现要么已经失效，要么就是使用不太友好（对我个人而言），所以我用go语言花了半小时自己撸了一个导出工具。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a><a href="https://blog.csdn.net/yang731227/article/details/103098189"></a>分析</h1><p>我们先来分析如何获取到文章信息：</p><h2 id="1-获取文章地址"><a href="#1-获取文章地址" class="headerlink" title="1.获取文章地址"></a><a href="https://blog.csdn.net/yang731227/article/details/103098189"></a>1.获取文章地址</h2><p>首先我们通过文章列表获取文章的地址。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0Nsb3duOTUvU3Ryb3lCYWNrL21hc3Rlci8lRTUlQjAlOEYlRTQlQjklQTYlRTUlOEMlQTAvMTU3Mzg3NTg4Nzk3Mi5wbmc?x-oss-process=image/format,png" alt="enter description here"></p><pre><code>&lt;h4 class=&quot;&quot;&gt;        &lt;a href=&quot;https://blog.csdn.net/yang731227/article/details/103007106&quot; target=&quot;_blank&quot;&gt;        &lt;span class=&quot;article-type type-1 float-none&quot;&gt;原创&lt;/span&gt;        Beego脱坑（六）——使用模板获取数据      &lt;/a&gt;    &lt;/h4&gt;</code></pre><p>可以发现 每篇的文章地址 在 h4标签 下面的a 标签中。</p><h2 id="2-获取文章内容"><a href="#2-获取文章内容" class="headerlink" title="2.获取文章内容"></a><a href="https://blog.csdn.net/yang731227/article/details/103098189"></a>2.获取文章内容</h2><p>接着我们获取文章的具体内容，CSDN的文章类型有两种，一种是<code>富文本</code>类型，还有一种是<code>markdown</code>。因此我先查看它们显示的方式是否一样</p><p>首先我查看的是富文本格式的文章，发现内容是在<code>&lt;article class=&quot;baidu_pl&quot;&gt;</code>标签里面：</p><pre><code>&lt;article class=&quot;baidu_pl&quot;&gt;               &lt;!--忽略文章内容--&gt;   &lt;/article&gt;`</code></pre><p>接着我们在找一篇markdown格式编写的文章查看下,发现内容依然是在<code>&lt;article class=&quot;baidu_pl&quot;&gt;</code>标签里面。</p><h2 id="3-查找接口"><a href="#3-查找接口" class="headerlink" title="3.查找接口"></a><a href="https://blog.csdn.net/yang731227/article/details/103098189"></a>3.查找接口</h2><p>找到文章内容在什么标签内还没完事，我这人比较喜欢搞事情。因为我希望能到把博客导成md格式，但是现在网页上爬取的内容都是html，也就是富文本格式。因此我去寻找go语言 html转markdown 的库，但是不幸的是没有找到。虽然又工具可以帮我完成这份工作，但是我比较懒希望能减少工作就减少一点。</p><p>然后我的思维又开始拐弯，如果是md格式的文章，我们在文章的编辑界面不是可以直接获取到md文本吗？我在编辑页面把所有的md文章，都直接保存为md不就能省很多功夫？<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0Nsb3duOTUvU3Ryb3lCYWNrL21hc3Rlci8lRTUlQjAlOEYlRTQlQjklQTYlRTUlOEMlQTAvMTU3Mzg4MDU4MDc3My5wbmc?x-oss-process=image/format,png"></p><p>但是接下来我去查看编辑页面源代码的时候，没有发现文章的内容。这时候不要慌！那么它肯定是通过某个接口来加载数据的，查看下<code>XHR</code>果然发现了一个接口，参数是文章ID。<br><del><code>https://mp.csdn.net/mdeditor/getArticle?id=103007106</code></del> (该接口富文本内容已失效)</p><p>新的接口为：</p><blockquote><p><a href="https://blog-console-api.csdn.net/v1/editor/getArticle?id=103007106">https://blog-console-api.csdn.net/v1/editor/getArticle?id=103007106</a></p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0Nsb3duOTUvU3Ryb3lCYWNrL21hc3Rlci8lRTUlQjAlOEYlRTQlQjklQTYlRTUlOEMlQTAvMTU3Mzg4MDY2NzA3Mi5wbmc?x-oss-process=image/format,png"></p><p>以此类推，我再去打开富文本文章的编辑界面，我希望它也是通过接口加载数据的，这样在进行数据处理的时候我就能够省很多代码。然鹅富文本格式并没有接口数据。</p><p>但是我这个人比较轴，我就想试下，我把接口ID改成富文本文章的ID，看看它是否能够为我传来数据，果然有的时候搞开发就要有折腾的精神，我成功得到了文章内容 。<br><del><code>https://mp.csdn.net/mdeditor/getArticle?id=82253319</code></del></p><p><code>https://blog-console-api.csdn.net/v1/editor/getArticle?id=82253319</code><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0Nsb3duOTUvU3Ryb3lCYWNrL21hc3Rlci8lRTUlQjAlOEYlRTQlQjklQTYlRTUlOEMlQTAvMTU3Mzg4MDk3ODI2Ni5wbmc?x-oss-process=image/format,png" alt="enter description here"></p><p>两个数据不一样的地方就是，如果是md文章，它 <code>markdowncontent</code> 里面的内容是 md文本，如果是富文本的文章，它<code>markdowncontent</code>属性就为空，因此我们在导出文本的时候，如果遇到<code>markdowncontent</code>不为空就获取<code>markdowncontent</code>的内容并保存为.md ,如果遇到为空的情况，就获取<code>content</code>内容并保存为.html</p><h2 id="4-整理"><a href="#4-整理" class="headerlink" title="4.整理"></a><a href="https://blog.csdn.net/yang731227/article/details/103098189"></a>4.整理</h2><p>现在我们已知 <code>https://blog-console-api.csdn.net/v1/editor/getArticle?id=xxxx</code><br>这个接口可以获取到文章的信息，参数是文章ID。<br>所以接下来我们需要做的就是，通过爬虫模拟csdn登录状态，获取所爬的博客中每篇文章的ID,传递给接口，获取文章标题和内容，并根据格式保存不同的文件。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><a href="https://blog.csdn.net/yang731227/article/details/103098189"></a>实现代码</h1><h2 id="使用到的第三方库"><a href="#使用到的第三方库" class="headerlink" title="使用到的第三方库"></a><a href="https://blog.csdn.net/yang731227/article/details/103098189"></a>使用到的第三方库</h2><ul><li>  使用<code>goconfig</code>库，来加载配置信息，用来获取博客地址、文章列表页数和Cookie。</li><li>  使用<code>goquery</code> 进行爬虫</li></ul><h2 id="model-go"><a href="#model-go" class="headerlink" title="model.go"></a><a href="https://blog.csdn.net/yang731227/article/details/103098189"></a>model.go</h2><pre><code>package modelsimport (    &quot;CSDN/utils&quot;    &quot;github.com/Unknwon/goconfig&quot;)var ArrDetailID []string //保存文章IDvar BlogUrl string // 配置博客地址var Cookie string  // 配置Cookievar TotalPage int  // 博客文章列表总页数type Article struct &#123; //用来解析json    Data struct &#123;        //    ID              string `json:&quot;id&quot;`        Title string `json:&quot;title&quot;`        //    Articleedittype int    `json:&quot;articleedittype&quot;`        //    Description     string `json:&quot;description&quot;`        Content         string `json:&quot;content&quot;`        Markdowncontent string `json:&quot;markdowncontent&quot;`        /*            Tags string `json:&quot;tags&quot;`            Categories string `json:&quot;categories&quot;`            Channel string `json:&quot;channel&quot;`            Type string `json:&quot;type&quot;`            Status int `json:&quot;status&quot;`            ReadType string `json:&quot;readType&quot;`            UseVipView int `json:&quot;use_vip_view&quot;`            UseFansView int `json:&quot;use_fans_view&quot;`            Reason string `json:&quot;reason&quot;`            ResourceURL string `json:&quot;resource_url&quot;`            OriginalLink string `json:&quot;original_link&quot;`            AuthorizedStatus bool `json:&quot;authorized_status&quot;`            CheckOriginal bool `json:&quot;check_original&quot;`            SelfRecommend bool `json:&quot;selfRecommend&quot;`        */    &#125; `json:&quot;data&quot;`&#125;func init() &#123;    runpath := utils.GetRunPath()    cfg, err := goconfig.LoadConfigFile(runpath + &quot;/conf/conf.ini&quot;)    if err != nil &#123;        panic(&quot;没有加载到配置文件&quot;)    &#125;    BlogUrl, err = cfg.GetValue(&quot;csdn&quot;, &quot;blogurl&quot;)    if err != nil &#123;        panic(&quot;blogurl错误&quot;)    &#125;    Cookie, err = cfg.GetValue(&quot;csdn&quot;, &quot;cookie&quot;)    if err != nil &#123;        panic(&quot;cookie错误&quot;)    &#125;    TotalPage, err = cfg.Int(&quot;csdn&quot;, &quot;totalpage&quot;)    if err != nil &#123;        panic(&quot;totalpage错误&quot;)    &#125;&#125;</code></pre><h2 id="csdn-go"><a href="#csdn-go" class="headerlink" title="csdn.go"></a><a href="https://blog.csdn.net/yang731227/article/details/103098189"></a>csdn.go</h2><pre><code>package transactionimport (    &quot;CSDN/models&quot;    &quot;encoding/json&quot;    &quot;github.com/PuerkitoBio/goquery&quot;    &quot;io/ioutil&quot;    &quot;log&quot;    &quot;net/http&quot;    &quot;strings&quot;    &quot;time&quot;)func GetHtml(url string) *http.Response &#123;    client := &amp;http.Client&#123; //要管理HTTP客户端的头域、重定向策略和其他设置，创建一个Client        Timeout: time.Second * 2,    &#125;    req, err := http.NewRequest(&quot;GET&quot;, url, nil) //NewRequest使用指定的方法、网址和可选的主题创建并返回一个新的*Request。    if err != nil &#123;        log.Println(err)    &#125;    req.Header.Add(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36&quot;) //模拟浏览器User-Agent    req.Header.Add(&quot;Cookie&quot;, models.Cookie)    resp, err := client.Do(req) //Do方法发送请求，返回HTTP回复    if err != nil &#123;        log.Println(err)    &#125;    return resp //返回网页响应&#125;func GetdetailID(resp *http.Response) &#123;    defer resp.Body.Close()    dom, err := goquery.NewDocumentFromReader(resp.Body)    if err != nil &#123;        log.Fatalln(err)    &#125;    dom.Find(&quot;h4&quot;).Each(func(i int, selection *goquery.Selection) &#123;        time.Sleep(1 * time.Second) //防止访问次数过于频繁        detailurl, _ := selection.Find(&quot;a&quot;).Attr(&quot;href&quot;)        index := strings.LastIndex(detailurl, &quot;/&quot;)        models.ArrDetailID = append(models.ArrDetailID, detailurl[index+1:])    &#125;)&#125;func ParseArticleJson(jsonurl string) (string, string) &#123;    resp := GetHtml(jsonurl)    defer resp.Body.Close()    resp_byte, _ := ioutil.ReadAll(resp.Body)    respHtml := string(resp_byte)    var article models.Article    json.Unmarshal([]byte(respHtml), &amp;article)    title := article.Data.Title    content := article.Data.Content    markdown := article.Data.Markdowncontent    if markdown == &quot;&quot; &#123;        return title + &quot;.html&quot;, content    &#125; else &#123;        return title + &quot;.md&quot;, markdown    &#125;&#125;</code></pre><h2 id="utils-go"><a href="#utils-go" class="headerlink" title="utils.go"></a><a href="https://blog.csdn.net/yang731227/article/details/103098189"></a>utils.go</h2><pre><code>package utilsimport (    &quot;fmt&quot;    &quot;io/ioutil&quot;    &quot;os&quot;    &quot;os/exec&quot;    &quot;path/filepath&quot;    &quot;strings&quot;)func WriteWithIoutil(name, content string) &#123;    data := []byte(content)    if ioutil.WriteFile(name, data, 0644) == nil &#123;        fmt.Println(&quot;导出成功:&quot;, name)    &#125;&#125;// 获取程序当前运行路径func GetRunPath() string&#123;    file, _ := exec.LookPath(os.Args[0])    path, _ := filepath.Abs(file)    index := strings.LastIndex(path, string(os.PathSeparator))    runpath :=path[:index]    return  runpath&#125;</code></pre><h2 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a><a href="https://blog.csdn.net/yang731227/article/details/103098189"></a>main.go</h2><pre><code>package mainimport (    &quot;CSDN/models&quot;    &quot;CSDN/transaction&quot;    &quot;CSDN/utils&quot;    &quot;fmt&quot;    &quot;time&quot;)func main() &#123;    fmt.Println(&quot;设置成功，开始导出blog,时间较长请等待！！&quot;)    for i := 1; i &lt;= models.TotalPage; i++ &#123;        time.Sleep(800) //设置延时        url := fmt.Sprintf(&quot;%s/article/list/%d&quot;, models.BlogUrl, i)        resq := transaction.GetHtml(url)        transaction.GetdetailID(resq)    &#125;    runpath := utils.GetRunPath()    for i := 0; i &lt; len(models.ArrDetailID); i++ &#123;        //jsonurl := fmt.Sprintf(&quot;https://mp.csdn.net/mdeditor/getArticle?id=%s&quot;, models.ArrDetailID[i])        jsonurl := fmt.Sprintf(&quot;https://blog-console-api.csdn.net/v1/editor/getArticle?id=%s&quot;, models.ArrDetailID[i])        name, content := transaction.ParseArticleJson(jsonurl)        utils.WriteWithIoutil(runpath+&quot;/&quot;+name, content)        time.Sleep(1000) //设置延时    &#125;&#125;</code></pre><h2 id="conf-ini-配置文件"><a href="#conf-ini-配置文件" class="headerlink" title="conf.ini 配置文件"></a><a href="https://blog.csdn.net/yang731227/article/details/103098189"></a>conf.ini 配置文件</h2><pre><code>[csdn]blogurl = https://blog.csdn.net/yang731227  ;博客地址totalpage = 7   ;博客文章列表数cookie =     ;爬取账号的cookie</code></pre><h1 id="导出效果"><a href="#导出效果" class="headerlink" title="导出效果"></a><a href="https://blog.csdn.net/yang731227/article/details/103098189"></a>导出效果</h1><p><img src="https://img-blog.csdnimg.cn/20191116153807586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmc3MzEyMjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a><a href="https://blog.csdn.net/yang731227/article/details/103098189"></a>下载</h1><p>土豪通道：</p><ul><li>  win: <a href="https://download.csdn.net/download/yang731227/12157060">https://download.csdn.net/download/yang731227/12157060</a></li><li>  mac :<a href="https://download.csdn.net/download/yang731227/12154880">https://download.csdn.net/download/yang731227/12154880</a></li></ul><p>或者直接到github上面下载：<br><a href="https://github.com/Clown95/CSDN-Blog-Export">https://github.com/Clown95/CSDN-Blog-Export</a></p><p>如果你觉得对你有帮助给个star呗</p><p>本文转自 <a href="https://blog.csdn.net/yang731227/article/details/103098189">https://blog.csdn.net/yang731227/article/details/103098189</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn.net/yang731227/article/details/103098189&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Go爬虫" scheme="https://ysluckly.github.io/tags/Go%E7%88%AC%E8%99%AB/"/>
    
    <category term="goquery" scheme="https://ysluckly.github.io/tags/goquery/"/>
    
  </entry>
  
  <entry>
    <title>Go全栈面试题（2）-Go进阶面试题</title>
    <link href="https://ysluckly.github.io/2022/01/07/golang/"/>
    <id>https://ysluckly.github.io/2022/01/07/golang/</id>
    <published>2022-01-07T07:29:32.000Z</published>
    <updated>2022-02-26T05:56:51.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang进阶面试题"><a href="#Golang进阶面试题" class="headerlink" title="Golang进阶面试题"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>Golang进阶面试题</h1><h2 id="Go的堆栈使用"><a href="#Go的堆栈使用" class="headerlink" title="Go的堆栈使用"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>Go的堆栈使用</h2><ul><li>  每个goroutine维护着一个栈空间，默认最大为4KB.</li><li>  当goroutine的栈空间不足时，golang会调用<code>runtime.morestack</code>(汇编实现：asm_xxx.s)来进行动态扩容.</li><li>  连续栈：当栈空间不足的时候申请一个2倍于当前大小的新栈，并把所有数据拷贝到新栈， 接下来的所有调用执行都发生在新栈上.</li><li>  每个function维护着各自的栈帧(stack frame)，当function退出时会释放栈帧.</li></ul><h2 id="Go运行时内存分配的策略"><a href="#Go运行时内存分配的策略" class="headerlink" title="Go运行时内存分配的策略"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>Go运行时内存分配的策略</h2><p>对于小对象（&lt;=32kb），go runtime首先从,Cache开始，然后是Cental，最后Heap。<br>对于大对象（&gt;32KB），直接从堆中获取。<br><img src="https://www.github.com/Clown95/StroyBack/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1557990499640.png"></p><ul><li>  heap: 全局根对象。负责向操作系统申请内存,管理由垃圾回收器收回的空闲 span 内存块。</li><li>  central: 从 heap 获取空闲 span,并按需要将其切分成 object 块。heap 管理着多个central 对象,每个 central 负责处理一一种等级的内存分配需求。</li><li>  cache: 运行行期,每个 cache 都与某个具体线程相绑定,实现无无锁内存分配操作。其内部有个以等级为序号的数组,持有多个切分好的 span 对象。缺少空间时,向等级对应的 central 获取新的 span 即可。</li></ul><h2 id="运行时何时从堆中分配内存，何时从堆栈中分配内存？"><a href="#运行时何时从堆中分配内存，何时从堆栈中分配内存？" class="headerlink" title="运行时何时从堆中分配内存，何时从堆栈中分配内存？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>运行时何时从堆中分配内存，何时从堆栈中分配内存？</h2><ul><li>  对于生命周期仅在堆栈帧内的小对象，将分配栈内存。</li><li>  对于将通过堆栈帧传递的小对象，堆内存。</li><li>  对于大对象（&gt;32KB），堆内存。</li><li>  对于可以转义到堆但实际上是内联的小对象，栈内存。</li></ul><h2 id="Go运行时是否维护Map元素的遍历顺序？"><a href="#Go运行时是否维护Map元素的遍历顺序？" class="headerlink" title="Go运行时是否维护Map元素的遍历顺序？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>Go运行时是否维护Map元素的遍历顺序？</h2><p>不维护，Go白皮书明确提到映射元素的迭代顺序是未定义的。 所以对于同一个映射值，它的一个遍历过程和下一个遍历过程中的元素呈现次序不保证是相同的。 对于标准编译器，映射元素的遍历顺序是随机的。 如果你需要固定的映射元素遍历顺序，那么你就需要自己来维护这个顺序。</p><blockquote><p>但是请注意：从Go 1.12开始，标准库包中的各个打印函数的结果中，映射条目总是排了序的。</p></blockquote><h2 id="函数返回局部变量的指针是否安全？"><a href="#函数返回局部变量的指针是否安全？" class="headerlink" title="函数返回局部变量的指针是否安全？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>函数返回局部变量的指针是否安全？</h2><p>是的，在Go中这是绝对安全的。支持栈的Go编译器将会对每个局部变量进行逃逸分析。 如果编译器发现某个局部变量开辟在栈上不是绝对安全的，则此局部变量将被开辟在堆上。</p><h2 id="goroutine是怎么样调度的？"><a href="#goroutine是怎么样调度的？" class="headerlink" title="goroutine是怎么样调度的？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>goroutine是怎么样调度的？</h2><p>Golang中调度器的主要有4个重要部分，分别是G、P、M、Sched：</p><ul><li>  G (goroutine) G代表一个goroutine对象，每次go调用的时候，都会创建一个G对象,包括了调用栈，重要的调度信息，例如channel等。</li><li>  P (processor) 衔接M和G的调度上下文，它负责将等待执行的G与M对接。P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行。</li><li>  M (work thread) 代表一个线程，每次创建一个M的时候，都会有一个底层线程创建；所有的G任务，最终还是在M上执行</li><li>Sched是调度实现中使用的数据结构,大多数需要的信息都已放在了结构体M、G和P中，Sched结构体只是一个壳。Sched结构体中的Lock是非常必须的，如果M或P等做一些非局部的操作，它们一般需要先锁住调度器。<br>  每次go调用的时候，都会：</li></ul><ol><li> 创建一个G对象，加入到本地队列或者全局队列</li><li> 如果还有空闲的P，则创建一个M</li><li> M会启动一个底层线程，循环执行能找到的G任务</li><li> G任务的执行顺序是，先从本地队列找，本地没有则从全局队列找（一次性转移(全局G个数/P个数）个，再去其它P中找（一次性转移一半），</li><li> 以上的G任务执行是按照队列顺序（也就是go调用的顺序）执行的。</li></ol><p>G是顺序执行的是不是有点奇怪，跟我们实际了解到情况不一样。原因是，启动的时候，会专门创建一个线程sysmon，用来监控和管理，在内部是一个循环：</p><ol><li> 记录所有P的G任务计数schedtick，（schedtick会在每执行一个G任务后递增）</li><li> 如果检查到 schedtick一直没有递增，说明这个P一直在执行同一个G任务，如果超过一定的时间（10ms），就在这个G任务的栈信息里面加一个标记。</li><li> 然后这个G任务在执行的时候，如果遇到非内联函数调用，就会检查一次这个标记，然后中断自己，把自己加到队列末尾，执行下一个G 。</li><li> 如果没有遇到非内联函数（有时候正常的小函数会被优化成内联函数）调用的话，那就惨了，会一直执行这个G任务，直到它自己结束；</li></ol><h2 id="如何等待所有goroutine的退出？"><a href="#如何等待所有goroutine的退出？" class="headerlink" title="如何等待所有goroutine的退出？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>如何等待所有goroutine的退出？</h2><p>Go中的goroutines和channel提供了一种优雅而独特的结构化并发软件的方法，我们可以利用通道(channel)的特性，来实现当前等待goroutine的操作。但是channel并不是当前这个场景的最佳方案，用它来实现的方式是稍显笨拙的，需要知道确定个数的goroutine，同时稍不注意就极易产生死锁,但事实上比较优雅的方式是使用go标准库sync，其中提供了专门的解决方案sync.WaitGroup用于等待一个goroutines集合的结束。</p><h2 id="怎么限制Goroutine的数量"><a href="#怎么限制Goroutine的数量" class="headerlink" title="怎么限制Goroutine的数量?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>怎么限制Goroutine的数量?</h2><p>在Golang中，Goroutine虽然很好，但是数量太多了，往往会带来很多麻烦，比如耗尽系统资源导致程序崩溃，或者CPU使用率过高导致系统忙不过来。所以我们可以限制下Goroutine的数量,这样就需要在每一次执行go之前判断goroutine的数量，如果数量超了，就要阻塞go的执行。第一时间想到的就是使用通道。每次执行的go之前向通道写入值，直到通道满的时候就阻塞了，</p><pre><code>package mainimport &quot;fmt&quot;var ch chan  intfunc elegance()&#123;    &lt;-ch    fmt.Println(&quot;the ch value receive&quot;,ch)&#125;func main()&#123;    ch = make(chan int,5)    for i:=0;i&lt;10;i++&#123;        ch &lt;-1        fmt.Println(&quot;the ch value send&quot;,ch)        go elegance()        fmt.Println(&quot;the result i&quot;,i)    &#125;&#125;</code></pre><p>运行:</p><pre><code>&gt; go run goroutine.go the ch value send 0xc00009c000the result i 0the ch value send 0xc00009c000the result i 1the ch value send 0xc00009c000the result i 2the ch value send 0xc00009c000the result i 3the ch value send 0xc00009c000the result i 4the ch value send 0xc00009c000the result i 5the ch value send 0xc00009c000the ch value receive 0xc00009c000the result i 6the ch value receive 0xc00009c000the ch value send 0xc00009c000the result i 7the ch value send 0xc00009c000the result i 8the ch value send 0xc00009c000the result i 9the ch value send 0xc00009c000the ch value receive 0xc00009c000the ch value receive 0xc00009c000the ch value receive 0xc00009c000the result i 10the ch value send 0xc00009c000the result i 11the ch value send 0xc00009c000the result i 12the ch value send 0xc00009c000the result i 13the ch value send 0xc00009c000the ch value receive 0xc00009c000the ch value receive 0xc00009c000the ch value receive 0xc00009c000the ch value receive 0xc00009c000the result i 14the ch value receive 0xc00009c000</code></pre><pre><code>&gt; go run goroutine.go the ch value send 0xc00007e000the result i 0the ch value send 0xc00007e000the result i 1the ch value send 0xc00007e000the result i 2the ch value send 0xc00007e000the result i 3the ch value send 0xc00007e000the ch value receive 0xc00007e000the result i 4the ch value send 0xc00007e000the ch value receive 0xc00007e000the result i 5the ch value send 0xc00007e000the ch value receive 0xc00007e000the result i 6the ch value send 0xc00007e000the result i 7the ch value send 0xc00007e000the ch value receive 0xc00007e000the ch value receive 0xc00007e000the ch value receive 0xc00007e000the result i 8the ch value send 0xc00007e000the result i 9</code></pre><p>这样每次同时运行的goroutine就被限制为5个了。但是新的问题于是就出现了，因为并不是所有的goroutine都执行完了，在main函数退出之后，还有一些goroutine没有执行完就被强制结束了。这个时候我们就需要用到sync.WaitGroup。使用WaitGroup等待所有的goroutine退出。</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;runtime&quot;    &quot;sync&quot;    &quot;time&quot;)// Pool Goroutine Pooltype Pool struct &#123;    queue chan int    wg *sync.WaitGroup&#125;// New 新建一个协程池func NewPool(size int) *Pool&#123;    if size &lt;=0&#123;        size = 1    &#125;    return &amp;Pool&#123;        queue:make(chan int,size),        wg:&amp;sync.WaitGroup&#123;&#125;,    &#125;&#125;// Add 新增一个执行func (p *Pool)Add(delta int)&#123;    // delta为正数就添加    for i :=0;i&lt;delta;i++&#123;        p.queue &lt;-1    &#125;    // delta为负数就减少    for i:=0;i&gt;delta;i--&#123;        &lt;-p.queue    &#125;    p.wg.Add(delta)&#125;// Done 执行完成减一func (p *Pool) Done()&#123;    &lt;-p.queue    p.wg.Done()&#125;// Wait 等待Goroutine执行完毕func (p *Pool) Wait()&#123;    p.wg.Wait()&#125;func main()&#123;    // 这里限制5个并发    pool := NewPool(5)    fmt.Println(&quot;the NumGoroutine begin is:&quot;,runtime.NumGoroutine())    for i:=0;i&lt;20;i++&#123;        pool.Add(1)        go func(i int) &#123;            time.Sleep(time.Second)            fmt.Println(&quot;the NumGoroutine continue is:&quot;,runtime.NumGoroutine())            pool.Done()        &#125;(i)    &#125;    pool.Wait()    fmt.Println(&quot;the NumGoroutine done is:&quot;,runtime.NumGoroutine())&#125;</code></pre><p>运行:</p><pre><code>the NumGoroutine begin is: 1the NumGoroutine continue is: 6the NumGoroutine continue is: 7the NumGoroutine continue is: 6the NumGoroutine continue is: 6the NumGoroutine continue is: 6the NumGoroutine continue is: 6the NumGoroutine continue is: 6the NumGoroutine continue is: 6the NumGoroutine continue is: 6the NumGoroutine continue is: 6the NumGoroutine continue is: 6the NumGoroutine continue is: 6the NumGoroutine continue is: 6the NumGoroutine continue is: 6the NumGoroutine continue is: 6the NumGoroutine continue is: 6the NumGoroutine continue is: 6the NumGoroutine continue is: 6the NumGoroutine continue is: 3the NumGoroutine continue is: 2the NumGoroutine done is: 1</code></pre><p>其中，Go的GOMAXPROCS默认值已经设置为CPU的核数， 这里允许我们的Go程序充分使用机器的每一个CPU,最大程度的提高我们程序的并发性能。runtime.NumGoroutine函数在被调用后，会返回系统中的处于特定状态的Goroutine的数量。这里的特指是指Grunnable\Gruning\Gsyscall\Gwaition。处于这些状态的Groutine即被看做是活跃的或者说正在被调度。</p><p>这里需要注意下：垃圾回收所在Groutine的状态也处于这个范围内的话，也会被纳入该计数器。</p><h2 id="Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？"><a href="#Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？" class="headerlink" title="Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？</h2><p>Golang中Goroutine 可以通过 Channel 进行安全读写共享变量。</p><h2 id="Golang-中常用的并发模型？"><a href="#Golang-中常用的并发模型？" class="headerlink" title="Golang 中常用的并发模型？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>Golang 中常用的并发模型？</h2><p>Golang 中常用的并发模型有三种:</p><ul><li>  通过channel通知实现并发控制</li></ul><p>无缓冲的通道指的是通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送 goroutine 和接收 goroutine 同时准备好，才可以完成发送和接收操作。</p><p>从上面无缓冲的通道定义来看，发送 goroutine 和接收 gouroutine 必须是同步的，同时准备后，如果没有同时准备好的话，先执行的操作就会阻塞等待，直到另一个相对应的操作准备好为止。这种无缓冲的通道我们也称之为同步通道。</p><pre><code>func main() &#123;    ch := make(chan struct&#123;&#125;)    go func() &#123;        fmt.Println(&quot;start working&quot;)        time.Sleep(time.Second * 1)        ch &lt;- struct&#123;&#125;&#123;&#125;    &#125;()    &lt;-ch    fmt.Println(&quot;finished&quot;)&#125;</code></pre><p>当主 goroutine 运行到 &lt;-ch 接受 channel 的值的时候，如果该 channel 中没有数据，就会一直阻塞等待，直到有值。 这样就可以简单实现并发控制</p><ul><li>  通过sync包中的WaitGroup实现并发控制</li></ul><p>Goroutine是异步执行的，有的时候为了防止在结束mian函数的时候结束掉Goroutine，所以需要同步等待，这个时候就需要用 WaitGroup了，在 sync 包中，提供了 WaitGroup ，它会等待它收集的所有 goroutine 任务全部完成。在WaitGroup里主要有三个方法:</p><ul><li>  Add, 可以添加或减少 goroutine的数量.</li><li>  Done, 相当于Add(-1).</li><li>  Wait, 执行后会堵塞主线程，直到WaitGroup 里的值减至0.</li></ul><p>在主 goroutine 中 Add(delta int) 索要等待goroutine 的数量。<br>在每一个 goroutine 完成后 Done() 表示这一个goroutine 已经完成，当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回返回。</p><pre><code>func main()&#123;    var wg sync.WaitGroup    var urls = []string&#123;        &quot;http://www.golang.org/&quot;,        &quot;http://www.google.com/&quot;,    &#125;    for _, url := range urls &#123;        wg.Add(1)        go func(url string) &#123;            defer wg.Done()            http.Get(url)        &#125;(url)    &#125;    wg.Wait()&#125;</code></pre><p>在Golang官网中对于WaitGroup介绍是<code>A WaitGroup must not be copied after first use</code>,在 WaitGroup 第一次使用后，不能被拷贝</p><p>应用示例:</p><pre><code>func main()&#123; wg := sync.WaitGroup&#123;&#125;    for i := 0; i &lt; 5; i++ &#123;        wg.Add(1)        go func(wg sync.WaitGroup, i int) &#123;            fmt.Printf(&quot;i:%d&quot;, i)            wg.Done()        &#125;(wg, i)    &#125;    wg.Wait()    fmt.Println(&quot;exit&quot;)&#125;</code></pre><p>运行:</p><pre><code>i:1i:3i:2i:0i:4fatal error: all goroutines are asleep - deadlock!goroutine 1 [semacquire]:sync.runtime_Semacquire(0xc000094018)        /home/keke/soft/go/src/runtime/sema.go:56 +0x39sync.(*WaitGroup).Wait(0xc000094010)        /home/keke/soft/go/src/sync/waitgroup.go:130 +0x64main.main()        /home/keke/go/Test/wait.go:17 +0xabexit status 2</code></pre><p>它提示所有的 goroutine 都已经睡眠了，出现了死锁。这是因为 wg 给拷贝传递到了 goroutine 中，导致只有 Add 操作，其实 Done操作是在 wg 的副本执行的。</p><p>因此 Wait 就死锁了。</p><p>这个第一个修改方式:将匿名函数中 wg 的传入类型改为 *sync.WaitGrou,这样就能引用到正确的WaitGroup了。<br>这个第二个修改方式:将匿名函数中的 wg 的传入参数去掉，因为Go支持闭包类型，在匿名函数中可以直接使用外面的 wg 变量</p><ul><li>  在Go 1.7 以后引进的强大的Context上下文，实现并发控制</li></ul><p>通常,在一些简单场景下使用 channel 和 WaitGroup 已经足够了，但是当面临一些复杂多变的网络并发场景下 channel 和 WaitGroup 显得有些力不从心了。<br>比如一个网络请求 Request，每个 Request 都需要开启一个 goroutine 做一些事情，这些 goroutine 又可能会开启其他的 goroutine，比如数据库和RPC服务。<br>所以我们需要一种可以跟踪 goroutine 的方案，才可以达到控制他们的目的，这就是Golang为我们提供的 Context，称之为上下文非常贴切，它就是goroutine 的上下文。<br>它是包括一个程序的运行环境、现场和快照等。每个程序要运行时，都需要知道当前程序的运行状态，通常Go 将这些封装在一个 Context 里，再将它传给要执行的 goroutine 。</p><p>context 包主要是用来处理多个 goroutine 之间共享数据，及多个 goroutine 的管理。</p><p>context 包的核心是 struct Context，接口声明如下：</p><pre><code>// A Context carries a deadline, cancelation signal, and request-scoped values// across API boundaries. Its methods are safe for simultaneous use by multiple// goroutines.type Context interface &#123;    // Done returns a channel that is closed when this `Context` is canceled    // or times out.    Done() &lt;-chan struct&#123;&#125;    // Err indicates why this Context was canceled, after the Done channel    // is closed.    Err() error    // Deadline returns the time when this Context will be canceled, if any.    Deadline() (deadline time.Time, ok bool)    // Value returns the value associated with key or nil if none.    Value(key interface&#123;&#125;) interface&#123;&#125;&#125;</code></pre><p>Done() 返回一个只能接受数据的channel类型，当该context关闭或者超时时间到了的时候，该channel就会有一个取消信号</p><p>Err() 在Done() 之后，返回context 取消的原因。</p><p>Deadline() 设置该context cancel的时间点</p><p>Value() 方法允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。</p><p>Context 对象是线程安全的，你可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。</p><p>一个 Context 不能拥有 Cancel 方法，同时我们也只能 Done channel 接收数据。<br>其中的原因是一致的：接收取消信号的函数和发送信号的函数通常不是一个。<br>典型的场景是：父操作为子操作操作启动 goroutine，子操作也就不能取消父操作。</p><h2 id="Goroutine和Channel的作用分别是什么"><a href="#Goroutine和Channel的作用分别是什么" class="headerlink" title="Goroutine和Channel的作用分别是什么?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>Goroutine和Channel的作用分别是什么?</h2><p>进程是内存资源管理和cpu调度的执行单元。为了有效利用多核处理器的优势，将进程进一步细分，允许一个进程里存在多个线程，这多个线程还是共享同一片内存空间，但cpu调度的最小单元变成了线程。</p><p>那协程又是什么呢，以及与线程的差异性??</p><p>协程，可以看作是轻量级的线程。但与线程不同的是，线程的切换是由操作系统控制的，而协程的切换则是由用户控制的。</p><p>最早支持协程的程序语言应该是lisp方言scheme里的continuation（续延），续延允许scheme保存任意函数调用的现场，保存起来并重新执行。Lua,C#,python等语言也有自己的协程实现。</p><p>Go中的goroutinue就是协程,可以实现并行，多个协程可以在多个处理器同时跑。而协程同一时刻只能在一个处理器上跑（可以把宿主语言想象成单线程的就好了）。<br>然而,多个goroutine之间的通信是通过channel，而协程的通信是通过yield和resume()操作。</p><p>goroutine非常简单，只需要在函数的调用前面加关键字go即可，例如:</p><pre><code>go elegance()</code></pre><p>我们也可以启动5个goroutines分别打印索引。</p><pre><code>func main() &#123;    for i:=1;i&lt;5;i++ &#123;        go func(i int) &#123;            fmt.Println(i)        &#125;(i)    &#125;    // 停歇5s，保证打印全部结束    time.Sleep(5*time.Second)&#125;</code></pre><p>在分析goroutine执行的随机性和并发性，启动了5个goroutine，再加上main函数的主goroutine，总共有6个goroutines。由于goroutine类似于”守护线程“，异步执行的,如果主goroutine不等待片刻，可能程序就没有输出打印了。</p><p>在Golang中channel则是goroutinues之间进行通信的渠道。</p><p>可以把channel形象比喻为工厂里的传送带,一头的生产者goroutine往传输带放东西,另一头的消费者goroutinue则从输送带取东西。channel实际上是一个有类型的消息队列,遵循先进先出的特点。</p><ol><li> channel的操作符号</li></ol><p>ch &lt;- data 表示data被发送给channel ch；</p><p>data &lt;- ch 表示从channel ch取一个值，然后赋给data。</p><ol start="2"><li> 阻塞式channel</li></ol><p>channel默认是没有缓冲区的，也就是说，通信是阻塞的。send操作必须等到有消费者accept才算完成。</p><p>应用示例:</p><pre><code>func main() &#123;    ch1 := make(chan int)    go pump(ch1) // pump hangs    fmt.Println(&lt;-ch1) // prints only 1&#125;func pump(ch chan int) &#123;    for i:= 1; ; i++ &#123;        ch &lt;- i    &#125;&#125;</code></pre><p>在函数pump()里的channel在接受到第一个元素后就被阻塞了，直到主goroutinue取走了数据。最终channel阻塞在接受第二个元素，程序只打印 1。</p><p>没有缓冲(buffer)的channel只能容纳一个元素，而带有缓冲(buffer)channel则可以非阻塞容纳N个元素。发送数据到缓冲(buffer) channel不会被阻塞，除非channel已满；同样的，从缓冲(buffer) channel取数据也不会被阻塞，除非channel空了。</p><h2 id="怎么查看Goroutine的数量"><a href="#怎么查看Goroutine的数量" class="headerlink" title="怎么查看Goroutine的数量?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>怎么查看Goroutine的数量?</h2><p>在Golang中,GOMAXPROCS中控制的是未被阻塞的所有Goroutine,可以被Multiplex到多少个线程上运行,通过GOMAXPROCS可以查看Goroutine的数量。</p><h2 id="如何测试代码是否有goroutine泄漏的"><a href="#如何测试代码是否有goroutine泄漏的" class="headerlink" title="如何测试代码是否有goroutine泄漏的?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>如何测试代码是否有goroutine泄漏的?</h2><p>使用runtime.Stack在测试代码运行前后计算goroutine数量，当然我理解测试代码运行完成之后是会触发gc的。如果触发gc之后，发现还有goroutine没有被回收，那么这个goroutine很有可能是被泄漏的。</p><pre><code>堆栈将调用goroutine的堆栈跟踪格式化为buf 并返回写入buf的字节数。如果全部为真，则在当前goroutine的跟踪之后，Stack格式化所有其他goroutine的跟踪到buf中。func Stack(buf []byte, all bool) int &#123;    if all &#123;        stopTheWorld(&quot;stack trace&quot;)    &#125;    n := 0    if len(buf) &gt; 0 &#123;        gp := getg()        sp := getcallersp()        pc := getcallerpc()        systemstack(func() &#123;            g0 := getg()            // Force traceback=1 to override GOTRACEBACK setting,            // so that Stack&#39;s results are consistent.            // GOTRACEBACK is only about crash dumps.            g0.m.traceback = 1            g0.writebuf = buf[0:0:len(buf)]            goroutineheader(gp)            traceback(pc, sp, 0, gp)            if all &#123;                tracebackothers(gp)            &#125;            g0.m.traceback = 0            n = len(g0.writebuf)            g0.writebuf = nil        &#125;)    &#125;    if all &#123;        startTheWorld()    &#125;    return n&#125;</code></pre><h2 id="如何使map能够安全的并发？"><a href="#如何使map能够安全的并发？" class="headerlink" title="如何使map能够安全的并发？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>如何使map能够安全的并发？</h2><p>map并发读写是不安全的。map属于引用类型，并发读写时多个协程见是通过指针访问同一个地址，即访问共享变量，此时同时读写资源存在竞争关系。利用读写锁可实现对map的安全访问。</p><h2 id="实现阻塞读且并发安全的map"><a href="#实现阻塞读且并发安全的map" class="headerlink" title="实现阻塞读且并发安全的map"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>实现阻塞读且并发安全的map</h2><p>GO里面MAP如何实现key不存在 get操作等待 直到key存在或者超时，保证并发安全，且需要实现以下接口：</p><pre><code>type sp interface &#123;    Out(key string, val interface&#123;&#125;)  //存入key /val，如果该key读取的goroutine挂起，则唤醒。此方法不会阻塞，时刻都可以立即执行并返回    Rd(key string, timeout time.Duration) interface&#123;&#125;  //读取一个key，如果key不存在阻塞，等待key存在或者超时&#125;</code></pre><p>解析：</p><p>看到阻塞协程第一个想到的就是channel，题目中要求并发安全，那么必须用锁，还要实现多个goroutine读的时候如果值不存在则阻塞，直到写入值，那么每个键值需要有一个阻塞goroutine 的 channel。</p><p>实现如下：</p><pre><code>type Map struct &#123;    c   map[string]*entry    rmx *sync.RWMutex&#125;type entry struct &#123;    ch      chan struct&#123;&#125;    value   interface&#123;&#125;    isExist bool&#125;func (m *Map) Out(key string, val interface&#123;&#125;) &#123;    m.rmx.Lock()    defer m.rmx.Unlock()    if e, ok := m.c[key]; ok &#123;        e.value = val        e.isExist = true        close(e.ch)    &#125; else &#123;        e = &amp;entry&#123;ch: make(chan struct&#123;&#125;), isExist: true,value:val&#125;        m.c[key] = e        close(e.ch)    &#125;&#125;func (m *Map) Rd(key string, timeout time.Duration) interface&#123;&#125; &#123;    m.rmx.Lock()    if e, ok := m.c[key]; ok &amp;&amp; e.isExist &#123;        m.rmx.Unlock()        return e.value    &#125; else if !ok &#123;        e = &amp;entry&#123;ch: make(chan struct&#123;&#125;), isExist: false&#125;        m.c[key] = e        m.rmx.Unlock()        fmt.Println(&quot;协程阻塞 -&gt; &quot;, key)        select &#123;        case &lt;-e.ch:            return e.value        case &lt;-time.After(timeout):            fmt.Println(&quot;协程超时 -&gt; &quot;, key)            return nil        &#125;    &#125; else &#123;        m.rmx.Unlock()        fmt.Println(&quot;协程阻塞 -&gt; &quot;, key)        select &#123;        case &lt;-e.ch:            return e.value        case &lt;-time.After(timeout):            fmt.Println(&quot;协程超时 -&gt; &quot;, key)            return nil        &#125;    &#125;&#125;</code></pre><h2 id="主协程如何等其余协程完再操作"><a href="#主协程如何等其余协程完再操作" class="headerlink" title="主协程如何等其余协程完再操作?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>主协程如何等其余协程完再操作?</h2><ul><li><p>  使用管道实现同步，协程结束后发送信号给主协程。</p></li><li><p>  最理想的方案是使用<code>sync.WaitGroup</code>,WaitGroup内部实现了一个计数器，用来记录未完成的操作个数，它提供了三个方法，Add()用来添加计数。Done()用来在操作结束时调用，使计数减一。Wait()用来等待所有的操作结束，即计数变为0，该函数会在计数不为0时等待，在计数为0时立即返回。</p></li><li><p>  <a href="https://blog.csdn.net/u011304970/article/details/72722044">Go并发：利用sync.WaitGroup实现协程同步</a></p></li></ul><h2 id="简述go语言的CSP并发模型"><a href="#简述go语言的CSP并发模型" class="headerlink" title="简述go语言的CSP并发模型"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>简述go语言的CSP并发模型</h2><p>Actor模型是多线程通过共享内存来通信，它是”通过内存共享来进行通讯”，CSP不同于Actor模型，它讲究的是“以通信的方式来共享内存”。GSP用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。<br>Golang中使用 CSP中 channel 这个概念。channel 是被单独创建并且可以在进程之间传递，它的通信模式类似于 boss-worker 模式的，一个实体通过将消息发送到channel 中，然后又监听这个 channel 的实体处理，两个实体之间是匿名的，这个就实现实体中间的解耦，其中 channel 是同步的一个消息被发送到 channel 中，最终是一定要被另外的实体消费掉的，在实现原理上其实是一个阻塞的消息队列。<br>Golang的CSP并发模型，是通过Goroutine和Channel来实现的。Goroutine 是Golang中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。 Channel是Golang中各个并发结构体(Goroutine)之前的通信机制。通常Channel，是各个Goroutine之间通信的”管道“，有点类似于Linux中的管道。<br>通信机制channel也很方便，传数据用channel &lt;- data，取数据用&lt;-channel。<br>在通信过程中，传数据channel &lt;- data和取数据&lt;-channel必然会成对出现，因为这边传，那边取，两个goroutine之间才会实现通信。<br>而且不管传还是取，必阻塞，直到另外的goroutine传或者取为止。</p><h2 id="context包的用途是什么"><a href="#context包的用途是什么" class="headerlink" title="context包的用途是什么?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>context包的用途是什么?</h2><p>context包的主要用途是用于控制并发，可以有效的避免goroutine泄露。在实际的业务种，我们可能会有这么一种场景：需要我们主动的通知某一个goroutine结束。比如我们开启一个后台goroutine一直做事情，比如监控，现在不需要了，就需要通知这个监控goroutine结束，不然它会一直跑，就泄漏了。所以我们需要一种可以跟踪goroutine的方案，才可以达到控制他们的目的，这就是Golang为我们提供的Context，称之为上下文非常贴切，它就是goroutine的上下文。</p><h2 id="Context-使用原则"><a href="#Context-使用原则" class="headerlink" title="Context 使用原则"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>Context 使用原则</h2><ul><li>  不要把 Context 放在结构体中，要以参数的方式传递</li><li>  以 Context 作为参数的函数方法，应该把 Context 作为第一个参数，放在第一位。</li><li>  给一个函数方法传递 Context 的时候，不要传递 nil，如果不知道传递什么，就使用 context.TODO</li><li>  Context 的 Value 相关方法应该传递必须的数据，不要什么数据都使用这个传递</li><li>  Context 是线程安全的，可以放心的在多个 goroutine 中传递</li></ul><h2 id="互斥锁，读写锁，死锁问题是怎么解决。"><a href="#互斥锁，读写锁，死锁问题是怎么解决。" class="headerlink" title="互斥锁，读写锁，死锁问题是怎么解决。"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>互斥锁，读写锁，死锁问题是怎么解决。</h2><ul><li>  互斥锁</li></ul><p>互斥锁就是互斥变量mutex，用来锁住临界区的.</p><p>条件锁就是条件变量，当进程的某些资源要求不满足时就进入休眠，也就是锁住了。当资源被分配到了，条件锁打开，进程继续运行；读写锁，也类似，用于缓冲区等临界资源能互斥访问的。</p><ul><li>  读写锁</li></ul><p>通常有些公共数据修改的机会很少，但其读的机会很多。并且在读的过程中会伴随着查找，给这种代码加锁会降低我们的程序效率。读写锁可以解决这个问题。<br><img src="https://www.github.com/Clown95/StroyBack/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1557903367889.png"><br>注意：写独占，读共享，写锁优先级高</p><ul><li>  死锁</li></ul><p>一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）。<br>另外一种情况是：若线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。</p><p>死锁产生的四个必要条件:</p><ol><li> 互斥条件：一个资源每次只能被一个进程使用</li><li> 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li> 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。<br> 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</li></ol><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>预防死锁</h3><p>可以把资源一次性分配：（破坏请求和保持条件）</p><p>然后剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）</p><p>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>避免死锁</h3><p>预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。</p><h3 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>检测死锁</h3><p>首先为每个进程和每个资源指定一个唯一的号码,然后建立资源分配表和进程等待表.</p><h3 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>解除死锁</h3><p>当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有.</p><ul><li>剥夺资源<br>  从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态.</li><li>撤消进程<br>  可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止.所谓代价是指优先级、运行代价、进程的重要性和价值等。</li></ul><h2 id="说下Go中的锁有哪些"><a href="#说下Go中的锁有哪些" class="headerlink" title="说下Go中的锁有哪些?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>说下Go中的锁有哪些?</h2><p>Go中的三种锁包括:互斥锁,读写锁,sync.Map的安全的锁.</p><ul><li>  互斥锁</li></ul><p>Go并发程序对共享资源进行访问控制的主要手段，由标准库代码包中sync中的Mutex结构体表示。</p><pre><code>//Mutex 是互斥锁， 零值是解锁的互斥锁， 首次使用后不得复制互斥锁。type Mutex struct &#123;   state int32   sema  uint32&#125;</code></pre><p>sync.Mutex包中的类型只有两个公开的指针方法Lock和Unlock。</p><pre><code>//Locker表示可以锁定和解锁的对象。type Locker interface &#123;   Lock()   Unlock()&#125;//锁定当前的互斥量//如果锁已被使用，则调用goroutine//阻塞直到互斥锁可用。func (m *Mutex) Lock() //对当前互斥量进行解锁//如果在进入解锁时未锁定m，则为运行时错误。//锁定的互斥锁与特定的goroutine无关。//允许一个goroutine锁定Mutex然后安排另一个goroutine来解锁它。func (m *Mutex) Unlock()</code></pre><p>声明一个互斥锁：</p><pre><code>var mutex sync.Mutex</code></pre><p>不像C或Java的锁类工具，我们可能会犯一个错误：忘记及时解开已被锁住的锁，从而导致流程异常。但Go由于存在defer，所以此类问题出现的概率极低。关于defer解锁的方式如下：</p><pre><code>var mutex sync.Mutexfunc Write()  &#123;   mutex.Lock()   defer mutex.Unlock()&#125;</code></pre><p>如果对一个已经上锁的对象再次上锁，那么就会导致该锁定操作被阻塞，直到该互斥锁回到被解锁状态.</p><pre><code>fpackage mainimport (    &quot;fmt&quot;    &quot;sync&quot;    &quot;time&quot;)func main() &#123;    var mutex sync.Mutex    fmt.Println(&quot;begin lock&quot;)    mutex.Lock()    fmt.Println(&quot;get locked&quot;)    for i := 1; i &lt;= 3; i++ &#123;        go func(i int) &#123;            fmt.Println(&quot;begin lock &quot;, i)            mutex.Lock()            fmt.Println(&quot;get locked &quot;, i)        &#125;(i)    &#125;    time.Sleep(time.Second)    fmt.Println(&quot;Unlock the lock&quot;)    mutex.Unlock()    fmt.Println(&quot;get unlocked&quot;)    time.Sleep(time.Second)&#125;</code></pre><p>我们在for循环之前开始加锁，然后在每一次循环中创建一个协程，并对其加锁，但是由于之前已经加锁了，所以这个for循环中的加锁会陷入阻塞直到main中的锁被解锁， time.Sleep(time.Second) 是为了能让系统有足够的时间运行for循环，输出结果如下：</p><pre><code>&gt; go run mutex.go begin lockget lockedbegin lock  3begin lock  1begin lock  2Unlock the lockget unlockedget locked  3</code></pre><p>这里可以看到解锁后，三个协程会重新抢夺互斥锁权，最终协程3获胜。</p><p>互斥锁锁定操作的逆操作并不会导致协程阻塞，但是有可能导致引发一个无法恢复的运行时的panic，比如对一个未锁定的互斥锁进行解锁时就会发生panic。避免这种情况的最有效方式就是使用defer。</p><p>我们知道如果遇到panic，可以使用recover方法进行恢复，但是如果对重复解锁互斥锁引发的panic却是无用的（Go 1.8及以后）。</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;sync&quot;)func main() &#123;    defer func() &#123;        fmt.Println(&quot;Try to recover the panic&quot;)        if p := recover(); p != nil &#123;            fmt.Println(&quot;recover the panic : &quot;, p)        &#125;    &#125;()    var mutex sync.Mutex    fmt.Println(&quot;begin lock&quot;)    mutex.Lock()    fmt.Println(&quot;get locked&quot;)    fmt.Println(&quot;unlock lock&quot;)    mutex.Unlock()    fmt.Println(&quot;lock is unlocked&quot;)    fmt.Println(&quot;unlock lock again&quot;)    mutex.Unlock()&#125;</code></pre><p>运行:</p><pre><code>&gt; go run mutex.go begin lockget lockedunlock locklock is unlockedunlock lock againfatal error: sync: unlock of unlocked mutexgoroutine 1 [running]:runtime.throw(0x4bc1a8, 0x1e)        /home/keke/soft/go/src/runtime/panic.go:617 +0x72 fp=0xc000084ea8 sp=0xc000084e78 pc=0x427ba2sync.throw(0x4bc1a8, 0x1e)        /home/keke/soft/go/src/runtime/panic.go:603 +0x35 fp=0xc000084ec8 sp=0xc000084ea8 pc=0x427b25sync.(*Mutex).Unlock(0xc00001a0c8)        /home/keke/soft/go/src/sync/mutex.go:184 +0xc1 fp=0xc000084ef0 sp=0xc000084ec8 pc=0x45f821main.main()        /home/keke/go/Test/mutex.go:25 +0x25f fp=0xc000084f98 sp=0xc000084ef0 pc=0x486c1fruntime.main()        /home/keke/soft/go/src/runtime/proc.go:200 +0x20c fp=0xc000084fe0 sp=0xc000084f98 pc=0x4294ecruntime.goexit()        /home/keke/soft/go/src/runtime/asm_amd64.s:1337 +0x1 fp=0xc000084fe8 sp=0xc000084fe0 pc=0x450ad1exit status 2</code></pre><p>这里试图对重复解锁引发的panic进行recover，但是我们发现操作失败，虽然互斥锁可以被多个协程共享，但还是建议将对同一个互斥锁的加锁解锁操作放在同一个层次的代码中。</p><ul><li>  读写锁</li></ul><p>读写锁是针对读写操作的互斥锁，可以分别针对读操作与写操作进行锁定和解锁操作 。</p><p>读写锁的访问控制规则如下：</p><p>① 多个写操作之间是互斥的<br>② 写操作与读操作之间也是互斥的<br>③ 多个读操作之间不是互斥的</p><p>在这样的控制规则下，读写锁可以大大降低性能损耗。</p><p>在Go的标准库代码包中sync中的RWMutex结构体表示为:</p><pre><code>// RWMutex是一个读/写互斥锁，可以由任意数量的读操作或单个写操作持有。// RWMutex的零值是未锁定的互斥锁。//首次使用后，不得复制RWMutex。//如果goroutine持有RWMutex进行读取而另一个goroutine可能会调用Lock，那么在释放初始读锁之前，goroutine不应该期望能够获取读锁定。 //特别是，这种禁止递归读锁定。 这是为了确保锁最终变得可用; 阻止的锁定会阻止新读操作获取锁定。type RWMutex struct &#123;   w           Mutex  //如果有待处理的写操作就持有   writerSem   uint32 // 写操作等待读操作完成的信号量   readerSem   uint32 //读操作等待写操作完成的信号量   readerCount int32  // 待处理的读操作数量   readerWait  int32  // number of departing readers&#125;</code></pre><p>sync中的RWMutex有以下几种方法：</p><pre><code>//对读操作的锁定func (rw *RWMutex) RLock()//对读操作的解锁func (rw *RWMutex) RUnlock()//对写操作的锁定func (rw *RWMutex) Lock()//对写操作的解锁func (rw *RWMutex) Unlock()//返回一个实现了sync.Locker接口类型的值，实际上是回调rw.RLock and rw.RUnlock.func (rw *RWMutex) RLocker() Locker</code></pre><p>Unlock方法会试图唤醒所有想进行读锁定而被阻塞的协程，而 RUnlock方法只会在已无任何读锁定的情况下，试图唤醒一个因欲进行写锁定而被阻塞的协程。若对一个未被写锁定的读写锁进行写解锁，就会引发一个不可恢复的panic，同理对一个未被读锁定的读写锁进行读写锁也会如此。</p><p>由于读写锁控制下的多个读操作之间不是互斥的，因此对于读解锁更容易被忽视。对于同一个读写锁，添加多少个读锁定，就必要有等量的读解锁，这样才能其他协程有机会进行操作。</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;sync&quot;    &quot;time&quot;)func main() &#123;    var rwm sync.RWMutex    for i := 0; i &lt; 5; i++ &#123;        go func(i int) &#123;            fmt.Println(&quot;try to lock read &quot;, i)            rwm.RLock()            fmt.Println(&quot;get locked &quot;, i)            time.Sleep(time.Second * 2)            fmt.Println(&quot;try to unlock for reading &quot;, i)            rwm.RUnlock()            fmt.Println(&quot;unlocked for reading &quot;, i)        &#125;(i)    &#125;    time.Sleep(time.Millisecond * 1000)    fmt.Println(&quot;try to lock for writing&quot;)    rwm.Lock()    fmt.Println(&quot;locked for writing&quot;)&#125;</code></pre><p>运行:</p><pre><code>&gt; go run rwmutex.go try to lock read  0get locked  0try to lock read  4get locked  4try to lock read  3get locked  3try to lock read  1get locked  1try to lock read  2get locked  2try to lock for writingtry to unlock for reading  0unlocked for reading  0try to unlock for reading  2unlocked for reading  2try to unlock for reading  1unlocked for reading  1try to unlock for reading  3unlocked for reading  3try to unlock for reading  4unlocked for reading  4locked for writing</code></pre><p>这里可以看到创建了五个协程用于对读写锁的读锁定与读解锁操作。在 rwm.Lock()种会对main中协程进行写锁定，但是for循环中的读解锁尚未完成，因此会造成mian中的协程阻塞。当for循环中的读解锁操作都完成后就会试图唤醒main中阻塞的协程，main中的写锁定才会完成。</p><ul><li>  sync.Map安全锁</li></ul><p>golang中的sync.Map是并发安全的，其实也就是sync包中golang自定义的一个名叫Map的结构体。</p><p>应用示例:</p><pre><code>package mainimport (    &quot;sync&quot;    &quot;fmt&quot;)func main() &#123;    //开箱即用    var sm sync.Map    //store 方法,添加元素    sm.Store(1,&quot;a&quot;)    //Load 方法，获得value    if v,ok:=sm.Load(1);ok&#123;        fmt.Println(v)    &#125;    //LoadOrStore方法，获取或者保存    //参数是一对key：value，如果该key存在且没有被标记删除则返回原先的value（不更新）和true；不存在则store，返回该value 和false    if vv,ok:=sm.LoadOrStore(1,&quot;c&quot;);ok&#123;        fmt.Println(vv)    &#125;    if vv,ok:=sm.LoadOrStore(2,&quot;c&quot;);!ok&#123;        fmt.Println(vv)    &#125;    //遍历该map，参数是个函数，该函数参的两个参数是遍历获得的key和value，返回一个bool值，当返回false时，遍历立刻结束。    sm.Range(func(k,v interface&#123;&#125;)bool&#123;        fmt.Print(k)        fmt.Print(&quot;:&quot;)        fmt.Print(v)        fmt.Println()        return true    &#125;)&#125;</code></pre><p>运行 :</p><pre><code>aac1:a2:c</code></pre><p>sync.Map的数据结构:</p><pre><code> type Map struct &#123;    // 该锁用来保护dirty    mu Mutex    // 存读的数据，因为是atomic.value类型，只读类型，所以它的读是并发安全的    read atomic.Value // readOnly    //包含最新的写入的数据，并且在写的时候，会把read 中未被删除的数据拷贝到该dirty中，因为是普通的map存在并发安全问题，需要用到上面的mu字段。    dirty map[interface&#123;&#125;]*entry    // 从read读数据的时候，会将该字段+1，当等于len（dirty）的时候，会将dirty拷贝到read中（从而提升读的性能）。    misses int&#125;</code></pre><p>read的数据结构是：</p><pre><code>type readOnly struct &#123;    m  map[interface&#123;&#125;]*entry    // 如果Map.dirty的数据和m 中的数据不一样是为true    amended bool &#125;</code></pre><p>entry的数据结构：</p><pre><code>type entry struct &#123;    //可见value是个指针类型，虽然read和dirty存在冗余情况（amended=false），但是由于是指针类型，存储的空间应该不是问题    p unsafe.Pointer // *interface&#123;&#125;&#125;</code></pre><p>Delete 方法:</p><pre><code>func (m *Map) Delete(key interface&#123;&#125;) &#123;    read, _ := m.read.Load().(readOnly)    e, ok := read.m[key]    //如果read中没有，并且dirty中有新元素，那么就去dirty中去找    if !ok &amp;&amp; read.amended &#123;        m.mu.Lock()        //这是双检查（上面的if判断和锁不是一个原子性操作）        read, _ = m.read.Load().(readOnly)        e, ok = read.m[key]        if !ok &amp;&amp; read.amended &#123;            //直接删除            delete(m.dirty, key)        &#125;        m.mu.Unlock()    &#125;    if ok &#123;    //如果read中存在该key，则将该value 赋值nil（采用标记的方式删除！）        e.delete()    &#125;&#125;func (e *entry) delete() (hadValue bool) &#123;    for &#123;        p := atomic.LoadPointer(&amp;e.p)        if p == nil || p == expunged &#123;            return false        &#125;        if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) &#123;            return true        &#125;    &#125;&#125;</code></pre><p>Store 方法:</p><pre><code>func (m *Map) Store(key, value interface&#123;&#125;) &#123;    // 如果m.read存在这个key，并且没有被标记删除，则尝试更新。    read, _ := m.read.Load().(readOnly)    if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;        return    &#125;    // 如果read不存在或者已经被标记删除    m.mu.Lock()    read, _ = m.read.Load().(readOnly)    if e, ok := read.m[key]; ok &#123;    //如果entry被标记expunge，则表明dirty没有key，可添加入dirty，并更新entry        if e.unexpungeLocked() &#123;             //加入dirty中            m.dirty[key] = e        &#125;        //更新value值        e.storeLocked(&amp;value)         //dirty 存在该key，更新    &#125; else if e, ok := m.dirty[key]; ok &#123;         e.storeLocked(&amp;value)        //read 和dirty都没有，新添加一条    &#125; else &#123;     //dirty中没有新的数据，往dirty中增加第一个新键        if !read.amended &#123;             //将read中未删除的数据加入到dirty中            m.dirtyLocked()             m.read.Store(readOnly&#123;m: read.m, amended: true&#125;)        &#125;        m.dirty[key] = newEntry(value)     &#125;    m.mu.Unlock()&#125;//将read中未删除的数据加入到dirty中func (m *Map) dirtyLocked() &#123;    if m.dirty != nil &#123;        return    &#125;    read, _ := m.read.Load().(readOnly)    m.dirty = make(map[interface&#123;&#125;]*entry, len(read.m))    //read如果较大的话，可能影响性能    for k, e := range read.m &#123;    //通过此次操作，dirty中的元素都是未被删除的，可见expunge的元素不在dirty中        if !e.tryExpungeLocked() &#123;            m.dirty[k] = e        &#125;    &#125;&#125;//判断entry是否被标记删除，并且将标记为nil的entry更新标记为expungefunc (e *entry) tryExpungeLocked() (isExpunged bool) &#123;    p := atomic.LoadPointer(&amp;e.p)    for p == nil &#123;        // 将已经删除标记为nil的数据标记为expunged        if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) &#123;            return true        &#125;        p = atomic.LoadPointer(&amp;e.p)    &#125;    return p == expunged&#125;//对entry 尝试更新func (e *entry) tryStore(i *interface&#123;&#125;) bool &#123;    p := atomic.LoadPointer(&amp;e.p)    if p == expunged &#123;        return false    &#125;    for &#123;        if atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123;            return true        &#125;        p = atomic.LoadPointer(&amp;e.p)        if p == expunged &#123;            return false        &#125;    &#125;&#125;//read里 将标记为expunge的更新为nilfunc (e *entry) unexpungeLocked() (wasExpunged bool) &#123;    return atomic.CompareAndSwapPointer(&amp;e.p, expunged, nil)&#125;//更新entryfunc (e *entry) storeLocked(i *interface&#123;&#125;) &#123;    atomic.StorePointer(&amp;e.p, unsafe.Pointer(i))&#125;</code></pre><p>因此，每次操作先检查read，因为read 并发安全，性能好些；read不满足，则加锁检查dirty，一旦是新的键值，dirty会被read更新。</p><p>Load方法:</p><p>Load方法是一个加载方法，查找key。</p><pre><code>func (m *Map) Load(key interface&#123;&#125;) (value interface&#123;&#125;, ok bool) &#123;    //因read只读，线程安全，先查看是否满足条件    read, _ := m.read.Load().(readOnly)    e, ok := read.m[key]    //如果read没有，并且dirty有新数据，那从dirty中查找，由于dirty是普通map，线程不安全，这个时候用到互斥锁了    if !ok &amp;&amp; read.amended &#123;        m.mu.Lock()        // 双重检查        read, _ = m.read.Load().(readOnly)        e, ok = read.m[key]        // 如果read中还是不存在，并且dirty中有新数据        if !ok &amp;&amp; read.amended &#123;            e, ok = m.dirty[key]            // mssLocked（）函数是性能是sync.Map 性能得以保证的重要函数，目的讲有锁的dirty数据，替换到只读线程安全的read里            m.missLocked()        &#125;        m.mu.Unlock()    &#125;    if !ok &#123;        return nil, false    &#125;    return e.load()&#125;//dirty 提升至read 关键函数，当misses 经过多次因为load之后，大小等于len（dirty）时候，讲dirty替换到read里，以此达到性能提升。func (m *Map) missLocked() &#123;    m.misses++    if m.misses &lt; len(m.dirty) &#123;        return    &#125;    //原子操作，耗时很小    m.read.Store(readOnly&#123;m: m.dirty&#125;)    m.dirty = nil    m.misses = 0&#125;</code></pre><p>sync.Map是通过冗余的两个数据结构(read、dirty),实现性能的提升。为了提升性能，load、delete、store等操作尽量使用只读的read；为了提高read的key击中概率，采用动态调整，将dirty数据提升为read；对于数据的删除，采用延迟标记删除法，只有在提升dirty的时候才删除。</p><h2 id="死锁条件，如何避免？"><a href="#死锁条件，如何避免？" class="headerlink" title="死锁条件，如何避免？"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>死锁条件，如何避免？</h2><p>死锁产生的四个必要条件:</p><ol><li> 互斥条件：一个资源每次只能被一个进程使用</li><li> 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li> 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。<br> 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</li></ol><ul><li>  预防死锁</li></ul><p>可以把资源一次性分配：（破坏请求和保持条件）</p><p>然后剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）</p><p>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</p><ul><li>避免死锁<br>  预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。</li></ul><h2 id="常见的GC模式"><a href="#常见的GC模式" class="headerlink" title="常见的GC模式"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>常见的GC模式</h2><ul><li><p>  引用计数（reference counting）每个对象维护一个引用计数器，当引用该对象的对象被销毁或者更新的时候，被引用对象的引用计数器自动减 1，当被应用的对象被创建，或者赋值给其他对象时，引用 +1，引用为 0 的时候回收，思路简单，但是频繁更新引用计数器降低性能，存在循环以引用（php，Python所使用的）</p></li><li><p>  标记清除（mark and sweep）就是 golang 所使用的，从根变量来时遍历所有被引用对象，标记之后进行清除操作，对未标记对象进行回收，缺点：每次垃圾回收的时候都会暂停所有的正常运行的代码，系统的响应能力会大大降低，各种 mark&amp;swamp 变种（三色标记法），缓解性能问题。</p></li><li><p>  分代搜集（generation）jvm 就使用的分代回收的思路。在面向对象编程语言中，绝大多数对象的生命周期都非常短。分代收集的基本思想是，将堆划分为两个或多个称为代（generation）的空间。新创建的对象存放在称为新生代（young generation）中（一般来说，新生代的大小会比 老年代小很多），随着垃圾回收的重复执行，生命周期较长的对象会被提升（promotion）到老年代中（这里用到了一个分类的思路，这个是也是科学思考的一个基本思路）。</p></li></ul><h2 id="Go-触发GC机制"><a href="#Go-触发GC机制" class="headerlink" title="Go 触发GC机制"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>Go 触发GC机制</h2><ol><li><p> 在申请内存的时候，检查当前当前已分配的内存是否大于上次GC后的内存的2倍，若是则触发（主GC线程为当前M）</p></li><li><p> 监控线程发现上次GC的时间已经超过两分钟了，触发；将一个G任务放到全局G队列中去。（主GC线程为执行这个G任务的M）</p></li></ol><h2 id="Golang-GC-时会发生什么"><a href="#Golang-GC-时会发生什么" class="headerlink" title="Golang GC 时会发生什么?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>Golang GC 时会发生什么?</h2><p>Golang 1.5后，采取的是“非分代的、非移动的、并发的、三色的”标记清除垃圾回收算法。<br>golang 中的 gc 基本上是标记清除的过程：<br><img src="https://www.github.com/Clown95/StroyBack/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1557903763811.png"></p><p>gc的过程一共分为四个阶段：</p><ol><li> 栈扫描（开始时STW（Stop the world））</li><li> 第一次标记（并发）</li><li> 第二次标记（STW）</li><li> 清除（并发）</li></ol><p>整个进程空间里申请每个对象占据的内存可以视为一个图，初始状态下每个内存对象都是白色标记。</p><ol><li> 先STW，做一些准备工作，比如 enable write barrier。然后取消STW，将扫描任务作为多个并发的goroutine立即入队给调度器，进而被CPU处理</li><li> 第一轮先扫描root对象，包括全局指针和 goroutine 栈上的指针，标记为灰色放入队列</li><li> 第二轮将第一步队列中的对象引用的对象置为灰色加入队列，一个对象引用的所有对象都置灰并加入队列后，这个对象才能置为黑色并从队列之中取出。循环往复，最后队列为空时，整个图剩下的白色内存空间即不可到达的对象，即没有被引用的对象；</li><li> 第三轮再次STW，将第二轮过程中新增对象申请的内存进行标记（灰色），这里使用了write barrier（写屏障）去记录</li></ol><p>Golang gc 优化的核心就是尽量使得 STW(Stop The World) 的时间越来越短。</p><h2 id="怎么设计orm，让你写-你会怎么写"><a href="#怎么设计orm，让你写-你会怎么写" class="headerlink" title="怎么设计orm，让你写,你会怎么写?"></a><a href="https://blog.csdn.net/yang731227/article/details/90637510"></a>怎么设计orm，让你写,你会怎么写?</h2><p>对象关系映射（Object Relational Mapping，简称ORM），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的–“虚拟对象数据库”。</p><p>通常来讲,ORM就是将数据库中的表映射成一个对象实体A，对A进行操作，就相对对数据库进行操作，完成这个过程，其实只要你好好想想你是怎么操作数据库的，然后将类似的行为换成对象即可。</p><p>要设计一个ORM，我们需要几步操作：</p><ol><li><p> 先准备好一个对象A和数据库中某张表对应T（A-&gt;T)</p></li><li><p> 我们知道当你创建一个表时，一般使用create命令如下：</p></li></ol><pre><code>CREATE TABLE database_name.table_name( column1 datatype PRIMARY KEY(one or more columns), column2 datatype, column3 datatype, ….. columnN datatype, );</code></pre><p>从这里我们可以看就对应着表名，表字段名，字段类型，是否是主键等，此时我们需要如何根据A中成员变量，而知道T的这些内容？如果你能根据A能够转化成T，那此时你就已经将A映射到了T了.</p><ol start="3"><li> 映射过程完成后，接下来就是要具备表的四种操作：增,删,改,查.</li></ol><pre><code>SELECT * FROM T WHERE field1 &gt;= ？ OR field2 &gt;= ？;</code></pre><p>这个过程其实是构建where语句的过程，我们可以根据一些条件，构建where语句，然后映射到成一个sql语句，根据sql语句我们就可以查询到一组符合条件的数据（cursor），然后就是将cursor数据转化成A.</p><p>现在总结下第三步操作的两个过程：condition -&gt;sql语句；cursor reslut-&gt;A</p><p>完成这三部，基本上就完成了一个ORM的设计，如果后面需要对性能，细节进行优化，就可以慢慢来。毕竟主功能已具备。</p><p>注意：如果想线程安全进行数据库操作可以考虑  db.enableWriteAheadLogging();</p><p>设计orm过程就是:</p><ul><li>  根据A得到 T;</li><li>  根据condition构建where,拼接成sql;</li><li>  根据sql从T中查出cursors；</li><li>  cursor转化成A.</li></ul><p>本文转自 <a href="https://blog.csdn.net/yang731227/article/details/90637510">https://blog.csdn.net/yang731227/article/details/90637510</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Golang进阶面试题&quot;&gt;&lt;a href=&quot;#Golang进阶面试题&quot; class=&quot;headerlink&quot; title=&quot;Golang进阶面试题&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn.net/yang731227/article/det</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="Go进阶面试题" scheme="https://ysluckly.github.io/tags/Go%E8%BF%9B%E9%98%B6%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>【Go项目】用Go生成和识别二维码</title>
    <link href="https://ysluckly.github.io/2022/01/06/golang/"/>
    <id>https://ysluckly.github.io/2022/01/06/golang/</id>
    <published>2022-01-06T07:29:32.000Z</published>
    <updated>2022-02-26T05:55:25.517Z</updated>
    
    <content type="html"><![CDATA[<p>我们在做go web开发的时候，应该都遇到生成二维码分享的应用场景，下面我将介绍下使用go如何生成二维码。</p><h1 id="安装-go-qrcode"><a href="#安装-go-qrcode" class="headerlink" title="安装 go-qrcode"></a><a href="https://blog.csdn.net/yang731227/article/details/88542480"></a>安装 go-qrcode</h1><p>我们不得不庆幸go的生态已经越来越丰富，有很多大牛已经帮我们写好了库，我们不必造轮子，直接拿过来用就好。</p><p>首先，我们安装我们用到的<code>go-qrcode</code>库。</p><blockquote><p>go get -u <a href="http://github.com/skip2/go-qrcode/">github.com/skip2/go-qrcode/</a>…</p></blockquote><h1 id="生成普通二维码"><a href="#生成普通二维码" class="headerlink" title="生成普通二维码"></a><a href="https://blog.csdn.net/yang731227/article/details/88542480"></a>生成普通二维码</h1><p>使用了这个库，你会发现二维码生成原来是如此的简单，现在我们就来演示一下。</p><pre><code>package mainimport &quot;github.com/skip2/go-qrcode&quot;func main() &#123;    qrcode.WriteFile(&quot;https://blog.csdn.net/yang731227&quot;,qrcode.Medium,256,&quot;./qrcode.png&quot;)&#125;</code></pre><p><img src="http://ww1.sinaimg.cn/large/5fe79106ly1g11h5kuhudj20ba0ba3yl.jpg"><br>这样我们就可以生成了一个二维码。</p><p>我们首先看下<code>func WriteFile(content string, level RecoveryLevel, size int, filename string) error</code>的参数。</p><ul><li>  content string 简单明了，这个是二维码内容</li><li>  level RecoveryLevel 这个是二维码容错等级，取值有Low、Medium、High、Highest。</li><li>  size int 不用说都知道这个是定义二维码大小</li><li>  filename string 二维码的保存路径</li></ul><h1 id="生成有前后背景颜色的二维码"><a href="#生成有前后背景颜色的二维码" class="headerlink" title="生成有前后背景颜色的二维码"></a><a href="https://blog.csdn.net/yang731227/article/details/88542480"></a>生成有前后背景颜色的二维码</h1><p>刚刚我们生成了一个前黑后白的二维码，这次我们想搞点花样，生成一个花花绿绿的二维码，我们直接上代码</p><pre><code>package mainimport (    &quot;github.com/skip2/go-qrcode&quot;    &quot;image/color&quot;)func main() &#123;    //qrcode.WriteFile(&quot;https://blog.csdn.net/yang731227&quot;,qrcode.High,200,&quot;./qrcode.png&quot;)    qrcode.WriteColorFile(&quot;https://blog.csdn.net/yang731227&quot;, qrcode.High, 256, color.Black, color.White, &quot;./qrcode.png&quot;)&#125;</code></pre><p>我们来看下<code>func WriteColorFile(content string, level RecoveryLevel, size int, background, foreground color.Color, filename string) error</code>的参数，比<code>WriteFile</code> 多了两个参数 background, foreground color.Color 。我们可以从字面意思就知道，background 是背景颜色，foreground是前景颜色。</p><p>颜色我们可以使用 <code>color</code>定义 ，它为我们定义了两个默认颜色，Black和White。如果我们想用其他颜色怎么办呢？它为我们提供了color.RGBA() 这个方法，RGBA()有4个参数 分别是RGB的值和透明值。</p><p>例如：</p><pre><code>    b:=color.RGBA&#123;100,100,100,255&#125;    f:=color.RGBA&#123;200,200,200,255&#125;    qrcode.WriteColorFile(&quot;https://blog.csdn.net/yang731227&quot;, qrcode.High, 256, b, f, &quot;./qrcode1.png&quot;)</code></pre><h1 id="识别二维码"><a href="#识别二维码" class="headerlink" title="识别二维码"></a><a href="https://blog.csdn.net/yang731227/article/details/88542480"></a>识别二维码</h1><p>上面我们讲了怎么生成二维，现在我们来实习解析二维码，当然我们还是需要借助别人写的库。</p><p>首先我们安装库<code>go get github.com/tuotoo/qrcode</code></p><p>然后我们直接上代码</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;github.com/tuotoo/qrcode&quot;)func main() &#123;    fi, err := os.Open(&quot;./qrcode.png&quot;)    if err != nil &#123;        fmt.Println(err.Error())        return    &#125;    defer fi.Close()    qrmatrix, err := qrcode.Decode(fi)    if err != nil &#123;        fmt.Println(err.Error())        return    &#125;    fmt.Println(qrmatrix.Content)&#125;</code></pre><p>本文转自 <a href="https://blog.csdn.net/yang731227/article/details/88542480">https://blog.csdn.net/yang731227/article/details/88542480</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们在做go web开发的时候，应该都遇到生成二维码分享的应用场景，下面我将介绍下使用go如何生成二维码。&lt;/p&gt;
&lt;h1 id=&quot;安装-go-qrcode&quot;&gt;&lt;a href=&quot;#安装-go-qrcode&quot; class=&quot;headerlink&quot; title=&quot;安装 go-q</summary>
      
    
    
    
    <category term="后端" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Go" scheme="https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"/>
    
    
    <category term="go-qrcode" scheme="https://ysluckly.github.io/tags/go-qrcode/"/>
    
    <category term="二维码" scheme="https://ysluckly.github.io/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
  </entry>
  
</feed>
