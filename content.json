{"meta":{"title":"码农印象","subtitle":"","description":"专职于互联网企业后端开发，专注于分享Linux C/C++/Golang、数据库等技术栈和互联网求职面试干货、经典面试算法。在这里我们终将一起从前沿技术，探索巅峰人生！","author":"码农印象","url":"https://ysluckly.github.io","root":"/"},"pages":[{"title":"","date":"2022-02-20T04:41:43.082Z","updated":"2022-02-19T09:27:58.478Z","comments":true,"path":"README.html","permalink":"https://ysluckly.github.io/README.html","excerpt":"","text":"为 layui 扩展的 下拉多选select在线demo： http://yelog.org/layui-select-multiple/ 这个在线 demo就是本项目的 index.html。 可将项目 clone 到本地查看效果。 效果图 参数 属性名 属性值 备注 multiple 无 开启多选 lay-search 无 开启搜索 lay-case 无 大小写敏感 lay-omit 无 开启多选简写，显示勾选条数 使用 将项目中的 form.js 覆盖自己项目中的 form.js。 引入下面cssselect[multiple]+.layui-form-select&gt;.layui-select-title&gt;input.layui-input&#123; border-bottom: 0&#125; select[multiple]+.layui-form-select dd&#123; padding:0;&#125; select[multiple]+.layui-form-select .layui-form-checkbox[lay-skin=primary]&#123; margin:0 !important; display:block; line-height:36px !important; position:relative; padding-left:26px;&#125; select[multiple]+.layui-form-select .layui-form-checkbox[lay-skin=primary] span&#123;line-height:36px !important; float:none;&#125; select[multiple]+.layui-form-select .layui-form-checkbox[lay-skin=primary] i&#123; position:absolute; left:10px; top:0; margin-top:9px;&#125; .multiSelect&#123; line-height:normal; height:auto; padding:4px 10px; overflow:hidden;min-height:38px; margin-top:-38px; left:0; z-index:99;position:relative;background:none;&#125; .multiSelect a&#123; padding:2px 5px; background:#908e8e; border-radius:2px; color:#fff; display:block; line-height:20px; height:20px; margin:2px 5px 2px 0; float:left;&#125; .multiSelect a span&#123; float:left;&#125; .multiSelect a i &#123;float:left;display:block;margin:2px 0 0 2px;border-radius:2px;width:8px;height:8px;padding:4px;position:relative;-webkit-transition:all .3s;transition:all .3s&#125; .multiSelect a i:before, .multiSelect a i:after &#123;position:absolute;left:8px;top:2px;content:&#39;&#39;;height:12px;width:1px;background-color:#fff&#125; .multiSelect a i:before &#123;-webkit-transform:rotate(45deg);transform:rotate(45deg)&#125; .multiSelect a i:after &#123;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)&#125; .multiSelect a i:hover&#123; background-color:#545556;&#125; 使用实例下面实例 开启了下拉多选（multiple）, 并开启了检索功能（lay-search）。效果可以参考 在线实例 的 多选+搜索+大小写不敏感 模块 &lt;select name=&quot;多选+搜索+大小写不敏感&quot; lay-verify=&quot;required&quot; multiple lay-search&gt; &lt;option value=&quot;&quot;&gt;请选择您的兴趣爱好&lt;/option&gt; &lt;option&gt;sing1&lt;/option&gt; &lt;option selected&gt;sing2&lt;/option&gt; &lt;option&gt;SING1-大写&lt;/option&gt; &lt;option&gt;movie1&lt;/option&gt; &lt;option selected&gt;movie2&lt;/option&gt; &lt;option&gt;movie3&lt;/option&gt; &lt;option&gt;MOVIE4&lt;/option&gt; &lt;option&gt;swim&lt;/option&gt; &lt;option&gt;moon&lt;/option&gt; &lt;/select&gt; 更多实例参考 在线实例、或 index.html。 声明此项目基于 https://gitee.com/layuicms/XiaLaDuoXuan 项目修改得来，修复了一些bug，扩展了 简化多选、多选搜索、大小写敏感控制等功能。"},{"title":"","date":"2022-02-21T15:11:42.705Z","updated":"2022-02-21T15:11:42.705Z","comments":true,"path":"googleddd7f3e93b89923f.html","permalink":"https://ysluckly.github.io/googleddd7f3e93b89923f.html","excerpt":"","text":"google-site-verification: googleddd7f3e93b89923f.html"},{"title":"","date":"2022-02-20T04:41:26.407Z","updated":"2022-02-19T09:27:58.597Z","comments":true,"path":"index.html","permalink":"https://ysluckly.github.io/index.html","excerpt":"","text":"layui-select-multiple /* 下拉多选样式 需要引用*/ select[multiple]+.layui-form-select>.layui-select-title>input.layui-input{ border-bottom: 0} select[multiple]+.layui-form-select dd{ padding:0;} select[multiple]+.layui-form-select .layui-form-checkbox[lay-skin=primary]{ margin:0 !important; display:block; line-height:36px !important; position:relative; padding-left:26px;} select[multiple]+.layui-form-select .layui-form-checkbox[lay-skin=primary] span{line-height:36px !important; float:none;} select[multiple]+.layui-form-select .layui-form-checkbox[lay-skin=primary] i{ position:absolute; left:10px; top:0; margin-top:9px;} .multiSelect{ line-height:normal; height:auto; padding:4px 10px; overflow:hidden;min-height:38px; margin-top:-38px; left:0; z-index:99;position:relative;background:none;} .multiSelect a{ padding:2px 5px; background:#908e8e; border-radius:2px; color:#fff; display:block; line-height:20px; height:20px; margin:2px 5px 2px 0; float:left;} .multiSelect a span{ float:left;} .multiSelect a i {float:left;display:block;margin:2px 0 0 2px;border-radius:2px;width:8px;height:8px;padding:4px;position:relative;-webkit-transition:all .3s;transition:all .3s} .multiSelect a i:before, .multiSelect a i:after {position:absolute;left:8px;top:2px;content:'';height:12px;width:1px;background-color:#fff} .multiSelect a i:before {-webkit-transform:rotate(45deg);transform:rotate(45deg)} .multiSelect a i:after {-webkit-transform:rotate(-45deg);transform:rotate(-45deg)} .multiSelect a i:hover{ background-color:#545556;} /* 下面是页面内样式，无需引用 */ .layui-block { margin-bottom: 10px; } .layui-form-label { width: 180px; } .code { color: gray; margin-left: 10px; } .unshow>#result { display: none; } pre { padding: 5px; margin: 5px; } .string { color: green; } .number { color: darkorange; } .boolean { color: blue; } .null { color: magenta; } .key { color: red; } 基础属性 属性名 属性值 备注 multiple 无 开启多选 lay-search 无 开启搜索 lay-case 无 大小写敏感 lay-omit 无 开启多选简写，显示勾选条数 单选select 单选 请选择您的兴趣爱好 sing1 sing2 SING1-大写 movie1 movie2 movie3 MOVIE4 swim moon &ltselect> 单选+搜索+大小写不敏感 请选择您的兴趣爱好 sing1 sing2 SING1-大写 movie1 movie2 movie3 MOVIE4 swim moon &ltselect lay-search> 单选+搜索+大小写敏感 请选择您的兴趣爱好 sing1 sing2 SING1-大写 movie1 movie2 movie3 MOVIE4 swim moon &ltselect lay-search lay-case> 查看表单信息 多选select 多选 请选择您的兴趣爱好 sing1 sing2 SING1-大写 movie1 movie2 movie3 MOVIE4 swim moon &ltselect multiple> 简化多选 请选择您的兴趣爱好 sing1 sing2 SING1-大写 movie1 movie2 movie3 MOVIE4 swim moon &ltselect multiple lay-omit> 多选+搜索+大小写不敏感 请选择您的兴趣爱好 sing1 sing2 SING1-大写 movie1 movie2 movie3 MOVIE4 swim moon &ltselect multiple lay-search> 简化多选+搜索+大小写敏感 请选择您的兴趣爱好 sing1 sing2 SING1-大写 movie1 movie2 movie3 MOVIE4 swim moon &ltselect multiple lay-search lay-case lay-omit> 查看表单信息 赋值 // 有两种赋值方式： 1. 直接在option中写selected。 2. 通过 js 赋值。 // 1. 直接在option中写selected 请选择您的兴趣爱好 sing1 sing2 SING1-大写 movie1 movie2 movie3 MOVIE4 swim moon // 2. 通过 js 赋值。 请选择您的兴趣爱好 sing1 sing2 SING1-大写 movie1 movie2 movie3 MOVIE4 swim moon &ltscript> // 手动赋值 $('select[name=\"简化多选+搜索+大小写敏感\"]').val(['sing1', 'movie2']); form.render(); &lt/script> layui.use(['form','code'], function () { var form = layui.form, $ = layui.$; // 代码块 layui.code({ title: 'html', encode: true, about: false }); // 手动赋值 $('select[name=\"简化多选+搜索+大小写敏感\"]').val(['sing1', 'movie2']); form.render(); // 提交事件 form.on(\"submit(*)\", function (data) { $('#result').html(syntaxHighlight(data.field)); layer.open({ type: 1, title: '提交信息', shadeClose: true, content:$('#result') }); return false; }); // json 格式化+高亮 function syntaxHighlight(json) { if (typeof json != 'string') { json = JSON.stringify(json, undefined, 2); } json = json.replace(/&/g, '&').replace(//g, '>'); return json.replace(/(\"(\\\\u[a-zA-Z0-9]{4}|\\\\[^u]|[^\\\\\"])*\"(\\s*:)?|\\b(true|false|null)\\b|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)/g, function(match) { var cls = 'number'; if (/^\"/.test(match)) { if (/:$/.test(match)) { cls = 'key'; } else { cls = 'string'; } } else if (/true|false/.test(match)) { cls = 'boolean'; } else if (/null/.test(match)) { cls = 'null'; } return '' + match + ''; }); } })"},{"title":"404 Not Found：该页无法显示","date":"2016-09-27T03:31:01.000Z","updated":"2022-02-20T12:11:04.731Z","comments":true,"path":"/404.html","permalink":"https://ysluckly.github.io/404.html","excerpt":"","text":"很抱歉，您所访问的地址并不存在"},{"title":"","date":"2021-09-08T22:25:28.547Z","updated":"2020-09-09T14:32:06.000Z","comments":true,"path":"about/about.css","permalink":"https://ysluckly.github.io/about/about.css","excerpt":"","text":"body { margin: 0; overflow-x: hidden; overflow-y: hidden; } .mdui-container, .mdui-container-fluid { -webkit-box-sizing: border-box; box-sizing: border-box; padding-right: 8px; padding-left: 8px; margin-right: auto; margin-left: auto } .mdui-container-fluid:after, .mdui-container:after { display: table; clear: both; content: '' } .mdui-container { width: 96%; max-width: 1280px } @media (min-width:600px) { .mdui-container { width: 94% } } @media (min-width:1024px) { .mdui-container { width: 92% } } h3 { text-align: center } .icon { padding: 0 2% 1% 2%; width: 40px; height: 40px } table { text-align: left; font-family:'STZhongsong'; margin: 0 0 0 230px; font-size: 20px; height: 145px; width: 75% } .showarea-1 { opacity: 0.9; background-color: white; margin: 4% 10% 0% 10%; padding: 10px } .showarea-2 { opacity: 0.9; background-color: white; height: 300px; margin: 0.5% 0 0 10%; float: left; width: 38%; padding: 0 0 8px 20px } .showarea-3 { opacity: 0.9; background-color: white; height: 300px; float: left; width: 38.3%; margin: 0.5% 0 0 0.5%; padding: 0 0 8px 20px } .showarea-4 { opacity: 0.9; background-color: white; margin: 0.5% 10% 0 10%; padding: 8px; text-align: center } .skill { max-width: 700px; margin: auto; } .skill .item { width: 100%; clear: both; margin-right: auto; margin-left: auto; height: 35px; } .skill .describe { font-family: \"Microsoft Yahei\"; margin-right: 12px; text-align: center; } .skill .progress { float: left; height: 25px; background: #fbfbfb; border-left: 1px solid transparent; border-right: 1px solid transparent; width: 70%; } .skill .progress>span { position: relative; float: left; margin: 0 -1px; min-width: 30px; height: 25px; line-height: 21px; text-align: right; background: #cccccc; border: none; border-color: #bfbfbf #b3b3b3 #9e9e9e; -webkit-box-shadow: inset 0 1px rgba(255, 255, 255, 0.3), 0 1px 2px rgba(0, 0, 0, 0.2); box-shadow: inset 0 1px rgba(255, 255, 255, 0.3), 0 1px 2px rgba(0, 0, 0, 0.2); } .skill .progress>span>span { padding: 0 8px; font-size: 14px; color: #404040; color: rgba(0, 0, 0, 0.7); font-family: \"Microsoft Yahie\"; line-height: 25px; } .skill .progress>span:before { content: ''; position: absolute; top: 0; bottom: 0; left: 0; right: 0; z-index: 1; height: 25px; border-radius: 10px; } .skill .progress .green { background: #49C085; } .skill .progress .darkblue { background: #7782D1; } .skill .progress .red { background: #EC5B5B; } .skill .progress .orange { background: #f2b63c; } .skill .progress .blue { background: #6F92FF; } @media (min-width:750px) { .skill .describe { width: 100px; float: left; } .skill .progress { width: 70%; float: left; } } @media (max-width:750px) { .skill .describe { width: 100%; margin-bottom: 5px; text-align: left; } .skill .progress { width: 100%; margin-bottom: 5px; } } #mainicon { -webkit-animation: rotateImg 5s linear infinite; height: 140px; width: 140px; float: left; border: 3px solid; border-color: aqua; border-radius: 50%; transition: transform 1s; max-width: 50%; display: block } @keyframes rotateImg { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } @-webkit-keyframes rotateImg { 0% { -webkit-transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); } } canvas { top: 0; padding: 0; margin: 0; position: absolute; z-index: -1; left: 0px } #footer { position: relative; clear: both; width: 100%; top: 20px; text-align: center; display: inline-block; color: #D3D3D3; font-family:Georgia, 'Times New Roman', Times, serif } #footer a { text-decoration: none; color: #D3D3D3; cursor: pointer } #footer a:hover { border-bottom: 1px dotted #FFFFFF; color: #FFFFFF } @media screen and (max-width:480px) { #mainicon { position: relative; float: top; display: block } }"},{"title":"","date":"2022-02-20T11:31:21.375Z","updated":"2022-02-20T11:31:21.375Z","comments":true,"path":"about/index.html","permalink":"https://ysluckly.github.io/about/index.html","excerpt":"","text":"YSLIVING'S HOME | ABOUT document.onkeydown = function () { if (window.event && window.event.keyCode == 123) { event.keyCode = 0; event.returnValue = false; return false; } }; 您的浏览器不支持audio标签，无法播放音乐！"},{"title":"","date":"2021-09-16T17:16:13.716Z","updated":"2021-09-16T17:16:13.715Z","comments":true,"path":"games/PacMan/index.html","permalink":"https://ysluckly.github.io/games/PacMan/index.html","excerpt":"","text":"吃豆人 |YSLIVING'S BLOG body{background-color: #000} *{padding:0;margin:0;} .wrapper{ width: 960px; margin:0 auto; line-height:36px; text-align:center; color:#999; } canvas{display:block;background: #000;} .mod-botton{ height: 32px; padding: 15px 0; text-align: center; } #footer{position:relative;clear:both;padding:10px 20px 40px 0;padding:10px 0;width:100%;text-align:center}#footer address{display:inline-block;padding:2px 10px;color:rgba(255, 255, 255, 0.5);font-style:normal} #footer a{color:rgba(255, 255, 255, 0.5);cursor:grab}#footer a:hover{border-bottom:1px dotted #00387d;color:#00387d} 不支持画布 【按空格键开始、暂停或继续游戏，方向键移动吃豆人】 Copyright&nbsp;©&nbsp;2020-至今&nbsp;YSLIVING'S HOME&nbsp;|&nbsp; &nbsp; 沪ICP备1******8号-X&nbsp;|&nbsp; 中国互联网违法和不良信息举报中心 推荐使用1920*1080分辨率、谷歌或者火狐浏览器浏览此页&nbsp;|&nbsp; 996.ICU&nbsp;|&nbsp; 申请友链&nbsp;|&nbsp; Powered By Hexo&nbsp;|&nbsp; Hosted By GitHub Pages 部分资料来源于网络，版权属于其合法持有人，只供学习交流之用，非商务用途。如有侵犯您的权益，请及时告知删除。互动交流时请遵守理性，宽容，换位思考的原则。 document.onkeydown=function (e){ var currKey=0,evt=e||window.event; currKey=evt.keyCode||evt.which||evt.charCode; if (currKey == 123) { window.event.cancelBubble = true; window.event.returnValue = false; } }"},{"title":"","date":"2022-02-20T13:52:55.712Z","updated":"2022-02-20T13:52:55.712Z","comments":true,"path":"games/2048/index.html","permalink":"https://ysluckly.github.io/games/2048/index.html","excerpt":"","text":"2048 | ysliving's home 2048 使用方向键操作 New Game score:0 GAME OVER Copyright&nbsp;©&nbsp;2022-至今&nbsp;YSLIVING'S HOME&nbsp;|&nbsp; &nbsp; 沪ICP备1******8号-X&nbsp;|&nbsp; 中国互联网违法和不良信息举报中心 推荐使用1920*1080分辨率、谷歌或者火狐浏览器浏览此页&nbsp;|&nbsp; 996.ICU&nbsp;|&nbsp; 申请友链&nbsp;|&nbsp; Powered By Hexo&nbsp;|&nbsp; Hosted By GitHub Pages 部分资料来源于网络，版权属于其合法持有人，只供学习交流之用，非商务用途。如有侵犯您的权益，请及时告知删除。互动交流时请遵守理性，宽容，换位思考的原则。 document.onkeydown=function (e){ var currKey=0,evt=e||window.event; currKey=evt.keyCode||evt.which||evt.charCode; if (currKey == 123) { window.event.cancelBubble = true; window.event.returnValue = false; } }"},{"title":"","date":"2022-02-20T13:53:16.172Z","updated":"2022-02-20T13:53:16.172Z","comments":true,"path":"games/cat/index.html","permalink":"https://ysluckly.github.io/games/cat/index.html","excerpt":"","text":"圈小猫 | YSLIVING'S BLOG body {background-color: #eeeeee} #catch-the-cat {width: 100%;text-align: center;} #footer{position:relative;clear:both;padding:10px 20px 40px 0;padding:10px 0;width:100%;text-align:center}#footer address{display:inline-block;padding:2px 10px;color:rgba(0,0,0,.5);font-style:normal} #footer a{color:rgba(0,0,0,.5);cursor:grab}#footer a:hover{border-bottom:1px dotted #00387d;color:#00387d} 游戏：《圈小猫》 window.game = new CatchTheCatGame({ w: 11, h: 11, r: 20, backgroundColor: 0xffffff, parent: 'catch-the-cat', statusBarAlign: 'center', credit: '码农印象' }); Copyright&nbsp;©&nbsp;2022-至今&nbsp;YSLIVING'S HOME&nbsp;|&nbsp; &nbsp; 沪ICP备1******8号-X&nbsp;|&nbsp; 中国互联网违法和不良信息举报中心 推荐使用1920*1080分辨率、谷歌或者火狐浏览器浏览此页&nbsp;|&nbsp; 996.ICU&nbsp;|&nbsp; 申请友链&nbsp;|&nbsp; Powered By Hexo&nbsp;|&nbsp; Hosted By GitHub Pages 部分资料来源于网络，版权属于其合法持有人，只供学习交流之用，非商务用途。如有侵犯您的权益，请及时告知删除。互动交流时请遵守理性，宽容，换位思考的原则。 document.onkeydown=function (e){ var currKey=0,evt=e||window.event; currKey=evt.keyCode||evt.which||evt.charCode; if (currKey == 123) { window.event.cancelBubble = true; window.event.returnValue = false; } }"},{"title":"","date":"2021-09-11T13:10:32.570Z","updated":"2021-09-11T13:10:32.570Z","comments":true,"path":"games/element/index.html","permalink":"https://ysluckly.github.io/games/element/index.html","excerpt":"","text":"3D元素周期表 | YSLIVING'S BLOG html, body { height: 100%; } body { background-color: #000000; margin: 0; font-family: Helvetica, sans-serif;; overflow: hidden; } a { color: #ffffff; } #info { position: absolute; width: 100%; color: #ffffff; padding: 5px; font-family: Monospace; font-size: 13px; font-weight: bold; text-align: center; z-index: 1; } #menu { position: absolute; bottom: 20px; width: 100%; text-align: center; font-family: verdana,Tahoma,Arial,Hei,\"Microsoft Yahei\",SimHei; } .element { width: 120px; height: 160px; box-shadow: 0px 0px 12px rgba(0,255,255,0.5); border: 1px solid rgba(127,255,255,0.25); text-align: center; cursor: default; } .element:hover { box-shadow: 0px 0px 12px rgba(0,255,255,0.75); border: 1px solid rgba(127,255,255,0.75); } .element .number { position: absolute; top: 20px; right: 20px; font-size: 12px; color: rgba(127,255,255,0.75); } .element .symbol { position: absolute; top: 40px; left: 0px; right: 0px; font-size: 60px; font-weight: bold; color: rgba(255,255,255,0.75); text-shadow: 0 0 10px rgba(0,255,255,0.95); } .element .details { position: absolute; bottom: 15px; left: 0px; right: 0px; font-size: 12px; color: rgba(127,255,255,0.75); } button { color: rgba(127,255,255,0.75); background: transparent; outline: 1px solid rgba(127,255,255,0.75); border: 0px; padding: 5px 10px; cursor: pointer; } button:hover { background-color: rgba(0,255,255,0.5); } button:active { color: #000000; background-color: rgba(0,255,255,0.75); } 表面 球体 螺旋 网格 var table = [ \"H\", \"Hydrogen\", \"1.00794\", 1, 1, \"He\", \"Helium\", \"4.002602\", 18, 1, \"Li\", \"Lithium\", \"#6.941\", 1, 2, \"Be\", \"Beryllium\", \"9.012182\", 2, 2, \"B\", \"Boron\", \"#10.811\", 13, 2, \"C\", \"Carbon\", \"#12.0107\", 14, 2, \"N\", \"Nitrogen\", \"#14.0067\", 15, 2, \"O\", \"Oxygen\", \"#15.9994\", 16, 2, \"F\", \"Fluorine\", \"18.9984032\", 17, 2, \"Ne\", \"Neon\", \"#20.1797\", 18, 2, \"Na\", \"Sodium\", \"22.98976...\", 1, 3, \"Mg\", \"Magnesium\", \"#24.305\", 2, 3, \"Al\", \"Aluminium\", \"26.9815386\", 13, 3, \"Si\", \"Silicon\", \"#28.0855\", 14, 3, \"P\", \"Phosphorus\", \"30.973762\", 15, 3, \"S\", \"Sulfur\", \"#32.065\", 16, 3, \"Cl\", \"Chlorine\", \"#35.453\", 17, 3, \"Ar\", \"Argon\", \"#39.948\", 18, 3, \"K\", \"Potassium\", \"#39.948\", 1, 4, \"Ca\", \"Calcium\", \"#40.078\", 2, 4, \"Sc\", \"Scandium\", \"44.955912\", 3, 4, \"Ti\", \"Titanium\", \"#47.867\", 4, 4, \"V\", \"Vanadium\", \"#50.9415\", 5, 4, \"Cr\", \"Chromium\", \"#51.9961\", 6, 4, \"Mn\", \"Manganese\", \"54.938045\", 7, 4, \"Fe\", \"Iron\", \"#55.845\", 8, 4, \"Co\", \"Cobalt\", \"58.933195\", 9, 4, \"Ni\", \"Nickel\", \"#58.6934\", 10, 4, \"Cu\", \"Copper\", \"#63.546\", 11, 4, \"Zn\", \"Zinc\", \"#65.38\", 12, 4, \"Ga\", \"Gallium\", \"#69.723\", 13, 4, \"Ge\", \"Germanium\", \"#72.63\", 14, 4, \"As\", \"Arsenic\", \"#74.9216\", 15, 4, \"Se\", \"Selenium\", \"#78.96\", 16, 4, \"Br\", \"Bromine\", \"#79.904\", 17, 4, \"Kr\", \"Krypton\", \"#83.798\", 18, 4, \"Rb\", \"Rubidium\", \"#85.4678\", 1, 5, \"Sr\", \"Strontium\", \"#87.62\", 2, 5, \"Y\", \"Yttrium\", \"88.90585\", 3, 5, \"Zr\", \"Zirconium\", \"#91.224\", 4, 5, \"Nb\", \"Niobium\", \"92.90628\", 5, 5, \"Mo\", \"Molybdenum\", \"#95.96\", 6, 5, \"Tc\", \"Technetium\", \"(98)\", 7, 5, \"Ru\", \"Ruthenium\", \"#101.07\", 8, 5, \"Rh\", \"Rhodium\", \"#102.9055\", 9, 5, \"Pd\", \"Palladium\", \"#106.42\", 10, 5, \"Ag\", \"Silver\", \"#107.8682\", 11, 5, \"Cd\", \"Cadmium\", \"#112.411\", 12, 5, \"In\", \"Indium\", \"#114.818\", 13, 5, \"Sn\", \"Tin\", \"#118.71\", 14, 5, \"Sb\", \"Antimony\", \"#121.76\", 15, 5, \"Te\", \"Tellurium\", \"127.6\", 16, 5, \"I\", \"Iodine\", \"126.90447\", 17, 5, \"Xe\", \"Xenon\", \"#131.293\", 18, 5, \"Cs\", \"Caesium\", \"#132.9054\", 1, 6, \"Ba\", \"Barium\", \"#132.9054\", 2, 6, \"La\", \"Lanthanum\", \"138.90547\", 4, 9, \"Ce\", \"Cerium\", \"#140.116\", 5, 9, \"Pr\", \"Praseodymium\", \"140.90765\", 6, 9, \"Nd\", \"Neodymium\", \"#144.242\", 7, 9, \"Pm\", \"Promethium\", \"(145)\", 8, 9, \"Sm\", \"Samarium\", \"#150.36\", 9, 9, \"Eu\", \"Europium\", \"#151.964\", 10, 9, \"Gd\", \"Gadolinium\", \"#157.25\", 11, 9, \"Tb\", \"Terbium\", \"158.92535\", 12, 9, \"Dy\", \"Dysprosium\", \"162.5\", 13, 9, \"Ho\", \"Holmium\", \"164.93032\", 14, 9, \"Er\", \"Erbium\", \"#167.259\", 15, 9, \"Tm\", \"Thulium\", \"168.93421\", 16, 9, \"Yb\", \"Ytterbium\", \"#173.054\", 17, 9, \"Lu\", \"Lutetium\", \"#174.9668\", 18, 9, \"Hf\", \"Hafnium\", \"#178.49\", 4, 6, \"Ta\", \"Tantalum\", \"180.94788\", 5, 6, \"W\", \"Tungsten\", \"#183.84\", 6, 6, \"Re\", \"Rhenium\", \"#186.207\", 7, 6, \"Os\", \"Osmium\", \"#190.23\", 8, 6, \"Ir\", \"Iridium\", \"#192.217\", 9, 6, \"Pt\", \"Platinum\", \"#195.084\", 10, 6, \"Au\", \"Gold\", \"196.966569\", 11, 6, \"Hg\", \"Mercury\", \"#200.59\", 12, 6, \"Tl\", \"Thallium\", \"#204.3833\", 13, 6, \"Pb\", \"Lead\", \"207.2\", 14, 6, \"Bi\", \"Bismuth\", \"#208.9804\", 15, 6, \"Po\", \"Polonium\", \"(209)\", 16, 6, \"At\", \"Astatine\", \"(210)\", 17, 6, \"Rn\", \"Radon\", \"(222)\", 18, 6, \"Fr\", \"Francium\", \"(223)\", 1, 7, \"Ra\", \"Radium\", \"(226)\", 2, 7, \"Ac\", \"Actinium\", \"(227)\", 4, 10, \"Th\", \"Thorium\", \"232.03806\", 5, 10, \"Pa\", \"Protactinium\", \"#231.0588\", 6, 10, \"U\", \"Uranium\", \"238.02891\", 7, 10, \"Np\", \"Neptunium\", \"(237)\", 8, 10, \"Pu\", \"Plutonium\", \"(244)\", 9, 10, \"Am\", \"Americium\", \"(243)\", 10, 10, \"Cm\", \"Curium\", \"(247)\", 11, 10, \"Bk\", \"Berkelium\", \"(247)\", 12, 10, \"Cf\", \"Californium\", \"(251)\", 13, 10, \"Es\", \"Einstenium\", \"(252)\", 14, 10, \"Fm\", \"Fermium\", \"(257)\", 15, 10, \"Md\", \"Mendelevium\", \"(258)\", 16, 10, \"No\", \"Nobelium\", \"(259)\", 17, 10, \"Lr\", \"Lawrencium\", \"(262)\", 18, 10, \"Rf\", \"Rutherfordium\", \"(267)\", 4, 7, \"Db\", \"Dubnium\", \"(268)\", 5, 7, \"Sg\", \"Seaborgium\", \"(271)\", 6, 7, \"Bh\", \"Bohrium\", \"(272)\", 7, 7, \"Hs\", \"Hassium\", \"(270)\", 8, 7, \"Mt\", \"Meitnerium\", \"(276)\", 9, 7, \"Ds\", \"Darmstadium\", \"(281)\", 10, 7, \"Rg\", \"Roentgenium\", \"(280)\", 11, 7, \"Cn\", \"Copernicium\", \"(285)\", 12, 7, \"Uut\", \"Unutrium\", \"(284)\", 13, 7, \"Fl\", \"Flerovium\", \"(289)\", 14, 7, \"Uup\", \"Ununpentium\", \"(288)\", 15, 7, \"Lv\", \"Livermorium\", \"(293)\", 16, 7, \"Uus\", \"Ununseptium\", \"(294)\", 17, 7, \"Uuo\", \"Ununoctium\", \"(294)\", 18, 7 ]; var camera, scene, renderer; var controls; var objects = []; var targets = { table: [], sphere: [], helix: [], grid: [] }; init(); animate(); function init() { camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 ); camera.position.z = 3000; scene = new THREE.Scene(); // table for ( var i = 0; i < table.length; i += 5 ) { var element = document.createElement( 'div' ); element.className = 'element'; element.style.backgroundColor = 'rgba(0,127,127,' + ( Math.random() * 0.5 + 0.25 ) + ')'; var number = document.createElement( 'div' ); number.className = 'number'; number.textContent = (i/5) + 1; element.appendChild( number ); var symbol = document.createElement( 'div' ); symbol.className = 'symbol'; symbol.textContent = table[ i ]; element.appendChild( symbol ); var details = document.createElement( 'div' ); details.className = 'details'; details.innerHTML = table[ i + 1 ] + '' + table[ i + 2 ]; element.appendChild( details ); var object = new THREE.CSS3DObject( element ); object.position.x = Math.random() * 4000 - 2000; object.position.y = Math.random() * 4000 - 2000; object.position.z = Math.random() * 4000 - 2000; scene.add( object ); objects.push( object ); // var object = new THREE.Object3D(); object.position.x = ( table[ i + 3 ] * 140 ) - 1330; object.position.y = - ( table[ i + 4 ] * 180 ) + 990; targets.table.push( object ); } // sphere var vector = new THREE.Vector3(); for ( var i = 0, l = objects.length; i < l; i ++ ) { var phi = Math.acos( -1 + ( 2 * i ) / l ); var theta = Math.sqrt( l * Math.PI ) * phi; var object = new THREE.Object3D(); object.position.x = 800 * Math.cos( theta ) * Math.sin( phi ); object.position.y = 800 * Math.sin( theta ) * Math.sin( phi ); object.position.z = 800 * Math.cos( phi ); vector.copy( object.position ).multiplyScalar( 2 ); object.lookAt( vector ); targets.sphere.push( object ); } // helix var vector = new THREE.Vector3(); for ( var i = 0, l = objects.length; i < l; i ++ ) { var phi = i * 0.175 + Math.PI; var object = new THREE.Object3D(); object.position.x = 900 * Math.sin( phi ); object.position.y = - ( i * 8 ) + 450; object.position.z = 900 * Math.cos( phi ); vector.x = object.position.x * 2; vector.y = object.position.y; vector.z = object.position.z * 2; object.lookAt( vector ); targets.helix.push( object ); } // grid for ( var i = 0; i < objects.length; i ++ ) { var object = new THREE.Object3D(); object.position.x = ( ( i % 5 ) * 400 ) - 800; object.position.y = ( - ( Math.floor( i / 5 ) % 5 ) * 400 ) + 800; object.position.z = ( Math.floor( i / 25 ) ) * 1000 - 2000; targets.grid.push( object ); } // renderer = new THREE.CSS3DRenderer(); renderer.setSize( window.innerWidth, window.innerHeight ); renderer.domElement.style.position = 'absolute'; document.getElementById( 'container' ).appendChild( renderer.domElement ); // controls = new THREE.TrackballControls( camera, renderer.domElement ); controls.rotateSpeed = 0.5; controls.minDistance = 500; controls.maxDistance = 6000; controls.addEventListener( 'change', render ); var button = document.getElementById( 'table' ); button.addEventListener( 'click', function ( event ) { transform( targets.table, 2000 ); }, false ); var button = document.getElementById( 'sphere' ); button.addEventListener( 'click', function ( event ) { transform( targets.sphere, 2000 ); }, false ); var button = document.getElementById( 'helix' ); button.addEventListener( 'click', function ( event ) { transform( targets.helix, 2000 ); }, false ); var button = document.getElementById( 'grid' ); button.addEventListener( 'click', function ( event ) { transform( targets.grid, 2000 ); }, false ); transform( targets.table, 5000 ); // window.addEventListener( 'resize', onWindowResize, false ); } function transform( targets, duration ) { TWEEN.removeAll(); for ( var i = 0; i < objects.length; i ++ ) { var object = objects[ i ]; var target = targets[ i ]; new TWEEN.Tween( object.position ) .to( { x: target.position.x, y: target.position.y, z: target.position.z }, Math.random() * duration + duration ) .easing( TWEEN.Easing.Exponential.InOut ) .start(); new TWEEN.Tween( object.rotation ) .to( { x: target.rotation.x, y: target.rotation.y, z: target.rotation.z }, Math.random() * duration + duration ) .easing( TWEEN.Easing.Exponential.InOut ) .start(); } new TWEEN.Tween( this ) .to( {}, duration * 2 ) .onUpdate( render ) .start(); } function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize( window.innerWidth, window.innerHeight ); render(); } function animate() { requestAnimationFrame( animate ); TWEEN.update(); controls.update(); } function render() { renderer.render( scene, camera ); } document.onkeydown=function (e){ var currKey=0,evt=e||window.event; currKey=evt.keyCode||evt.which||evt.charCode; if (currKey == 123) { window.event.cancelBubble = true; window.event.returnValue = false; } }"},{"title":"","date":"2021-09-16T17:16:46.968Z","updated":"2021-09-16T17:16:46.968Z","comments":true,"path":"games/piano/index.html","permalink":"https://ysluckly.github.io/games/piano/index.html","excerpt":"","text":"网页版钢琴 | YSLIVING'S BLOG 网页版钢琴 qaz sx dc rfv gb hn jm ik, w e t y u 弹奏方法 使用鼠标左键点击钢琴键，或者键入钢琴键上输入的键盘字母。 Copyright&nbsp;©&nbsp;2020-至今&nbsp;YSLIVING'S HOME&nbsp;|&nbsp; &nbsp; 沪ICP备1******8号-X&nbsp;|&nbsp; 中国互联网违法和不良信息举报中心 推荐使用1920*1080分辨率、谷歌或者火狐浏览器浏览此页&nbsp;|&nbsp; 996.ICU&nbsp;|&nbsp; 申请友链&nbsp;|&nbsp; Powered By Hexo&nbsp;|&nbsp; Hosted By GitHub Pages 部分资料来源于网络，版权属于其合法持有人，只供学习交流之用，非商务用途。如有侵犯您的权益，请及时告知删除。互动交流时请遵守理性，宽容，换位思考的原则。 document.onkeydown=function (e){ var currKey=0,evt=e||window.event; currKey=evt.keyCode||evt.which||evt.charCode; if (currKey == 123) { window.event.cancelBubble = true; window.event.returnValue = false; } }"},{"title":"","date":"2022-02-20T13:53:35.750Z","updated":"2022-02-20T13:53:35.750Z","comments":true,"path":"games/gobang/index.html","permalink":"https://ysluckly.github.io/games/gobang/index.html","excerpt":"","text":"五子棋 |YSLIVING'S BLOG canvas { display: block; margin: 60px auto; box-shadow: -2px -2px 2px #efefef, 5px 5px 5px #b9b9b9; cursor: pointer; } .btn-wrap { display: flex; flex-direction: row; justify-content: center; } .btn-wrap div { margin: 0 10px; } div>span { display: inline-block; padding: 10px 20px; color: #fff; background-color: #6496ED; border-radius: 5px; cursor: pointer; } div.unable span { background: #D6D6D4; color: #adacaa; } #result-wrap { text-align: center; margin:50px 0 0 0; } #footer{position:relative;clear:both;padding:10px 20px 40px 0;padding:10px 0;width:100%;text-align:center}#footer address{display:inline-block;padding:2px 10px;color:rgba(0,0,0,.5);font-style:normal} #footer a{color:rgba(0,0,0,.5);cursor:grab}#footer a:hover{border-bottom:1px dotted #00387d;color:#00387d} 人机五子棋对弈 重新开始 悔棋 撤销悔棋 var over = false; var me = true; //我 var _nowi = 0, _nowj = 0; //记录自己下棋的坐标 var _compi = 0, _compj = 0; //记录计算机当前下棋的坐标 var _myWin = [], _compWin = []; //记录我，计算机赢的情况 var backAble = false, returnAble = false; var resultTxt = document.getElementById('result-wrap'); var chressBord = []; //棋盘 for (var i = 0; i < 15; i++) { chressBord[i] = []; for (var j = 0; j < 15; j++) { chressBord[i][j] = 0; } } //赢法的统计数组 var myWin = []; var computerWin = []; //赢法数组 var wins = []; for (var i = 0; i < 15; i++) { wins[i] = []; for (var j = 0; j < 15; j++) { wins[i][j] = []; } } var count = 0; //赢法总数 //横线赢法 for (var i = 0; i < 15; i++) { for (var j = 0; j < 11; j++) { for (var k = 0; k < 5; k++) { wins[i][j + k][count] = true; } count++; } } //竖线赢法 for (var i = 0; i < 15; i++) { for (var j = 0; j < 11; j++) { for (var k = 0; k < 5; k++) { wins[j + k][i][count] = true; } count++; } } //正斜线赢法 for (var i = 0; i < 11; i++) { for (var j = 0; j < 11; j++) { for (var k = 0; k < 5; k++) { wins[i + k][j + k][count] = true; } count++; } } //反斜线赢法 for (var i = 0; i < 11; i++) { for (var j = 14; j > 3; j--) { for (var k = 0; k < 5; k++) { wins[i + k][j - k][count] = true; } count++; } } // debugger; for (var i = 0; i < count; i++) { myWin[i] = 0; _myWin[i] = 0; computerWin[i] = 0; _compWin[i] = 0; } var chess = document.getElementById(\"chess\"); var context = chess.getContext('2d'); context.strokeStyle = '#bfbfbf'; //边框颜色 var backbtn = document.getElementById(\"goback\"); var returnbtn = document.getElementById(\"return\"); window.onload = function () { drawChessBoard(); // 画棋盘 } document.getElementById(\"restart\").onclick = function () { window.location.reload(); } // 我，下棋 chess.onclick = function (e) { if (over) { return; } if (!me) { return; } // 悔棋功能可用 backbtn.className = backbtn.className.replace(new RegExp(\"(\\\\s|^)unable(\\\\s|$)\"), \" \"); var x = e.offsetX; var y = e.offsetY; var i = Math.floor(x / 30); var j = Math.floor(y / 30); _nowi = i; _nowj = j; if (chressBord[i][j] == 0) { oneStep(i, j, me); chressBord[i][j] = 1; //我，已占位置 for (var k = 0; k < count; k++) { // 将可能赢的情况都加1 if (wins[i][j][k]) { // debugger; myWin[k]++; _compWin[k] = computerWin[k]; computerWin[k] = 6; //这个位置对方不可能赢了 if (myWin[k] == 5) { // window.alert('你赢了'); resultTxt.innerHTML = '恭喜，你赢了！'; over = true; } } } if (!over) { me = !me; computerAI(); } } } // 悔棋 backbtn.onclick = function (e) { if (!backAble) { return; } over = false; me = true; // resultTxt.innerHTML = 'emmmm，悔棋中'; // 撤销悔棋功能可用 returnbtn.className = returnbtn.className.replace(new RegExp(\"(\\\\s|^)unable(\\\\s|$)\"), \" \"); // 我，悔棋 chressBord[_nowi][_nowj] = 0; //我，已占位置 还原 minusStep(_nowi, _nowj); //销毁棋子 for (var k = 0; k < count; k++) { // 将可能赢的情况都减1 if (wins[_nowi][_nowj][k]) { myWin[k]--; computerWin[k] = _compWin[k]; //这个位置对方可能赢 } }// 计算机相应的悔棋 chressBord[_compi][_compj] = 0; //计算机，已占位置 还原 minusStep(_compi, _compj); //销毁棋子 for (var k = 0; k < count; k++) { // 将可能赢的情况都减1 if (wins[_compi][_compj][k]) { computerWin[k]--; myWin[k] = _myWin[i]; //这个位置对方可能赢 } } resultTxt.innerHTML = '--人机五子棋--'; returnAble = true; backAble = false; } // 撤销悔棋 returnbtn.onclick = function (e) { if (!returnAble) { return; } // 我，撤销悔棋 chressBord[_nowi][_nowj] = 1; //我，已占位置 oneStep(_nowi, _nowj, me); for (var k = 0; k < count; k++) { if (wins[_nowi][_nowj][k]) { myWin[k]++; _compWin[k] = computerWin[k]; computerWin[k] = 6; //这个位置对方不可能赢 } if (myWin[k] == 5) { resultTxt.innerHTML = '恭喜，你赢了！'; over = true; } }// 计算机撤销相应的悔棋 chressBord[_compi][_compj] = 2; //计算机，已占位置 oneStep(_compi, _compj, false); for (var k = 0; k < count; k++) { // 将可能赢的情况都减1 if (wins[_compi][_compj][k]) { computerWin[k]++; _myWin[k] = myWin[k]; myWin[k] = 6; //这个位置对方不可能赢 } if (computerWin[k] == 5) { resultTxt.innerHTML = '很遗憾，计算机赢了，继续加油哦！'; over = true; } } returnbtn.className += ' ' + 'unable'; returnAble = false; backAble = true; } // 计算机下棋 var computerAI = function () { var myScore = []; var computerScore = []; var max = 0; var u = 0, v = 0; for (var i = 0; i < 15; i++) { myScore[i] = []; computerScore[i] = []; for (var j = 0; j < 15; j++) { myScore[i][j] = 0; computerScore[i][j] = 0; } } for (var i = 0; i < 15; i++) { for (var j = 0; j < 15; j++) { if (chressBord[i][j] == 0) { for (var k = 0; k < count; k++) { if (wins[i][j][k]) { if (myWin[k] == 1) { myScore[i][j] += 200; } else if (myWin[k] == 2) { myScore[i][j] += 400; } else if (myWin[k] == 3) { myScore[i][j] += 2000; } else if (myWin[k] == 4) { myScore[i][j] += 10000; } if (computerWin[k] == 1) { computerScore[i][j] += 220; } else if (computerWin[k] == 2) { computerScore[i][j] += 420; } else if (computerWin[k] == 3) { computerScore[i][j] += 2100; } else if (computerWin[k] == 4) { computerScore[i][j] += 20000; } } } if (myScore[i][j] > max) { max = myScore[i][j]; u = i; v = j; } else if (myScore[i][j] == max) { if (computerScore[i][j] > computerScore[u][v]) { u = i; v = j; } } if (computerScore[i][j] > max) { max = computerScore[i][j]; u = i; v = j; } else if (computerScore[i][j] == max) { if (myScore[i][j] > myScore[u][v]) { u = i; v = j; } } } } } _compi = u; _compj = v; oneStep(u, v, false); chressBord[u][v] = 2;//计算机占据位置 for (var k = 0; k < count; k++) { if (wins[u][v][k]) { computerWin[k]++; _myWin[k] = myWin[k]; myWin[k] = 6; //这个位置对方不可能赢了 if (computerWin[k] == 5) { resultTxt.innerHTML = '很遗憾，计算机赢了，继续加油哦！'; over = true; } } } if (!over) { me = !me; } backAble = true; returnAble = false; var hasClass = new RegExp('unable').test(' ' + returnbtn.className + ' '); if (!hasClass) { returnbtn.className += ' ' + 'unable'; } } //绘画棋盘 var drawChessBoard = function () { for (var i = 0; i < 15; i++) { context.moveTo(15 + i * 30, 15); context.lineTo(15 + i * 30, 435); context.stroke(); context.moveTo(15, 15 + i * 30); context.lineTo(435, 15 + i * 30); context.stroke(); } } //画棋子 var oneStep = function (i, j, me) { context.beginPath(); context.arc(15 + i * 30, 15 + j * 30, 13, 0, 2 * Math.PI); // 画圆 context.closePath(); //渐变 var gradient = context.createRadialGradient(15 + i * 30 + 2, 15 + j * 30 - 2, 13, 15 + i * 30 + 2, 15 + j * 30 - 2, 0); if (me) { gradient.addColorStop(0, '#0a0a0a'); gradient.addColorStop(1, '#636766'); } else { gradient.addColorStop(0, '#d1d1d1'); gradient.addColorStop(1, '#f9f9f9'); } context.fillStyle = gradient; context.fill(); } //销毁棋子 var minusStep = function (i, j) { //擦除该圆 context.clearRect((i) * 30, (j) * 30, 30, 30); // 重画该圆周围的格子 context.beginPath(); context.moveTo(15 + i * 30, j * 30); context.lineTo(15 + i * 30, j * 30 + 30); context.moveTo(i * 30, j * 30 + 15); context.lineTo((i + 1) * 30, j * 30 + 15); context.stroke(); } Copyright&nbsp;©&nbsp;2022-至今&nbsp;YSLIVING'S HOME&nbsp;|&nbsp; &nbsp; 沪ICP备1******8号-X&nbsp;|&nbsp; 中国互联网违法和不良信息举报中心 推荐使用1920*1080分辨率、谷歌或者火狐浏览器浏览此页&nbsp;|&nbsp; 996.ICU&nbsp;|&nbsp; 申请友链&nbsp;|&nbsp; Powered By Hexo&nbsp;|&nbsp; Hosted By GitHub Pages 部分资料来源于网络，版权属于其合法持有人，只供学习交流之用，非商务用途。如有侵犯您的权益，请及时告知删除。互动交流时请遵守理性，宽容，换位思考的原则。 document.onkeydown=function (e){ var currKey=0,evt=e||window.event; currKey=evt.keyCode||evt.which||evt.charCode; if (currKey == 123) { window.event.cancelBubble = true; window.event.returnValue = false; } }"},{"title":"","date":"2021-09-08T22:25:28.555Z","updated":"2020-09-09T14:32:06.000Z","comments":true,"path":"about/sakura.js","permalink":"https://ysluckly.github.io/about/sakura.js","excerpt":"","text":"// Utilities var Vector3 = {}; var Matrix44 = {}; Vector3.create = function(x, y, z) { return {'x':x, 'y':y, 'z':z}; }; Vector3.dot = function (v0, v1) { return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z; }; Vector3.cross = function (v, v0, v1) { v.x = v0.y * v1.z - v0.z * v1.y; v.y = v0.z * v1.x - v0.x * v1.z; v.z = v0.x * v1.y - v0.y * v1.x; }; Vector3.normalize = function (v) { var l = v.x * v.x + v.y * v.y + v.z * v.z; if(l > 0.00001) { l = 1.0 / Math.sqrt(l); v.x *= l; v.y *= l; v.z *= l; } }; Vector3.arrayForm = function(v) { if(v.array) { v.array[0] = v.x; v.array[1] = v.y; v.array[2] = v.z; } else { v.array = new Float32Array([v.x, v.y, v.z]); } return v.array; }; Matrix44.createIdentity = function () { return new Float32Array([1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]); }; Matrix44.loadProjection = function (m, aspect, vdeg, near, far) { var h = near * Math.tan(vdeg * Math.PI / 180.0 * 0.5) * 2.0; var w = h * aspect; m[0] = 2.0 * near / w; m[1] = 0.0; m[2] = 0.0; m[3] = 0.0; m[4] = 0.0; m[5] = 2.0 * near / h; m[6] = 0.0; m[7] = 0.0; m[8] = 0.0; m[9] = 0.0; m[10] = -(far + near) / (far - near); m[11] = -1.0; m[12] = 0.0; m[13] = 0.0; m[14] = -2.0 * far * near / (far - near); m[15] = 0.0; }; Matrix44.loadLookAt = function (m, vpos, vlook, vup) { var frontv = Vector3.create(vpos.x - vlook.x, vpos.y - vlook.y, vpos.z - vlook.z); Vector3.normalize(frontv); var sidev = Vector3.create(1.0, 0.0, 0.0); Vector3.cross(sidev, vup, frontv); Vector3.normalize(sidev); var topv = Vector3.create(1.0, 0.0, 0.0); Vector3.cross(topv, frontv, sidev); Vector3.normalize(topv); m[0] = sidev.x; m[1] = topv.x; m[2] = frontv.x; m[3] = 0.0; m[4] = sidev.y; m[5] = topv.y; m[6] = frontv.y; m[7] = 0.0; m[8] = sidev.z; m[9] = topv.z; m[10] = frontv.z; m[11] = 0.0; m[12] = -(vpos.x * m[0] + vpos.y * m[4] + vpos.z * m[8]); m[13] = -(vpos.x * m[1] + vpos.y * m[5] + vpos.z * m[9]); m[14] = -(vpos.x * m[2] + vpos.y * m[6] + vpos.z * m[10]); m[15] = 1.0; }; // var timeInfo = { 'start':0, 'prev':0, // Date 'delta':0, 'elapsed':0 // Number(sec) }; // var gl; var renderSpec = { 'width':0, 'height':0, 'aspect':1, 'array':new Float32Array(3), 'halfWidth':0, 'halfHeight':0, 'halfArray':new Float32Array(3) // and some render targets. see setViewport() }; renderSpec.setSize = function(w, h) { renderSpec.width = w; renderSpec.height = h; renderSpec.aspect = renderSpec.width / renderSpec.height; renderSpec.array[0] = renderSpec.width; renderSpec.array[1] = renderSpec.height; renderSpec.array[2] = renderSpec.aspect; renderSpec.halfWidth = Math.floor(w / 2); renderSpec.halfHeight = Math.floor(h / 2); renderSpec.halfArray[0] = renderSpec.halfWidth; renderSpec.halfArray[1] = renderSpec.halfHeight; renderSpec.halfArray[2] = renderSpec.halfWidth / renderSpec.halfHeight; }; function deleteRenderTarget(rt) { gl.deleteFramebuffer(rt.frameBuffer); gl.deleteRenderbuffer(rt.renderBuffer); gl.deleteTexture(rt.texture); } function createRenderTarget(w, h) { var ret = { 'width':w, 'height':h, 'sizeArray':new Float32Array([w, h, w / h]), 'dtxArray':new Float32Array([1.0 / w, 1.0 / h]) }; ret.frameBuffer = gl.createFramebuffer(); ret.renderBuffer = gl.createRenderbuffer(); ret.texture = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, ret.texture); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.bindFramebuffer(gl.FRAMEBUFFER, ret.frameBuffer); gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, ret.texture, 0); gl.bindRenderbuffer(gl.RENDERBUFFER, ret.renderBuffer); gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w, h); gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, ret.renderBuffer); gl.bindTexture(gl.TEXTURE_2D, null); gl.bindRenderbuffer(gl.RENDERBUFFER, null); gl.bindFramebuffer(gl.FRAMEBUFFER, null); return ret; } function compileShader(shtype, shsrc) { var retsh = gl.createShader(shtype); gl.shaderSource(retsh, shsrc); gl.compileShader(retsh); if(!gl.getShaderParameter(retsh, gl.COMPILE_STATUS)) { var errlog = gl.getShaderInfoLog(retsh); gl.deleteShader(retsh); console.error(errlog); return null; } return retsh; } function createShader(vtxsrc, frgsrc, uniformlist, attrlist) { var vsh = compileShader(gl.VERTEX_SHADER, vtxsrc); var fsh = compileShader(gl.FRAGMENT_SHADER, frgsrc); if(vsh == null || fsh == null) { return null; } var prog = gl.createProgram(); gl.attachShader(prog, vsh); gl.attachShader(prog, fsh); gl.deleteShader(vsh); gl.deleteShader(fsh); gl.linkProgram(prog); if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) { var errlog = gl.getProgramInfoLog(prog); console.error(errlog); return null; } if(uniformlist) { prog.uniforms = {}; for(var i = 0; i < uniformlist.length; i++) { prog.uniforms[uniformlist[i]] = gl.getUniformLocation(prog, uniformlist[i]); } } if(attrlist) { prog.attributes = {}; for(var i = 0; i < attrlist.length; i++) { var attr = attrlist[i]; prog.attributes[attr] = gl.getAttribLocation(prog, attr); } } return prog; } function useShader(prog) { gl.useProgram(prog); for(var attr in prog.attributes) { gl.enableVertexAttribArray(prog.attributes[attr]);; } } function unuseShader(prog) { for(var attr in prog.attributes) { gl.disableVertexAttribArray(prog.attributes[attr]);; } gl.useProgram(null); } ///// var projection = { 'angle':60, 'nearfar':new Float32Array([0.1, 100.0]), 'matrix':Matrix44.createIdentity() }; var camera = { 'position':Vector3.create(0, 0, 100), 'lookat':Vector3.create(0, 0, 0), 'up':Vector3.create(0, 1, 0), 'dof':Vector3.create(10.0, 4.0, 8.0), 'matrix':Matrix44.createIdentity() }; var pointFlower = {}; var meshFlower = {}; var sceneStandBy = false; var BlossomParticle = function () { this.velocity = new Array(3); this.rotation = new Array(3); this.position = new Array(3); this.euler = new Array(3); this.size = 1.0; this.alpha = 1.0; this.zkey = 0.0; }; BlossomParticle.prototype.setVelocity = function (vx, vy, vz) { this.velocity[0] = vx; this.velocity[1] = vy; this.velocity[2] = vz; }; BlossomParticle.prototype.setRotation = function (rx, ry, rz) { this.rotation[0] = rx; this.rotation[1] = ry; this.rotation[2] = rz; }; BlossomParticle.prototype.setPosition = function (nx, ny, nz) { this.position[0] = nx; this.position[1] = ny; this.position[2] = nz; }; BlossomParticle.prototype.setEulerAngles = function (rx, ry, rz) { this.euler[0] = rx; this.euler[1] = ry; this.euler[2] = rz; }; BlossomParticle.prototype.setSize = function (s) { this.size = s; }; BlossomParticle.prototype.update = function (dt, et) { this.position[0] += this.velocity[0] * dt; this.position[1] += this.velocity[1] * dt; this.position[2] += this.velocity[2] * dt; this.euler[0] += this.rotation[0] * dt; this.euler[1] += this.rotation[1] * dt; this.euler[2] += this.rotation[2] * dt; }; function createPointFlowers() { // get point sizes var prm = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE); renderSpec.pointSize = {'min':prm[0], 'max':prm[1]}; var vtxsrc = document.getElementById(\"sakura_point_vsh\").textContent; var frgsrc = document.getElementById(\"sakura_point_fsh\").textContent; pointFlower.program = createShader( vtxsrc, frgsrc, ['uProjection', 'uModelview', 'uResolution', 'uOffset', 'uDOF', 'uFade'], ['aPosition', 'aEuler', 'aMisc'] ); useShader(pointFlower.program); pointFlower.offset = new Float32Array([0.0, 0.0, 0.0]); pointFlower.fader = Vector3.create(0.0, 10.0, 0.0); // paramerters: velocity[3], rotate[3] pointFlower.numFlowers = 1600; pointFlower.particles = new Array(pointFlower.numFlowers); // vertex attributes {position[3], euler_xyz[3], size[1]} pointFlower.dataArray = new Float32Array(pointFlower.numFlowers * (3 + 3 + 2)); pointFlower.positionArrayOffset = 0; pointFlower.eulerArrayOffset = pointFlower.numFlowers * 3; pointFlower.miscArrayOffset = pointFlower.numFlowers * 6; pointFlower.buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, pointFlower.buffer); gl.bufferData(gl.ARRAY_BUFFER, pointFlower.dataArray, gl.DYNAMIC_DRAW); gl.bindBuffer(gl.ARRAY_BUFFER, null); unuseShader(pointFlower.program); for(var i = 0; i < pointFlower.numFlowers; i++) { pointFlower.particles[i] = new BlossomParticle(); } } function initPointFlowers() { //area pointFlower.area = Vector3.create(20.0, 20.0, 20.0); pointFlower.area.x = pointFlower.area.y * renderSpec.aspect; pointFlower.fader.x = 10.0; //env fade start pointFlower.fader.y = pointFlower.area.z; //env fade half pointFlower.fader.z = 0.1; //near fade start //particles var PI2 = Math.PI * 2.0; var tmpv3 = Vector3.create(0, 0, 0); var tmpv = 0; var symmetryrand = function() {return (Math.random() * 2.0 - 1.0);}; for(var i = 0; i < pointFlower.numFlowers; i++) { var tmpprtcl = pointFlower.particles[i]; //velocity tmpv3.x = symmetryrand() * 0.3 + 0.8; tmpv3.y = symmetryrand() * 0.2 - 1.0; tmpv3.z = symmetryrand() * 0.3 + 0.5; Vector3.normalize(tmpv3); tmpv = 2.0 + Math.random() * 1.0; tmpprtcl.setVelocity(tmpv3.x * tmpv, tmpv3.y * tmpv, tmpv3.z * tmpv); //rotation tmpprtcl.setRotation( symmetryrand() * PI2 * 0.5, symmetryrand() * PI2 * 0.5, symmetryrand() * PI2 * 0.5 ); //position tmpprtcl.setPosition( symmetryrand() * pointFlower.area.x, symmetryrand() * pointFlower.area.y, symmetryrand() * pointFlower.area.z ); //euler tmpprtcl.setEulerAngles( Math.random() * Math.PI * 2.0, Math.random() * Math.PI * 2.0, Math.random() * Math.PI * 2.0 ); //size tmpprtcl.setSize(0.9 + Math.random() * 0.1); } } function renderPointFlowers() { //update var PI2 = Math.PI * 2.0; var limit = [pointFlower.area.x, pointFlower.area.y, pointFlower.area.z]; var repeatPos = function (prt, cmp, limit) { if(Math.abs(prt.position[cmp]) - prt.size * 0.5 > limit) { //out of area if(prt.position[cmp] > 0) { prt.position[cmp] -= limit * 2.0; } else { prt.position[cmp] += limit * 2.0; } } }; var repeatEuler = function (prt, cmp) { prt.euler[cmp] = prt.euler[cmp] % PI2; if(prt.euler[cmp] < 0.0) { prt.euler[cmp] += PI2; } }; for(var i = 0; i < pointFlower.numFlowers; i++) { var prtcl = pointFlower.particles[i]; prtcl.update(timeInfo.delta, timeInfo.elapsed); repeatPos(prtcl, 0, pointFlower.area.x); repeatPos(prtcl, 1, pointFlower.area.y); repeatPos(prtcl, 2, pointFlower.area.z); repeatEuler(prtcl, 0); repeatEuler(prtcl, 1); repeatEuler(prtcl, 2); prtcl.alpha = 1.0;//(pointFlower.area.z - prtcl.position[2]) * 0.5; prtcl.zkey = (camera.matrix[2] * prtcl.position[0] + camera.matrix[6] * prtcl.position[1] + camera.matrix[10] * prtcl.position[2] + camera.matrix[14]); } // sort pointFlower.particles.sort(function(p0, p1){return p0.zkey - p1.zkey;}); // update data var ipos = pointFlower.positionArrayOffset; var ieuler = pointFlower.eulerArrayOffset; var imisc = pointFlower.miscArrayOffset; for(var i = 0; i < pointFlower.numFlowers; i++) { var prtcl = pointFlower.particles[i]; pointFlower.dataArray[ipos] = prtcl.position[0]; pointFlower.dataArray[ipos + 1] = prtcl.position[1]; pointFlower.dataArray[ipos + 2] = prtcl.position[2]; ipos += 3; pointFlower.dataArray[ieuler] = prtcl.euler[0]; pointFlower.dataArray[ieuler + 1] = prtcl.euler[1]; pointFlower.dataArray[ieuler + 2] = prtcl.euler[2]; ieuler += 3; pointFlower.dataArray[imisc] = prtcl.size; pointFlower.dataArray[imisc + 1] = prtcl.alpha; imisc += 2; } //draw gl.enable(gl.BLEND); //gl.disable(gl.DEPTH_TEST); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); var prog = pointFlower.program; useShader(prog); gl.uniformMatrix4fv(prog.uniforms.uProjection, false, projection.matrix); gl.uniformMatrix4fv(prog.uniforms.uModelview, false, camera.matrix); gl.uniform3fv(prog.uniforms.uResolution, renderSpec.array); gl.uniform3fv(prog.uniforms.uDOF, Vector3.arrayForm(camera.dof)); gl.uniform3fv(prog.uniforms.uFade, Vector3.arrayForm(pointFlower.fader)); gl.bindBuffer(gl.ARRAY_BUFFER, pointFlower.buffer); gl.bufferData(gl.ARRAY_BUFFER, pointFlower.dataArray, gl.DYNAMIC_DRAW); gl.vertexAttribPointer(prog.attributes.aPosition, 3, gl.FLOAT, false, 0, pointFlower.positionArrayOffset * Float32Array.BYTES_PER_ELEMENT); gl.vertexAttribPointer(prog.attributes.aEuler, 3, gl.FLOAT, false, 0, pointFlower.eulerArrayOffset * Float32Array.BYTES_PER_ELEMENT); gl.vertexAttribPointer(prog.attributes.aMisc, 2, gl.FLOAT, false, 0, pointFlower.miscArrayOffset * Float32Array.BYTES_PER_ELEMENT); // doubler for(var i = 1; i < 2; i++) { var zpos = i * -2.0; pointFlower.offset[0] = pointFlower.area.x * -1.0; pointFlower.offset[1] = pointFlower.area.y * -1.0; pointFlower.offset[2] = pointFlower.area.z * zpos; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset); gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers); pointFlower.offset[0] = pointFlower.area.x * -1.0; pointFlower.offset[1] = pointFlower.area.y * 1.0; pointFlower.offset[2] = pointFlower.area.z * zpos; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset); gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers); pointFlower.offset[0] = pointFlower.area.x * 1.0; pointFlower.offset[1] = pointFlower.area.y * -1.0; pointFlower.offset[2] = pointFlower.area.z * zpos; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset); gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers); pointFlower.offset[0] = pointFlower.area.x * 1.0; pointFlower.offset[1] = pointFlower.area.y * 1.0; pointFlower.offset[2] = pointFlower.area.z * zpos; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset); gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers); } //main pointFlower.offset[0] = 0.0; pointFlower.offset[1] = 0.0; pointFlower.offset[2] = 0.0; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset); gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers); gl.bindBuffer(gl.ARRAY_BUFFER, null); unuseShader(prog); gl.enable(gl.DEPTH_TEST); gl.disable(gl.BLEND); } // effects //common util function createEffectProgram(vtxsrc, frgsrc, exunifs, exattrs) { var ret = {}; var unifs = ['uResolution', 'uSrc', 'uDelta']; if(exunifs) { unifs = unifs.concat(exunifs); } var attrs = ['aPosition']; if(exattrs) { attrs = attrs.concat(exattrs); } ret.program = createShader(vtxsrc, frgsrc, unifs, attrs); useShader(ret.program); ret.dataArray = new Float32Array([ -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0 ]); ret.buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, ret.buffer); gl.bufferData(gl.ARRAY_BUFFER, ret.dataArray, gl.STATIC_DRAW); gl.bindBuffer(gl.ARRAY_BUFFER, null); unuseShader(ret.program); return ret; } // basic usage // useEffect(prog, srctex({'texture':texid, 'dtxArray':(f32)[dtx, dty]})); //basic initialize // gl.uniform**(...); //additional uniforms // drawEffect() // unuseEffect(prog) // TEXTURE0 makes src function useEffect(fxobj, srctex) { var prog = fxobj.program; useShader(prog); gl.uniform3fv(prog.uniforms.uResolution, renderSpec.array); if(srctex != null) { gl.uniform2fv(prog.uniforms.uDelta, srctex.dtxArray); gl.uniform1i(prog.uniforms.uSrc, 0); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, srctex.texture); } } function drawEffect(fxobj) { gl.bindBuffer(gl.ARRAY_BUFFER, fxobj.buffer); gl.vertexAttribPointer(fxobj.program.attributes.aPosition, 2, gl.FLOAT, false, 0, 0); gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); } function unuseEffect(fxobj) { unuseShader(fxobj.program); } var effectLib = {}; function createEffectLib() { var vtxsrc, frgsrc; //common var cmnvtxsrc = document.getElementById(\"fx_common_vsh\").textContent; //background frgsrc = document.getElementById(\"bg_fsh\").textContent; effectLib.sceneBg = createEffectProgram(cmnvtxsrc, frgsrc, ['uTimes'], null); // make brightpixels buffer frgsrc = document.getElementById(\"fx_brightbuf_fsh\").textContent; effectLib.mkBrightBuf = createEffectProgram(cmnvtxsrc, frgsrc, null, null); // direction blur frgsrc = document.getElementById(\"fx_dirblur_r4_fsh\").textContent; effectLib.dirBlur = createEffectProgram(cmnvtxsrc, frgsrc, ['uBlurDir'], null); //final composite vtxsrc = document.getElementById(\"pp_final_vsh\").textContent; frgsrc = document.getElementById(\"pp_final_fsh\").textContent; effectLib.finalComp = createEffectProgram(vtxsrc, frgsrc, ['uBloom'], null); } // background function createBackground() { //console.log(\"create background\"); } function initBackground() { //console.log(\"init background\"); } function renderBackground() { gl.disable(gl.DEPTH_TEST); useEffect(effectLib.sceneBg, null); gl.uniform2f(effectLib.sceneBg.program.uniforms.uTimes, timeInfo.elapsed, timeInfo.delta); drawEffect(effectLib.sceneBg); unuseEffect(effectLib.sceneBg); gl.enable(gl.DEPTH_TEST); } // post process var postProcess = {}; function createPostProcess() { //console.log(\"create post process\"); } function initPostProcess() { //console.log(\"init post process\"); } function renderPostProcess() { gl.enable(gl.TEXTURE_2D); gl.disable(gl.DEPTH_TEST); var bindRT = function (rt, isclear) { gl.bindFramebuffer(gl.FRAMEBUFFER, rt.frameBuffer); gl.viewport(0, 0, rt.width, rt.height); if(isclear) { gl.clearColor(0, 0, 0, 0); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); } }; //make bright buff bindRT(renderSpec.wHalfRT0, true); useEffect(effectLib.mkBrightBuf, renderSpec.mainRT); drawEffect(effectLib.mkBrightBuf); unuseEffect(effectLib.mkBrightBuf); // make bloom for(var i = 0; i < 2; i++) { var p = 1.5 + 1 * i; var s = 2.0 + 1 * i; bindRT(renderSpec.wHalfRT1, true); useEffect(effectLib.dirBlur, renderSpec.wHalfRT0); gl.uniform4f(effectLib.dirBlur.program.uniforms.uBlurDir, p, 0.0, s, 0.0); drawEffect(effectLib.dirBlur); unuseEffect(effectLib.dirBlur); bindRT(renderSpec.wHalfRT0, true); useEffect(effectLib.dirBlur, renderSpec.wHalfRT1); gl.uniform4f(effectLib.dirBlur.program.uniforms.uBlurDir, 0.0, p, 0.0, s); drawEffect(effectLib.dirBlur); unuseEffect(effectLib.dirBlur); } //display gl.bindFramebuffer(gl.FRAMEBUFFER, null); gl.viewport(0, 0, renderSpec.width, renderSpec.height); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); useEffect(effectLib.finalComp, renderSpec.mainRT); gl.uniform1i(effectLib.finalComp.program.uniforms.uBloom, 1); gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, renderSpec.wHalfRT0.texture); drawEffect(effectLib.finalComp); unuseEffect(effectLib.finalComp); gl.enable(gl.DEPTH_TEST); } ///// var SceneEnv = {}; function createScene() { createEffectLib(); createBackground(); createPointFlowers(); createPostProcess(); sceneStandBy = true; } function initScene() { initBackground(); initPointFlowers(); initPostProcess(); //camera.position.z = 17.320508; camera.position.z = pointFlower.area.z + projection.nearfar[0]; projection.angle = Math.atan2(pointFlower.area.y, camera.position.z + pointFlower.area.z) * 180.0 / Math.PI * 2.0; Matrix44.loadProjection(projection.matrix, renderSpec.aspect, projection.angle, projection.nearfar[0], projection.nearfar[1]); } function renderScene() { //draw Matrix44.loadLookAt(camera.matrix, camera.position, camera.lookat, camera.up); gl.enable(gl.DEPTH_TEST); //gl.bindFramebuffer(gl.FRAMEBUFFER, null); gl.bindFramebuffer(gl.FRAMEBUFFER, renderSpec.mainRT.frameBuffer); gl.viewport(0, 0, renderSpec.mainRT.width, renderSpec.mainRT.height); gl.clearColor(0.005, 0, 0.05, 0); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); renderBackground(); renderPointFlowers(); renderPostProcess(); } ///// function onResize(e) { makeCanvasFullScreen(document.getElementById(\"sakura\")); setViewports(); if(sceneStandBy) { initScene(); } } function setViewports() { renderSpec.setSize(gl.canvas.width, gl.canvas.height); gl.clearColor(0.2, 0.2, 0.5, 1.0); gl.viewport(0, 0, renderSpec.width, renderSpec.height); var rtfunc = function (rtname, rtw, rth) { var rt = renderSpec[rtname]; if(rt) deleteRenderTarget(rt); renderSpec[rtname] = createRenderTarget(rtw, rth); }; rtfunc('mainRT', renderSpec.width, renderSpec.height); rtfunc('wFullRT0', renderSpec.width, renderSpec.height); rtfunc('wFullRT1', renderSpec.width, renderSpec.height); rtfunc('wHalfRT0', renderSpec.halfWidth, renderSpec.halfHeight); rtfunc('wHalfRT1', renderSpec.halfWidth, renderSpec.halfHeight); } function render() { renderScene(); } var animating = true; function toggleAnimation(elm) { animating ^= true; if(animating) animate(); if(elm) { elm.innerHTML = animating? \"Stop\":\"Start\"; } } function stepAnimation() { if(!animating) animate(); } function animate() { var curdate = new Date(); timeInfo.elapsed = (curdate - timeInfo.start) / 1000.0; timeInfo.delta = (curdate - timeInfo.prev) / 1000.0; timeInfo.prev = curdate; if(animating) requestAnimationFrame(animate); render(); } function makeCanvasFullScreen(canvas) { var b = document.body; var d = document.documentElement; fullw = Math.max(b.clientWidth , b.scrollWidth, d.scrollWidth, d.clientWidth); fullh = Math.max(b.clientHeight , b.scrollHeight, d.scrollHeight, d.clientHeight); canvas.width = fullw; canvas.height = fullh; } window.addEventListener('load', function(e) { var canvas = document.getElementById(\"sakura\"); try { makeCanvasFullScreen(canvas); gl = canvas.getContext('experimental-webgl'); } catch(e) { alert(\"WebGL not supported.\" + e); console.error(e); return; } window.addEventListener('resize', onResize); setViewports(); createScene(); initScene(); timeInfo.start = new Date(); timeInfo.prev = timeInfo.start; animate(); }); //set window.requestAnimationFrame (function (w, r) { w['r'+r] = w['r'+r] || w['webkitR'+r] || w['mozR'+r] || w['msR'+r] || w['oR'+r] || function(c){ w.setTimeout(c, 1000 / 60); }; })(window, 'equestAnimationFrame');"}],"posts":[{"title":"MySQL数据库面试题","slug":"database/1645799276221","date":"2022-03-03T07:29:32.000Z","updated":"2022-02-25T15:57:28.031Z","comments":true,"path":"2022/03/03/mysql/","link":"","permalink":"https://ysluckly.github.io/2022/03/03/mysql/","excerpt":"","text":"文章目录 数据库基础知识 为什么要使用数据库 什么是SQL？ 什么是MySQL? 数据库三大范式是什么 mysql有关权限的表都有哪几个 MySQL的binlog有有几种录入格式？分别有什么区别？ 数据类型 mysql有哪些数据类型 引擎 MySQL存储引擎MyISAM与InnoDB区别 MyISAM索引与InnoDB索引的区别？ InnoDB引擎的4大特性 存储引擎选择 索引 什么是索引？ 索引有哪些优缺点？ 索引使用场景（重点） 索引有哪几种类型？ 索引的数据结构（b树，hash） 索引的基本原理 索引算法有哪些？ 索引设计的原则？ 创建索引的原则（重中之重） 创建索引的三种方式，删除索引 创建索引时需要注意什么？ 使用索引查询一定能提高查询的性能吗？为什么 百万级别或以上的数据如何删除 前缀索引 什么是最左前缀原则？什么是最左匹配原则 B树和B+树的区别 使用B树的好处 使用B+树的好处 Hash索引和B+树所有有什么区别或者说优劣呢? 数据库为什么使用B+树而不是B树 B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据， 什么是聚簇索引？何时使用聚簇索引与非聚簇索引 非聚簇索引一定会回表查询吗？ 联合索引是什么？为什么需要注意联合索引中的顺序？ 事务 什么是数据库事务？ 事物的四大特性(ACID)介绍一下? 什么是脏读？幻读？不可重复读？ 什么是事务的隔离级别？MySQL的默认隔离级别是什么？ 锁 对MySQL的锁了解吗 隔离级别与锁的关系 按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法 从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了 MySQL中InnoDB引擎的行锁是怎么实现的？ InnoDB存储引擎的锁的算法有三种 什么是死锁？怎么解决？ 数据库的乐观锁和悲观锁是什么？怎么实现的？ 视图 为什么要使用视图？什么是视图？ 视图有哪些特点？ 视图的使用场景有哪些？ 视图的优点 视图的缺点 什么是游标？ 存储过程与函数 什么是存储过程？有哪些优缺点？ 触发器 什么是触发器？触发器的使用场景有哪些？ MySQL中都有哪些触发器？ 常用SQL语句 SQL语句主要分为哪几类 超键、候选键、主键、外键分别是什么？ SQL 约束有哪几种？ 六种关联查询 什么是子查询 子查询的三种情况 mysql中 in 和 exists 区别 varchar与char的区别 varchar(50)中50的涵义 int(20)中20的涵义 mysql为什么这么设计 mysql中int(10)和char(10)以及varchar(10)的区别 FLOAT和DOUBLE的区别是什么？ drop、delete与truncate的区别 UNION与UNION ALL的区别？ SQL优化 如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？ SQL的生命周期？ 大表数据查询，怎么优化 超大分页怎么处理？ mysql 分页 慢查询日志 关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？ 为什么要尽量设定一个主键？ 主键使用自增ID还是UUID？ 字段为什么要求定义为not null？ 如果要存储用户的密码散列，应该使用什么字段进行存储？ 优化查询过程中的数据访问 优化长难的查询语句 优化特定类型的查询语句 优化关联查询 优化子查询 优化LIMIT分页 优化UNION查询 优化WHERE子句 数据库优化 为什么要优化 数据库结构优化 MySQL数据库cpu飙升到500%的话他怎么处理？ 大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？ 垂直分表 适用场景 缺点 水平分表： 适用场景 水平切分的缺点 MySQL的复制原理以及流程 读写分离有哪些解决方案？ 备份计划，mysqldump以及xtranbackup的实现原理 数据表损坏的修复方式有哪些？ Java面试总结汇总，整理了包括Java基础知识，集合容器，并发编程，JVM，常用开源框架Spring，MyBatis，数据库，中间件等，包含了作为一个Java工程师在面试中需要用到或者可能用到的绝大部分知识。欢迎大家阅读，本人见识有限，写的博客难免有错误或者疏忽的地方，还望各位大佬指点，在此表示感激不尽。文章持续更新中… 序号 内容 链接地址 1 Java基础知识面试题（2020最新版） https://thinkwon.blog.csdn.net/article/details/104390612 2 Java集合容器面试题（2020最新版） https://thinkwon.blog.csdn.net/article/details/104588551 3 Java异常面试题（2020最新版） https://thinkwon.blog.csdn.net/article/details/104390689 4 并发编程面试题（2020最新版） https://thinkwon.blog.csdn.net/article/details/104863992 5 JVM面试题（2020最新版） https://thinkwon.blog.csdn.net/article/details/104390752 6 Spring面试题（2020最新版） https://thinkwon.blog.csdn.net/article/details/104397516 7 Spring MVC面试题（2020最新版） https://thinkwon.blog.csdn.net/article/details/104397427 8 Spring Boot面试题（2020最新版） https://thinkwon.blog.csdn.net/article/details/104397299 9 Spring Cloud面试题（2020最新版） https://thinkwon.blog.csdn.net/article/details/104397367 10 MyBatis面试题（2020最新版） https://thinkwon.blog.csdn.net/article/details/101292950 11 Redis面试题（2020最新版） https://thinkwon.blog.csdn.net/article/details/103522351 12 MySQL数据库面试题（2020最新版） https://thinkwon.blog.csdn.net/article/details/104778621 13 消息中间件MQ与RabbitMQ面试题（2020最新版） https://thinkwon.blog.csdn.net/article/details/104588612 14 Dubbo面试题（2020最新版） https://thinkwon.blog.csdn.net/article/details/104390006 15 Linux面试题（2020最新版） https://thinkwon.blog.csdn.net/article/details/104588679 16 Tomcat面试题（2020最新版） https://thinkwon.blog.csdn.net/article/details/104397665 17 ZooKeeper面试题（2020最新版） https://thinkwon.blog.csdn.net/article/details/104397719 18 Netty面试题（2020最新版） https://thinkwon.blog.csdn.net/article/details/104391081 19 架构设计&amp;分布式&amp;数据结构与算法面试题（2020最新版） https://thinkwon.blog.csdn.net/article/details/105870730 数据库基础知识为什么要使用数据库数据保存在内存 优点： 存取速度快 缺点： 数据不能永久保存 数据保存在文件 优点： 数据永久保存 缺点：1）速度比内存操作慢，频繁的IO操作。2）查询数据不方便 数据保存在数据库 1）数据永久保存 2）使用SQL语句，查询方便效率高。 3）管理数据方便 什么是SQL？结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。 作用：用于存取数据、查询、更新和管理关系数据库系统。 什么是MySQL?MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。 数据库三大范式是什么第一范式：每个列都不可以再拆分。 第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。 第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。 在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。 mysql有关权限的表都有哪几个MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容： user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。 db权限表：记录各个帐号在各个数据库上的操作权限。 table_priv权限表：记录数据表级的操作权限。 columns_priv权限表：记录数据列级的操作权限。 host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。 MySQL的binlog有有几种录入格式？分别有什么区别？有三种格式，statement，row和mixed。 statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。 row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。 mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。 此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。 数据类型mysql有哪些数据类型 分类 类型名称 说明 整数类型 tinyInt 很小的整数(8位二进制) smallint 小的整数(16位二进制) mediumint 中等大小的整数(24位二进制) int(integer) 普通大小的整数(32位二进制) 小数类型 float 单精度浮点数 double 双精度浮点数 decimal(m,d) 压缩严格的定点数 日期类型 year YYYY 1901~2155 time HH:MM:SS -838:59:59~838:59:59 date YYYY-MM-DD 1000-01-01~9999-12-3 datetime YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59 timestamp YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC 文本、二进制类型 CHAR(M) M为0~255之间的整数 VARCHAR(M) M为0~65535之间的整数 TINYBLOB 允许长度0~255字节 BLOB 允许长度0~65535字节 MEDIUMBLOB 允许长度0~167772150字节 LONGBLOB 允许长度0~4294967295字节 TINYTEXT 允许长度0~255字节 TEXT 允许长度0~65535字节 MEDIUMTEXT 允许长度0~167772150字节 LONGTEXT 允许长度0~4294967295字节 VARBINARY(M) 允许长度0~M个字节的变长字节字符串 BINARY(M) 允许长度0~M个字节的定长字节字符串 1、整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。 长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。 例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。 2、实数类型，包括FLOAT、DOUBLE、DECIMAL。 DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。 而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。 计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。 3、字符串类型，包括VARCHAR、CHAR、TEXT、BLOB VARCHAR用于存储可变长字符串，它比定长类型更节省空间。 VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。 VARCHAR存储的内容超出设置的长度时，内容会被截断。 CHAR是定长的，根据定义的字符串长度分配足够的空间。 CHAR会根据需要使用空格进行填充方便比较。 CHAR适合存储很短的字符串，或者所有值都接近同一个长度。 CHAR存储的内容超出设置的长度时，内容同样会被截断。 使用策略： 对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。 对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。 使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。 尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。 4、枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。 有时可以使用ENUM代替常用的字符串类型。 ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。 ENUM在内部存储时，其实存的是整数。 尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。 排序是按照内部存储的整数 5、日期和时间类型，尽量使用timestamp，空间效率高于datetime， 用整数保存时间戳通常不方便处理。 如果需要存储微妙，可以使用bigint存储。 看到这里，这道真题是不是就比较容易回答了。 引擎MySQL存储引擎MyISAM与InnoDB区别存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。 常用的存储引擎有以下： Innodb引擎：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。 MyIASM引擎(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。 MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。 MyISAM与InnoDB区别 MyISAM Innodb 存储结构 每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件 所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB 存储空间 MyISAM可被压缩，存储空间较小 InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引 可移植性、备份及恢复 由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作 免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了 文件格式 数据和索引是分别存储的，数据.MYD，索引.MYI 数据和索引是集中存储的，.ibd 记录存储顺序 按记录插入顺序保存 按主键大小有序插入 外键 不支持 支持 事务 不支持 支持 锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的） 表级锁定 行级锁定、表级锁定，锁定力度小并发能力高 SELECT MyISAM更优 INSERT、UPDATE、DELETE InnoDB更优 select count(*) myisam更快，因为myisam内部维护了一个计数器，可以直接调取。 索引的实现方式 B+树索引，myisam 是堆表 B+树索引，Innodb 是索引组织表 哈希索引 不支持 支持 全文索引 支持 不支持 MyISAM索引与InnoDB索引的区别？ InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。 InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。 MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。 InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。 InnoDB引擎的4大特性 插入缓冲（insert buffer) 二次写(double write) 自适应哈希索引(ahi) 预读(read ahead) 存储引擎选择如果没有特别的需求，使用默认的Innodb即可。 MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。 Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。 索引什么是索引？索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。 索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。 更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。 索引有哪些优缺点？索引的优点 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 索引的缺点 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率； 空间方面：索引需要占物理空间。 索引使用场景（重点）where 上图中，根据id查询记录，因为id字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。 -- 增加一个没有建立索引的字段 alter table innodb1 add sex char(1); -- 按sex检索时可选的索引为null EXPLAIN SELECT * from innodb1 where sex=&#39;男&#39;; 可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（alter table 表名 add index(字段名)），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。 order by 当我们使用order by将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。 但是如果我们对该字段建立索引alter table 表名 add index(字段名)，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用取出索引表某个范围内的索引对应的数据，而不用像上述那取出所有数据进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的） join 对join语句匹配关系（on）涉及的字段建立索引能够提高效率 索引覆盖 如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。 这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。 索引有哪几种类型？主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。 唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。 可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引 可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索引 普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。 可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引 可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);创建组合索引 全文索引： 是目前搜索引擎使用的一种关键技术。 可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引 索引的数据结构（b树，hash）索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。 1）B树索引 mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引） 查询方式： 主键索引区:PI(关联保存的时数据的地址)按主键查询, 普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快 B+tree性质： 1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。 2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。 4.）B+ 树中，数据对象的插入和删除仅在叶节点上进行。 5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。 2）哈希索引 简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。 索引的基本原理索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。 索引的原理很简单，就是把无序的数据变成有序的查询 把创建了索引的列的内容进行排序 对排序结果生成倒排表 在倒排表内容上拼上数据地址链 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据 索引算法有哪些？索引算法有 BTree算法和Hash算法 BTree算法 BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如： -- 只要它的查询条件是一个不以通配符开头的常量 select * from user where name like &#39;jack%&#39;; -- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： select * from user where name like &#39;%jack&#39;; Hash算法 Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。 索引设计的原则？ 适合索引的列是出现在where子句中的列，或者连接子句中指定的列 基数较小的类，索引效果较差，没有必要在此列建立索引 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。 创建索引的原则（重中之重）索引虽好，但也不是无限制的使用，最好符合一下几个原则 1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 2）较频繁作为查询条件的字段才去创建索引 3）更新频繁字段不适合创建索引 4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低) 5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。 6）定义有外键的数据列一定要建立索引。 7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。 8）对于定义为text、image和bit的数据类型的列不要建立索引。 创建索引的三种方式，删除索引第一种方式：在执行CREATE TABLE时创建索引 CREATE TABLE user_index2 ( id INT auto_increment PRIMARY KEY, first_name VARCHAR (16), last_name VARCHAR (16), id_card VARCHAR (18), information text, KEY name (first_name, last_name), FULLTEXT KEY (information), UNIQUE KEY (id_card) ); 第二种方式：使用ALTER TABLE命令去增加索引 ALTER TABLE table_name ADD INDEX index_name (column_list); ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。 其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。 索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。 第三种方式：使用CREATE INDEX命令创建 CREATE INDEX index_name ON table_name (column_list); CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引） 删除索引 根据索引名删除普通索引、唯一索引、全文索引：alter table 表名 drop KEY 索引名 alter table user_index drop KEY name; alter table user_index drop KEY id_card; alter table user_index drop KEY information; 删除主键索引：alter table 表名 drop primary key（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）： 需要取消自增长再行删除： alter table user_index -- 重新定义字段 MODIFY id int, drop PRIMARY KEY 但通常不会删除主键，因为设计主键一定与业务逻辑无关。 创建索引时需要注意什么？ 非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值； 取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高； 索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。 使用索引查询一定能提高查询的性能吗？为什么通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。 索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况: 基于一个范围的检索，一般查询返回结果集小于表中记录数的30% 基于非唯一性索引的检索 百万级别或以上的数据如何删除关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。 所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟） 然后删除其中无用数据（此过程需要不到两分钟） 删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。 与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。 前缀索引语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。 前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。 实操的难度：在于前缀截取的长度。 我们可以利用select count(*)/count(distinct left(password,prefixLen));，通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录） 什么是最左前缀原则？什么是最左匹配原则 顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式 B树和B+树的区别 在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。 B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。 使用B树的好处B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。 使用B+树的好处由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间 Hash索引和B+树所有有什么区别或者说优劣呢?首先要知道Hash索引和B+树索引的底层实现原理： hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。 那么可以看出他们有以下的不同： hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。 因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。 hash索引不支持使用索引进行排序，原理同上。 hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。 hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。 hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。 因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。 数据库为什么使用B+树而不是B树 B树只适合随机检索，而B+树同时支持随机检索和顺序检索； B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素； B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。 B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。 增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。 B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。 当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。 什么是聚簇索引？何时使用聚簇索引与非聚簇索引 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因 澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值 何时使用聚簇索引与非聚簇索引 非聚簇索引一定会回表查询吗？不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。 举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。 联合索引是什么？为什么需要注意联合索引中的顺序？MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。 具体原因为: MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。 当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。 事务什么是数据库事务？事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。 事务最经典也经常被拿出来说例子就是转账了。 假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。 事物的四大特性(ACID)介绍一下?关系性数据库需要遵循ACID规则，具体内容如下： 原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的； 隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 什么是脏读？幻读？不可重复读？ 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。 不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。 幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。 什么是事务的隔离级别？MySQL的默认隔离级别是什么？为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。 隔离级别 脏读 不可重复读 幻影读 READ-UNCOMMITTED √ √ √ READ-COMMITTED × √ √ REPEATABLE-READ × × √ SERIALIZABLE × × × SQL 标准定义了四个隔离级别： READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别 事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。 因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是*READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 \\*REPEATABLE-READ（可重读）**并不会有任何性能损失。 InnoDB 存储引擎在 分布式事务 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。 锁对MySQL的锁了解吗当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。 就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。 隔离级别与锁的关系在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突 在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁； 在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。 SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。 按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。 MyISAM和InnoDB存储引擎使用的锁： MyISAM采用表级锁(table-level locking)。 InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁 行级锁，表级锁和页级锁对比 行级锁 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。 特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 表级锁 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。 特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。 页级锁 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。 特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般 从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了从锁的类别上来讲，有共享锁和排他锁。 共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。 排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。 用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。 锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。 他们的加锁开销从大到小，并发能力也是从大到小。 MySQL中InnoDB引擎的行锁是怎么实现的？答：InnoDB是基于索引来完成行锁 例: select * from tab_with_index where id = 1 for update; for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起 InnoDB存储引擎的锁的算法有三种 Record lock：单个行记录上的锁 Gap lock：间隙锁，锁定一个范围，不包括记录本身 Next-key lock：record+gap 锁定一个范围，包含记录本身 相关知识点： innodb对于行的查询使用next-key lock Next-locking keying为了解决Phantom Problem幻读问题 当查询的索引含有唯一属性时，将next-key lock降级为record key Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1 什么是死锁？怎么解决？死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。 常见的解决死锁的方法 1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。 2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率； 3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率； 如果业务处理不好可以用分布式事务锁或者使用乐观锁 数据库的乐观锁和悲观锁是什么？怎么实现的？数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。 两种锁的使用场景 从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。 但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。 视图为什么要使用视图？什么是视图？为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。 视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。 视图有哪些特点？视图的特点如下: 视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。 视图是由基本表(实表)产生的表(虚表)。 视图的建立和删除不影响基本表。 对视图内容的更新(添加，删除和修改)直接影响基本表。 当视图来自多个基本表时，不允许添加和删除数据。 视图的操作包括创建视图，查看视图，删除视图和修改视图。 视图的使用场景有哪些？视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。 下面是视图的常见使用场景： 重用SQL语句； 简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节； 使用表的组成部分而不是整个表； 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限； 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。 视图的优点 查询简单化。视图能简化用户的操作 数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护 逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性 视图的缺点 性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。 修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的 这些视图有如下特征：1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\\SUM\\MAX等聚合函数的视图。 4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外） 什么是游标？游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。 存储过程与函数什么是存储过程？有哪些优缺点？存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。 优点 1）存储过程是预编译过的，执行效率高。 2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。 3）安全性高，执行存储过程需要有一定权限的用户。 4）存储过程可以重复使用，减少数据库开发人员的工作量。 缺点 1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。 2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。 3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。 4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。 触发器什么是触发器？触发器的使用场景有哪些？触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。 使用场景 可以通过数据库中的相关表实现级联更改。 实时监控某张表中的某个字段的更改而需要做出相应的处理。 例如可以生成某些业务的编号。 注意不要滥用，否则会造成数据库及应用程序的维护困难。 大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。 MySQL中都有哪些触发器？在MySQL数据库中有如下六种触发器： Before Insert After Insert Before Update After Update Before Delete After Delete 常用SQL语句SQL语句主要分为哪几类数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER 主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。 数据查询语言DQL（Data Query Language）SELECT 这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。 数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE 主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。 数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK 主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。 超键、候选键、主键、外键分别是什么？ 超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 候选键：是最小超键，即没有冗余元素的超键。 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。 外键：在一个表中存在的另一个表的主键称此表的外键。 SQL 约束有哪几种？ SQL 约束有哪几种？ NOT NULL: 用于控制字段的内容一定不能为空（NULL）。 UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。 PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。 FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。 CHECK: 用于控制字段的值范围。 六种关联查询 交叉连接（CROSS JOIN） 内连接（INNER JOIN） 外连接（LEFT JOIN/RIGHT JOIN） 联合查询（UNION与UNION ALL） 全连接（FULL JOIN） 交叉连接（CROSS JOIN） SELECT * FROM A,B(,C)或者SELECT * FROM A CROSS JOIN B (CROSS JOIN C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER JOIN）SELECT * FROM A,B WHERE A.id=B.id或者SELECT * FROM A INNER JOIN B ON A.id=B.id多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN 内连接分为三类 等值连接：ON A.id=B.id 不等值连接：ON A.id &gt; B.id 自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid 外连接（LEFT JOIN/RIGHT JOIN） 左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN 右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN 联合查询（UNION与UNION ALL） SELECT * FROM A UNION SELECT * FROM B UNION ... 就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并 如果使用UNION ALL，不会合并重复的记录行 效率 UNION 高于 UNION ALL 全连接（FULL JOIN） MySQL不支持全连接 可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用 SELECT * FROM A LEFT JOIN B ON A.id=B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id=B.id 表连接面试题 有2张表，1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录。 R表 A B C a1 b1 c1 a2 b2 c2 a3 b3 c3 S表 C D c1 d1 c2 d2 c4 d3 交叉连接(笛卡尔积): select r.*,s.* from r,s A B C C D a1 b1 c1 c1 d1 a2 b2 c2 c1 d1 a3 b3 c3 c1 d1 a1 b1 c1 c2 d2 a2 b2 c2 c2 d2 a3 b3 c3 c2 d2 a1 b1 c1 c4 d3 a2 b2 c2 c4 d3 a3 b3 c3 c4 d3 内连接结果： select r.*,s.* from r inner join s on r.c=s.c A B C C D a1 b1 c1 c1 d1 a2 b2 c2 c2 d2 左连接结果： select r.*,s.* from r left join s on r.c=s.c A B C C D a1 b1 c1 c1 d1 a2 b2 c2 c2 d2 a3 b3 c3 右连接结果： select r.*,s.* from r right join s on r.c=s.c A B C C D a1 b1 c1 c1 d1 a2 b2 c2 c2 d2 c4 d3 全表连接的结果（MySql不支持，Oracle支持）： select r.*,s.* from r full join s on r.c=s.c A B C C D a1 b1 c1 c1 d1 a2 b2 c2 c2 d2 a3 b3 c3 c4 d3 什么是子查询 条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果 嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。 子查询的三种情况 子查询是单行单列的情况：结果集是一个值，父查询使用：=、 &lt;、 &gt; 等运算符 -- 查询工资最高的员工是谁？ select * from employee where salary=(select max(salary) from employee); 子查询是多行单列的情况：结果集类似于一个数组，父查询使用：in 运算符 -- 查询工资最高的员工是谁？ select * from employee where salary=(select max(salary) from employee); 子查询是多行多列的情况：结果集类似于一张虚拟表，不能用于where条件，用于select子句中做为子表 -- 1) 查询出2011年以后入职的员工信息 -- 2) 查询所有的部门信息，与上面的虚拟表中的信息比对，找出所有部门ID相等的员工。 select * from dept d, (select * from employee where join_date &gt; &#39;2011-1-1&#39;) e where e.dept_id = d.id; -- 使用表连接： select d.*, e.* from dept d inner join employee e on d.id = e.dept_id where e.join_date &gt; &#39;2011-1-1&#39; mysql中 in 和 exists 区别mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。 如果查询的两个表大小相当，那么用in和exists差别不大。 如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。 not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。 varchar与char的区别char的特点 char表示定长字符串，长度是固定的； 如果插入数据的长度小于char的固定长度时，则用空格填充； 因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法； 对于char来说，最多能存放的字符个数为255，和编码无关 varchar的特点 varchar表示可变长字符串，长度是可变的； 插入的数据是多长，就按照多长来存储； varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法； 对于varchar来说，最多能存放的字符个数为65532 总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。 varchar(50)中50的涵义最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。 int(20)中20的涵义是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变； 不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示 mysql为什么这么设计对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样； mysql中int(10)和char(10)以及varchar(10)的区别 int(10)的10表示显示的数据的长度，不是存储数据的大小；chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。 int(10) 10位的数据长度 9999999999，占32个字节，int型4位 char(10) 10位固定字符串，不足补空格 最多10个字符 varchar(10) 10位可变字符串，不足补空格 最多10个字符 char(10)表示存储定长的10个字符，不足10个就用空格补齐，占用更多的存储空间 varchar(10)表示存储10个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符 FLOAT和DOUBLE的区别是什么？ FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。 DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。 drop、delete与truncate的区别三者都表示删除，但是三者有一些差别： Delete Truncate Drop 类型 属于DML 属于DDL 属于DDL 回滚 可回滚 不可回滚 不可回滚 删除内容 表结构还在，删除表的全部或者一部分数据行 表结构还在，删除表中的所有数据 从数据库中删除表，所有的数据行，索引和权限也会被删除 删除速度 删除速度慢，需要逐行删除 删除速度快 删除速度最快 因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。 UNION与UNION ALL的区别？ 如果使用UNION ALL，不会合并重复的记录行 效率 UNION 高于 UNION ALL SQL优化如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，对于查询语句，最重要的优化方式就是使用索引。 而执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等。 执行计划包含的信息 id 有一组数字组成。表示一个查询中各个子查询的执行顺序; id相同执行顺序由上至下。 id不同，id值越大优先级越高，越先被执行。 id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。 select_type 每个子查询的查询类型，一些常见的查询类型。 id select_type description 1 SIMPLE 不包含任何子查询或union等查询 2 PRIMARY 包含子查询最外层查询就显示为 PRIMARY 3 SUBQUERY 在select或 where字句中包含的查询 4 DERIVED from字句中包含的查询 5 UNION 出现在union后的查询语句中 6 UNION RESULT 从UNION中获取结果集，例如上文的第三个例子 table 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划id partitions 表分区、表创建的时候可以指定通过那个列进行表分区。 举个例子： create table tmp ( id int unsigned not null AUTO_INCREMENT, name varchar(255), PRIMARY KEY (id) ) engine = innodb partition by key (id) partitions 5; type(非常重要，可以看到有没有走索引) 访问类型 ALL 扫描全表数据 index 遍历索引 range 索引范围查找 index_subquery 在子查询中使用 ref unique_subquery 在子查询中使用 eq_ref ref_or_null 对Null进行索引的优化的 ref fulltext 使用全文索引 ref 使用非唯一索引查找数据 eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。 possible_keys 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。 key 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。 TIPS:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中 key_length 索引长度 ref 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值 rows 返回估算的结果集数目，并不是一个准确的值。 extra 的信息非常丰富，常见的有： Using index 使用覆盖索引 Using where 使用了用where子句来过滤结果集 Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。 Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册 【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。 说明： 1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 2） ref 指的是使用普通的索引（normal index）。 3） range 对索引进行范围检索。 反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。 SQL的生命周期？ 应用服务器与数据库服务器建立一个连接 数据库进程拿到请求sql 解析并生成执行计划，执行 读取数据到内存并进行逻辑处理 通过步骤一的连接，发送结果到客户端 关掉连接，释放资源 大表数据查询，怎么优化 优化shema、sql语句+索引； 第二加缓存，memcached, redis； 主从复制，读写分离； 垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统； 水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表； 超大分页怎么处理？超大的分页一般从两个方向上来解决. 数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据. 从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击. 解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可. 在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种. 【推荐】利用延迟关联或者子查询优化超多分页场景。 说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 正例：先快速定位需要获取的id段，然后再关联： SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id mysql 分页LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1) mysql&gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. 如果只给定一个参数，它表示返回最大的记录行数目： mysql&gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行 换句话说，LIMIT n 等价于 LIMIT 0,n。 慢查询日志 用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。 开启慢查询日志 配置项：slow_query_log 可以使用show variables like ‘slov_query_log’查看是否开启，如果状态值为OFF，可以使用set GLOBAL slow_query_log = on来开启，它会在datadir下产生一个xxx-slow.log的文件。 设置临界时间 配置项：long_query_time 查看：show VARIABLES like &#39;long_query_time&#39;，单位秒 设置：set long_query_time=0.5 实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉 查看日志，一旦SQL超过了我们设置的临界时间就会被记录到xxx-slow.log中 关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。 慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？ 所以优化也是针对这三个方向来的， 首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。 分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。 如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。 为什么要尽量设定一个主键？主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。 主键使用自增ID还是UUID？推荐使用自增ID，不要使用UUID。 因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。 总之，在数据量大一些的情况下，用自增主键性能会好一些。 关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。 字段为什么要求定义为not null？null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。 如果要存储用户的密码散列，应该使用什么字段进行存储？密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。 优化查询过程中的数据访问 访问数据太多导致查询性能下降 确定应用程序是否在检索大量超过需要的数据，可能是太多行或列 确认MySQL服务器是否在分析大量不必要的数据行 避免犯如下SQL语句错误 查询不需要的数据。解决办法：使用limit解决 多表关联返回全部列。解决办法：指定列名 总是返回全部列。解决办法：避免使用SELECT * 重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存 是否在扫描额外的记录。解决办法： 使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化： 使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。 改变数据库和表的结构，修改数据表范式 重写SQL语句，让优化器可以以更优的方式执行查询。 优化长难的查询语句 一个复杂查询还是多个简单查询 MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多 使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。 切分查询 将一个大的查询分为多个小的相同的查询 一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。 分解关联查询，让缓存的效率更高。 执行单个查询可以减少锁的竞争。 在应用层做关联更容易对数据库进行拆分。 查询效率会有大幅提升。 较少冗余记录的查询。 优化特定类型的查询语句 count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名) MyISAM中，没有任何where条件的count(*)非常快。 当有where条件时，MyISAM的count统计不一定比其它引擎快。 可以使用explain查询近似值，用近似值替代count(*) 增加汇总表 使用缓存 优化关联查询 确定ON或者USING子句中是否有索引。 确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。 优化子查询 用关联查询替代 优化GROUP BY和DISTINCT 这两种查询据可以使用索引来优化，是最有效的优化方法 关联查询中，使用标识列分组的效率更高 如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。 WITH ROLLUP超级聚合，可以挪到应用程序处理 优化LIMIT分页 LIMIT偏移量大的时候，查询效率较低 可以记录上次查询的最大ID，下次查询时直接根据该ID来查询 优化UNION查询 UNION ALL的效率高于UNION 优化WHERE子句解题方法 对于此类考题，先说明如何定位低效SQL语句，然后根据SQL语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑以上几个方面，数据访问的问题，长难查询句的问题还是一些特定类型优化的问题，逐一回答。 SQL语句优化的一些方法？ 1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null -- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num= 3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。 4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num=10 or num=20 -- 可以这样查询： select id from t where num=10 union all select id from t where num=20 5.in 和 not in 也要慎用，否则会导致全表扫描，如： select id from t where num in(1,2,3) -- 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3 6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。 7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： select id from t where num=@num -- 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num 8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where num/2=100 -- 应改为: select id from t where num=100*2 9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where substring(name,1,3)=’abc’ -- name以abc开头的id应改为: select id from t where name like ‘abc%’ 10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 数据库优化为什么要优化 系统的吞吐量瓶颈往往出现在数据库的访问速度上 随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢 数据是存放在磁盘上的，读写速度无法和内存相比 优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。 数据库结构优化一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。 需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。 将字段很多的表分解成多个表 对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。 因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。 增加中间表 对于需要经常联合查询的表，可以建立中间表以提高查询效率。 通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。 增加冗余字段 设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。 表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。 注意： 冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。 MySQL数据库cpu飙升到500%的话他怎么处理？当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。 如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。 一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。 也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等 大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下： 限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。； 读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读； 缓存： 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存； 还有就是通过分库分表的方式进行优化，主要有垂直分表和水平分表 垂直分区： 根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。 简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。 垂直拆分的优点： 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。 垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂； 垂直分表 把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中 适用场景 1、如果一个表中某些列常用，另外一些列不常用 2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数 缺点 有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差 对于应用层来说，逻辑算法增加开发成本 管理冗余列，查询所有数据需要join操作 水平分区： 保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。 水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。 水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨界点Join性能较差，逻辑复杂。 《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。 水平分表： 表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数 适用场景 1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。 2、需要把数据存放在多个介质上。 水平切分的缺点 1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作 2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数 *下面补充一下数据库分片的两种常见方案：** 客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。 中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。 分库分表后面临的问题 事务支持 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。 跨库join 只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品 跨节点的count,order by,group by以及聚合函数问题 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。 数据迁移，容量规划，扩容等问题 来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。 ID问题 一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由. 一些常见的主键生成策略 UUID 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 Twitter的分布式自增ID算法Snowflake 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。 跨分片的排序分页 般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示： MySQL的复制原理以及流程主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。 主从复制的作用 主数据库出现问题，可以切换到从数据库。 可以进行数据库层面的读写分离。 可以在从数据库上进行日常备份。 MySQL主从复制解决的问题 数据分布：随意开始或停止复制，并在不同地理位置分布数据备份 负载均衡：降低单个服务器的压力 高可用和故障切换：帮助应用程序避免单点失败 升级测试：可以用更高版本的MySQL作为从库 MySQL主从复制工作原理 在主库上把数据更高记录到二进制日志 从库将主库的日志复制到自己的中继日志 从库读取中继日志的事件，将其重放到从库数据中 基本原理流程，3个线程以及之间的关联 主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中； 从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中； 从：sql执行线程——执行relay log中的语句； 复制过程 Binary log：主数据库的二进制日志 Relay log：从服务器的中继日志 第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。 第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。 第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。 读写分离有哪些解决方案？读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求slave不能写只能读（如果对slave执行写操作，那么show slave status将会呈现Slave_SQL_Running=NO，此时你需要按照前面提到的手动同步一下slave）。 方案一 使用mysql-proxy代理 优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用 缺点：降低性能， 不支持事务 方案二 使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的insert/update/delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下DataSourceTransactionManager， 将read-only的事务扔进读库， 其余的有读有写的扔进写库。 方案三 使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务. 缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。 备份计划，mysqldump以及xtranbackup的实现原理(1)备份计划 视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。 100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。 (2)备份恢复时间 物理备份恢复快，逻辑备份恢复慢 这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考 20G的2分钟（mysqldump） 80G的30分钟(mysqldump) 111G的30分钟（mysqldump) 288G的3小时（xtra) 3T的4小时（xtra) 逻辑导入时间一般是备份时间的5倍以上 (3)备份恢复失败如何处理 首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。 (4)mysqldump和xtrabackup实现原理 mysqldump mysqldump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个事务(START TRANSACTION /*!40100 WITH CONSISTENTSNAPSHOT */)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data=1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务 Xtrabackup: xtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。最后完成 innodb 的备份后，会做一个 flush engine logs 的操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交 概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢最后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事 情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。 数据表损坏的修复方式有哪些？使用 myisamchk 来修复，具体步骤： 1）修复前将mysql服务停止。 2）打开命令行方式，然后进入到mysql的/bin目录。 3）执行myisamchk –recover 数据库所在路径/*.MYI 使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。 OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库） 本文转自 https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164574504116780274141388&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2alltop_positive~default-4-104778621.pc_search_result_positive&amp;utm_term=mysql&amp;spm=1018.2226.3001.4187，如有侵权，请联系删除。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"}],"tags":[{"name":"MySQL面试","slug":"MySQL面试","permalink":"https://ysluckly.github.io/tags/MySQL%E9%9D%A2%E8%AF%95/"}]},{"title":"【C语言】动态顺序表 + 文件存储 = 通讯录","slug":"back-end/2018530","date":"2022-02-26T05:28:26.536Z","updated":"2022-02-26T05:24:46.420Z","comments":true,"path":"2022/02/26/undefined/","link":"","permalink":"https://ysluckly.github.io/2022/02/26/undefined/","excerpt":"前言 在前面曾用静态、动态顺序表两种方式实现通讯录，但每次运行程序我们都得重新输入，之前输入的成员信息并不会保存，而现实中，通讯录里的信息创建后是永久保存的，除非你删除它，今天我们就来模拟一下如何将数据存储在文件中，当下一次运行时加载一下即可，这种做法更贴合实际。","text":"前言 在前面曾用静态、动态顺序表两种方式实现通讯录，但每次运行程序我们都得重新输入，之前输入的成员信息并不会保存，而现实中，通讯录里的信息创建后是永久保存的，除非你删除它，今天我们就来模拟一下如何将数据存储在文件中，当下一次运行时加载一下即可，这种做法更贴合实际。 程序中会用到与文件操作相关的函数，提前介绍一下： fopen 它的函数原型为：FILE*fopen(const char *filename,const char *mode) ，filename:创建文件的名字；mode:允许进入文件的类型;简单来说这个文件的作用就是打开一个文件流；与fclose:关闭文件流配套使用. perror: 它的函数原型为：void perror(const char * string) ,这是一种报告文件错误的函数；后面包括一个分号和一个空格，然后打印出一条用于解释errno当前错误代码的信息; fwrite: 它的函数原型为：size_t fwrite(const void buffer,size_t size,size_t count,FILEstream) ,buffer:数据写入的体格缓冲区； 通讯录简要功能： 初始化通讯录 添加联系人 查找联系人 删除联系人 修改联系人 按姓名排序 清空联系人 联系人列表 检查容量 加载文件 保存文件 销毁通讯录 退出 参考代码：Contact.h：/*********************************************************** * 程序名称：通讯录（静态顺序表） * * 编译环境：VS2013 * * 编制日期：2018.5.29 * * -----by Hunter * ***********************************************************/ #ifndef __CONTACT_H__ #define __CONTACT_H__ #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; #include &lt;assert.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; enum OPPTION &#123; EXIT, ADD, SEARCH, DEIETE, MODIFY, SORT, SHOW, EMPTY &#125;; typedef char datatype; #define MAX_NAME 10 #define MAX_SEX 5 #define MAX_TEL 11 #define MAX_ADDR 30 #define MAX_SIZE 1000 #define FILE_NAME &quot;contact.dat&quot; typedef struct PeoInfo &#123; datatype Name[MAX_NAME]; datatype Sex[MAX_SEX]; int age; datatype Tel[MAX_TEL]; datatype Addr[MAX_ADDR]; &#125;PeoInfo, *pPeoInfo; typedef struct Contact &#123; pPeoInfo data; int size; int capacity; &#125;Contact, *pContact; //初始化通讯录 void InitContact(pContact pc); //添加联系人 void AddContact(pContact pc); //删除联系人 void DeleteContact(pContact pc); //查找联系人 int SearchContact(pContact pc); //修改联系人 void ModifyContact(pContact pc); //按姓排序 void SortContact(pContact pc); //列表联系人 void ShowContact(pContact pc); //清空联系人 void EmptyContact(pContact pc); //销毁 void DestoryContact(pContact pc); //加载 void LoadContact(pContact pc); //保存 void SaveContact(pContact pc); #endif //__CONTACT_H__ Contact.c：#define _CRT_SECURE_NO_WARNINGS 1 #include &quot;contact.h&quot; //检查扩容 void CheckCapacity(pContact pc) &#123; assert(pc); pPeoInfo *p = NULL; if (pc-&gt;size == pc-&gt;capacity) &#123; p = (pPeoInfo)realloc(pc-&gt;data, (pc-&gt;capacity + 2)*sizeof(PeoInfo)); if (p != NULL) &#123; pc-&gt;data = p; &#125; else &#123; printf(&quot;\\t\\t\\t增容失败&quot;); exit(EXIT_FAILURE); &#125; pc-&gt;capacity += 2; printf(&quot;\\t\\t\\t增容成功\\n&quot;); &#125; &#125; //加载 void LoadContact(pContact pc) &#123; int i = 0; FILE* pfRead = fopen(&quot;contact.dat&quot;, &quot;r&quot;); PeoInfo tmp = &#123; 0 &#125;; //创建临时变量保存每次读取的信息 assert(pc); if (pfRead == NULL) &#123; perror(&quot;the file to read&quot;); exit(EXIT_FAILURE); &#125; while (fread(&amp;tmp, sizeof(PeoInfo), 1, pfRead)) &#123; CheckCapacity(pc); pc-&gt;data[i] = tmp; i++; pc-&gt;size++; &#125; fclose(pfRead); pfRead = NULL; &#125; //保存 void SaveContact(pContact pc) &#123; assert(pc); FILE *pfwrite = fopen(&quot;contact.dat&quot;, &quot;w&quot;); int i = 0; if (pfwrite == NULL) &#123; perror(&quot;the file to write&quot;); exit(EXIT_FAILURE); &#125; for (i = 0; i&lt;pc-&gt;size; i++) &#123; fwrite(pc-&gt;data+ i, sizeof(PeoInfo), 1, pfwrite); &#125; fclose(pfwrite); pfwrite = NULL; &#125; //初始化通讯录 void InitContact(pContact pc) &#123; assert(pc); pc-&gt;size = 0; pc-&gt;capacity = 3; pc-&gt;data = (pPeoInfo)malloc((pc-&gt;capacity)*sizeof(PeoInfo)); if (pc-&gt;data == NULL) &#123; printf(&quot;\\t\\t\\t内存分配失败&quot;); exit(EXIT_FAILURE); &#125; memset(pc-&gt;data, 0, sizeof(pc-&gt;data)); LoadContact(pc); &#125; //添加联系人 void AddContact(pContact pc) &#123; assert(pc); if (pc-&gt;size == MAX_SIZE) &#123; printf(&quot;\\t\\t\\t空间不足&quot;); return; &#125; CheckCapacity(pc); printf(&quot;\\t\\t\\t请输入姓名:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].Name); printf(&quot;\\t\\t\\t请输入性别:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].Sex); printf(&quot;\\t\\t\\t请输入年龄:&gt;&quot;); scanf(&quot;%d&quot;, &amp;pc-&gt;data[pc-&gt;size].age); printf(&quot;\\t\\t\\t请输入电话号:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].Tel); printf(&quot;\\t\\t\\t请输入地址:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].Addr); pc-&gt;size++; printf(&quot;\\t\\t\\t添加成功\\n&quot;); &#125; //查找联系人 int SearchContact(pContact pc) &#123; char name[MAX_NAME]; int i = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf(&quot;\\t\\t\\t无此联系人\\n&quot;); return -1; &#125; printf(&quot;\\t\\t\\t&quot;); scanf(&quot;%s&quot;, name); printf(&quot;\\t\\t\\tName\\tSex\\tAge\\tTel\\t\\tAddr\\n&quot;); for (i = 0; i &lt; pc-&gt;size; i++) &#123; if (0 == strcmp(pc-&gt;data[i].Name, name)) &#123; printf(&quot;\\t\\t\\t%-5s\\t%-5s\\t%-5d\\t%-12s\\t%-15s\\n&quot;, pc-&gt;data[i].Name, pc-&gt;data[i].Sex, pc-&gt;data[i].age, pc-&gt;data[i].Tel, pc-&gt;data[i].Addr); return i; &#125; &#125; printf(&quot;\\t\\t\\t无此联系人\\n&quot;); return -1; &#125; //删除联系人 void DeleteContact(pContact pc) &#123; int i = 0; int num = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf(&quot;\\t\\t\\t无联系人\\n&quot;); return; &#125; num = SearchContact(pc); if (num != -1) &#123; int n = 0; printf(&quot;\\t\\t\\t确定删除？ 1.yes, 2.no:&gt;&quot;); printf(&quot;\\t\\t\\t&quot;); scanf(&quot;%d&quot;, &amp;n); if (1 == n) &#123; for (i = num; i &lt; (pc-&gt;size) - 1; i++) &#123; pc-&gt;data[i] = pc-&gt;data[i + 1]; &#125; pc-&gt;size--; printf(&quot;\\t\\t\\t删除成功\\n&quot;); &#125; else &#123; return; &#125; &#125; &#125; //交换 void Swap(pPeoInfo *a, pPeoInfo *b) &#123; pPeoInfo *Tmp; Tmp = *a; *a = *b; *b = Tmp; &#125; //修改联系人 void ModifyContact(pContact pc) &#123; int modify = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf(&quot;\\t\\t\\t无联系人\\n&quot;); return; &#125; modify = SearchContact(pc); if (modify != -1) &#123; int n = 0; printf(&quot;\\t\\t\\t确认修改？1.yes 2.no:&gt;&quot;); printf(&quot;\\t\\t\\t&quot;); scanf(&quot;%d&quot;, &amp;n); if (1 == n) &#123; printf(&quot;\\t\\t\\t请输入姓名:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[modify].Name); printf(&quot;\\t\\t\\t请输入性别:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[modify].Sex); printf(&quot;\\t\\t\\t请输入年龄:&gt;&quot;); scanf(&quot;%d&quot;, &amp;pc-&gt;data[modify].age); printf(&quot;\\t\\t\\t请输入电话号:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[modify].Tel); printf(&quot;\\t\\t\\t请输入地址:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[modify].Addr); printf(&quot;\\t\\t\\t修改成功\\n&quot;); &#125; else &#123; return; &#125; &#125; &#125; //按姓排序 void SortContact(pContact pc) &#123; int i = 0; int j = 0; int flag = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf(&quot;\\t\\t\\t无联系人\\n&quot;); return; &#125; // 冒泡次数 for (i = 0; i &lt; pc-&gt;size - 1; i++) &#123; //冒泡排序 for (j = 0; j &lt; pc-&gt;size - i - 1; j++) &#123; if (strcmp(pc-&gt;data[j].Name, pc-&gt;data[j + 1].Name)&gt;0) &#123; Swap(&amp;pc-&gt;data[j], &amp;pc-&gt;data[j + 1]); flag = 1; &#125; &#125; if (0 == flag) &#123; break; &#125; &#125; printf(&quot;排序成功\\n&quot;); &#125; //列表联系人 void ShowContact(pContact pc) &#123; int i = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf(&quot;\\t\\t\\t无联系人\\n&quot;); return; &#125; printf(&quot;\\t\\t\\tName\\tSex\\tAge\\tTel\\t\\tAddr\\n&quot;); for (i = 0; i &lt; pc-&gt;size; i++) &#123; printf(&quot;\\t\\t\\t%-5s\\t%-5s\\t%-5d\\t%-12s\\t%-15s\\n&quot;, pc-&gt;data[i].Name, pc-&gt;data[i].Sex, pc-&gt;data[i].age, pc-&gt;data[i].Tel, pc-&gt;data[i].Addr); &#125; &#125; //清空联系人 void EmptyContact(pContact pc) &#123; assert(pc); pc-&gt;size = 0; printf(&quot;\\t\\t\\t清空成功&quot;); &#125; //销毁通讯录 void DestoryContact(pContact pc) &#123; assert(pc); SaveContact(pc); free(pc-&gt;data); pc-&gt;data = NULL; pc-&gt;capacity = 0; pc-&gt;size = 0; printf(&quot;\\t\\t\\t销毁成功&quot;); &#125; test.c： #define _CRT_SECURE_NO_WARNINGS 1 #include &quot;contact.h&quot; void meau() &#123; printf(&quot;\\t\\t\\t****** 《通讯录》 ********\\n&quot;); printf(&quot;\\t\\t\\t****************************************\\n&quot;); printf(&quot;\\t\\t\\t****** 1.添加信息 2.查找信息******\\n&quot;); printf(&quot;\\t\\t\\t****** 3.删除信息 4.修改信息******\\n&quot;); printf(&quot;\\t\\t\\t****** 5.按姓排序 6.信息列表******\\n&quot;); printf(&quot;\\t\\t\\t****** 7.清空信息 0.退出 ******\\n&quot;); printf(&quot;\\t\\t\\t****************************************\\n&quot;); &#125; void test() &#123; int input = 0; Contact pc; InitContact(&amp;pc); do &#123; meau(); printf(&quot;\\t\\t\\t请选择:&gt;&quot;); scanf(&quot;%d&quot;, &amp;input); switch (input) &#123; case ADD: AddContact(&amp;pc); break; case SEARCH: SearchContact(&amp;pc); break; case DEIETE: DeleteContact(&amp;pc); break; case MODIFY: ModifyContact(&amp;pc); break; case SORT: SortContact(&amp;pc); break; case SHOW: ShowContact(&amp;pc); break; case EMPTY: EmptyContact(&amp;pc); break; case EXIT: break; default: printf(&quot;\\t\\t\\t输入有误，请重新输入:&gt;&quot;); break; &#125; &#125; while (input); &#125; int main() &#123; Contact pc; test(); //销毁通讯录 DestoryContact(&amp;pc); system(&quot;pause&quot;); return 0; &#125; 结语： 最初的自己是个编程菜鸟，然而通过努力的学习，现在也能逐渐的自己写小程序了，相信这就是一种进步，暂不希望自己能有多强大。只要每一步走的充实，我相信一定会有好的回报，且行且努力！","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C语言","slug":"后端/C语言","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"通讯录","slug":"通讯录","permalink":"https://ysluckly.github.io/tags/%E9%80%9A%E8%AE%AF%E5%BD%95/"}]},{"title":"Go Mock (gomock)简明教程","slug":"back-end/quick-gomock","date":"2022-02-16T13:59:10.000Z","updated":"2022-02-20T13:36:40.177Z","comments":true,"path":"2022/02/16/go/","link":"","permalink":"https://ysluckly.github.io/2022/02/16/go/","excerpt":"","text":"1 gomock 简介上一篇文章 Go Test 单元测试简明教程 介绍了 Go 语言中单元测试的常用方法，包括子测试(subtests)、表格驱动测试(table-driven tests)、帮助函数(helpers)、网络测试和基准测试(Benchmark)等。这篇文章介绍一种新的测试方法，mock/stub 测试，当待测试的函数/对象的依赖关系很复杂，并且有些依赖不能直接创建，例如数据库连接、文件I/O等。这种场景就非常适合使用 mock/stub 测试。简单来说，就是用 mock 对象模拟依赖项的行为。 GoMock is a mocking framework for the Go programming language. It integrates well with Go’s built-in testing package, but can be used in other contexts too. gomock 是官方提供的 mock 框架，同时还提供了 mockgen 工具用来辅助生成测试代码。 使用如下命令即可安装： go get -u github.com/golang/mock/gomock go get -u github.com/golang/mock/mockgen 2 一个简单的 Demo// db.go type DB interface &#123; Get(key string) (int, error) &#125; func GetFromDB(db DB, key string) int &#123; if value, err := db.Get(key); err == nil &#123; return value &#125; return -1 &#125; 假设 DB 是代码中负责与数据库交互的部分(在这里用 map 模拟)，测试用例中不能创建真实的数据库连接。这个时候，如果我们需要测试 GetFromDB 这个函数内部的逻辑，就需要 mock 接口 DB。 第一步：使用 mockgen 生成 db_mock.go。一般传递三个参数。包含需要被mock的接口得到源文件source，生成的目标文件destination，包名package。 $ mockgen -source=db.go -destination=db_mock.go -package=main 第二步：新建 db_test.go，写测试用例。 func TestGetFromDB(t *testing.T) &#123; ctrl := gomock.NewController(t) defer ctrl.Finish() // 断言 DB.Get() 方法是否被调用 m := NewMockDB(ctrl) m.EXPECT().Get(gomock.Eq(&quot;Tom&quot;)).Return(100, errors.New(&quot;not exist&quot;)) if v := GetFromDB(m, &quot;Tom&quot;); v != -1 &#123; t.Fatal(&quot;expected -1, but got&quot;, v) &#125; &#125; 这个测试用例有2个目的，一是使用 ctrl.Finish() 断言 DB.Get() 被是否被调用，如果没有被调用，后续的 mock 就失去了意义； 二是测试方法 GetFromDB() 的逻辑是否正确(如果 DB.Get() 返回 error，那么 GetFromDB() 返回 -1)。 NewMockDB() 的定义在 db_mock.go 中，由 mockgen 自动生成。 最终的代码结构如下： project/ |--db.go |--db_mock.go // generated by mockgen |--db_test.go 执行测试： $ go test . -cover -v === RUN TestGetFromDB --- PASS: TestGetFromDB (0.00s) PASS coverage: 81.2% of statements ok example 0.008s coverage: 81.2% of statements 3 打桩(stubs)在上面的例子中，当 Get() 的参数为 Tom，则返回 error，这称之为打桩(stub)，有明确的参数和返回值是最简单打桩方式。除此之外，检测调用次数、调用顺序，动态设置返回值等方式也经常使用。 3.1 参数(Eq, Any, Not, Nil) m.EXPECT().Get(gomock.Eq(&quot;Tom&quot;)).Return(0, errors.New(&quot;not exist&quot;)) m.EXPECT().Get(gomock.Any()).Return(630, nil) m.EXPECT().Get(gomock.Not(&quot;Sam&quot;)).Return(0, nil) m.EXPECT().Get(gomock.Nil()).Return(0, errors.New(&quot;nil&quot;)) Eq(value) 表示与 value 等价的值。 Any() 可以用来表示任意的入参。 Not(value) 用来表示非 value 以外的值。 Nil() 表示 None 值 3.2 返回值(Return, DoAndReturn) m.EXPECT().Get(gomock.Not(&quot;Sam&quot;)).Return(0, nil) m.EXPECT().Get(gomock.Any()).Do(func(key string) &#123; t.Log(key) &#125;) m.EXPECT().Get(gomock.Any()).DoAndReturn(func(key string) (int, error) &#123; if key == &quot;Sam&quot; &#123; return 630, nil &#125; return 0, errors.New(&quot;not exist&quot;) &#125;) Return 返回确定的值 Do Mock 方法被调用时，要执行的操作吗，忽略返回值。 DoAndReturn 可以动态地控制返回值。 3.3 调用次数(Times) func TestGetFromDB(t *testing.T) &#123; ctrl := gomock.NewController(t) defer ctrl.Finish() m := NewMockDB(ctrl) m.EXPECT().Get(gomock.Not(&quot;Sam&quot;)).Return(0, nil).Times(2) GetFromDB(m, &quot;ABC&quot;) GetFromDB(m, &quot;DEF&quot;) &#125; Times() 断言 Mock 方法被调用的次数。 MaxTimes() 最大次数。 MinTimes() 最小次数。 AnyTimes() 任意次数（包括 0 次）。 3.4 调用顺序(InOrder) func TestGetFromDB(t *testing.T) &#123; ctrl := gomock.NewController(t) defer ctrl.Finish() // 断言 DB.Get() 方法是否被调用 m := NewMockDB(ctrl) o1 := m.EXPECT().Get(gomock.Eq(&quot;Tom&quot;)).Return(0, errors.New(&quot;not exist&quot;)) o2 := m.EXPECT().Get(gomock.Eq(&quot;Sam&quot;)).Return(630, nil) gomock.InOrder(o1, o2) GetFromDB(m, &quot;Tom&quot;) GetFromDB(m, &quot;Sam&quot;) &#125; 4 如何编写可 mock 的代码写可测试的代码与写好测试用例是同等重要的，如何写可 mock 的代码呢？ mock 作用的是接口，因此将依赖抽象为接口，而不是直接依赖具体的类。 不直接依赖的实例，而是使用依赖注入降低耦合性。 在软件工程中，依赖注入的意思为，给予调用方它所需要的事物。 “依赖”是指可被方法调用的事物。依赖注入形式下，调用方不再直接指使用“依赖”，取而代之是“注入” 。“注入”是指将“依赖”传递给调用方的过程。在“注入”之后，调用方才会调用该“依赖”。传递依赖给调用方，而不是让让调用方直接获得依赖，这个是该设计的根本需求。– 依赖注入 - Wikipedia 如果 GetFromDB() 方法长这个样子 func GetFromDB(key string) int &#123; db := NewDB() if value, err := db.Get(key); err == nil &#123; return value &#125; return -1 &#125; 对 DB 接口的 mock 并不能作用于 GetFromDB() 内部，这样写是没办法进行测试的。那如果将接口 db DB 通过参数传递到 GetFromDB()，那么就可以轻而易举地传入 Mock 对象了。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80/"},{"name":"单元测试","slug":"单元测试","permalink":"https://ysluckly.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"mock框架","slug":"mock框架","permalink":"https://ysluckly.github.io/tags/mock%E6%A1%86%E6%9E%B6/"},{"name":"stub","slug":"stub","permalink":"https://ysluckly.github.io/tags/stub/"}]},{"title":"Go 语言简明教程","slug":"back-end/quick-golang","date":"2022-02-16T13:59:10.000Z","updated":"2022-02-20T13:35:38.378Z","comments":true,"path":"2022/02/16/go/","link":"","permalink":"https://ysluckly.github.io/2022/02/16/go/","excerpt":"","text":"Go（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。 —— Go - wikipedia.org 1 Go 安装最新版本下载地址官方下载 golang.org，当前是 1.13.6。如无法访问，可以在 studygolang.com/dl 下载 使用 Linux，可以用如下方式快速安装。 $ wget https://studygolang.com/dl/golang/go1.13.6.linux-amd64.tar.gz $ tar -zxvf go1.13.6.linux-amd64.tar.gz $ sudo mv go /usr/local/ $ go version go version go1.13.6 linux/amd64 从 Go 1.11 版本开始，Go 提供了 Go Modules 的机制，推荐设置以下环境变量，第三方包的下载将通过国内镜像，避免出现官方网址被屏蔽的问题。 $ go env -w GOPROXY=https://goproxy.cn,direct 或在 ~/.profile 中设置环境变量 export GOPROXY=https://goproxy.cn 2 Hello World新建一个文件 main.go，写入 package main import &quot;fmt&quot; func main() &#123; fmt.Println(&quot;Hello World!&quot;) &#125; 执行go run main.go 或 go run .，将会输出 $ go run . Hello World! 如果强制启用了 Go Modules 机制，即环境变量中设置了 GO111MODULE=on，则需要先初始化模块 go mod init hello否则会报错误：go: cannot find main module; see ‘go help modules’ 我们的第一个 Go 程序就完成了，接下来我们逐行来解读这个程序： package main：声明了 main.go 所在的包，Go 语言中使用包来组织代码。一般一个文件夹即一个包，包内可以暴露类型或方法供其他包使用。 import “fmt”：fmt 是 Go 语言的一个标准库/包，用来处理标准输入输出。 func main：main 函数是整个程序的入口，main 函数所在的包名也必须为 main。 fmt.Println(“Hello World!”)：调用 fmt 包的 Println 方法，打印出 “Hello World!” go run main.go，其实是 2 步： go build main.go：编译成二进制可执行程序 ./main：执行该程序 3 变量与内置数据类型3.1 变量(Variable)Go 语言是静态类型的，变量声明时必须明确变量的类型。Go 语言与其他语言显著不同的一个地方在于，Go 语言的类型在变量后面。比如 java 中，声明一个整体一般写成 int a = 1，在 Go 语言中，需要这么写： var a int // 如果没有赋值，默认为0 var a int = 1 // 声明时赋值 var a = 1 // 声明时赋值 var a = 1，因为 1 是 int 类型的，所以赋值时，a 自动被确定为 int 类型，所以类型名可以省略不写，这种方式还有一种更简单的表达： a := 1 msg := &quot;Hello World!&quot; 3.2 简单类型空值：nil 整型类型： int(取决于操作系统), int8, int16, int32, int64, uint8, uint16, … 浮点数类型：float32, float64 字节类型：byte (等价于uint8) 字符串类型：string 布尔值类型：boolean，(true 或 false) var a int8 = 10 var c1 byte = &#39;a&#39; var b float32 = 12.2 var msg = &quot;Hello World&quot; ok := false 3.3 字符串在 Go 语言中，字符串使用 UTF8 编码，UTF8 的好处在于，如果基本是英文，每个字符占 1 byte，和 ASCII 编码是一样的，非常节省空间，如果是中文，一般占3字节。包含中文的字符串的处理方式与纯 ASCII 码构成的字符串有点区别。 我们看下面的例子： package main import ( &quot;fmt&quot; &quot;reflect&quot; ) func main() &#123; str1 := &quot;Golang&quot; str2 := &quot;Go语言&quot; fmt.Println(reflect.TypeOf(str2[2]).Kind()) // uint8 fmt.Println(str1[2], string(str1[2])) // 108 l fmt.Printf(&quot;%d %c\\n&quot;, str2[2], str2[2]) // 232 è fmt.Println(&quot;len(str2)：&quot;, len(str2)) // len(str2)： 8 &#125; reflect.TypeOf().Kind() 可以知道某个变量的类型，我们可以看到，字符串是以 byte 数组形式保存的，类型是 uint8，占1个 byte，打印时需要用 string 进行类型转换，否则打印的是编码值。 因为字符串是以 byte 数组的形式存储的，所以，str2[2] 的值并不等于语。str2 的长度 len(str2) 也不是 4，而是 8（ Go 占 2 byte，语言占 6 byte）。 正确的处理方式是将 string 转为 rune 数组 str2 := &quot;Go语言&quot; runeArr := []rune(str2) fmt.Println(reflect.TypeOf(runeArr[2]).Kind()) // int32 fmt.Println(runeArr[2], string(runeArr[2])) // 35821 语 fmt.Println(&quot;len(runeArr)：&quot;, len(runeArr)) // len(runeArr)： 4 转换成 []rune 类型后，字符串中的每个字符，无论占多少个字节都用 int32 来表示，因而可以正确处理中文。 3.4 数组(array)与切片(slice)声明数组 var arr [5]int // 一维 var arr2 [5][5]int // 二维 声明时初始化 var arr = [5]int&#123;1, 2, 3, 4, 5&#125; // 或 arr := [5]int&#123;1, 2, 3, 4, 5&#125; 使用 [] 索引/修改数组 arr := [5]int&#123;1, 2, 3, 4, 5&#125; for i := 0; i &lt; len(arr); i++ &#123; arr[i] += 100 &#125; fmt.Println(arr) // [101 102 103 104 105] 数组的长度不能改变，如果想拼接2个数组，或是获取子数组，需要使用切片。切片是数组的抽象。 切片使用数组作为底层结构。切片包含三个组件：容量，长度和指向底层数组的指针,切片可以随时进行扩展 声明切片： slice1 := make([]float32, 0) // 长度为0的切片 slice2 := make([]float32, 3, 5) // [0 0 0] 长度为3容量为5的切片 fmt.Println(len(slice2), cap(slice2)) // 3 5 使用切片： // 添加元素，切片容量可以根据需要自动扩展 slice2 = append(slice2, 1, 2, 3, 4) // [0, 0, 0, 1, 2, 3, 4] fmt.Println(len(slice2), cap(slice2)) // 7 12 // 子切片 [start, end) sub1 := slice2[3:] // [1 2 3 4] sub2 := slice2[:3] // [0 0 0] sub3 := slice2[1:4] // [0 0 1] // 合并切片 combined := append(sub1, sub2...) // [1, 2, 3, 4, 0, 0, 0] 声明切片时可以为切片设置容量大小，为切片预分配空间。在实际使用的过程中，如果容量不够，切片容量会自动扩展。 sub2... 是切片解构的写法，将切片解构为 N 个独立的元素。 3.5 字典(键值对，map)map 类似于 java 的 HashMap，Python的字典(dict)，是一种存储键值对(Key-Value)的数据解构。使用方式和其他语言几乎没有区别。 // 仅声明 m1 := make(map[string]int) // 声明时初始化 m2 := map[string]string&#123; &quot;Sam&quot;: &quot;Male&quot;, &quot;Alice&quot;: &quot;Female&quot;, &#125; // 赋值/修改 m1[&quot;Tom&quot;] = 18 3.6 指针(pointer)指针即某个值的地址，类型定义时使用符号*，对一个已经存在的变量，使用 &amp; 获取该变量的地址。 str := &quot;Golang&quot; var p *string = &amp;str // p 是指向 str 的指针 *p = &quot;Hello&quot; fmt.Println(str) // Hello 修改了 p，str 的值也发生了改变 一般来说，指针通常在函数传递参数，或者给某个类型定义新的方法时使用。Go 语言中，参数是按值传递的，如果不使用指针，函数内部将会拷贝一份参数的副本，对参数的修改并不会影响到外部变量的值。如果参数使用指针，对参数的传递将会影响到外部变量。 例如： func add(num int) &#123; num += 1 &#125; func realAdd(num *int) &#123; *num += 1 &#125; func main() &#123; num := 100 add(num) fmt.Println(num) // 100，num 没有变化 realAdd(&amp;num) fmt.Println(num) // 101，指针传递，num 被修改 &#125; 4 流程控制(if, for, switch)4.1 条件语句 if elseage := 18 if age &lt; 18 &#123; fmt.Printf(&quot;Kid&quot;) &#125; else &#123; fmt.Printf(&quot;Adult&quot;) &#125; // 可以简写为： if age := 18; age &lt; 18 &#123; fmt.Printf(&quot;Kid&quot;) &#125; else &#123; fmt.Printf(&quot;Adult&quot;) &#125; 4.2 switchtype Gender int8 const ( MALE Gender = 1 FEMALE Gender = 2 ) gender := MALE switch gender &#123; case FEMALE: fmt.Println(&quot;female&quot;) case MALE: fmt.Println(&quot;male&quot;) default: fmt.Println(&quot;unknown&quot;) &#125; // male 在这里，使用了type 关键字定义了一个新的类型 Gender。 使用 const 定义了 MALE 和 FEMALE 2 个常量，Go 语言中没有枚举(enum)的概念，一般可以用常量的方式来模拟枚举。 和其他语言不同的地方在于，Go 语言的 switch 不需要 break，匹配到某个 case，执行完该 case 定义的行为后，默认不会继续往下执行。如果需要继续往下执行，需要使用 fallthrough，例如： switch gender &#123; case FEMALE: fmt.Println(&quot;female&quot;) fallthrough case MALE: fmt.Println(&quot;male&quot;) fallthrough default: fmt.Println(&quot;unknown&quot;) &#125; // 输出结果 // male // unknown 4.3 for 循环一个简单的累加的例子，break 和 continue 的用法与其他语言没有区别。 sum := 0 for i := 0; i &lt; 10; i++ &#123; if sum &gt; 50 &#123; break &#125; sum += i &#125; 对数组(arr)、切片(slice)、字典(map) 使用 for range 遍历： nums := []int&#123;10, 20, 30, 40&#125; for i, num := range nums &#123; fmt.Println(i, num) &#125; // 0 10 // 1 20 // 2 30 // 3 40 m2 := map[string]string&#123; &quot;Sam&quot;: &quot;Male&quot;, &quot;Alice&quot;: &quot;Female&quot;, &#125; for key, value := range m2 &#123; fmt.Println(key, value) &#125; // Sam Male // Alice Female 5 函数(functions)5.1 参数与返回值一个典型的函数定义如下，使用关键字 func，参数可以有多个，返回值也支持有多个。特别地，package main 中的func main() 约定为可执行程序的入口。 func funcName(param1 Type1, param2 Type2, ...) (return1 Type3, ...) &#123; // body &#125; 例如，实现2个数的加法（一个返回值）和除法（多个返回值）： func add(num1 int, num2 int) int &#123; return num1 + num2 &#125; func div(num1 int, num2 int) (int, int) &#123; return num1 / num2, num1 % num2 &#125; func main() &#123; quo, rem := div(100, 17) fmt.Println(quo, rem) // 5 15 fmt.Println(add(100, 17)) // 117 &#125; 也可以给返回值命名，简化 return，例如 add 函数可以改写为 func add(num1 int, num2 int) (ans int) &#123; ans = num1 + num2 return &#125; 5.2 错误处理(error handling)如果函数实现过程中，如果出现不能处理的错误，可以返回给调用者处理。比如我们调用标准库函数os.Open读取文件，os.Open 有2个返回值，第一个是 *File，第二个是 error， 如果调用成功，error 的值是 nil，如果调用失败，例如文件不存在，我们可以通过 error 知道具体的错误信息。 import ( &quot;fmt&quot; &quot;os&quot; ) func main() &#123; _, err := os.Open(&quot;filename.txt&quot;) if err != nil &#123; fmt.Println(err) &#125; &#125; // open filename.txt: no such file or directory 可以通过 errorw.New 返回自定义的错误 import ( &quot;errors&quot; &quot;fmt&quot; ) func hello(name string) error &#123; if len(name) == 0 &#123; return errors.New(&quot;error: name is null&quot;) &#125; fmt.Println(&quot;Hello,&quot;, name) return nil &#125; func main() &#123; if err := hello(&quot;&quot;); err != nil &#123; fmt.Println(err) &#125; &#125; // error: name is null error 往往是能预知的错误，但是也可能出现一些不可预知的错误，例如数组越界，这种错误可能会导致程序非正常退出，在 Go 语言中称之为 panic。 func get(index int) int &#123; arr := [3]int&#123;2, 3, 4&#125; return arr[index] &#125; func main() &#123; fmt.Println(get(5)) fmt.Println(&quot;finished&quot;) &#125; $ go run . panic: runtime error: index out of range [5] with length 3 goroutine 1 [running]: exit status 2 在 Python、Java 等语言中有 try...catch 机制，在 try 中捕获各种类型的异常，在 catch 中定义异常处理的行为。Go 语言也提供了类似的机制 defer 和 recover。 func get(index int) (ret int) &#123; defer func() &#123; if r := recover(); r != nil &#123; fmt.Println(&quot;Some error happened!&quot;, r) ret = -1 &#125; &#125;() arr := [3]int&#123;2, 3, 4&#125; return arr[index] &#125; func main() &#123; fmt.Println(get(5)) fmt.Println(&quot;finished&quot;) &#125; $ go run . Some error happened! runtime error: index out of range [5] with length 3 -1 finished 在 get 函数中，使用 defer 定义了异常处理的函数，在协程退出前，会执行完 defer 挂载的任务。因此如果触发了 panic，控制权就交给了 defer。 在 defer 的处理逻辑中，使用 recover，使程序恢复正常，并且将返回值设置为 -1，在这里也可以不处理返回值，如果不处理返回值，返回值将被置为默认值 0。 6 结构体，方法和接口6.1 结构体(struct) 和方法(methods)结构体类似于其他语言中的 class，可以在结构体中定义多个字段，为结构体实现方法，实例化等。接下来我们定义一个结构体 Student，并为 Student 添加 name，age 字段，并实现 hello() 方法。 type Student struct &#123; name string age int &#125; func (stu *Student) hello(person string) string &#123; return fmt.Sprintf(&quot;hello %s, I am %s&quot;, person, stu.name) &#125; func main() &#123; stu := &amp;Student&#123; name: &quot;Tom&quot;, &#125; msg := stu.hello(&quot;Jack&quot;) fmt.Println(msg) // hello Jack, I am Tom &#125; 使用 Student&#123;field: value, ...&#125;的形式创建 Student 的实例，字段不需要每个都赋值，没有显性赋值的变量将被赋予默认值，例如 age 将被赋予默认值 0。 实现方法与实现函数的区别在于，func 和函数名hello 之间，加上该方法对应的实例名 stu 及其类型 *Student，可以通过实例名访问该实例的字段name和其他方法了。 调用方法通过 实例名.方法名(参数) 的方式。 除此之外，还可以使用 new 实例化： func main() &#123; stu2 := new(Student) fmt.Println(stu2.hello(&quot;Alice&quot;)) // hello Alice, I am , name 被赋予默认值&quot;&quot; &#125; 6.2 接口(interfaces)一般而言，接口定义了一组方法的集合，接口不能被实例化，一个类型可以实现多个接口。 举一个简单的例子，定义一个接口 Person和对应的方法 getName() 和 getAge()： type Person interface &#123; getName() string &#125; type Student struct &#123; name string age int &#125; func (stu *Student) getName() string &#123; return stu.name &#125; type Worker struct &#123; name string gender string &#125; func (w *Worker) getName() string &#123; return w.name &#125; func main() &#123; var p Person = &amp;Student&#123; name: &quot;Tom&quot;, age: 18, &#125; fmt.Println(p.getName()) // Tom &#125; Go 语言中，并不需要显式地声明实现了哪一个接口，只需要直接实现该接口对应的方法即可。 实例化 Student后，强制类型转换为接口类型 Person。 在上面的例子中，我们在 main 函数中尝试将 Student 实例类型转换为 Person，如果 Student 没有完全实现 Person 的方法，比如我们将 (*Student).getName() 删掉，编译时会出现如下报错信息。 *Student does not implement Person (missing getName method) 但是删除 (*Worker).getName() 程序并不会报错，因为我们并没有在 main 函数中使用。这种情况下我们如何确保某个类型实现了某个接口的所有方法呢？一般可以使用下面的方法进行检测，如果实现不完整，编译期将会报错。 var _ Person = (*Student)(nil) var _ Person = (*Worker)(nil) 将空值 nil 转换为 *Student 类型，再转换为 Person 接口，如果转换失败，说明 Student 并没有实现 Person 接口的所有方法。 Worker 同上。 实例可以强制类型转换为接口，接口也可以强制类型转换为实例。 func main() &#123; var p Person = &amp;Student&#123; name: &quot;Tom&quot;, age: 18, &#125; stu := p.(*Student) // 接口转为实例 fmt.Println(stu.getAge()) &#125; 6.3 空接口如果定义了一个没有任何方法的空接口，那么这个接口可以表示任意类型。例如 func main() &#123; m := make(map[string]interface&#123;&#125;) m[&quot;name&quot;] = &quot;Tom&quot; m[&quot;age&quot;] = 18 m[&quot;scores&quot;] = [3]int&#123;98, 99, 85&#125; fmt.Println(m) // map[age:18 name:Tom scores:[98 99 85]] &#125; 7 并发编程(goroutine)7.1 syncGo 语言提供了 sync 和 channel 两种方式支持协程(goroutine)的并发。 例如我们希望并发下载 N 个资源，多个并发协程之间不需要通信，那么就可以使用 sync.WaitGroup，等待所有并发协程执行结束。 import ( &quot;fmt&quot; &quot;sync&quot; &quot;time&quot; ) var wg sync.WaitGroup func download(url string) &#123; fmt.Println(&quot;start to download&quot;, url) time.Sleep(time.Second) // 模拟耗时操作 wg.Done() &#125; func main() &#123; for i := 0; i &lt; 3; i++ &#123; wg.Add(1) go download(&quot;a.com/&quot; + string(i+&#39;0&#39;)) &#125; wg.Wait() fmt.Println(&quot;Done!&quot;) &#125; wg.Add(1)：为 wg 添加一个计数，wg.Done()，减去一个计数。 go download()：启动新的协程并发执行 download 函数。 wg.Wait()：等待所有的协程执行结束。 $ time go run . start to download a.com/2 start to download a.com/0 start to download a.com/1 Done! real 0m1.563s 可以看到串行需要 3s 的下载操作，并发后，只需要 1s。 7.2 channelvar ch = make(chan string, 10) // 创建大小为 10 的缓冲信道 func download(url string) &#123; fmt.Println(&quot;start to download&quot;, url) time.Sleep(time.Second) ch &lt;- url // 将 url 发送给信道 &#125; func main() &#123; for i := 0; i &lt; 3; i++ &#123; go download(&quot;a.com/&quot; + string(i+&#39;0&#39;)) &#125; for i := 0; i &lt; 3; i++ &#123; msg := &lt;-ch // 等待信道返回消息。 fmt.Println(&quot;finish&quot;, msg) &#125; fmt.Println(&quot;Done!&quot;) &#125; 使用 channel 信道，可以在协程之间传递消息。阻塞等待并发协程返回消息。 $ time go run . start to download a.com/2 start to download a.com/0 start to download a.com/1 finish a.com/2 finish a.com/1 finish a.com/0 Done! real 0m1.528s 8 单元测试(unit test)假设我们希望测试 package main 下 calc.go 中的函数，要只需要新建 calc_test.go 文件，在calc_test.go中新建测试用例即可。 // calc.go package main func add(num1 int, num2 int) int &#123; return num1 + num2 &#125; // calc_test.go package main import &quot;testing&quot; func TestAdd(t *testing.T) &#123; if ans := add(1, 2); ans != 3 &#123; t.Error(&quot;add(1, 2) should be equal to 3&quot;) &#125; &#125; 运行 go test，将自动运行当前 package 下的所有测试用例，如果需要查看详细的信息，可以添加-v参数。 $ go test -v === RUN TestAdd --- PASS: TestAdd (0.00s) PASS ok example 0.040s 9 包(Package)和模块(Modules)9.1 Package一般来说，一个文件夹可以作为 package，同一个 package 内部变量、类型、方法等定义可以相互看到。 比如我们新建一个文件 calc.go， main.go 平级，分别定义 add 和 main 方法。 // calc.go package main func add(num1 int, num2 int) int &#123; return num1 + num2 &#125; // main.go package main import &quot;fmt&quot; func main() &#123; fmt.Println(add(3, 5)) // 8 &#125; 运行 go run main.go，会报错，add 未定义： ./main.go:6:14: undefined: add 因为 go run main.go 仅编译 main.go 一个文件，所以命令需要换成 $ go run main.go calc.go 8 或 $ go run . 8 Go 语言也有 Public 和 Private 的概念，粒度是包。如果类型/接口/方法/函数/字段的首字母大写，则是 Public 的，对其他 package 可见，如果首字母小写，则是 Private 的，对其他 package 不可见。 9.2 ModulesGo Modules 是 Go 1.11 版本之后引入的，Go 1.11 之前使用 $GOPATH 机制。Go Modules 可以算作是较为完善的包管理工具。同时支持代理，国内也能享受高速的第三方包镜像服务。接下来简单介绍 go mod 的使用。Go Modules 在 1.13 版本仍是可选使用的，环境变量 GO111MODULE 的值默认为 AUTO，强制使用 Go Modules 进行依赖管理，可以将 GO111MODULE 设置为 ON。 在一个空文件夹下，初始化一个 Module $ go mod init example go: creating new go.mod: module example 此时，在当前文件夹下生成了go.mod，这个文件记录当前模块的模块名以及所有依赖包的版本。 接着，我们在当前目录下新建文件 main.go，添加如下代码： package main import ( &quot;fmt&quot; &quot;rsc.io/quote&quot; ) func main() &#123; fmt.Println(quote.Hello()) // Ahoy, world! &#125; 运行 go run .，将会自动触发第三方包 rsc.io/quote的下载，具体的版本信息也记录在了go.mod中： module example go 1.13 require rsc.io/quote v3.1.0+incompatible 我们在当前目录，添加一个子 package calc，代码目录如下： demo/ |--calc/ |--calc.go |--main.go 在 calc.go 中写入 package calc func Add(num1 int, num2 int) int &#123; return num1 + num2 &#125; 在 package main 中如何使用 package cal 中的 Add 函数呢？import 模块名/子目录名 即可，修改后的 main 函数如下： package main import ( &quot;fmt&quot; &quot;example/calc&quot; &quot;rsc.io/quote&quot; ) func main() &#123; fmt.Println(quote.Hello()) fmt.Println(calc.Add(10, 3)) &#125; $ go run . Ahoy, world! 13 附 参考 golang 官方文档 - golang.org goproxy.cn 文档 - github.com Go Modules - github.com","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80/"},{"name":"Go语言程序设计","slug":"Go语言程序设计","permalink":"https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"Go语言教程中文版","slug":"Go语言教程中文版","permalink":"https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%E4%B8%AD%E6%96%87%E7%89%88/"}]},{"title":"Go Mmap 文件内存映射简明教程","slug":"back-end/quick-go-mmap","date":"2022-02-11T13:59:10.000Z","updated":"2022-02-20T13:36:11.469Z","comments":true,"path":"2022/02/11/go/","link":"","permalink":"https://ysluckly.github.io/2022/02/11/go/","excerpt":"","text":"1 mmap 简介 In computing, mmap is a POSIX-compliant Unix system call that maps files or devices into memory. It is a method of memory-mapped file I/O.– mmap - wikipedia.org 简单理解，mmap 是一种将文件/设备映射到内存的方法，实现文件的磁盘地址和进程虚拟地址空间中的一段虚拟地址的一一映射关系。也就是说，可以在某个进程中通过操作这一段映射的内存，实现对文件的读写等操作。修改了这一段内存的内容，文件对应位置的内容也会同步修改，而读取这一段内存的内容，相当于读取文件对应位置的内容。 mmap 另一个非常重要的特性是：减少内存的拷贝次数。在 linux 系统中，文件的读写操作通常通过 read 和 write 这两个系统调用来实现，这个过程会产生频繁的内存拷贝。比如 read 函数就涉及了 2 次内存拷贝： 操作系统读取磁盘文件到页缓存； 从页缓存将数据拷贝到 read 传递的 buf 中(例如进程中创建的byte数组)。 mmap 只需要一次拷贝。即操作系统读取磁盘文件到页缓存，进程内部直接通过指针方式修改映射的内存。因此 mmap 特别适合读写频繁的场景，既减少了内存拷贝次数，提高效率，又简化了操作。KV数据库 bbolt 就使用了这个方法持久化数据。 2 标准库 mmapGo 语言标准库 golang.org/x/exp/mmap 仅实现了 read 操作，后续能否支持 write 操作未知。使用场景非常有限。看一个简单的例子： 从第4个byte开始，读取 tmp.txt 2个byte的内容。 package main import ( &quot;fmt&quot; &quot;golang.org/x/exp/mmap&quot; ) func main() &#123; at, _ := mmap.Open(&quot;./tmp.txt&quot;) buff := make([]byte, 2) _, _ = at.ReadAt(buff, 4) _ = at.Close() fmt.Println(string(buff)) &#125; $ echo &quot;abcdefg&quot; &gt; tmp.txt $ go run . ef 如果使用 os.File 操作，代码几乎是一样的，os.File 还支持写操作 WriteAt： package main import ( &quot;fmt&quot; &quot;os&quot; ) func main() &#123; f, _ := os.OpenFile(&quot;tmp.txt&quot;, os.O_CREATE|os.O_RDWR, 0644) _, _ = f.WriteAt([]byte(&quot;abcdefg&quot;), 0) buff := make([]byte, 2) _, _ = f.ReadAt(buff, 4) _ = f.Close() fmt.Println(string(buff)) &#125; 3 mmap(linux)如果要支持 write 操作，那么就需要直接调用 mmap 的系统调用来实现了。Linux 和 Windows 都支持 mmap，但接口有所不同。对于 linux 系统，mmap 方法定义如下： func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, err error) 每个参数的含义分别是： - fd：待映射的文件描述符。 - offset：映射到内存区域的起始位置，0 表示由内核指定内存地址。 - length：要映射的内存区域的大小。 - prot：内存保护标志位，可以通过或运算符`|`组合 - PROT_EXEC // 页内容可以被执行 - PROT_READ // 页内容可以被读取 - PROT_WRITE // 页可以被写入 - PROT_NONE // 页不可访问 - flags：映射对象的类型，常用的是以下两类 - MAP_SHARED // 共享映射，写入数据会复制回文件, 与映射该文件的其他进程共享。 - MAP_PRIVATE // 建立一个写入时拷贝的私有映射，写入数据不影响原文件。 首先定义2个常量和数据类型Demo： const defaultMaxFileSize = 1 &lt;&lt; 30 // 假设文件最大为 1G const defaultMemMapSize = 128 * (1 &lt;&lt; 20) // 假设映射的内存大小为 128M type Demo struct &#123; file *os.File data *[defaultMaxFileSize]byte dataRef []byte &#125; func _assert(condition bool, msg string, v ...interface&#123;&#125;) &#123; if !condition &#123; panic(fmt.Sprintf(msg, v...)) &#125; &#125; 内存有换页机制，映射的物理内存可以远小于文件。 Demo结构体由3个字段构成，file 即文件描述符，data 是映射内存的起始地址，dataRef 用于后续取消映射。 定义 mmap, grow, ummap 三个方法： func (demo *Demo) mmap() &#123; b, err := syscall.Mmap(int(demo.file.Fd()), 0, defaultMemMapSize, syscall.PROT_WRITE|syscall.PROT_READ, syscall.MAP_SHARED) _assert(err == nil, &quot;failed to mmap&quot;, err) demo.dataRef = b demo.data = (*[defaultMaxFileSize]byte)(unsafe.Pointer(&amp;b[0])) &#125; func (demo *Demo) grow(size int64) &#123; if info, _ := demo.file.Stat(); info.Size() &gt;= size &#123; return &#125; _assert(demo.file.Truncate(size) == nil, &quot;failed to truncate&quot;) &#125; func (demo *Demo) munmap() &#123; _assert(syscall.Munmap(demo.dataRef) == nil, &quot;failed to munmap&quot;) demo.data = nil demo.dataRef = nil &#125; mmap 传入的内存保护标志位为 syscall.PROT_WRITE|syscall.PROT_READ，即可读可写，映射类型为 syscall.MAP_SHARED，即对内存的修改会同步到文件。 syscall.Mmap 返回的是一个切片对象，需要从该切片中获取到内存的起始地址，并转换为可操作的 byte 数组，byte数组的长度为 defaultMaxFileSize。 grow 用于修改文件的大小，Linux 不允许操作超过文件大小之外的内存地址。例如文件大小为 4K，可访问的地址是data[0~4095]，如果访问 data[10000] 会报错。 munmap 用于取消映射。 在文件中写入 hello, geektutu! func main() &#123; _ = os.Remove(&quot;tmp.txt&quot;) f, _ := os.OpenFile(&quot;tmp.txt&quot;, os.O_CREATE|os.O_RDWR, 0644) demo := &amp;Demo&#123;file: f&#125; demo.grow(1) demo.mmap() defer demo.munmap() msg := &quot;hello geektutu!&quot; demo.grow(int64(len(msg) * 2)) for i, v := range msg &#123; demo.data[2*i] = byte(v) demo.data[2*i+1] = byte(&#39; &#39;) &#125; &#125; 在调用 mmap 之前，调用了 grow(1)，因为在 mmap 中使用 &amp;b[0] 获取到映射内存的起始地址，所以文件大小至少为 1 byte。 接下来，便是通过直接操作 demo.data，修改文件内容了。 运行： $ go run . $ cat tmp.txt h e l l o g e e k t u t u ! 4 mmap(Windows)相对于 Linux，Windows 上 mmap 的使用要复杂一些。 func (demo *Demo) mmap() &#123; h, err := syscall.CreateFileMapping(syscall.Handle(demo.file.Fd()), nil, syscall.PAGE_READWRITE, 0, defaultMemMapSize, nil) _assert(h != 0, &quot;failed to map&quot;, err) addr, err := syscall.MapViewOfFile(h, syscall.FILE_MAP_WRITE, 0, 0, uintptr(defaultMemMapSize)) _assert(addr != 0, &quot;MapViewOfFile failed&quot;, err) err = syscall.CloseHandle(syscall.Handle(h)); _assert(err == nil, &quot;CloseHandle failed&quot;) // Convert to a byte array. demo.data = (*[defaultMaxFileSize]byte)(unsafe.Pointer(addr)) &#125; func (demo *Demo) munmap() &#123; addr := (uintptr)(unsafe.Pointer(&amp;demo.data[0])) _assert(syscall.UnmapViewOfFile(addr) == nil, &quot;failed to munmap&quot;) &#125; 需要 CreateFileMapping 和 MapViewOfFile 两步才能完成内存映射。MapViewOfFile 返回映射成功的内存地址，因此可以直接将该地址转换成 byte 数组。 Windows 对文件的大小没有要求，直接操作内存data，文件大小会自动发生改变。 使用时无需关注文件的大小。 func main() &#123; _ = os.Remove(&quot;tmp.txt&quot;) f, _ := os.OpenFile(&quot;tmp.txt&quot;, os.O_CREATE|os.O_RDWR, 0644) demo := &amp;Demo&#123;file: f&#125; demo.mmap() defer demo.munmap() msg := &quot;hello geektutu!&quot; for i, v := range msg &#123; demo.data[2*i] = byte(v) demo.data[2*i+1] = byte(&#39; &#39;) &#125; &#125; $ go run . $ cat .\\tmp.txt h e l l o g e e k t u t u ! 附 参考 edsrzf/mmap-go - github.com golang 官方文档 syscall - golang.org","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://ysluckly.github.io/tags/golang/"},{"name":"mmap","slug":"mmap","permalink":"https://ysluckly.github.io/tags/mmap/"},{"name":"memory mapping","slug":"memory-mapping","permalink":"https://ysluckly.github.io/tags/memory-mapping/"},{"name":"windows","slug":"windows","permalink":"https://ysluckly.github.io/tags/windows/"}]},{"title":"Go全栈面试题（5）-网络编程面试题","slug":"back-end/1645851832298","date":"2022-02-03T07:29:32.000Z","updated":"2022-02-26T05:52:02.072Z","comments":true,"path":"2022/02/03/golang/","link":"","permalink":"https://ysluckly.github.io/2022/02/03/golang/","excerpt":"","text":"网络面试题说一下五层协议 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 ISO七层模型中表示层和会话层功能是什么？ 表示层 ：数据压缩、加密以及数据描述。这使得应用程序不必担心在各台主机中表示/存储的内部格式（二进制、ASCII，比如乱码）不同的问题。 会话层 ：建立会话，如session认证、断点续传。通信的应用程序之间建立、维护和释放面向用户的连接。通信的应用程序之间建立会话，需要传输层建立1个或多个连接。（…后台运行的木马，netstat -n） 说明：五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。 数据在各层之间的传递过程是怎么样的？在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。 路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。 交换机只有下面两层协议 TCP/IP四层模型它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。 TCP 和 UDP 有什么区别,适用场景？ TCP 是面向连接的，UDP 是面向无连接的；故 TCP 需要建立连接和断开连接，UDP 不需要。 TCP 是流协议，UDP 是数据包协议；故 TCP 数据没有大小限制，UDP 数据报有大小限制（UDP 协议本身限制、数据链路层的 MTU、缓存区大小）。 TCP 是可靠协议，UDP 是不可靠协议；故 TCP 会处理数据丢包重发以及乱序等情况，UDP 则不会处理。 UDP 的特点及使用场景: UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务，随时都可以发送数据，处理简单且高效，经常用于以下场景： 包总量较小的通信（DNS、SNMP） 视频、音频等多媒体通信（即时通信） 广播通信 TCP 的特点及使用场景: 相对于 UDP，TCP 实现了数据传输过程中的各种控制，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。 在对可靠性要求较高的情况下，可以使用 TCP，即不考虑 UDP 的时候，都可以选择 TCP。 TCP三次握手 假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文段，SYN=1，ACK=0，选择一个初始的序号 seq = x。 B 收到连接请求报文段，如果同意建立连接，则向 A 发送连接确认报文段，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 seq = y。 A 收到 B 的连接确认报文段后，还要向 B 发出确认，确认号为 ack = y+1，序号为 seq = x+1。 A 的 TCP 通知上层应用进程，连接已经建立。 B 收到 A 的确认后，连接建立。 B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立。 为什么TCP连接需要三次握手，两次不可以吗，为什么？为了防止已失效的连接请求报文段突然又传送到了服务端，占用服务器资源。 （假设主机A为客户端，主机B为服务器端） 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 四次挥手 数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP连接。 A 把连接释放报文段首部的 FIN = 1，其序号 seq = u，等待 B 的确认。 B 发出确认，确认号 ack = u+1，而这个报文段自己的序号 seq = v。（TCP 服务器进程通知高层应用进程）。 从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。A 不能向 B 发送数据；B 若发送数据，A 仍要接收。 当 B 不再需要连接时，发送连接释放请求报文段，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（2*2 = 4 mins）时间后释放连接。 B 收到 A 的确认后释放连接。 四次挥手的原因？客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 如何保证可靠传输？ 应用数据被分割成TCP认为最适合发送的数据块。 超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 校验和：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 TCP的接收端会丢弃重复的数据。 流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的我数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。 拥塞控制：当网络拥塞时，减少数据的发送。 如何区分流量控制和拥塞控制 ？ 拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。 拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制。 流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 流量控制属于通信双方协商；拥塞控制涉及通信链路全局。 流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。 实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。 HTTP状态都代表什么？服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 状态码 类别 原因短语 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 GET和POST的区别？ GET 被强制服务器支持 浏览器对URL的长度有限制，所以GET请求不能代替POST请求发送大量数据 GET请求发送数据更小 GET请求是不安全的 GET请求是幂等的 幂等的意味着对同一URL的多个请求应该返回同样的结果 POST请求不能被缓存 POST请求相对GET请求是「安全」的 这里安全的含义仅仅是指是非修改信息 GET用于信息获取，而且是安全的和幂等的. 所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 POST是用于修改服务器上的资源的请求 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 引申：说完原理性的问题，我们从表面上来看看GET和POST的区别： GET是从服务器上获取数据，POST是向服务器传送数据。 GET和 POST只是一种传递数据的方式，GET也可以把数据传到服务器，他们的本质都是发送请求和接收结果。只是组织格式和数据量上面有差别，http协议里面有介绍 GET是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。POST是通过HTTP POST机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。 因为GET设计成传输小数据，而且最好是不修改服务器的数据，所以浏览器一般都在地址栏里面可以看到，但POST一般都用来传递大数据，或比较隐私的数据，所以在地址栏看不到，能不能看到不是协议规定，是浏览器规定的。 对于GET方式，服务器端用Request.QueryString获取变量的值，对于POST方式，服务器端用Request.Form获取提交的数据。 没明白，怎么获得变量和你的服务器有关，和GET或POST无关，服务器都对这些请求做了封装 GET传送的数据量较小，不能大于2KB。POST传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。 POST基本没有限制，我想大家都上传过文件，都是用POST方式的。只不过要修改form里面的那个type参数 GET安全性非常低，POST安全性较高。 如果没有加密，他们安全级别都是一样的，随便一个监听器都可以把所有的数据监听到。 如何理解HTTP协议是无状态的?HTTP协议是无状态的（stateless），指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。 缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 Cookie 与 Session 选择 Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session； Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密； 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。 HTTP和HTTPS的区别? http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。 https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。 https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议 http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。 http的连接很简单,是无状态的 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全 本文转自 https://blog.csdn.net/yang731227/article/details/90637577，如有侵权，请联系删除。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"https://ysluckly.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"面试题","slug":"面试题","permalink":"https://ysluckly.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Go语言练习题","slug":"back-end/1645851747618","date":"2022-02-02T07:29:32.000Z","updated":"2022-02-26T05:51:18.714Z","comments":true,"path":"2022/02/02/golang/","link":"","permalink":"https://ysluckly.github.io/2022/02/02/golang/","excerpt":"","text":"Go基础编程Go初体验 熟悉go的编译环境已经编译过程，根据Hello World输出，拓展打印出自我介绍。 查询资料了解go语言的特点并简单的叙述。 一个包是否可以在一个源文件里面多次引用？ 基础结构和类型 以下变量名有哪些是不合法的? 1a、abc、a&amp;b 、年龄、 var、bool 、public、a2 、2#、a2_1、f unction、class、new 以下变量声明哪些条款是正确的？ var i =1 var i int var i = int i := 1 i = 1 阅读以下代码，写出输出结果。 package main import &quot;fmt&quot; func main()&#123; var a int =10 fmt.Println(a) &#123; a:=9 fmt.Println(a) &#125; fmt.Println(a) &#125; 编程实现：使用itoa和const，定义一周的数值，如Monday=1 ，Tuesday=2，依次类推Sunday=7。 编程实现：实现字符串”123”和整数123之间的互转，并格式化输出他们转换后的类型和值。 编程实现：使用类型别名，让go语言支持中文关键字，如 int可以用整数型替代。 输入输出 编程实现：声明一组变量:姓名(Name)，年龄(Age)，籍贯(From)，专业(Major),从控制台接收内容并赋值给这些变量，最后输出这些变量的值。 简述内置的print和println函数与fmt和log标准库包中相应的打印函数有什么区别？ 以下代码，输出结果会出现什么问题？如何解决？ func main() &#123; for i := 0; i &lt; 5; i++ &#123; fmt.Println(&quot;请输入一个字符&quot;) var code byte fmt.Scanf(&quot;%c&quot;,&amp;code) fmt.Println(code) &#125; &#125; 表达式与运算符 不依靠程序计算 (1+6)/2*4^2+10%3&lt;&lt;2的值 写出下面代码输出的内容(%4b是4位二进制)。 const( read byte=1 &lt;&lt; iota write exec freeze ) func main()&#123; a:=read|write|freeze b:=read|freeze|exec c:= a &amp;^b fmt.Printf(&quot;%4b &amp;^ %4b= %04b\\n&quot;, a, b, c) &#125; 编程实现：现有一个四位数, 计算它每位数的和、每位数的乘积 ，并用乘积除以和，输出它们的结果。 什么是byte？什么是rune？ 如何将[]byte和[]rune类型的值转换为字符串？ 数组 以下不能正确定义数组和赋初值的语句是 var a=[5]int&#123;1,2,3,4,5&#125; var b=[...]int&#123;1,2,3,4,5&#125; var c[5]int=&#123;1,2,3,4,5&#125; var d=[5]int(2: 4,4:61&#125; 编程实现：有一个长度为5的int数组，初始化该数组并计算平均值。 执行以下代码将会出现什么样的结果？怎么让它正确运行？ var arr []int arr[0] =1 fmt.Println(arr[0]) 切片 关于整型切片的初始化，下面正确的有哪些？ s := make([]int)&#123;1,2,3,4&#125; s := make([]int, 0) s := make([]int, 5, 10) s := []int&#123;1, 2, 3, 4, 5&#125; 编程实现：花样体操比赛，6个评委打分，运动员的成绩去掉一个最高分，去掉一个最低分，剩下的4个分数的平均分就是最后得分，要求： （1）请把最高分，最低分的评委。（需要考虑存在多个最低分和最高分的情况） （2）找出最佳评委和最差评委。最佳评委是最后得分差距最小，最差评委最后得分差距最大。 编程实现：切片的升序排序，反转，搜索功能。 请简述切片和数组的区别。 Map 编程实现：现有字典map1的键是string型，值是int型，初始化为[psw1:123 psw2:456 psw3:789]，要求删除键值对psw2:456，增加键值对psw4:135。 编程实现：实现一个函数,计算字符串的单词的个数，它应该返回一个包含字符串中单词个数的map。 为什么映射元素不可被取地址？ struct 编程实现：实现一个同学录，建立学生信息的结构体Student，每个学生的信息包括姓名()、性别、年龄。实现学生信息的添加、修改、删除、查询等功能。 go语言中哪些类型的值可以被取地址，哪些不可以被取地址？ 罗列出哪些类型不支持比较？ 下面的变量a和b相等吗？变量c和d相等吗？ a := struct&#123;&#125;&#123;&#125; b := struct&#123;&#125;&#123;&#125; c := [10]struct&#123;&#125;&#123;&#125; d := [10]struct&#123;&#125;&#123;&#125; 为什么两个nil值有时候会不相等？ 简述go语言中make和new的区别。 哪些类型是值类型，那些是引用类型? 以下代码有什么问题，说明原因并修改代码得到预期结果。 type student struct &#123; Name string Age int &#125; func main() &#123; m := make(map[string]*student) stus := []student&#123; &#123;Name: &quot;zhou&quot;, Age: 24&#125;, &#123;Name: &quot;li&quot;, Age: 23&#125;, &#123;Name: &quot;wang&quot;, Age: 22&#125;, &#125; for _, stu := range stus &#123; m[stu.Name] = &amp;stu &#125; fmt.Println(m) &#125; 指针类型 通过指针变量 p 访问其成员变量 name，下面语法正确的哪些？ p.name (*p).name (&amp;p).name p-&gt;name 填写A行和B行的空白，以确保打印输出为“foo” package main type S struct &#123; m string &#125; func f() *S &#123; return __ //A &#125; func main() &#123; p := __ //B print(p.m) //print &quot;foo&quot; &#125; 执行以下代码时将打印什么？ func main() &#123; s := &quot;123&quot; ps := &amp;s b := []byte(*ps) pb := &amp;b s += &quot;4&quot; *ps += &quot;5&quot; b[1] = &#39;0&#39; println(*ps,&quot; &quot;,string(*pb)) &#125; 解释为什么下面的打印输出是333，并修改A行以确保打印012。 package main const N = 3 func main() &#123; m := make(map[int]*int) for i := 0; i &lt; N; i++ &#123; m[i] = &amp;i //A &#125; for _, v := range m &#123; print(*v) &#125; &#125; 函数返回局部变量的指针是否安全？ 流程控制条件判断 编程实现：从控制台输入学生的成绩并判断等级，0-59 不及格，60-79 良好 ，80-100 优秀，使用if 和switch两种方法实现。 编程实现：从键盘接收一个整数，求奖金提成，规则：低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%；高于100万元时，超过100万元的部分按1%提成从键盘输入当月利润，求应发放奖金总数？ 编程实现：输入一个字符，判断它如果是小写字母输出其对应的大写字母；如果是大写字母输出其对应的小写字母；如果是数字输出数字本身；如果是空格输出“SPACE”；如果不是上述情况输出“Other”。(可用ASCII码判断) 下面的代码将会输出什么？ package main import &quot;fmt&quot; func False() bool &#123; return false &#125; func main() &#123; switch False() &#123; case true: fmt.Println(&quot;true&quot;) case false: fmt.Println(&quot;false&quot;) &#125; &#125; switch流程控制代码块中的case表达式能重复吗？ 循环结构 编程实现：从键盘输入字符串str，使用for range语句遍历该字符串中的每一个字符，并打印输出。 执行以下代码时将打印什么？ package main import ( &quot;fmt&quot; ) func main() &#123; s := []int&#123;1, 2, 3&#125; ss := s[1:] ss = append(ss, 4) for _, v := range ss &#123; v += 10 &#125; for i := range ss &#123; ss[i] += 10 &#125; fmt.Println(s) &#125; 编程实现：FizzBuzz是英国学校里常玩的游戏，从1数到100，如果遇见了3的倍数要说Fizz，如果遇见了5的倍数要说Buzz，如果既是3的倍数又是5的倍数要说FizzBuzz。编写一个程序，按游戏要求打印数字1-100。 编程实现：打印出所有的“水仙花数”,所谓“水仙花数”是指一个三位数,其各位数字立方和等于该数本身。例如,153是一个水仙花数,因为153=13+53+33。 编程实现：完成一个猜数字小游戏，要求：当用户输入的数字大于随机数时候，提示用户输入数字大了，反之提示用户数字小了，当用户在5次内都没有猜对，打印正确结果。并且额外添加成绩判定功能，当用户一次猜对结果，评定为S ，当用户在2-3次内猜对结果，评定为A,当用户在4-5次内猜对结果，评定为B, 一次都没有猜中，评定为C。 编程实现：求 5X+2Y+Z=50 的所有非负整数解。 函数 编程实现：已知三角形三边a、b、c,编写函数求三角形面积公式area(),求三角形面积。(三角形面积公式为area=√s(s-a)(s-b)(s-c),s为周长一半)。 编程实现：两种匿名函数，要求: (1)函数一，可以传参任意数量的int变量，计算这些参数的和并返回给某个变量。 (2)函数二，传参int类型切片，计算切片内元素的和并返给某个变量。 编程实现：完成函数fac()，使用递归调用计算n的阶乘。 编程实现：函数FindInt()，功能：实现从一个指定位置找出字节切片中的整型数字，并返回该整数和下一个数的索引数的索引位置。（提示：使用ASCII码判断） 以下代码,最终打印的结果是什么？ package main import &quot;fmt&quot; func main() &#123; defer fmt.Println(1) defer fmt.Println(2) fmt.Println(3) defer fmt.Println(4) &#125; 简述当多个包中含有init()函数，它的执行顺序是什么？ 假设声明x并且未声明y，则下面哪些声明是正确的？ x, _ := f() x, _ = f() x, y := f() x, y = f() 简要描述go中的main和init函数的区别。 简述下闭包的生命周期和作用范围。 go面向对象 go语言是一个面向对象语言吗？ 编程实现：定义一个People结构体，具有姓名(name)、年龄(age)、性别（Sex）等属性。要求： （1）封装set() 和get()函数,主要功能是设置Person对象属性和得到Person对象的属性，访问权限设置为私有 （2）封装Show()函数，主要功能是打印Person对象信息，访问权限设置为公共。 编程实现：定义 Student结构体，继承上题的People结构体,并添加学号和专业等属性。并且设置Student的 set()、get()和Show()函数。 编程实现：定义一个任意类型键值对的Map,初始化并打印该Map,使用空接口 interface{}定义键值对数据类型。 编程实现：有一批图书,每本书有书名(name)、作者( author)、书号(isdn)、出版日期(date)4项数据,希望既可以通过书名查询,也可以使用作者或书号来查询图书。编写方法来实现此功能,如果查到,打印出此书的书名、作者、书号和出版日期信息。如果查不到此书,则打印出“无此书”。 对任意的非指针和非接口定义类型T，为什么类型*T的方法集总是类型T的方法集的超集，但是反之却不然？ 以下代码编译能否通过？为什么？ package main import ( &quot;fmt&quot; ) type People interface &#123; Speak(string) string &#125; type Stduent struct&#123;&#125; func (stu *Stduent) Speak(think string) (talk string) &#123; if think == &quot;good&quot; &#123; talk = &quot;You are a good boy&quot; &#125; else &#123; talk = &quot;hi&quot; &#125; return &#125; func main() &#123; var peo People = Stduent&#123;&#125; think := &quot;good&quot; fmt.Println(peo.Speak(think)) &#125; 类型断言 下面的代码是否能够正确运行？如果不能请修改代码。 package main import &quot;fmt&quot; func echoArray(a interface&#123;&#125;)&#123; for _,v:=range a&#123; fmt.Print(v,&quot; &quot;) &#125; fmt.Println() return &#125; func main()&#123; a:=[]int&#123;2,1,3,5,4&#125; echoArray(a) &#125; 定义一个容量为8的空接口 Slice,并进行初始化,然后使用 Comma-ok断言推断,Slice中各元素的数据类型。 Go软件工程异常处理 执行以下代码时将打印什么？ package main func f1() &#123; defer println(&quot;f1-begin&quot;) f2() defer println(&quot;f1-end&quot;) &#125; func f2() &#123; defer println(&quot;f2-begin&quot;) f3() defer println(&quot;f2-end&quot;) &#125; func f3() &#123; defer println(&quot;f3-begin&quot;) panic(0) defer println(&quot;f3-end&quot;) &#125; func main() &#123; f1() &#125; 执行以下代码时将打印什么？退出代码是什么? package main import &quot;log&quot; func f() &#123; defer func() &#123; if r := recover() r != nil &#123; log.Printf(&quot;recover:%#v&quot;, r) &#125; &#125;() panic(1) panic(2) &#125; func main() &#123; f() &#125; 使用panic 和 recover机制编写一个检测用户账号合法性的程序，比如用户中不能出现空格，不能出现非法字符，比如‘，’、’#’、’!’等。 关于异常设计，下面说法正确的是（） A. 在程序开发阶段，坚持速错，让程序异常崩溃 B. 在程序部署后，应恢复异常避免程序终止 C. 一切皆错误，不用进行异常设计 D. 对于不应该出现的分支，使用异常处理 罗列出在go语言中哪些行为会触发异常，不少于3种。 测试 每个测试文件必须以什么结尾？每个测试文件必须导入什么包？功能测试函数必须以什么开头？ 要执行压力测试需要带上什么参数？ 在压力测试用例中,要在循环体内使用什么?以使测试可以正常的运行。 标准库字符串操作 使用go语言实现网络流传价值一个亿Python的AI代码。 通过键盘输入英文字符串,并统计字符串中的英文字母的个数,同时输出字符串字节长度. 时间与日期 有字符串”2020-10-1 22:00:00”,要求：把该字符串解析为Time格式，并计算和今天的时差。（注意时区） 函数调用time.Sleep(d)和数据通道接收&lt;-time.After(d)操作之间有何区别？ flag 填写A行和B行的空白，解析ip和port的终端参数，默认值为0.0.0.0和8000。 package main import &quot;flag&quot; import &quot;fmt&quot; var ip string var port int func init() &#123; // A // B &#125; func main() &#123; flag.Parse() fmt.Printf(&quot;%s:%d&quot;, ip, port) &#125; 文件操作 使用Flag包，从控制台接收参数，完成文件的创建，写入，读取，删除 ，拷贝等操作。 编程实现：使用Go语言动态打印歌词，假设有以下类似lrc歌词文件，读取lrc文件，根据[]里面的时间动态的输出歌词。 [00:00.00]青花瓷 - 周杰伦 [00:20.89]素胚勾勒出青花笔锋浓转淡 [00:25.58]瓶身描绘的牡丹一如你初妆 [00:29.96]冉冉檀香透过窗心事我了然 [00:34.43]宣纸上 走笔至此搁一半 [00:38.99]釉色渲染仕女图韵味被私藏 [00:43.33]而你嫣然的一笑如含苞待放 [00:47.80]你的美一缕飘散 [00:50.27]去到我去不了的地方 [00:56.40]天青色等烟雨 而我在等你 [01:00.43]炊烟袅袅升起 隔江千万里 [01:05.34]在瓶底书汉隶仿前朝的飘逸 [01:09.37]就当我为遇见你伏笔 JSON解析 假设我们有如下一个结构体student，及其一个实例对象st,现在我们需要把这个结构体的一个对象st转换为JSON格式。 type Student struct &#123; StuID string Name string Age int Classes []string money float32 &#125; st := &amp;Student &#123; &quot;Go0001&quot; &quot;Xiao Ming&quot;, 20, []string&#123;&quot;Math&quot;, &quot;English&quot;, &quot;Chinese&quot;&#125;, 99.99, &#125; 编程实现：根据现有的Api ( https://www.sojson.com/blog/305.html ），制作天气预报表,表格打印可以使用github.com/modood/table 库 注意因为接口有访问限制，如果你不太熟悉，建议把json返回信息先保存在文本中测试 查询的城市：北京 ┌────────────────┬─────────┬────────────────┬────────────────┬────────┬─────┬───────────┬────────┬────────┬──────────────────────────────────────┐ │ Date │ Sunrise │ High │ Low │ Sunset │ Aqi │ Fx │ Fl │ Type │ Notice │ ├────────────────┼─────────┼────────────────┼────────────────┼────────┼─────┼───────────┼────────┼────────┼──────────────────────────────────────┤ │ 28日星期一 │ 04:51 │ 高温 30.0℃ │ 低温 16.0℃ │ 19:33 │ 51 │ 西北风 │ 4-5级 │ 晴 │ 愿你拥有比阳光明媚的心情 │ │ 29日星期二 │ 04:50 │ 高温 30.0℃ │ 低温 16.0℃ │ 19:34 │ 49 │ 西风 │ &lt;3级 │ 多云 │ 阴晴之间，谨防紫外线侵扰 │ │ 30日星期三 │ 04:50 │ 高温 33.0℃ │ 低温 19.0℃ │ 19:34 │ 39 │ 西南风 │ &lt;3级 │ 晴 │ 愿你拥有比阳光明媚的心情 │ │ 31日星期四 │ 04:49 │ 高温 34.0℃ │ 低温 20.0℃ │ 19:35 │ 41 │ 西南风 │ &lt;3级 │ 晴 │ 愿你拥有比阳光明媚的心情 │ │ 01日星期五 │ 04:49 │ 高温 35.0℃ │ 低温 20.0℃ │ 19:36 │ 74 │ 西南风 │ &lt;3级 │ 晴 │ 愿你拥有比阳光明媚的心情 │ └────────────────┴─────────┴────────────────┴────────────────┴────────┴─────┴───────────┴────────┴────────┴────────────────────────────────────── 正则表达式 编程实现：使用正则表达式提取以下文本中的 邮箱账号 手机号 和网址 qq1234@qq.com|1802188880$http:\\\\wwww.baidu.com 编程实现：实现一个简单的爬虫程序，爬取百度go语言关键字的搜索结果，使用正则表达式获取每个结果的超链接地址。 反射 编程实现：List是个切片类型(List := make([]interface{},3)，现有以下的数据，要求使用反射筛选出各类型的数据。 List[0] =&quot;123&quot; List[1] =13579 List[2] =20.2 List[3] =Person&#123;&quot;小明&quot;,18&#125; 编程实现：每个学生的信息包括学号(num)、姓名(name)、性别(sex)、成绩( score),请定义学生信息结构体对象 student,并初始化。最后要求使用反射原理修改学生基本信息,并输出修改后的结果。 解释为什么打印输出是false？修改A行以确保打印输出true。 package main import ( &quot;fmt&quot; &quot;reflect&quot; ) type S struct &#123; a, b, c string &#125; func main() &#123; x := interface&#123;&#125;(&amp;S&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;) y := interface&#123;&#125;(&amp;S&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;) fmt.Println( x == y) //A &#125; go并发与通信协程goroutine 简述 线程和协程之间的区别。 编程实现：协程交替执行,使其能顺序输出1-20的自然数。 如何限制goroutine的创建数量？ 如何等待所有goroutine的退出？ goroutine是怎么样调度的？ 通道channel 编程实现：使用channel实现斐波那契数列。 编程实现：使用for循环10次，打印出计数器i的值，要求：main调用的函数是一个goroutine并且使用channel通讯，不用关心goroutine是如何停止的。 编程实现：对上面一题进行拓展，使用两个channel和select，另一个channel用于状态判断，实程序正常运行。 select可以用于什么? 无缓冲和缓冲通道之间有什么区别？ 关于channel的特性，下面说法正确的是（） A. 给一个 nil channel 发送数据，造成永远阻塞 B. 从一个 nil channel 接收数据，造成永远阻塞 C. 给一个已经关闭的 channel 发送数据，引起 panic D. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值 E. 无缓冲的channel和有缓冲的channel都是非同步的 F. 无缓冲的channel是同步的，而有缓冲的channel是非同步的 goroutine的泄漏怎么处理？ 锁与同步 执行以下代码时将打印什么？并解决问题以确保len（m）打印为10。 package main import ( &quot;sync&quot; ) const N = 10 func main() &#123; m := make(map[int]int) wg := &amp;sync.WaitGroup&#123;&#125; mu := &amp;sync.Mutex&#123;&#125; wg.Add(N) for i := 0; i &lt; N; i++ &#123; go func() &#123; defer wg.Done() mu.Lock() m[i] = i mu.Unlock() &#125;() &#125; wg.Wait() println(len(m)) &#125; 编程实现：使用读写锁实现一个安全Map,下面代码是安全Map的实现，要求：实现这个Map的 存储操作 获取操作 删除操作 遍历Map type SynchronizedMap struct &#123; rw *sync.RWMutex data map[interface&#123;&#125;]interface&#123;&#125; &#125; 如何实现消息队列（多生产者，多消费者）？ 原子操作 编程实现：使用add原子操作来并发地递增一个int32值。创建1000个新协程。每个新协程将整数n的值增加1。 原子操作保证这1000个新协程之间不会发生数据竞争，最终程序打印1000。 什么是乐观锁？什么是悲观锁？各自的应用场景是什么? 赋值是原子操作吗？ 64位整数值的地址是否能保证总是64位对齐的，以便可以被安全地原子访问？ 本文转自 https://blog.csdn.net/yang731227/article/details/90637411，如有侵权，请联系删除。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"Go总结","slug":"Go总结","permalink":"https://ysluckly.github.io/tags/Go%E6%80%BB%E7%BB%93/"},{"name":"Go练习题","slug":"Go练习题","permalink":"https://ysluckly.github.io/tags/Go%E7%BB%83%E4%B9%A0%E9%A2%98/"}]},{"title":"休闲娱乐-小游戏","slug":"game","date":"2022-02-01T17:00:10.000Z","updated":"2022-02-20T13:54:25.410Z","comments":true,"path":"2022/02/02/gamesh/","link":"","permalink":"https://ysluckly.github.io/2022/02/02/gamesh/","excerpt":"","text":"休闲小游戏是小游戏的一种。一般都是在看技术博客累的时候玩的，后来发展成网页游戏。并成为网络游戏集，并加以利用加入网络等元素，可以和网友进行比拼，使得休闲小游戏得以发展。 ①、2048-小游戏 | 点击进入…②、五子棋- 小游戏 | 点击进入…③、圈小猫-小游戏 | 点击进入…④、3D元素周期表-小游戏 | 点击进入…⑤、弹钢琴-小游戏 | 点击进入…⑥、吃豆人-小游戏 | 点击进入…","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"game","slug":"game","permalink":"https://ysluckly.github.io/tags/game/"}]},{"title":"Go全栈面试题（4）-数据库面试题","slug":"back-end/1645851816502","date":"2022-02-01T07:29:32.000Z","updated":"2022-02-26T05:49:38.710Z","comments":true,"path":"2022/02/01/mysql/","link":"","permalink":"https://ysluckly.github.io/2022/02/01/mysql/","excerpt":"","text":"=================================================================== 数据库MySQL面试题 MySQL的数据类型 整型 类型 存储 存储 最小值 最大值 byte bit signed signed TINYINT 1 8 -27 = -128 27-1 = 127 SMALLINT 2 16 MEDIUMINT 3 24 INT 4 32 -231 = -2147483648 231-1 = 2147483647 BIGINT 8 64 TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。 INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。2. 浮点数 FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。 FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。 字符串 MySQL中主要有 CHAR 和 VARCHAR 两种字符串类型，一种是定长的，一种是变长的。 VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。 VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。 时间和日期 MySQL中提供了两种相似的日期时间类型：DATATIME 和 TIMESTAMP。 DATATIME 能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。 它与时区无关。 默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATATIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。 TIMESTAMP 和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。 它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。 MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。 默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。 应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。 MySQL中utf8和utf8mb4区别?MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。好在utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。当然，为了节省空间，一般情况下使用utf8也就可以了。 MySQL支持的 utf8 编码最大字符长度为 3 字节，如果遇到 4 字节的宽字符就会插入异常了。三个字节的 UTF-8 最大能编码的 Unicode 字符是 0xffff，也就是 Unicode 中的基本多文种平面(BMP)。任何不在基本多文本平面的 Unicode字符，都无法使用 MySQL 的 utf8 字符集存储。包括 Emoji 表情(Emoji 是一种特殊的 Unicode 编码，常见于 ios 和 android 手机上)，和很多不常用的汉字，以及任何新增的 Unicode 字符等等。 MySQL 中保存 4 字节长度的 UTF-8 字符，需要使用 utf8mb4 字符集，但只有 5.5.3 版本以后的才支持(查看版本： select version()?。我觉得，为了获取更好的兼容性，应该总是使用 utf8mb4 而非 utf8. 对于 CHAR 类型数据，utf8mb4 会多消耗一些空间，根据 MySQL 官方建议，使用 VARCHAR 替代 CHAR。 MySQL和redis区别是什么？ MySQL和redis的数据库类型 MySQL是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢。 redis是NOSQL，即非关系型数据库，也是缓存数据库，即将数据存储在缓存中，缓存的读取速度快，能够大大的提高运行效率，但是保存时间有限。 MySQL的运行机制 MySQL作为持久化存储的关系型数据库，相对薄弱的地方在于每次请求访问数据库时，都存在着I/O操作，如果反复频繁的访问数据库。第一：会在反复链接数据库上花费大量时间，从而导致运行效率过慢；第二：反复的访问数据库也会导致数据库的负载过高，那么此时缓存的概念就衍生了出来。 缓存 缓存就是数据交换的缓冲区（cache），当浏览器执行请求时，首先会对在缓存中进行查找，如果存在，就获取；否则就访问数据库。 缓存的好处就是读取速度快。 redis数据库 redis数据库就是一款缓存数据库，用于存储使用频繁的数据，这样减少访问数据库的次数，提高运行效率。 redis和MySQL的区别总结 （1）类型上 从类型上来说，MySQL是关系型数据库，redis是缓存数据库 （2）作用上 MySQL用于持久化的存储数据到硬盘，功能强大，但是速度较慢 redis用于存储使用较为频繁的数据到缓存中，读取速度快 （3）需求上 MySQL和redis因为需求的不同，一般都是配合使用。 MySQL高可用方案有哪些?MySQL高可用方案包括: 主从复制方案 这是MySQL自身提供的一种高可用解决方案，数据同步方法采用的是MySQL replication技术。MySQL replication就是从服务器到主服务器拉取二进制日志文件，然后再将日志文件解析成相应的SQL在从服务器上重新执行一遍主服务器的操作，通过这种方式保证数据的一致性。为了达到更高的可用性，在实际的应用环境中，一般都是采用MySQL replication技术配合高可用集群软件keepalived来实现自动failover，这种方式可以实现95.000%的SLA。 MMM/MHA高可用方案 MMM提供了MySQL主主复制配置的监控、故障转移和管理的一套可伸缩的脚本套件。在MMM高可用方案中，典型的应用是双主多从架构，通过MySQL replication技术可以实现两个服务器互为主从，且在任何时候只有一个节点可以被写入，避免了多点写入的数据冲突。同时，当可写的主节点故障时，MMM套件可以立刻监控到，然后将服务自动切换到另一个主节点，继续提供服务，从而实现MySQL的高可用。 Heartbeat/SAN高可用方案 在这个方案中，处理failover的方式是高可用集群软件Heartbeat，它监控和管理各个节点间连接的网络，并监控集群服务，当节点出现故障或者服务不可用时，自动在其他节点启动集群服务。在数据共享方面，通过SAN（Storage Area Network）存储来共享数据，这种方案可以实现99.990%的SLA。 Heartbeat/DRBD高可用方案 这个方案处理failover的方式上依旧采用Heartbeat，不同的是，在数据共享方面，采用了基于块级别的数据同步软件DRBD来实现。DRBD是一个用软件实现的、无共享的、服务器之间镜像块设备内容的存储复制解决方案。和SAN网络不同，它并不共享存储，而是通过服务器之间的网络复制数据。 NDB CLUSTER高可用方案 国内用NDB集群的公司非常少，貌似有些银行有用。NDB集群不需要依赖第三方组件，全部都使用官方组件，能保证数据的一致性，某个数据节点挂掉，其他数据节点依然可以提供服务，管理节点需要做冗余以防挂掉。缺点是：管理和配置都很复杂，而且某些SQL语句例如join语句需要避免。 MySQL并发一致性问题在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。 丢失修改T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。 读脏数据T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。 不可重复读T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。 幻影读T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。 产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。 MySQL中乐观锁和悲观锁 原理、区别?悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。 乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。 乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。 乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，然后按照如下方式实现： 1. SELECT data AS old_data, version AS old_version FROM …; 2. 根据获取的数据进行业务操作，得到new_data和new_version 3. UPDATE SET data = new_data, version = new_version WHERE version = old_version if (updated row &gt; 0) &#123; // 乐观锁获取成功，操作完成 &#125; else &#123; // 乐观锁获取失败，回滚并重试 &#125; 乐观锁是否在事务中其实都是无所谓的，其底层机制是这样：在数据库内部update同一行的时候是不允许并发的，即数据库每次执行一条update语句时会获取被update行的写锁，直到这一行被成功更新后才释放。因此在业务操作进行前获取需要锁的数据的当前版本号，然后实际更新数据时再次对比版本号确认与之前获取的相同，并更新版本号，即可确认这之间没有发生并发的修改。如果更新失败即可认为老版本的数据已经被并发修改掉而不存在了，此时认为获取锁失败，需要回滚整个业务操作并可根据需要重试整个过程。 两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。 什么是MySQL事务？事务是一组原子性的sql命令或者说是一个独立的工作单元,如果数据库引擎能够成功的对数据库应用该组的全部sql语句,那么就执行该组命令如果其中有任何一条语句因为崩溃或者其它原因无法执行,那么该组中所有的sql语句都不会执行,如果没有显示启动事务,数据库会根据autocommit的值.默认每条sql操作都会自动提交。 原子性（Atomicity） 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。 回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。 一致性（Consistency） 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。 隔离性（Isolation） 一个事务所做的修改在最终提交以前，对其它事务是不可见的。 持久性（Durability） 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。使用重做日志来保证持久性。 事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系： 只有满足一致性，事务的执行结果才是正确的。 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。 事务满足持久化是为了能应对数据库崩溃的情况。 MySQL 默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。 什么是 Next-Key Locks？Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。 MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。 Record Locks 锁定一个记录上的索引，而不是记录本身。 如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。 Gap Locks 锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。 SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE; Next-Key Locks 它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间： (negative infinity, 10] (10, 11] (11, 13] (13, 20] (20, positive infinity) ISAM是什么？MySQL 5.5 版本之前的默认存储引擎，在 5.0 以前最大表存储空间最大 4G，5.0 以后最大 256TB。 Myisam 存储引擎由 .myd（数据）和 .myi（索引文件）组成，.frm文件存储表结构（所以存储引擎都有） 特性 并发性和锁级别 （对于读写混合的操作不好，为表级锁，写入和读互斥） 表损坏修复 Myisam 表支持的索引类型（全文索引） Myisam 支持表压缩（压缩后，此表为只读，不可以写入。使用 myisampack 压缩） 应用场景 没有事务 只读类应用（插入不频繁，查询非常频繁） 空间类应用（唯一支持空间函数的引擎） 做很多 count 的计算 InnoDB是什么？MySQL 5.5 及之后版本的默认存储引擎 特性 InnoDB为事务性存储引擎 完全支持事物的 ACID 特性 Redo log （实现事务的持久性） 和 Undo log（为了实现事务的原子性，存储未完成事务log，用于回滚） InnoDB支持行级锁 行级锁可以最大程度的支持并发 行级锁是由存储引擎层实现的 应用场景 可靠性要求比较高，或者要求事务 表更新和查询都相当的频繁，并且行锁定的机会比较大的情况。 MyISAM和InnoDB引擎的区别?两者之间的区别： MyISAM 不支持外键，而 InnoDB 支持 MyISAM 是非事务安全型的，而 InnoDB 是事务安全型的。 MyISAM 锁的粒度是表级，而 InnoDB 支持行级锁定。 MyISAM 支持全文类型索引，而 InnoDB 不支持全文索引。 MyISAM 相对简单，所以在效率上要优于 InnoDB，小型应用可以考虑使用 MyISAM。 MyISAM 表是保存成文件的形式，在跨平台的数据转移中使用 MyISAM 存储会省去不少的麻烦。 InnoDB 表比 MyISAM 表更安全，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。 应用场景： MyISAM 管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的 SELECT 查询，那么 MyISAM 是更好的选择。 InnoDB 用于事务处理应用程序，具有众多特性，包括 ACID 事务支持。如果应用中需要执行大量的 INSERT 或 UPDATE 操作，则应该使用 InnoDB，这样可以提高多用户并发操作的性能。 MySQL如何支持事务？MYSQL的事务处理主要有两种方法 用begin,rollback,commit来实现 begin开始一个事务 rollback事务回滚 commit 事务确认 直接用set来改变MySQL的自动提交模式 MySQL默认是自动提交的，也就是你提交一个query，就直接执行！可以通过 set autocommit = 0 禁止自动提交 set autocommit = 1 开启自动提交 来实现事务的处理 MySQL索引使用场景在什么情况下使用索引 通常为了快速查找匹配WHERE条件的行。 通常为了从考虑的条件中消除行。 如果表有一个multiple-column索引，任何一个索引的最左前缀可以通过使用优化器来查找行。 查询中与其它表关联的字，字段常常建立了外键关系 查询中统计或分组统计的字段 select max(hbs_bh) from zl_yhjbqk select qc_bh,count(*) from zl_yhjbqk group by qc_bh 主键、外键和索引的区别 定义 作用 个数 主键 唯一标识一条记录，不能有重复的，不允许为空 用来保证数据完整性 主键只能有一个 外键 表的外键是另一表的主键，外键可以有重复的，可以是空值 用来和其他表建立联系用的 一个表可以有多个外键 索引 该字段没有重复值，但可以有一个空值 是提高查询排序的速度 一个表可以有多个惟一索引 RedisRedis的数据结构有哪些，以及实现场景?Redis的数据结构有五种: string 字符串 String 数据结构是简单的 key-value 类型，value 不仅可以是 String，也可以是数字（当数字类型用 Long 可以表示的时候encoding 就是整型，其他都存储在 sdshdr 当做字符串）。使用 Strings 类型，可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受 Redis 的定时持久化（可以选择 RDB 模式或者 AOF 模式），操作日志及 Replication 等功能。 除了提供与 Memcached 一样的 get、set、incr、decr 等操作外，Redis 还提供了下面一些操作： LEN niushuai：O(1)获取字符串长度. APPEND niushuai redis：往字符串 append 内容，而且采用智能分配内存（每次2倍）. 设置和获取字符串的某一段内容. 设置及获取字符串的某一位（bit）. 批量设置一系列字符串的内容. 原子计数器. GETSET 命令的妙用，请于清空旧值的同时设置一个新值，配合原子计数器使用. Hash 字典 在 Memcached 中，我们经常将一些结构化的信息打包成 hashmap，在客户端序列化后存储为一个字符串的值（一般是 JSON 格式），比如用户的昵称、年龄、性别、积分等。这时候在需要修改其中某一项时，通常需要将字符串（JSON）取出来，然后进行反序列化，修改某一项的值，再序列化成字符串（JSON）存储回去。简单修改一个属性就干这么多事情，消耗必定是很大的，也不适用于一些可能并发操作的场合（比如两个并发的操作都需要修改积分）。而 Redis 的 Hash 结构可以使你像在数据库中 Update 一个属性一样只修改某一项属性值。 Hash可以用来存储、读取、修改用户属性。 List 列表 List 说白了就是链表（redis 使用双端链表实现的 List），相信学过数据结构知识的人都应该能理解其结构。使用 List 结构，我们可以轻松地实现最新消息排行等功能（比如新浪微博的 TimeLine ）。List 的另一个应用就是消息队列，可以利用 List 的 *PUSH 操作，将任务存在 List 中，然后工作线程再用 POP 操作将任务取出进行执行。 Redis 还提供了操作 List 中某一段元素的 API，你可以直接查询，删除 List 中某一段的元素。 List 列表应用: 微博 TimeLine. 消息队列. Set 集合 Set 就是一个集合，集合的概念就是一堆不重复值的组合。利用 Redis 提供的 Set 数据结构，可以存储一些集合性的数据。比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。因为 Redis 非常人性化的为集合提供了求交集、并集、差集等操作，那么就可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。 Set 集合应用: 共同好友、二度好友 利用唯一性，可以统计访问网站的所有独立 IP. 好友推荐的时候，根据 tag 求交集，大于某个 threshold 就可以推荐. Sorted Set有序集合 和Sets相比，Sorted Sets是将 Set 中的元素增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，比如一个存储全班同学成绩的 Sorted Sets，其集合 value 可以是同学的学号，而 score 就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用 Sorted Sets 来做带权重的队列，比如普通消息的 score 为1，重要消息的 score 为2，然后工作线程可以选择按 score 的倒序来获取工作任务。让重要的任务优先执行。 Sorted Set有序集合应用: 1.带有权重的元素，比如一个游戏的用户得分排行榜.2.比较复杂的数据结构，一般用到的场景不算太多. Redis 其他功能使用场景: 订阅-发布系统 Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在 Redis 中，你可以设定对某一个 key 值进行消息发布及消息订阅，当一个 key 值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。 事务——Transactions 谁说 NoSQL 都不支持事务，虽然 Redis 的 Transactions 提供的并不是严格的 ACID 的事务（比如一串用 EXEC 提交执行的命令，在执行中服务器宕机，那么会有一部分命令执行了，剩下的没执行），但是这个 Transactions 还是提供了基本的命令打包执行的功能（在服务器不出问题的情况下，可以保证一连串的命令是顺序在一起执行的，中间有会有其它客户端命令插进来执行）。Redis 还提供了一个 Watch 功能，你可以对一个 key 进行 Watch，然后再执行 Transactions，在这过程中，如果这个 Watched 的值进行了修改，那么这个 Transactions 会发现并拒绝执行。 Redis分布式锁是什么回事？先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。 如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？这个锁就永远得不到释放了。 如何解决？set指令有非常复杂的参数，可以同时把setnx和expire合成一条指令来用。 Redis异步队列是怎么用的？一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。 如果不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。 如何生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。 pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。 redis如何实现延时队列？使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。 Redis如何做持久化的？bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，优先使用aof来恢复内存的状态，如果没有aof日志，就会使用rdb文件来恢复。 aof文件过大恢复时间过长怎么办？Redis会定期做aof重写，压缩aof文件日志大小。Redis4.0之后有了混合持久化的功能，将bgsave的全量和aof的增量做了融合处理，这样既保证了恢复的效率又兼顾了数据的安全性。 在大规模数据中，如何找出有固定前缀的key？使用keys指令可以扫出指定模式的key列表。 如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？redis有一个关键的特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。 如果有大量的key需要设置同一时间过期，一般需要注意什么？如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。 Pipeline有什么好处，为什么要用pipeline？可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。 Redis的同步机制是什么？Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。 Redis集群原理是什么？Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。 Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。 如何解决 Redis 的并发竞争 Key 问题?所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！ 推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能） 基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。 在实践中，当然是从以可靠性为主。所以首推Zookeeper。 为什么要用 redis/为什么要用缓存?主要从“高性能”和“高并发”这两点来看待这个问题。 高性能： 假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！ 高并发： 直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。 为什么要用 redis 而不用 map 做缓存?缓存分为本地缓存和分布式缓存。以 go为例，使用自带的 map实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着程序的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。 使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。 如何优化Redis查询性能？ 使用 Explain 进行分析 Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。 字段有： select_type : 查询类型，有简单查询、联合查询、子查询等 key : 使用的索引 rows : 扫描的行数 mysql&gt; explain select * from user_info where id = 3\\G *************************** 1. row *************************** id: 3 select_type: SIMPLE table: user_info partitions: NULL type: const possible_keys: PRIMARY key: PRIMARY key_len: 8 ref: const rows: 1 filtered: 100.00 Extra: NULL 1 row in set, 1 warning (0.00 sec) 优化数据访问 减少请求的数据量: 只返回必要的列 最好不要使用 SELECT * 语句。 只返回必要的行 使用 WHERE 语句进行查询过滤，有时候也需要使用 LIMIT 语句来限制返回的数据。 缓存重复查询的数据 使用缓存可以避免在数据库中进行查询，特别要查询的数据经常被重复查询，缓存可以带来的查询性能提升将会是非常明显的。 减少服务器端扫描的行数 对于查询来说，其中最有效的方式是使用索引来覆盖查询。 重构查询方式 切分大查询 一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。 DELEFT FROM info WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH); rows_affected = 0 do &#123; rows_affected = do_query( &quot;DELETE FROM info WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;) &#125; while rows_affected &gt; 0 分解大连接查询 将一个大连接查询（JOIN）分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有： 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。 减少锁竞争； 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可扩展。 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。 如何最大限度地降低死锁？ 按同一顺序访问对象 避免事务中的用户交互 保持事务简短并在一个批处理中 使用低隔离级别 使用绑定连接 本文转自 https://blog.csdn.net/yang731227/article/details/90637558，如有侵权，请联系删除。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://ysluckly.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"MySQL总结","slug":"MySQL总结","permalink":"https://ysluckly.github.io/tags/MySQL%E6%80%BB%E7%BB%93/"}]},{"title":"MySQL 有这一篇就够（呕心狂敲37k字，只为博君一点赞！！！）","slug":"database/1645798970213","date":"2022-01-31T07:29:32.000Z","updated":"2022-02-25T15:57:17.872Z","comments":true,"path":"2022/01/31/mysql/","link":"","permalink":"https://ysluckly.github.io/2022/01/31/mysql/","excerpt":"","text":"文章目录 前言 一、SQL简述 1.SQL的概述 2.SQL的优点 3.SQL的分类 二、数据库的三大范式 三、数据库的数据类型 1.整数类型 2.浮点数类型和定点数类型 3.字符串类型 4.字符串类型 5.日期与时间类型 5.1 YEAR类型 5.2 TIME类型 5.3 DATETIME类型 5.4 TIMESTAMP类型 6.二进制类型 四、数据库、数据表的基本操作 1.数据库的基本操作 2.数据表的基本操作 2.1 创建数据表 2.2 查看数据表 2.3 修改数据表 2.4 删除数据表 五、数据表的约束 1.主键约束 2.非空约束 3.默认值约束 5.唯一性约束 6.外键约束 6.1 数据一致性概念 6.2 删除外键 6.3 关于外键约束需要注意的细节 六、数据表插入数据 1. 为表中所有字段插入数据 2. 为表中指定字段插入数据 3. 同时插入多条记录 七、更新数据 1. UPDATE基本语法 2. UPDATE更新部分数据 3. UPDATE更新全部数据 八、删除数据 1. DELETE基本语法 2. DELETE删除部分数据 3. DELETE删除全部数据 4. TRUNCATE和DETELE的区别 九、MySQL数据表简单查询 1.简单查询概述 2.查询所有字段（方法不唯一只是举例） 3.查询指定字段（sid、sname） 4.常数的查询 5.从查询结果中过滤重复数据 6.算术运算符（举例加运算符） 十、函数 1.聚合函数 1.1、count（） 1.2、max（） 1.3、min（） 1.4、sum（） 1.5、avg（） 2.其他常用函数 2.1、时间函数 2.2、字符串函数 2.3、数学函数 十一、条件查询 1.使用关系运算符查询 2.使用IN关键字查询 3.使用BETWEEN AND关键字查询 4.使用空值查询 5.使用AND关键字查询 6.使用OR关键字查询 7.使用LIKE关键字查询 7.1 普通字符串 7.2 含有%通配的字符串 7.3 含有_通配的字符串 8.使用LIMIT限制查询结果的数量 9.使用GROUP BY进行分组查询 9.1 GROUP BY和聚合函数一起使用 9.2 GROUP BY和聚合函数以及HAVING一起使用 10.使用ORDER BY对查询结果排序 十二、别名设置 1.为表取别名 2.为字段取别名 十三、表的关联关系 1.关联查询 2.关于关联关系的删除数据 十四、多表连接查询 1.交叉连接查询 2.内连接查询 3.外连接查询 3.1 左（外）连接查询 3.2 右（外）连接查询 十五、子查询 1.带比较运算符的子查询 2.带EXISTS关键字的子查询 3.带ANY关键字的子查询 4.带ALL关键字的子查询 总结 前言知识无底，学海无涯，到今天进入MySQL的学习4天了，知识点虽然简单，但是比较多，所以写一篇博客将MySQL的基础写出来，方便自己以后查找，还有就是分享给大家。 一、SQL简述1.SQL的概述Structure Query Language(结构化查询语言)简称SQL，它被美国国家标准局(ANSI)确定为关系型数据库语言的美国标准，后被国际化标准组织(ISO)采纳为关系数据库语言的国际标准。数据库管理系统可以通过SQL管理数据库；定义和操作数据，维护数据的完整性和安全性。 2.SQL的优点1、简单易学，具有很强的操作性2、绝大多数重要的数据库管理系统均支持SQL3、高度非过程化；用SQL操作数据库时大部分的工作由DBMS自动完成 3.SQL的分类1、DDL(Data Definition Language) 数据定义语言，用来操作数据库、表、列等； 常用语句：CREATE、 ALTER、DROP2、DML(Data Manipulation Language) 数据操作语言，用来操作数据库中表里的数据；常用语句：INSERT、 UPDATE、 DELETE3、DCL(Data Control Language) 数据控制语言，用来操作访问权限和安全级别； 常用语句：GRANT、DENY4、DQL(Data Query Language) 数据查询语言，用来查询数据 常用语句：SELECT 二、数据库的三大范式1、第一范式(1NF)是指数据库表的每一列都是不可分割的基本数据线；也就是说：每列的值具有原子性，不可再分割。2、第二范式(2NF)是在第一范式(1NF)的基础上建立起来得，满足第二范式(2NF)必须先满足第一范式(1NF)。如果表是单主键，那么主键以外的列必须完全依赖于主键；如果表是复合主键，那么主键以外的列必须完全依赖于主键，不能仅依赖主键的一部分。3、第三范式(3NF)是在第二范式的基础上建立起来的，即满足第三范式必须要先满足第二范式。第三范式(3NF)要求：表中的非主键列必须和主键直接相关而不能间接相关；也就是说：非主键列之间不能相关依赖。 三、数据库的数据类型使用MySQL数据库存储数据时，不同的数据类型决定了 MySQL存储数据方式的不同。为此，MySQL数据库提供了多种数据类型，其中包括整数类型、浮点数类型、定点 数类型、日期和时间类型、字符串类型、二进制…等等数据类型。 1.整数类型根据数值取值范围的不同MySQL 中的整数类型可分为5种，分别是TINYINT、SMALUNT、MEDIUMINT、INT和 BIGINT。下图列举了 MySQL不同整数类型所对应的字节大小和取值范围而最常用的为INT类型的， 数据类型 字节数 无符号数的取值范围 有符号数的取值范围 TINYINT 1 0~255 -128~127 SMALLINT 2 0~65535 -32768~32768 MEDIUMINT 3 0~16777215 -8388608~8388608 INT 4 0~4294967295 -2147483648~ 2147483648 BIGINT 8 0~18446744073709551615 -9223372036854775808~9223372036854775808 2.浮点数类型和定点数类型在MySQL数据库中使用浮点数和定点数来存储小数。浮点数的类型有两种：单精度浮点数类型（FLOAT)和双精度浮点数类型（DOUBLE)。而定点数类型只有一种即DECIMAL类型。下图列举了 MySQL中浮点数和定点数类型所对应的字节大小及其取值范围： 数据类型 字节数 有符号的取值范围 无符号的取值范围 FLOAT 4 -3.402823466E+38~-1.175494351E-38 0和1.175494351E-38~3.402823466E+38 DOUBLE 8 -1.7976931348623157E+308~2.2250738585072014E-308 0和2.2250738585072014E-308~1.7976931348623157E+308 DECIMAL（M,D） M+2 -1.7976931348623157E+308~2.2250738585072014E-308 0和2.2250738585072014E-308~1.7976931348623157E+308 从上图中可以看出：DECIMAL类型的取值范围与DOUBLE类型相同。但是，请注意：DECIMAL类型的有效取值范围是由M和D决定的。其中，M表示的是数据的长 度，D表示的是小数点后的长度。比如，将数据类型为DECIMAL(6,2)的数据6.5243 插人数据库后显示的结果为6.52 3.字符串类型在MySQL中常用CHAR 和 VARCHAR 表示字符串。两者不同的是：VARCHAR存储可变长度的字符串。当数据为CHAR(M)类型时，不管插入值的长度是实际是多少它所占用的存储空间都是M个字节；而VARCHAR(M)所对应的数据所占用的字节数为实际长度加1 插入值 CHAR(3) 存储需求 VARCHAR(3) 存储需求 ‘’ ‘’ 3个字节 ‘’ 1个字节 ‘a’ ‘a’ 3个字节 ‘a’ 2个字节 ‘ab’ ‘ab’ 3个字节 ‘ab’ 3个字节 ‘abc’ ‘ab’ 3个字节 ‘abc’ 4个字节 ‘abcd’ ‘ab’ 3个字节 ‘abc’ 4字节 4.字符串类型文本类型用于表示大文本数据，例如，文章内容、评论、详情等，它的类型分为如下4种： 数据类型 储存范围 TINYTEXT 0~255字节 TEXT 0~65535字节 MEDIUMTEXT 0~16777215字节 LONGTEXT 0~4294967295字节 5.日期与时间类型MySQL提供的表示日期和时间的数据类型分别是 ：YEAR、DATE、TIME、DATETIME 和 TIMESTAMP。下图列举了日期和时间数据类型所对应的字节数、取值范围、日期格式以及零值： 数据类型 字节数 取值范围 日期格式 零值 YEAR 1 1901~2155 YYYY 0000 DATE 4 1000-01-01~9999-12-31 YYYY-MM-DD 0000-00-00 TIME 3 -838：59：59~ 838：59：59 HH:MM:SS 00:00:00 DATETIME 8 1000-01-01 00:00:00~9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 0000-00-00 00:00:00 TIMESTAMP 4 1970-01-01 00:00:01~2038-01-19 03:14:07 YYYY-MM-DD HH:MM:SS 0000-00-00 00:00:00 5.1 YEAR类型YEAR类型用于表示年份，在MySQL中，可以使用以下三种格式指定YEAR类型 的值。1、使用4位字符串或数字表示，范围为’1901’—‘2155’或1901—2155。例如，输人 ‘2019’或2019插人到数据库中的值均为2019。2、使用两位字符串表示，范围为’00’—‘99’。其中，‘00’—‘69’范围的值会被转换为 2000—2069范围的YEAR值，‘70’—‘99’范围的值会被转换为1970—1999范围的YEAR 值。例如，输人’19’插人到数据库中的值为2019。3、使用两位数字表示，范围为1—99。其中，1—69范围的值会被转换为2001— 2069范围的YEAR值，70—99范围的值会被转换为1970—1999范围的YEAR值。例 如，输人19插入到数据库中的值为2019。请注意：当使用YEAR类型时，一定要区分’0’和0。因为字符串格式的’0’表示的YEAR值是2000而数字格式的0表示的YEAR值是0000。 5.2 TIME类型TIME类型用于表示时间值，它的显示形式一般为HH:MM:SS，其中，HH表示小时， MM表示分,SS表示秒。在MySQL中，可以使用以下3种格式指定TIME类型的值。1、以’D HH:MM:SS’字符串格式表示。其中，D表示日可取0—34之间的值, 插人数据时，小时的值等于(DX24+HH)。例如，输入’2 11:30:50’插人数据库中的日期为59:30:50。2、以’HHMMSS’字符串格式或者HHMMSS数字格式表示。 例如，输人’115454’或115454,插入数据库中的日期为11:54:543、使用CURRENT_TIME或NOW()输人当前系统时间。 5.3 DATETIME类型DATETIME类型用于表示日期和时间，它的显示形式为’YYYY-MM-DD HH: MM:SS’，其中，YYYY表示年，MM表示月，DD表示日，HH表示小时，MM表示分，SS 表示秒。在MySQL中，可以使用以下4种格式指定DATETIME类型的值。以’YYYY-MM-DD HH:MM:SS’或者’YYYYMMDDHHMMSS’字符串格式表示的日期和时间，取值范围为’1000-01-01 00:00:00’—‘9999-12-3 23:59:59’。例如，输人’2019-01-22 09:01:23’或 ‘20140122_0_90123’插人数据库中的 DATETIME 值都为 2019-01-22 09:01:23。1、以’YY-MM-DD HH:MM:SS’或者’YYMMDDHHMMSS’字符串格式表示的日期和时间，其中YY表示年，取值范围为’00’—‘99’。与DATE类型中的YY相同，‘00’— ‘69’范围的值会被转换为2000—2069范围的值，‘70’—‘99’范围的值会被转换为1970—1999范围的值。2、以YYYYMMDDHHMMSS或者YYMMDDHHMMSS数字格式表示的日期 和时间。例如，插入20190122090123或者190122090123,插人数据库中的DATETIME值都 为 2019-01-22 09:01:23。3、使用NOW来输人当前系统的日期和时间。 5.4 TIMESTAMP类型TIMESTAMP类型用于表示日期和时间，它的显示形式与DATETIME相同但取值范围比DATETIME小。在此，介绍几种TIMESTAMP类型与DATATIME类型不同的形式：1、使用CURRENT_TIMESTAMP输人系统当前日期和时间。2、输人NULL时系统会输人系统当前日期和时间。3、无任何输人时系统会输入系统当前日期和时间。 6.二进制类型在MySQL中常用BLOB存储二进制类型的数据，例如：图片、PDF文档等。BLOB类型分为如下四种： 数据类型 储存范围 TINYBLOB 0~255字节 BLOB 0~65535字节 MEDIUMBLOB 0~16777215字节 LONGBLOB 0~4294967295字节 四、数据库、数据表的基本操作1.数据库的基本操作MySQL安装完成后，要想将数据存储到数据库的表中，首先要创建一个数据库。创 建数据库就是在数据库系统中划分一块空间存储数据，语法如下： create database 数据库名称; 创建一个叫db1的数据库MySQL命令： -- 创建一个叫db1的数据库 show create database db1; 运行效果展示：创建数据库后查看该数据库基本信息MySQL命令： show create database db1; 运行效果展示：删除数据库MySQL命令： drop database db1; 运行效果展示：查询出MySQL中所有的数据库MySQL命令： show databases; 运行效果展示：将数据库的字符集修改为gbk MySQL命令： alter database db1 character set gbk; 运行效果展示：切换数据库 MySQL命令： use db1; 运行效果展示：查看当前使用的数据库 MySQL命令： select database(); 运行效果展示： 2.数据表的基本操作数据库创建成功后可在该数据库中创建数据表(简称为表)存储数据。请注意：在操作数据表之前应使用“USE 数据库名;”指定操作是在哪个数据库中进行先关操作，否则会抛出“No database selected”错误。语法如下： create table 表名( 字段1 字段类型, 字段2 字段类型, … 字段n 字段类型 ); 2.1 创建数据表示例：创建学生表 MySQL命令： create table student( id int, name varchar(20), gender varchar(10), birthday date ); 运行效果展示： 2.2 查看数据表示例：查看当前数据库中所有表 MySQL命令： show tables; 运行效果展示：示例：查表的基本信息 MySQL命令： show create table student; 运行效果展示：示例：查看表的字段信息 MySQL命令： desc student; 运行效果展示： 2.3 修改数据表有时，希望对表中的某些信息进行修改，例如：修改表名、修改字段名、修改字段 数据类型…等等。在MySQL中使用alter table修改数据表.示例：修改表名 MySQL命令： alter table student rename to stu; 运行效果展示：示例：修改字段名 MySQL命令： alter table stu change name sname varchar(10); 运行效果展示：示例：修改字段数据类型 MySQL命令： alter table stu modify sname int; 运行效果展示：示例：增加字段 MySQL命令： alter table stu add address varchar(50); 运行效果展示：示例：删除字段 MySQL命令： alter table stu drop address; 运行效果展示： 2.4 删除数据表语法： drop table 表名; 示例：删除数据表 MySQL命令： drop table stu; 运行效果展示： 五、数据表的约束为防止错误的数据被插入到数据表，MySQL中定义了一些维护数据库完整性的规则；这些规则常称为表的约束。常见约束如下： 约束条件 说明 PRIMARY KEY 主键约束用于唯一标识对应的记录 FOREIGN KEY 外键约束 NOT NULL 非空约束 UNIQUE 唯一性约束 DEFAULT 默认值约束，用于设置字段的默认值 以上五种约束条件针对表中字段进行限制从而保证数据表中数据的正确性和唯一性。换句话说，表的约束实际上就是表中数据的限制条件。 1.主键约束主键约束即primary key用于唯一的标识表中的每一行。被标识为主键的数据在表中是唯一的且其值不能为空。这点类似于我们每个人都有一个身份证号，并且这个身份证号是唯一的。主键约束基本语法： 字段名 数据类型 primary key; 设置主键约束(primary key)的第一种方式示例：MySQL命令： create table student( id int primary key, name varchar(20) ); 运行效果展示：设置主键约束(primary key)的第二·种方式示例：MySQL命令： create table student01( id int name varchar(20), primary key(id) ); 运行效果展示： 2.非空约束非空约束即 NOT NULL指的是字段的值不能为空，基本的语法格式如下所示： 字段名 数据类型 NOT NULL; 示例：MySQL命令： create table student02( id int name varchar(20) not null ); 运行效果展示： 3.默认值约束默认值约束即DEFAULT用于给数据表中的字段指定默认值，即当在表中插入一条新记录时若未给该字段赋值，那么，数据库系统会自动为这个字段插人默认值；其基本的语法格式如下所示： 字段名 数据类型 DEFAULT 默认值； 示例：MySQL命令： create table student03( id int, name varchar(20), gender varchar(10) default &#39;male&#39; ); 运行效果展示： 5.唯一性约束唯一性约束即UNIQUE用于保证数据表中字段的唯一性，即表中字段的值不能重复出现，其基本的语法格式如下所示： 字段名 数据类型 UNIQUE; 示例：MySQL命令： create table student04( id int, name varchar(20) unique ); 运行效果展示： 6.外键约束外键约束即FOREIGN KEY常用于多张表之间的约束。基本语法如下： -- 在创建数据表时语法如下： CONSTRAINT 外键名 FOREIGN KEY (从表外键字段) REFERENCES 主表 (主键字段) -- 将创建数据表创号后语法如下： ALTER TABLE 从表名 ADD CONSTRAINT 外键名 FOREIGN KEY (从表外键字段) REFERENCES 主表 (主键字段); 示例：创建一个学生表 MySQL命令： create table student05( id int primary key, name varchar(20) ); 示例：创建一个班级表 MySQL命令： create table class( classid int primary key, studentid int ); 示例：学生表作为主表，班级表作为副表设置外键， MySQL命令： alter table class add constraint fk_class_studentid foreign key(studentid) references student05(id); 运行效果展示： 6.1 数据一致性概念大家知道：建立外键是为了保证数据的完整和统一性。但是，如果主表中的数据被删除或修改从表中对应的数据该怎么办呢？很明显，从表中对应的数据也应该被删除，否则数据库中会存在很多无意义的垃圾数据。 6.2 删除外键语法如下： alter table 从表名 drop foreign key 外键名； 示例：删除外键 MySQL命令： alter table class drop foreign key fk_class_studentid; 运行效果展示：外键的那个字段不在了证明删除成功了 6.3 关于外键约束需要注意的细节1、从表里的外键通常为主表的主键2、从表里外键的数据类型必须与主表中主键的数据类型一致3、主表发生变化时应注意主表与从表的数据一致性问题 六、数据表插入数据在MySQL通过INSERT语句向数据表中插入数据。在此，我们先准备一张学生表，代码如下： create table student( id int, name varchar(30), age int, gender varchar(30) ); 1. 为表中所有字段插入数据每个字段与其值是严格一一对应的。也就是说：每个值、值的顺序、值的类型必须与对应的字段相匹配。但是，各字段也无须与其在表中定义的顺序一致，它们只要与 VALUES中值的顺序一致即可。语法如下： INSERT INTO 表名（字段名1,字段名2,...) VALUES (值 1,值 2,...); 示例：向学生表中插入一条学生信息 MySQL命令： insert into student (id,name,age,gender) values (1,&#39;bob&#39;,16,&#39;male&#39;); 运行效果展示： 2. 为表中指定字段插入数据语法如下： INSERT INTO 表名（字段名1,字段名2,...) VALUES (值 1,值 2,...); 插入数据的方法基本和为表中所有字段插入数据，一样，只是需要插入的字段由你自己指定 3. 同时插入多条记录语法如下： INSERT INTO 表名 [(字段名1,字段名2,...)]VALUES (值 1,值 2,…),(值 1,值 2,…),...; 在该方式中：(字段名1,字段名2,…)是可选的，它用于指定插人的字段名；(值 1,值 2,…),(值 1,值 2,…)表示要插人的记录，该记录可有多条并且每条记录之间用逗号隔开。示例：向学生表中插入多条学生信息 MySQL命令： insert into student (id,name,age,gender) values (2,&#39;lucy&#39;,17,&#39;female&#39;),(3,&#39;jack&#39;,19,&#39;male&#39;),(4,&#39;tom&#39;,18,&#39;male&#39;); 运行效果展示： 七、更新数据在MySQL通过UPDATE语句更新数据表中的数据。在此，我们将就用六中的student学生表 1. UPDATE基本语法UPDATE 表名 SET 字段名1=值1[,字段名2 =值2,…] [WHERE 条件表达式]; 在该语法中：字段名1、字段名2…用于指定要更新的字段名称；值1、值 2…用于表示字段的新数据；WHERE 条件表达式 是可选的，它用于指定更新数据需要满足的条件 2. UPDATE更新部分数据示例：将name为tom的记录的age设置为20并将其gender设置为female MySQL命令： update student set age=20,gender=&#39;female&#39; where name=&#39;tom&#39;; 运行效果展示： 3. UPDATE更新全部数据示例：将所有记录的age设置为18 MySQL命令： update student set age=18; 运行效果展示： 八、删除数据在MySQL通过DELETE语句删除数据表中的数据。在此，我们先准备一张数据表，代码如下： -- 创建学生表 create table student( id int, name varchar(30), age int, gender varchar(30) ); -- 插入数据 insert into student (id,name,age,gender) values (2,&#39;lucy&#39;,17,&#39;female&#39;),(3,&#39;jack&#39;,19,&#39;male&#39;),(4,&#39;tom&#39;,18,&#39;male&#39;),(5,&#39;sal&#39;,19,&#39;female&#39;),(6,&#39;sun&#39;,20,&#39;male&#39;) ,(7,&#39;sad&#39;,13,&#39;female&#39;),(8,&#39;sam&#39;,14,&#39;male&#39;); 1. DELETE基本语法在该语法中：表名用于指定要执行删除操作的表；[WHERE 条件表达式]为可选参数用于指定删除的条件。 DELETE FROM 表名 [WHERE 条件表达式]; 2. DELETE删除部分数据示例：删除age等于14的所有记录 MySQL命令： delete from student where age=14; 运行效果展示： 3. DELETE删除全部数据示例：删除student表中的所有记录 MySQL命令： delete from student; 运行效果展示： 4. TRUNCATE和DETELE的区别TRUNCATE和DETELE都能实现删除表中的所有数据的功能，但两者也是有区别的：1、DELETE语句后可跟WHERE子句，可通过指定WHERE子句中的条件表达式只删除满足条件的部分记录；但是，TRUNCATE语句只能用于删除表中的所有记录。2、使用TRUNCATE语句删除表中的数据后，再次向表中添加记录时自动增加字段的默认初始值重新由1开始；使用DELETE语句删除表中所有记录后，再次向表中添加记录时自动增加字段的值为删除时该字段的最大值加13、DELETE语句是DML语句，TRUNCATE语句通常被认为是DDL语句 九、MySQL数据表简单查询1.简单查询概述简单查询即不含where的select语句。在此，我们讲解简单查询中最常用的两种查询：查询所有字段和查询指定字段。在此，先准备测试数据，代码如下： -- 创建数据库 DROP DATABASE IF EXISTS mydb; CREATE DATABASE mydb; USE mydb; -- 创建student表 CREATE TABLE student ( sid CHAR(6), sname VARCHAR(50), age INT, gender VARCHAR(50) DEFAULT &#39;male&#39; ); -- 向student表插入数据 INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1001&#39;, &#39;lili&#39;, 14, &#39;male&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1002&#39;, &#39;wang&#39;, 15, &#39;female&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1003&#39;, &#39;tywd&#39;, 16, &#39;male&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1004&#39;, &#39;hfgs&#39;, 17, &#39;female&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1005&#39;, &#39;qwer&#39;, 18, &#39;male&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1006&#39;, &#39;zxsd&#39;, 19, &#39;female&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1007&#39;, &#39;hjop&#39;, 16, &#39;male&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1008&#39;, &#39;tyop&#39;, 15, &#39;female&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1009&#39;, &#39;nhmk&#39;, 13, &#39;male&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1010&#39;, &#39;xdfv&#39;, 17, &#39;female&#39;); 2.查询所有字段（方法不唯一只是举例）查询所有字段 MySQL命令： select * from student; 运行效果展示： 3.查询指定字段（sid、sname）查询指定字段（sid、sname） MySQL命令： select sid,sname from student; 运行效果展示： 4.常数的查询在SELECT中除了书写列名，还可以书写常数。可以用于标记常数的查询日期标记 MySQL命令： select sid,sname,&#39;2021-03-02&#39; from student; 运行效果展示： 5.从查询结果中过滤重复数据在使用DISTINCT 时需要注意：在SELECT查询语句中DISTINCT关键字只能用在第一个所查列名之前。MySQL命令： select distinct gender from student; 运行效果展示： 6.算术运算符（举例加运算符）在SELECT查询语句中还可以使用加减乘除运算符。查询学生10年后的年龄 MySQL命令： select sname,age+10 from student; 运行效果展示： 十、函数在此，先准备测试数据，代码如下： -- 创建数据库 DROP DATABASE IF EXISTS mydb; CREATE DATABASE mydb; USE mydb; -- 创建student表 CREATE TABLE student ( sid CHAR(6), sname VARCHAR(50), age INT, gender VARCHAR(50) DEFAULT &#39;male&#39; ); -- 向student表插入数据 INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1001&#39;, &#39;lili&#39;, 14, &#39;male&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1002&#39;, &#39;wang&#39;, 15, &#39;female&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1003&#39;, &#39;tywd&#39;, 16, &#39;male&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1004&#39;, &#39;hfgs&#39;, 17, &#39;female&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1005&#39;, &#39;qwer&#39;, 18, &#39;male&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1006&#39;, &#39;zxsd&#39;, 19, &#39;female&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1007&#39;, &#39;hjop&#39;, 16, &#39;male&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1008&#39;, &#39;tyop&#39;, 15, &#39;female&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1009&#39;, &#39;nhmk&#39;, 13, &#39;male&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1010&#39;, &#39;xdfv&#39;, 17, &#39;female&#39;); 1.聚合函数在开发中，我们常常有类似的需求：统计某个字段的最大值、最小值、 平均值等等。为此，MySQL中提供了聚合函数来实现这些功能。所谓聚合，就是将多行汇总成一行；其实，所有的聚合函数均如此——输入多行，输出一行。聚合函数具有自动滤空的功能，若某一个值为NULL，那么会自动将其过滤使其不参与运算。聚合函数使用规则：只有SELECT子句和HAVING子句、ORDER BY子句中能够使用聚合函数。例如，在WHERE子句中使用聚合函数是错误的。接下来，我们学习常用聚合函数。 1.1、count（）统计表中数据的行数或者统计指定列其值不为NULL的数据个数查询有多少该表中有多少人MySQL命令： select count(*) from student; 运行效果展示： 1.2、max（）计算指定列的最大值，如果指定列是字符串类型则使用字符串排序运算 查询该学生表中年纪最大的学生MySQL命令： select max(age) from student; 运行效果展示： 1.3、min（）计算指定列的最小值，如果指定列是字符串类型则使用字符串排序运算 查询该学生表中年纪最小的学生 MySQL命令： select sname,min(age) from student; 运行效果展示： 1.4、sum（）计算指定列的数值和，如果指定列类型不是数值类型则计算结果为0查询该学生表中年纪的总和 MySQL命令： select sum(age) from student; 运行效果展示： 1.5、avg（）计算指定列的平均值，如果指定列类型不是数值类型则计算结果为 查询该学生表中年纪的平均数 MySQL命令： select avg(age) from student; 运行效果展示： 2.其他常用函数这里我就不一一举例了，基本混个眼熟，以后用到再细说 2.1、时间函数SELECT NOW(); SELECT DAY (NOW()); SELECT DATE (NOW()); SELECT TIME (NOW()); SELECT YEAR (NOW()); SELECT MONTH (NOW()); SELECT CURRENT_DATE(); SELECT CURRENT_TIME(); SELECT CURRENT_TIMESTAMP(); SELECT ADDTIME(&#39;14:23:12&#39;,&#39;01:02:01&#39;); SELECT DATE_ADD(NOW(),INTERVAL 1 DAY); SELECT DATE_ADD(NOW(),INTERVAL 1 MONTH); SELECT DATE_SUB(NOW(),INTERVAL 1 DAY); SELECT DATE_SUB(NOW(),INTERVAL 1 MONTH); SELECT DATEDIFF(&#39;2019-07-22&#39;,&#39;2019-05-05&#39;); 2.2、字符串函数--连接函数 SELECT CONCAT () -- SELECT INSTR (); --统计长度 SELECT LENGTH(); 2.3、数学函数-- 绝对值 SELECT ABS(-136); -- 向下取整 SELECT FLOOR(3.14); -- 向上取整 SELECT CEILING(3.14); 十一、条件查询数据库中存有大量数据，我们可根据需求获取指定的数据。此时，我们可在查询语句中通过WHERE子句指定查询条件对查询结果进行过滤。在开始学习条件查询之前，我们先准备测试数据，代码如下： -- 创建数据库 DROP DATABASE IF EXISTS mydb; CREATE DATABASE mydb; USE mydb; -- 创建student表 CREATE TABLE student ( sid CHAR(6), sname VARCHAR(50), age INT, gender VARCHAR(50) DEFAULT &#39;male&#39; ); -- 向student表插入数据 INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1001&#39;, &#39;lili&#39;, 14, &#39;male&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1002&#39;, &#39;wang&#39;, 15, &#39;female&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1003&#39;, &#39;tywd&#39;, 16, &#39;male&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1004&#39;, &#39;hfgs&#39;, 17, &#39;female&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1005&#39;, &#39;qwer&#39;, 18, &#39;male&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1006&#39;, &#39;zxsd&#39;, 19, &#39;female&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1007&#39;, &#39;hjop&#39;, 16, &#39;male&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1008&#39;, &#39;tyop&#39;, 15, &#39;female&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1009&#39;, &#39;nhmk&#39;, 13, &#39;male&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1010&#39;, &#39;xdfv&#39;, 17, &#39;female&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1012&#39;, &#39;lili&#39;, 14, &#39;male&#39;); INSERT INTO student (sid,sname,age,gender) VALUES (&#39;S_1013&#39;, &#39;wang&#39;, 15, &#39;female&#39;); 1.使用关系运算符查询在WHERE中可使用关系运算符进行条件查询，常用的关系运算符如下所示： 关系运算符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 查询年龄等于或大于17的学生的信息 MySQL命令： select * from student where age&gt;=17; 运行效果展示： 2.使用IN关键字查询IN关键字用于判断某个字段的值是否在指定集合中。如果字段的值恰好在指定的集合中，则将字段所在的记录将査询出来。 查询sid为S_1002和S_1003的学生信息 MySQL命令： select * from student where sid in (&#39;S_1002&#39;,&#39;S_1003&#39;); 运行效果展示：查询sid为S_1001以外的学生的信息 MySQL命令： select * from student where sid not in (&#39;S_1001&#39;); 运行效果展示： 3.使用BETWEEN AND关键字查询BETWEEN AND用于判断某个字段的值是否在指定的范围之内。如果字段的值在指定范围内，则将所在的记录将查询出来查询15到18岁的学生信息 MySQL命令： select * from student where age between 15 and 18; 运行效果展示：查询不是15到18岁的学生信息 MySQL命令： select * from student where age not between 15 and 18; 运行效果展示： 4.使用空值查询在MySQL中，使用 IS NULL关键字判断字段的值是否为空值。请注意：空值NULL不同于0，也不同于空字符串由于student表没有空值就不演示查询空值的了查询sname不为空值的学生信息 MySQL命令： select * from student where sname is not null; 运行效果展示： 5.使用AND关键字查询在MySQL中可使用AND关键字可以连接两个或者多个查询条件。查询年纪大于15且性别为male的学生信息 MySQL命令： select * from student where age&gt;15 and gender=&#39;male&#39;; 运行效果展示： 6.使用OR关键字查询在使用SELECT语句查询数据时可使用OR关键字连接多个査询条件。在使用OR关键字时，只要记录满足其中任意一个条件就会被查询出来查询年纪大于15或者性别为male的学生信息 MySQL命令： select * from student where age&gt;15 or gender=&#39;male&#39;; 运行效果展示： 7.使用LIKE关键字查询MySQL中可使用LIKE关键字可以判断两个字符串是否相匹配 7.1 普通字符串查询sname中与wang匹配的学生信息 MySQL命令： select * from student where sname like &#39;wang&#39;; 运行效果展示： 7.2 含有%通配的字符串%用于匹配任意长度的字符串。例如，字符串“a%”匹配以字符a开始任意长度的字符串查询学生姓名以li开始的记录 MySQL命令： select * from student where sname like &#39;li%&#39;; 运行效果展示：查询学生姓名以g结尾的记录 MySQL命令： select * from student where sname like &#39;%g&#39;; 运行效果展示：查询学生姓名包含s的记录 MySQL命令： select * from student where sname like &#39;%s%&#39;; 运行效果展示 7.3 含有_通配的字符串下划线通配符只匹配单个字符，如果要匹配多个字符，需要连续使用多个下划线通配符。例如，字符串“ab_”匹配以字符串“ab”开始长度为3的字符串，如abc、abp等等；字符串“a__d”匹配在字符“a”和“d”之间包含两个字符的字符串，如”abcd”、”atud”等等。查询学生姓名以zx开头且长度为4的记录 MySQL命令： select * from student where sname like &#39;zx__&#39;; 运行效果展示 查询学生姓名以g结尾且长度为4的记录 MySQL命令： select * from student where sname like &#39;___g&#39;; 运行效果展示 8.使用LIMIT限制查询结果的数量当执行查询数据时可能会返回很多条记录，而用户需要的数据可能只是其中的一条或者几条查询学生表中年纪最小的3位同学 MySQL命令： select * from student order by age asc limit 3; 运行效果展示 9.使用GROUP BY进行分组查询GROUP BY 子句可像切蛋糕一样将表中的数据进行分组，再进行查询等操作。换言之，可通俗地理解为：通过GROUP BY将原来的表拆分成了几张小表。接下来，我们通过一个例子开始学习GROUP BY，代码如下 -- 创建数据库 DROP DATABASE IF EXISTS mydb; CREATE DATABASE mydb; USE mydb; -- 创建员工表 CREATE TABLE employee ( id int, name varchar(50), salary int, departmentnumber int ); -- 向员工表中插入数据 INSERT INTO employee values(1,&#39;tome&#39;,2000,1001); INSERT INTO employee values(2,&#39;lucy&#39;,9000,1002); INSERT INTO employee values(3,&#39;joke&#39;,5000,1003); INSERT INTO employee values(4,&#39;wang&#39;,3000,1004); INSERT INTO employee values(5,&#39;chen&#39;,3000,1001); INSERT INTO employee values(6,&#39;yukt&#39;,7000,1002); INSERT INTO employee values(7,&#39;rett&#39;,6000,1003); INSERT INTO employee values(8,&#39;mujk&#39;,4000,1004); INSERT INTO employee values(9,&#39;poik&#39;,3000,1001); 9.1 GROUP BY和聚合函数一起使用统计各部门员工个数 MySQL命令： select count(*), departmentnumber from employee group by departmentnumber; 运行效果展示统计部门编号大于1001的各部门员工个数 MySQL命令： select count(*), departmentnumber from employee where departmentnumber&gt;1001 group by departmentnumber; 运行效果展示 9.2 GROUP BY和聚合函数以及HAVING一起使用统计工资总和大于8000的部门 MySQL命令： select sum(salary),departmentnumber from employee group by departmentnumber having sum(salary)&gt;8000; 运行效果展示 10.使用ORDER BY对查询结果排序从表中査询出来的数据可能是无序的或者其排列顺序不是我们期望的。为此，我们可以使用ORDER BY对查询结果进行排序其语法格式如下所示： SELECT 字段名1,字段名2,… FROM 表名 ORDER BY 字段名1 [ASC 丨 DESC],字段名2 [ASC | DESC]; 在该语法中：字段名1、字段名2是查询结果排序的依据；参数 ASC表示按照升序排序，DESC表示按照降序排序；默认情况下，按照ASC方式排序。通常情况下，ORDER BY子句位于整个SELECT语句的末尾。查询所有学生并按照年纪大小升序排列 MySQL命令： select * from student order by age asc; 运行效果展示查询所有学生并按照年纪大小降序排列 MySQL命令： select * from student order by age desc; 运行效果展示 十二、别名设置在査询数据时可为表和字段取別名，该别名代替表和字段的原名参与查询操作。操作的表事先已准备 1.为表取别名在查询操作时，假若表名很长使用起来就不太方便，此时可为表取一个別名，用该别名来代替表的名称。语法格式如下所示： SELECT * FROM 表名 [AS] 表的别名 WHERE .... ; 将student改为stu查询整表 MySQL命令： select * from student as stu; 运行效果展示 2.为字段取别名在查询操作时，假若字段名很长使用起来就不太方便，此时可该字段取一个別名，用该别名来代替字段的名称。语法格式如下所示： SELECT 字段名1 [AS] 别名1 , 字段名2 [AS] 别名2 , ... FROM 表名 WHERE ... ; 将student中的name取别名为“姓名” 查询整表 MySQL命令： select name as &#39;姓名&#39;,id from student; 运行效果展示 十三、表的关联关系在实际开发中数据表之间存在着各种关联关系。在此，介绍MySQL中数据表的三种关联关系。多对一多对一(亦称为一对多)是数据表中最常见的一种关系。例如：员工与部门之间的关系，一个部门可以有多个员工；而一个员工不能属于多个部门只属于某个部门。在多对一的表关系 中，应将外键建在多的一方否则会造成数据的冗余。多对多多对多是数据表中常见的一种关系。例如：学生与老师之间的关系，一个学生可以有多个老师而且一个老师有多个学生。通常情况下，为了实现这种关系需要定义一张中间表(亦称为连接表)该表会存在两个外键分别参照老师表和学生表。一对一在开发过程中，一对一的关联关系在数据库中并不常见；因为以这种方式存储的信息通常会放在同一张表中。接下来，我们来学习在一对多的关联关系中如果添加和删除数据。先准备一些测试数据，代码如下： DROP TABLE IF EXISTS student; DROP TABLE IF EXISTS class; -- 创建班级表 CREATE TABLE class( cid int(4) NOT NULL PRIMARY KEY, cname varchar(30) ); -- 创建学生表 CREATE TABLE student( sid int(8) NOT NULL PRIMARY KEY, sname varchar(30), classid int(8) NOT NULL ); -- 为学生表添加外键约束 ALTER TABLE student ADD CONSTRAINT fk_student_classid FOREIGN KEY(classid) REFERENCES class(cid); -- 向班级表插入数据 INSERT INTO class(cid,cname)VALUES(1,&#39;Java&#39;); INSERT INTO class(cid,cname)VALUES(2,&#39;Python&#39;); -- 向学生表插入数据 INSERT INTO student(sid,sname,classid)VALUES(1,&#39;tome&#39;,1); INSERT INTO student(sid,sname,classid)VALUES(2,&#39;lucy&#39;,1); INSERT INTO student(sid,sname,classid)VALUES(3,&#39;lili&#39;,2); INSERT INTO student(sid,sname,classid)VALUES(4,&#39;domi&#39;,2); 1.关联查询查询Java班的所有学生 MySQL命令： select * from student where classid=(select cid from class where cname=&#39;Java&#39;); 运行效果展示 2.关于关联关系的删除数据请从班级表中删除Java班级。在此，请注意：班级表和学生表之间存在关联关系；要删除Java班级，应该先删除学生表中与该班相关联的学生。否则，假若先删除Java班那么学生表中的cid就失去了关联删除Java班 MySQL命令： delete from student where classid=(select cid from class where cname=&#39;Java&#39;); delete from class where cname=&#39;Java&#39;; 运行效果展示 十四、多表连接查询1.交叉连接查询交叉连接返回的结果是被连接的两个表中所有数据行的笛卡儿积；比如：集合A={a,b}，集合B={0,1,2}，则集合A和B的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)}。所以，交叉连接也被称为笛卡尔连接，其语法格式如下： SELECT * FROM 表1 CROSS JOIN 表2; 在该语法中：CROSS JOIN用于连接两个要查询的表，通过该语句可以查询两个表中所有的数据组合。由于这个交叉连接查询在实际运用中没有任何意义，所以只做为了解即可 2.内连接查询内连接(Inner Join)又称简单连接或自然连接，是一种非常常见的连接查询。内连接使用比较运算符对两个表中的数据进行比较并列出与连接条件匹配的数据行，组合成新的 记录。也就是说在内连接查询中只有满足条件的记录才能出现在查询结果中。其语法格式如下： SELECT 查询字段1,查询字段2, ... FROM 表1 [INNER] JOIN 表2 ON 表1.关系字段=表2.关系字段 在该语法中：INNER JOIN用于连接两个表，ON来指定连接条件；其中INNER可以省略。 准备数据，代码如下： -- 若存在数据库mydb则删除 DROP DATABASE IF EXISTS mydb; -- 创建数据库mydb CREATE DATABASE mydb; -- 选择数据库mydb USE mydb; -- 创建部门表 CREATE TABLE department( did int (4) NOT NULL PRIMARY KEY, dname varchar(20) ); -- 创建员工表 CREATE TABLE employee ( eid int (4) NOT NULL PRIMARY KEY, ename varchar (20), eage int (2), departmentid int (4) NOT NULL ); -- 向部门表插入数据 INSERT INTO department VALUES(1001,&#39;财务部&#39;); INSERT INTO department VALUES(1002,&#39;技术部&#39;); INSERT INTO department VALUES(1003,&#39;行政部&#39;); INSERT INTO department VALUES(1004,&#39;生活部&#39;); -- 向员工表插入数据 INSERT INTO employee VALUES(1,&#39;张三&#39;,19,1003); INSERT INTO employee VALUES(2,&#39;李四&#39;,18,1002); INSERT INTO employee VALUES(3,&#39;王五&#39;,20,1001); INSERT INTO employee VALUES(4,&#39;赵六&#39;,20,1004); 查询员工姓名及其所属部门名称 MySQL命令： select employee.ename,department.dname from department inner join employee on department.did=employee.departmentid; 运行效果展示 3.外连接查询在使用内连接查询时我们发现：返回的结果只包含符合查询条件和连接条件的数据。但是，有时还需要在返回查询结果中不仅包含符合条件的数据，而且还包括左表、右表或两个表中的所有数据，此时我们就需要使用外连接查询。外连接又分为左(外)连接和右(外)连接。其语法格式如下： SELECT 查询字段1,查询字段2, ... FROM 表1 LEFT | RIGHT [OUTER] JOIN 表2 ON 表1.关系字段=表2.关系字段 WHERE 条件 由此可见，外连接的语法格式和内连接非常相似，只不过使用的是LEFT [OUTER] JOIN、RIGHT [OUTER] JOIN关键字。其中，关键字左边的表被称为左表，关键字右边的表被称为右表；OUTER可以省略。在使用左(外)连接和右(外)连接查询时，查询结果是不一致的，具体如下：1、LEFT [OUTER] JOIN 左(外)连接：返回包括左表中的所有记录和右表中符合连接条件的记录。2、RIGHT [OUTER] JOIN 右(外)连接：返回包括右表中的所有记录和左表中符合连接条件的记录。 先准备数据，代码如下： -- 若存在数据库mydb则删除 DROP DATABASE IF EXISTS mydb; -- 创建数据库mydb CREATE DATABASE mydb; -- 选择数据库mydb USE mydb; -- 创建班级表 CREATE TABLE class( cid int (4) NOT NULL PRIMARY KEY, cname varchar(20) ); -- 创建学生表 CREATE TABLE student ( sid int (4) NOT NULL PRIMARY KEY, sname varchar (20), sage int (2), classid int (4) NOT NULL ); -- 向班级表插入数据 INSERT INTO class VALUES(1001,&#39;Java&#39;); INSERT INTO class VALUES(1002,&#39;C++&#39;); INSERT INTO class VALUES(1003,&#39;Python&#39;); INSERT INTO class VALUES(1004,&#39;PHP&#39;); -- 向学生表插入数据 INSERT INTO student VALUES(1,&#39;张三&#39;,20,1001); INSERT INTO student VALUES(2,&#39;李四&#39;,21,1002); INSERT INTO student VALUES(3,&#39;王五&#39;,24,1002); INSERT INTO student VALUES(4,&#39;赵六&#39;,23,1003); INSERT INTO student VALUES(5,&#39;Jack&#39;,22,1009); 准备这组数据有一定的特点，为的是让大家直观的看出左连接与右连接的不同之处1、班级编号为1004的PHP班级没有学生2、学号为5的学生王跃跃班级编号为1009，该班级编号并不在班级表中 3.1 左（外）连接查询左(外)连接的结果包括LEFT JOIN子句中指定的左表的所有记录，以及所有满足连接条件的记录。如果左表的某条记录在右表中不存在则在右表中显示为空。查询每个班的班级ID、班级名称及该班的所有学生的名字 MySQL命令： select class.cid,class.cname,student.sname from class left outer join student on class.cid=student.classid; 运行效果展示展示结果分析：1、分别找出Java班、C++班、Python班的学生2、右表的王跃跃不满足查询条件故其没有出现在查询结果中3、虽然左表的PHP班没有学生，但是任然显示了PHP的信息；但是，它对应的学生名字为NULL 3.2 右（外）连接查询右(外)连接的结果包括RIGHT JOIN子句中指定的右表的所有记录，以及所有满足连接条件的记录。如果右表的某条记录在左表中没有匹配，则左表将返回空值。查询每个班的班级ID、班级名称及该班的所有学生的名字 MySQL命令： select class.cid,class.cname,student.sname from class right outer join student on class.cid=student.classid; 运行效果展示展示结果分析：1、分别找出Java班、C++班、Python班的学生2、左表的PHP班不满足查询条件故其没有出现在查询结果中3、虽然右表的jack没有对应班级，但是任然显示王跃跃的信息；但是，它对应的班级以及班级编号均为NULL 十五、子查询子查询是指一个查询语句嵌套在另一个查询语句内部的查询；该查询语句可以嵌套在一个 SELECT、SELECT…INTO、INSERT…INTO等语句中。在执行查询时，首先会执行子查询中的语句，再将返回的结果作为外层查询的过滤条件。在子査询中通常可以使用比较运算符和IN、EXISTS、ANY、ALL等关键字。 准备数据，代码如下： DROP TABLE IF EXISTS student; DROP TABLE IF EXISTS class; -- 创建班级表 CREATE TABLE class( cid int (4) NOT NULL PRIMARY KEY, cname varchar(20) ); -- 创建学生表 CREATE TABLE student ( sid int (4) NOT NULL PRIMARY KEY, sname varchar (20), sage int (2), classid int (4) NOT NULL ); -- 向班级表插入数据 INSERT INTO class VALUES(1001,&#39;Java&#39;); INSERT INTO class VALUES(1002,&#39;C++&#39;); INSERT INTO class VALUES(1003,&#39;Python&#39;); INSERT INTO class VALUES(1004,&#39;PHP&#39;); INSERT INTO class VALUES(1005,&#39;Android&#39;); -- 向学生表插入数据 INSERT INTO student VALUES(1,&#39;张三&#39;,20,1001); INSERT INTO student VALUES(2,&#39;李四&#39;,21,1002); INSERT INTO student VALUES(3,&#39;王五&#39;,24,1003); INSERT INTO student VALUES(4,&#39;赵六&#39;,23,1004); INSERT INTO student VALUES(5,&#39;小明&#39;,21,1001); INSERT INTO student VALUES(6,&#39;小红&#39;,26,1001); INSERT INTO student VALUES(7,&#39;小亮&#39;,27,1002); 1.带比较运算符的子查询比较运算符前面我们提到过得，就是&gt;、&lt;、=、&gt;=、&lt;=、!=等查询张三同学所在班级的信息 MySQL命令： select * from class where cid=(select classid from student where sname=&#39;张三&#39;); 运行效果展示查询比张三同学所在班级编号还大的班级的信息 MySQL命令： select * from class where cid&gt;(select classid from student where sname=&#39;张三&#39;); 运行效果展示 2.带EXISTS关键字的子查询EXISTS关键字后面的参数可以是任意一个子查询， 它不产生任何数据只返回TRUE或FALSE。当返回值为TRUE时外层查询才会 执行假如王五同学在学生表中则从班级表查询所有班级信息 MySQL命令： select * from class where exists (select * from student where sname=&#39;王五&#39;); 运行效果展示 3.带ANY关键字的子查询ANY关键字表示满足其中任意一个条件就返回一个结果作为外层查询条件。 查询比任一学生所属班级号还大的班级编号 MySQL命令： select * from class where cid &gt; any (select classid from student); 运行效果展示 4.带ALL关键字的子查询ALL关键字与ANY有点类似，只不过带ALL关键字的子査询返回的结果需同时满足所有内层査询条件。 查询比所有学生所属班级号还大的班级编号 MySQL命令： select * from class where cid &gt; all (select classid from student); 运行效果展示 总结重要（从关键字分析）：查询语句的书写顺序和执行顺序select ===&gt; from ===&gt; where ===&gt; group by ===&gt; having ===&gt; order by ===&gt; limit查询语句的执行顺序from ===&gt; where ===&gt; group by ===&gt; having ===&gt; select ===&gt; order by ===&gt; limi 基于复习，乐于分享 所以有了这篇文章！！！ 本文转自 https://blog.csdn.net/weixin_45851945/article/details/114287877?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164574504116780274141388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164574504116780274141388&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2alltop_positive~default-1-114287877.pc_search_result_positive&amp;utm_term=mysql&amp;spm=1018.2226.3001.4187，如有侵权，请联系删除。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"}],"tags":[{"name":"MySQL总结","slug":"MySQL总结","permalink":"https://ysluckly.github.io/tags/MySQL%E6%80%BB%E7%BB%93/"}]},{"title":"【Go项目】模拟网站登录并爬虫","slug":"back-end/1645851916087","date":"2022-01-19T07:29:32.000Z","updated":"2022-02-26T06:05:50.619Z","comments":true,"path":"2022/01/19/golang/","link":"","permalink":"https://ysluckly.github.io/2022/01/19/golang/","excerpt":"","text":"title: Go语言模拟网站登录并爬虫 想要学习爬虫的朋友知道，有时候我们需要爬的网站必须登录，才能获取到数据，那么我们该怎么模拟登录呢？ 需求我们登录上网站，并且选择应用管理。 我们现在需要爬取我们账号下的所有APP信息，根据签名期限，来计算APP剩余的时间（小时）。 获取cookie1.打开 https://866w.cn 登录上网站2.按F12（不考虑IE浏览器），我这里使用的Chrome, 我们选择Network，再次刷新下网页 3. 通过截图我们可以看到 我们等会爬虫的页面是 https://866w.cn/index.php/home 我先复制下我们的cookie var cookie string =&quot;in_userid=1; in_username=xxxxxqq.com; in_userpassword=xxxxx; in_adminid=3; in_adminname=xxxxxqq.com; in_adminpassword=xxxxx; in_permission=1%2C2%2C3%2C4%2C5%2C6&quot; 为了安全起见我把部分信息使用xxxx进行替换。 查看html 信息&lt;div class=&quot;card app card-ios&quot;&gt;&lt;i class=&quot;type-icon icon-apple&quot;&gt;&lt;/i&gt;&lt;div class=&quot;type-mark&quot;&gt;&lt;/div&gt;&lt;a class=&quot;appicon&quot; href=&quot;/index.php/each_app/38&quot;&gt;&lt;img class=&quot;icon ng-isolate-scope&quot; width=&quot;100&quot; height=&quot;100&quot; src=&quot;https://866w.cn/data/attachment/91541742353-1.png?v=1541750743&quot; onerror=&quot;this.src=&#39;/static/app/iOS.png&#39;&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;p class=&quot;appname&quot;&gt;&lt;i class=&quot;icon-owner&quot;&gt;&lt;/i&gt;&lt;span class=&quot;ng-binding&quot;&gt;鹿鼎娱乐&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;签名期限：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;a href=&quot;/index.php/sign_app/38&quot;&gt;2018-12-10 13:49:16&lt;/a&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;应用平台：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;iOS&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;应用标识：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;com.baochi.bc&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;最新版本：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;1.0（Build 1891）&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;div class=&quot;action&quot;&gt;&lt;a class=&quot;ng-binding&quot; href=&quot;/index.php/profile_app/38&quot;&gt;&lt;i class=&quot;icon-pen&quot;&gt;&lt;/i&gt; 管理&lt;/a&gt;&lt;a href=&quot;https://866w.cn/app.php/38&quot; target=&quot;_blank&quot; class=&quot;ng-binding&quot;&gt;&lt;i class=&quot;icon-eye&quot;&gt;&lt;/i&gt; 预览&lt;/a&gt;&lt;button class=&quot;btn btn-remove ng-scope&quot; onclick=&quot;del_app(38, 1)&quot;&gt;&lt;i class=&quot;icon icon-trash&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;/div&gt;&lt;/div&gt; 通过上面的代码我们可以看到 我们的app信息都在类为 card app card-ios 的div块里面, 并且我们的主要信息都在&lt;span class=&quot;ng-binding&quot;&gt;xxxxx&lt;/span&gt;包含着 制作正则表达式当然我这个正则表达式只是为了偷懒，所有需要爬去的信息都是使用(.*?)来获取，我这个肯定不是好的方案，你可以自己去尝试写一个正则表达式。 这里我定义一个 Reg变量，保存正则表达式。 Reg := `&lt;div class=&quot;card app card-ios&quot;&gt;(.*?)&lt;span class=&quot;ng-binding&quot;&gt;(.*?)&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;签名期限：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;应用平台：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;iOS&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;应用标识：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;(.*?)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;最新版本：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;(.*?)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;(.*?)&lt;/div&gt; 反爬虫有的时候一些网站会有一些反爬虫机制，判断你是人工访问，还是机器访问，判断的原则,就是识别user-agent ,这里我们定义一个字符串切片，来保存不同浏览器的user-agent。当然有得网站还有IP访问限制，你可以使用代理解决，这里我们就不讨论这种情况了。 user-agent 数组 var userAgentList = []string&#123;&quot;Mozilla/5.0 (compatible, MSIE 10.0, Windows NT, DigExt)&quot;, &quot;Mozilla/4.0 (compatible, MSIE 7.0, Windows NT 5.1, 360SE)&quot;, &quot;Mozilla/4.0 (compatible, MSIE 8.0, Windows NT 6.0, Trident/4.0)&quot;, &quot;Mozilla/5.0 (compatible, MSIE 9.0, Windows NT 6.1, Trident/5.0,&quot;, &quot;Opera/9.80 (Windows NT 6.1, U, en) Presto/2.8.131 Version/11.11&quot;, &quot;Mozilla/4.0 (compatible, MSIE 7.0, Windows NT 5.1, TencentTraveler 4.0)&quot;, &quot;Mozilla/5.0 (Windows, U, Windows NT 6.1, en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&quot;, &quot;Mozilla/5.0 (Macintosh, Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&quot;, &quot;Mozilla/5.0 (Macintosh, U, Intel Mac OS X 10_6_8, en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&quot;, &quot;Mozilla/5.0 (Linux, U, Android 3.0, en-us, Xoom Build/HRI39) AppleWebKit/534.13 (KHTML, like Gecko) Version/4.0 Safari/534.13&quot;, &quot;Mozilla/5.0 (iPad, U, CPU OS 4_3_3 like Mac OS X, en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5&quot;, &quot;Mozilla/4.0 (compatible, MSIE 7.0, Windows NT 5.1, Trident/4.0, SE 2.X MetaSr 1.0, SE 2.X MetaSr 1.0, .NET CLR 2.0.50727, SE 2.X MetaSr 1.0)&quot;, &quot;Mozilla/5.0 (iPhone, U, CPU iPhone OS 4_3_3 like Mac OS X, en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5&quot;, &quot;MQQBrowser/26 Mozilla/5.0 (Linux, U, Android 2.3.7, zh-cn, MB200 Build/GRJ22, CyanogenMod-7) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1&quot;&#125; 随机获取user-agent 上面我们存储了不同的浏览器user-agent, 现在我们还需要一个函数来随机调用它们。 func GetRandomUserAgent() string &#123; r := rand.New(rand.NewSource(time.Now().UnixNano())) return userAgentList[r.Intn(len(userAgentList))] &#125; 模拟登录并获取html代码现在我们开始进入重点，有了cookie我们怎么才能模拟登录，并且怎么才能获取网站的信息。 func getUrlRespHtml() string &#123; url := &quot;https://866w.cn/index.php/home&quot; client := &amp;http.Client&#123;&#125; req, err := http.NewRequest(&quot;GET&quot;, url, nil) if err!=nil &#123; fmt.Println(&quot;获取地址错误&quot;) &#125; req.Header.Set(&quot;Cookie&quot;, cookie) req.Header.Add(&quot;Agent&quot;,GetRandomUserAgent() ) resp, err := client.Do(req) if err!=nil &#123; fmt.Println(&quot;登录错误&quot;) &#125; resp_byte, err := ioutil.ReadAll(resp.Body) defer resp.Body.Close() respHtml := string(resp_byte) return respHtml &#125; 使用正则表达式筛选信息当然我们获取了网站的html 代码也不行，html的信息太多，我们需要对它进行筛选，我们需要获取应用名称、签名期限、应用标识、最新版本 等信息，并且我们还需要根据签名期限来计算剩余时间。 func Initialize() &#123; reader := getUrlRespHtml() Reg := `&lt;div class=&quot;card app card-ios&quot;&gt;(.*?)&lt;span class=&quot;ng-binding&quot;&gt;(.*?)&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;签名期限：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;应用平台：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;iOS&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;应用标识：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;(.*?)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;ng-binding&quot;&gt;最新版本：&lt;/td&gt;&lt;td&gt;&lt;span class=&quot;ng-binding&quot;&gt;(.*?)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;(.*?)&lt;/div&gt;` rp1 := regexp.MustCompile(Reg) heads := rp1.FindAllStringSubmatch(reader, -1) timeLayout := &quot;2006-01-02 15:04:05&quot; //转化所需模板 loc, _ := time.LoadLocation(&quot;Local&quot;) for _, v := range heads &#123; theTime, _ := time.ParseInLocation(timeLayout, v[4], loc) //使用模板在对应时区转化为time.time类型 TimeNow := time.Now() left := theTime.Sub(TimeNow) appHours := int(left.Hours()) fmt.Printf(&quot;应用名称：%s \\n到期时间: %s\\n剩余时间 :%s小时\\n应用标识:%s\\n应用版本:%s\\n &quot;,v[2],v[4],strconv.Itoa(appHours),v[5],v[6]) fmt.Println() &#125; &#125; 运行func main() &#123; Initialize() &#125; 我们可以查看到运行结果。 总结到此我们的教程已经结束，你可以自己根据你的需求来添加文本保存，或者其他啥的功能。如果你对正则表达式比较头疼，你也可以选择一些go的爬虫框架。 本文转自 https://blog.csdn.net/yang731227/article/details/83900422，如有侵权，请联系删除。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://ysluckly.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Go全栈面试题（3）-微服务面试题","slug":"back-end/1645851800038","date":"2022-01-19T07:29:32.000Z","updated":"2022-02-26T06:00:37.803Z","comments":true,"path":"2022/01/19/golang/","link":"","permalink":"https://ysluckly.github.io/2022/01/19/golang/","excerpt":"","text":"微服务面试题Http get跟headget:获取由Request-URI标识的任何信息(以实体的形式)，如果Request-URI引用某个数据处理过程，则应该以它产生的数据作为在响应中的实体，而不是该过程的源代码文本，除非该过程碰巧输出该文本。 head: 除了服务器不能在响应中返回消息体，HEAD方法与GET相同。用来获取暗示实体的元信息，而不需要传输实体本身。常用于测试超文本链接的有效性、可用性和最近的修改。 说一下中间件原理中间件（middleware）是基础软件的一大类，属于可复用软件的范畴。中间件处于操作系统软件与用户的应用软件的中间。中间件在操作系统、网络和数据库之上，应用软件的下层，总的作用是为处于自己上层的应用软件提供运行与开发的环境，帮助用户灵活、高效地开发和集成复杂的应用软件IDC的定义是：中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，管理计算资源和网络通信。 中间件解决的问题是： 在中间件产生以前，应用软件直接使用操作系统、网络协议和数据库等开发，这些都是计算机最底层的东西，越底层越复杂，开发者不得不面临许多很棘手的问题，如操作系统的多样性，繁杂的网络程序设计、管理，复杂多变的网络环境，数据分散处理带来的不一致性问题、性能和效率、安全，等等。这些与用户的业务没有直接关系，但又必须解决，耗费了大量有限的时间和精力。于是，有人提出能不能将应用软件所要面临的共性问题进行提炼、抽象，在操作系统之上再形成一个可复用的部分，供成千上万的应用软件重复使用。这一技术思想最终构成了中间件这类的软件。中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担。 用过原生的http包吗？Golang中http包中处理 HTTP 请求主要跟两个东西相关：ServeMux 和 Handler。 ServrMux 本质上是一个 HTTP 请求路由器（或者叫多路复用器，Multiplexor）。它把收到的请求与一组预先定义的 URL 路径列表做对比，然后在匹配到路径的时候调用关联的处理器（Handler）。 处理器（Handler）负责输出HTTP响应的头和正文。任何满足了http.Handler接口的对象都可作为一个处理器。通俗的说，对象只要有个如下签名的ServeHTTP方法即可： ServeHTTP(http.ResponseWriter, *http.Request) Go 语言的 HTTP 包自带了几个函数用作常用处理器，比如FileServer，NotFoundHandler 和 RedirectHandler。 应用示例: package main import ( &quot;log&quot; &quot;net/http&quot; ) func main() &#123; mux := http.NewServeMux() rh := http.RedirectHandler(&quot;http://www.baidu.com&quot;, 307) mux.Handle(&quot;/foo&quot;, rh) log.Println(&quot;Listening...&quot;) http.ListenAndServe(&quot;:3000&quot;, mux) &#125; 在这个应用示例中,首先在 main 函数中我们只用了 http.NewServeMux 函数来创建一个空的 ServeMux。然后我们使用 http.RedirectHandler 函数创建了一个新的处理器，这个处理器会对收到的所有请求，都执行307重定向操作到 http://www.baidu.com。接下来我们使用 ServeMux.Handle 函数将处理器注册到新创建的 ServeMux，所以它在 URL 路径/foo 上收到所有的请求都交给这个处理器。最后我们创建了一个新的服务器，并通过 http.ListenAndServe 函数监听所有进入的请求，通过传递刚才创建的 ServeMux来为请求去匹配对应处理器。在浏览器中访问 http://localhost:3000/foo，你应该能发现请求已经成功的重定向了。 此刻你应该能注意到一些有意思的事情：ListenAndServer 的函数签名是 ListenAndServe(addr string, handler Handler) ，但是第二个参数我们传递的是个 ServeMux。 通过这个例子我们就可以知道,net/http包在编写golang web应用中有很重要的作用，它主要提供了基于HTTP协议进行工作的client实现和server实现，可用于编写HTTP服务端和客户端。 grpc遵循什么协议？grpc是由Google主导开发的RPC框架，使用HTTP/2协议并用ProtoBuf作为序列化工具。gRPC是动态代理的模式实现的，客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法。和传统的REST不同的是gRPC使用了静态路径，从而提高性能，另外开发者不用了解各种底层网络协议，不用去拼REST风格的动态URL，用一些格式化的错误码代替了HTTP的状态码，不用管各种的HTTP状态码，开发者开发效率比较高。客户端可以充分利用高级流和链接功能，从而有助于节省带宽、降低的TCP链接次数、节省CPU使用. grpc内部原理是什么？gRPC 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。gRPC 默认使用 protocol buffers，这是 Google 开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如 JSON）. client如何实现长连接? 使用http keep-alvie 使用HeartBeat心跳包 微服务架构是什么样子的?通常传统的项目体积庞大，需求、设计、开发、测试、部署流程固定。新功能需要在原项目上做修改。 但是微服务可以看做是对大项目的拆分，是在快速迭代更新上线的需求下产生的。新的功能模块会发布成新的服务组件，与其他已发布的服务组件一同协作。服务内部有多个生产者和消费者，通常以http rest的方式调用，服务总体以一个（或几个）服务的形式呈现给客户使用。 微服务架构是一种思想对微服务架构我们没有一个明确的定义，但简单来说微服务架构是： 采用一组服务的方式来构建一个应用，服务独立部署在不同的进程中，不同服务通过一些轻量级交互机制来通信，例如 RPC、HTTP 等，服务可独立扩展伸缩，每个服务定义了明确的边界，不同的服务甚至可以采用不同的编程语言来实现，由独立的团队来维护。 Golang的微服务框架kit中有详细的微服务的例子,可以参考学习. 微服务架构设计包括： 服务熔断降级限流机制 熔断降级的概念(Rate Limiter 限流器,Circuit breaker 断路器). 框架调用方式解耦方式 Kit 或 Istio 或 Micro 服务发现(consul zookeeper kubeneters etcd ) RPC调用框架. 链路监控,zipkin和prometheus. 多级缓存. 网关 (kong gateway). Docker部署管理 Kubenetters. 自动集成部署 CI/CD 实践. 自动扩容机制规则. 压测 优化. Trasport 数据传输(序列化和反序列化). Logging 日志. Metrics 指针对每个请求信息的仪表盘化. 微服务有什么优点？ 解耦——系统中的服务在很大程度上是解耦的。因此，整个应用程序可以很容易地构建、修改和伸缩 组件化——微服务被视为独立的组件，可以很容易地替换和升级 业务功能——微服务非常简单，只关注一个功能 自治——开发人员和团队可以彼此独立工作，从而提高速度 持续交付——通过软件创建、测试和批准的系统自动化，允许频繁地发布软件 责任——微服务不关注应用程序作为项目。相反，他们将应用程序视为自己负责的产品 分散治理——重点是为正确的工作使用正确的工具。这意味着没有标准化的模式或任何技术模式。开发人员可以自由选择最有用的工具来解决他们的问题 敏捷——微服务支持敏捷开发。任何新特性都可以快速开发并再次丢弃 在使用微服务架构时，您面临的挑战是什么？开发一些较小的微服务听起来很容易，但开发它们时经常遇到的挑战如下。 自动化组件：难自动化，因为有许多较小的组件。因此，对于每个组件我们必须遵循Build，Deploy和Monitor的各个阶段。 易感性：将大量组件维护在一起变得难以部署，维护，监控和识别问题。它需要在所有组件周围具有很好的感知能力。 配置管理：在不同的环境中维护组件的配置有时会变得很困难。 调试：很难找出每个服务的错误。维护集中的日志记录和仪表板来调试问题是非常重要的。 SOA和微服务架构之间的主要区别是什么？SOA和微服务之间的主要区别如下： SOA 微服务 遵循“ 尽可能多的共享 ”架构方法 遵循“ 尽可能少分享 ”的架构方法 重要性在于 业务功能 重用 重要性在于“ 有界背景 ” 的概念 他们有 共同的 治理 和标准 他们专注于 人们的 合作 和其他选择的自由 使用 企业服务总线（ESB） 进行通信 简单的消息系统 它们支持 多种消息协议 他们使用 轻量级协议 ，如 HTTP / REST 等。 多线程， 有更多的开销来处理I / O 单线程 通常使用Event Loop功能进行非锁定I / O处理 最大化应用程序服务可重用性 专注于 解耦 传统的关系数据库 更常用 现代 关系数据库 更常用 系统的变化需要修改整体 系统的变化是创造一种新的服务 DevOps / Continuous Delivery正在变得流行，但还不是主流 专注于DevOps /持续交付 微服务之间是如何通信的呢？ REST over HTTP(S) 通过Message Broker进行消息传递 RPC (跨语言或单语言) REST over HTTP(S)自Roy Fielding提出RESTful架构自提出以来，一直都是备受欢迎的方案，特别是在Web应用的开发中。Fielding提出的约束虽然不是标准，但在声明我们的API为RESTful之前，应该始终遵循这些约束。HTTP上有各种各样的REST，因为没有强制执行的标准。开发人员可以自由选择以JSON、XML或某种自定义格式形成请求有效负载。REST over HTTP（S）仅意味着使用REST架构风格并通过HTTP（S）发送请求。 通过Message Broker进行消息传递该选项基本上通过将微服务连接到集中消息总线来工作，并且服务之间的所有通信都通过backbone发送消息来完成。 RPC (跨语言或单语言)远程过程调用在分布式系统中并不新鲜，它通过在网络上的另一个设备上执行函数/方法/过程来工作。 什么是微服务熔断?什么是服务降级?微服务的熔断与降级，当然熔断与降级并不是一个概念，只是很多时候会一起实现了： 服务熔断 一般是某个服务故障或异常引起，类似“保险丝”，当某个异常被触发，直接熔断整个服务，而不是等到此服务超时。 服务降级 降级是在客户端，与服务端无关。 降级，从整体负荷考虑，某个服务熔断后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，这样，虽然服务水平下降，但可用，比直接挂掉要好。 你能否给出关于REST和微服务的要点？ REST 虽然您可以通过多种方式实现微服务，但REST over HTTP是实现微服务的一种方式。REST还可用于其他应用程序，如Web应用程序，API设计和MVC应用程序，以提供业务数据。 微服务 微服务是一种体系结构，其中系统的所有组件都被放入单独的组件中，这些组件可以单独构建，部署和扩展。微服务的某些原则和最佳实践有助于构建弹性应用程序。 简而言之，您可以说REST是构建微服务的媒介。 Etcd怎么实现分布式锁?首先思考下Etcd是什么？可能很多人第一反应可能是一个键值存储仓库，却没有重视官方定义的后半句，用于配置共享和服务发现。 A highly-available key value store for shared configuration and service discovery. 实际上，etcd 作为一个受到 ZooKeeper 与 doozer 启发而催生的项目，除了拥有与之类似的功能外，更专注于以下四点。 简单：基于 HTTP+JSON 的 API 让你用 curl 就可以轻松使用。 安全：可选 SSL 客户认证机制。 快速：每个实例每秒支持一千次写操作。 可信：使用 Raft 算法充分实现了分布式。 但是这里我们主要讲述Etcd如何实现分布式锁? 因为 Etcd 使用 Raft 算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。 保持独占即所有获取锁的用户最终只有一个可以得到。etcd 为此提供了一套实现分布式锁原子操作 CAS（CompareAndSwap）的 API。通过设置prevExist值，可以保证在多个节点同时去创建某个目录时，只有一个成功。而创建成功的用户就可以认为是获得了锁。 控制时序，即所有想要获得锁的用户都会被安排执行，但是获得锁的顺序也是全局唯一的，同时决定了执行顺序。etcd 为此也提供了一套 API（自动创建有序键），对一个目录建值时指定为POST动作，这样 etcd 会自动在目录下生成一个当前最大的值为键，存储这个新的值（客户端编号）。同时还可以使用 API 按顺序列出所有当前目录下的键值。此时这些键的值就是客户端的时序，而这些键中存储的值可以是代表客户端的编号。 在这里Ectd实现分布式锁基本实现原理为： 在ectd系统里创建一个key 如果创建失败，key存在，则监听该key的变化事件，直到该key被删除，回到1 如果创建成功，则认为我获得了锁 应用示例: package etcdsync import ( &quot;fmt&quot; &quot;io&quot; &quot;os&quot; &quot;sync&quot; &quot;time&quot; &quot;github.com/coreos/etcd/client&quot; &quot;github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context&quot; ) const ( defaultTTL = 60 defaultTry = 3 deleteAction = &quot;delete&quot; expireAction = &quot;expire&quot; ) // A Mutex is a mutual exclusion lock which is distributed across a cluster. type Mutex struct &#123; key string id string // The identity of the caller client client.Client kapi client.KeysAPI ctx context.Context ttl time.Duration mutex *sync.Mutex logger io.Writer &#125; // New creates a Mutex with the given key which must be the same // across the cluster nodes. // machines are the ectd cluster addresses func New(key string, ttl int, machines []string) *Mutex &#123; cfg := client.Config&#123; Endpoints: machines, Transport: client.DefaultTransport, HeaderTimeoutPerRequest: time.Second, &#125; c, err := client.New(cfg) if err != nil &#123; return nil &#125; hostname, err := os.Hostname() if err != nil &#123; return nil &#125; if len(key) == 0 || len(machines) == 0 &#123; return nil &#125; if key[0] != &#39;/&#39; &#123; key = &quot;/&quot; + key &#125; if ttl &lt; 1 &#123; ttl = defaultTTL &#125; return &amp;Mutex&#123; key: key, id: fmt.Sprintf(&quot;%v-%v-%v&quot;, hostname, os.Getpid(), time.Now().Format(&quot;20060102-15:04:05.999999999&quot;)), client: c, kapi: client.NewKeysAPI(c), ctx: context.TODO(), ttl: time.Second * time.Duration(ttl), mutex: new(sync.Mutex), &#125; &#125; // Lock locks m. // If the lock is already in use, the calling goroutine // blocks until the mutex is available. func (m *Mutex) Lock() (err error) &#123; m.mutex.Lock() for try := 1; try &lt;= defaultTry; try++ &#123; if m.lock() == nil &#123; return nil &#125; m.debug(&quot;Lock node %v ERROR %v&quot;, m.key, err) if try &lt; defaultTry &#123; m.debug(&quot;Try to lock node %v again&quot;, m.key, err) &#125; &#125; return err &#125; func (m *Mutex) lock() (err error) &#123; m.debug(&quot;Trying to create a node : key=%v&quot;, m.key) setOptions := &amp;client.SetOptions&#123; PrevExist:client.PrevNoExist, TTL: m.ttl, &#125; resp, err := m.kapi.Set(m.ctx, m.key, m.id, setOptions) if err == nil &#123; m.debug(&quot;Create node %v OK [%q]&quot;, m.key, resp) return nil &#125; m.debug(&quot;Create node %v failed [%v]&quot;, m.key, err) e, ok := err.(client.Error) if !ok &#123; return err &#125; if e.Code != client.ErrorCodeNodeExist &#123; return err &#125; // Get the already node&#39;s value. resp, err = m.kapi.Get(m.ctx, m.key, nil) if err != nil &#123; return err &#125; m.debug(&quot;Get node %v OK&quot;, m.key) watcherOptions := &amp;client.WatcherOptions&#123; AfterIndex : resp.Index, Recursive:false, &#125; watcher := m.kapi.Watcher(m.key, watcherOptions) for &#123; m.debug(&quot;Watching %v ...&quot;, m.key) resp, err = watcher.Next(m.ctx) if err != nil &#123; return err &#125; m.debug(&quot;Received an event : %q&quot;, resp) if resp.Action == deleteAction || resp.Action == expireAction &#123; return nil &#125; &#125; &#125; // Unlock unlocks m. // It is a run-time error if m is not locked on entry to Unlock. // // A locked Mutex is not associated with a particular goroutine. // It is allowed for one goroutine to lock a Mutex and then // arrange for another goroutine to unlock it. func (m *Mutex) Unlock() (err error) &#123; defer m.mutex.Unlock() for i := 1; i &lt;= defaultTry; i++ &#123; var resp *client.Response resp, err = m.kapi.Delete(m.ctx, m.key, nil) if err == nil &#123; m.debug(&quot;Delete %v OK&quot;, m.key) return nil &#125; m.debug(&quot;Delete %v falied: %q&quot;, m.key, resp) e, ok := err.(client.Error) if ok &amp;&amp; e.Code == client.ErrorCodeKeyNotFound &#123; return nil &#125; &#125; return err &#125; func (m *Mutex) debug(format string, v ...interface&#123;&#125;) &#123; if m.logger != nil &#123; m.logger.Write([]byte(m.id)) m.logger.Write([]byte(&quot; &quot;)) m.logger.Write([]byte(fmt.Sprintf(format, v...))) m.logger.Write([]byte(&quot;\\n&quot;)) &#125; &#125; func (m *Mutex) SetDebugLogger(w io.Writer) &#123; m.logger = w &#125; 其实类似的实现有很多，但目前都已经过时，使用的都是被官方标记为deprecated的项目。且大部分接口都不如上述代码简单。 使用上，跟Golang官方sync包的Mutex接口非常类似，先New()，然后调用Lock()，使用完后调用Unlock()，就三个接口，就是这么简单。示例代码如下： package main import ( &quot;github.com/zieckey/etcdsync&quot; &quot;log&quot; ) func main() &#123; //etcdsync.SetDebug(true) log.SetFlags(log.Ldate|log.Ltime|log.Lshortfile) m := etcdsync.New(&quot;/etcdsync&quot;, &quot;123&quot;, []string&#123;&quot;http://127.0.0.1:2379&quot;&#125;) if m == nil &#123; log.Printf(&quot;etcdsync.NewMutex failed&quot;) &#125; err := m.Lock() if err != nil &#123; log.Printf(&quot;etcdsync.Lock failed&quot;) &#125; else &#123; log.Printf(&quot;etcdsync.Lock OK&quot;) &#125; log.Printf(&quot;Get the lock. Do something here.&quot;) err = m.Unlock() if err != nil &#123; log.Printf(&quot;etcdsync.Unlock failed&quot;) &#125; else &#123; log.Printf(&quot;etcdsync.Unlock OK&quot;) &#125; &#125; 负载均衡原理是什么?负载均衡Load Balance）是高可用网络基础架构的关键组件，通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。负载均衡，其核心就是网络流量分发，分很多维度。 负载均衡（Load Balance）通常是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。 负载均衡是建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。 通过一个例子详细介绍: 没有负载均衡 web 架构 在这里用户是直连到 web 服务器，如果这个服务器宕机了，那么用户自然也就没办法访问了。另外，如果同时有很多用户试图访问服务器，超过了其能处理的极限，就会出现加载速度缓慢或根本无法连接的情况。 而通过在后端引入一个负载均衡器和至少一个额外的 web 服务器，可以缓解这个故障。通常情况下，所有的后端服务器会保证提供相同的内容，以便用户无论哪个服务器响应，都能收到一致的内容。 有负载均衡 web 架构 用户访问负载均衡器，再由负载均衡器将请求转发给后端服务器。在这种情况下，单点故障现在转移到负载均衡器上了。这里又可以通过引入第二个负载均衡器来缓解。 那么负载均衡器的工作方式是什么样的呢,负载均衡器又可以处理什么样的请求？ 负载均衡器的管理员能主要为下面四种主要类型的请求设置转发规则： HTTP (七层) HTTPS (七层) TCP (四层) UDP (四层) 负载均衡器如何选择要转发的后端服务器？ 负载均衡器一般根据两个因素来决定要将请求转发到哪个服务器。首先，确保所选择的服务器能够对请求做出响应，然后根据预先配置的规则从健康服务器池（healthy pool）中进行选择。 因为，负载均衡器应当只选择能正常做出响应的后端服务器，因此就需要有一种判断后端服务器是否健康的方法。为了监视后台服务器的运行状况，运行状态检查服务会定期尝试使用转发规则定义的协议和端口去连接后端服务器。如果，服务器无法通过健康检查，就会从池中剔除，保证流量不会被转发到该服务器，直到其再次通过健康检查为止。 负载均衡算法 负载均衡算法决定了后端的哪些健康服务器会被选中。 其中常用的算法包括： Round Robin（轮询）：为第一个请求选择列表中的第一个服务器，然后按顺序向下移动列表直到结尾，然后循环。 Least Connections（最小连接）：优先选择连接数最少的服务器，在普遍会话较长的情况下推荐使用。 Source：根据请求源的 IP 的散列（hash）来选择要转发的服务器。这种方式可以一定程度上保证特定用户能连接到相同的服务器。 如果你的应用需要处理状态而要求用户能连接到和之前相同的服务器。可以通过 Source 算法基于客户端的 IP 信息创建关联，或者使用粘性会话（sticky sessions）。 除此之外，想要解决负载均衡器的单点故障问题，可以将第二个负载均衡器连接到第一个上，从而形成一个集群。 本文转自 https://blog.csdn.net/yang731227/article/details/90637535，如有侵权，请联系删除。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"Go面试","slug":"Go面试","permalink":"https://ysluckly.github.io/tags/Go%E9%9D%A2%E8%AF%95/"},{"name":"微服务","slug":"微服务","permalink":"https://ysluckly.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"Go WebAssembly (Wasm) 简明教程","slug":"back-end/quick-go-wasm","date":"2022-01-17T13:59:10.000Z","updated":"2022-02-20T13:38:38.925Z","comments":true,"path":"2022/01/17/go/","link":"","permalink":"https://ysluckly.github.io/2022/01/17/go/","excerpt":"","text":"1 WebAssembly 简介 WebAssembly是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如C / C ++等语言提供一个编译目标，以便它们可以在Web上运行。它也被设计为可以与JavaScript共存，允许两者一起工作。 —— MDN web docs - mozilla.org 从 MDN 的介绍中，我们可以得出几个结论： 1）WebAssembly 是一种二进制编码格式，而不是一门新的语言。 WebAssembly 不是为了取代 JavaScript，而是一种补充（至少现阶段是这样），结合 WebAssembly 的性能优势，很大可能集中在对性能要求高（例如游戏，AI），或是对交互体验要求高（例如移动端）的场景。 3）C/C++ 等语言可以编译 WebAssembly 的目标文件，也就是说，其他语言可以通过编译器支持，而写出能够在浏览器前端运行的代码。 Go 语言在 1.11 版本(2018年8月) 加入了对 WebAssembly (Wasm) 的原生支持，使用 Go 语言开发 WebAssembly 相关的应用变得更加地简单。Go 语言的内建支持是 Go 语言进军前端的一个重要的里程碑。在这之前，如果想使用 Go 语言开发前端，需要使用 GopherJS，GopherJS 是一个编译器，可以将 Go 语言转换成可以在浏览器中运行的 JavaScript 代码。新版本的 Go 则直接将 Go 代码编译为 wasm 二进制文件，而不再需要转为 JavaScript 代码。更巧的是，实现 GopherJS 和在 Go 语言中内建支持 WebAssembly 的是同一拨人。 Go 语言实现的函数可以直接导出供 JavaScript 代码调用，同时，Go 语言内置了 syscall/js 包，可以在 Go 语言中直接调用 JavaScript 函数，包括对 DOM 树的操作。 2 Hello World如果对 Go 语言不熟悉，推荐 Go 语言简明教程，一篇文章快速入门。 接下来，我们使用 Go 语言实现一个最简单的程序，在网页上弹出 Hello World。 第一步，新建文件 main.go，使用 js.Global().get(‘alert’) 获取全局的 alert 对象，通过 Invoke 方法调用。等价于在 js 中调用 window.alert(&quot;Hello World&quot;)。 // main.go package main import &quot;syscall/js&quot; func main() &#123; alert := js.Global().Get(&quot;alert&quot;) alert.Invoke(&quot;Hello World!&quot;) &#125; 第二步，将 main.go 编译为 static/main.wasm 如果启用了 GO MODULES，则需要使用 go mod init 初始化模块，或设置 GO111MODULE=auto。 $ GOOS=js GOARCH=wasm go build -o static/main.wasm 第三步，拷贝 wasm_exec.js (JavaScript 支持文件，加载 wasm 文件时需要) 到 static 文件夹 $ cp &quot;$(go env GOROOT)/misc/wasm/wasm_exec.js&quot; static 第四步，创建 index.html，引用 static/main.wasm 和 static/wasm_exec.js。 &lt;html&gt; &lt;script src=&quot;static/wasm_exec.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const go = new Go(); WebAssembly.instantiateStreaming(fetch(&quot;static/main.wasm&quot;), go.importObject) .then((result) =&gt; go.run(result.instance)); &lt;/script&gt; &lt;/html&gt; 第五步，使用 goexec 启动 Web 服务 如果没有安装 goexec，可用 go get -u github.com/shurcooL/goexec 安装，需要将 $GOBIN 或 $GOPATH/bin 加入环境变量 当前的目录结构如下： demo/ |--static/ |--wasm_exec.js |--main.wasm |--main.go |--index.html $ goexec &#39;http.ListenAndServe(`:9999`, http.FileServer(http.Dir(`.`)))&#39; 浏览器访问 localhost:9999，则会有一个弹出窗口，上面写着 *Hello World!*。 为了避免每次编译都需要输入繁琐的命令，可将这个过程写在 Makefile 中 all: static/main.wasm static/wasm_exec.js goexec &#39;http.ListenAndServe(`:9999`, http.FileServer(http.Dir(`.`)))&#39; static/wasm_exec.js: cp &quot;$(shell go env GOROOT)/misc/wasm/wasm_exec.js&quot; static static/main.wasm : main.go GO111MODULE=auto GOOS=js GOARCH=wasm go build -o static/main.wasm . 这样一个敲一下 make 就够了，代码已经上传到 7days-golang - github.com。 3 注册函数(Register Functions)在 Go 语言中调用 JavaScript 函数是一方面，另一方面，如果仅仅是使用 WebAssembly 替代性能要求高的模块，那么就需要注册函数，以便其他 JavaScript 代码调用。 假设我们需要注册一个计算斐波那契数列的函数，可以这么实现。 // main.go package main import &quot;syscall/js&quot; func fib(i int) int &#123; if i == 0 || i == 1 &#123; return 1 &#125; return fib(i-1) + fib(i-2) &#125; func fibFunc(this js.Value, args []js.Value) interface&#123;&#125; &#123; return js.ValueOf(fib(args[0].Int())) &#125; func main() &#123; done := make(chan int, 0) js.Global().Set(&quot;fibFunc&quot;, js.FuncOf(fibFunc)) &lt;-done &#125; fib 是一个普通的 Go 函数，通过递归计算第 i 个斐波那契数，接收一个 int 入参，返回值也是 int。 定义了 fibFunc 函数，为 fib 函数套了一个壳，从 args[0] 获取入参，计算结果用 js.ValueOf 包装，并返回。 使用 js.Global().Set() 方法，将注册函数 fibFunc 到全局，以便在浏览器中能够调用。 js.Value 可以将 Js 的值转换为 Go 的值，比如 args[0].Int()，则是转换为 Go 语言中的整型。js.ValueOf，则用来将 Go 的值，转换为 Js 的值。另外，注册函数的时候，使用 js.FuncOf 将函数转换为 Func 类型，只有 Func 类型的函数，才能在 JavaScript 中调用。可以认为这是 Go 与 JavaScript 之间的接口/约定。 js.Func() 接受一个函数类型作为其参数，该函数的定义必须是： func(this Value, args []Value) interface&#123;&#125; // this 即 JavaScript 中的 this // args 是在 JavaScript 中调用该函数的参数列表。 // 返回值需用 js.ValueOf 映射成 JavaScript 的值 在 main 函数中，创建了信道(chan) done，阻塞主协程(goroutine)。fibFunc 如果在 JavaScript 中被调用，会开启一个新的子协程执行。 A wrapped function triggered during a call from Go to JavaScript gets executed on the same goroutine. A wrapped function triggered by JavaScript’s event loop gets executed on an extra goroutine. —— FuncOf - golang.org 接下来，修改之前的 index.html，在其中添加一个输入框(num)，一个按钮(btn) 和一个文本框(ans，用来显示计算结果)，并给按钮添加了一个点击事件，调用 fibFunc，并将计算结果显示在文本框(ans)中。 &lt;html&gt; ... &lt;body&gt; &lt;input id=&quot;num&quot; type=&quot;number&quot; /&gt; &lt;button id=&quot;btn&quot; onclick=&quot;ans.innerHTML=fibFunc(num.value * 1)&quot;&gt;Click&lt;/button&gt; &lt;p id=&quot;ans&quot;&gt;1&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 使用之前的命令重新编译 main.go，并在 9999 端口启动 Web 服务，如果我们已经将命令写在 Makefile 中了，只需要运行 make 即可。 接下来访问 localhost:9999，可以看到如下效果。输入一个数字，点击Click，计算结果显示在输入框下方。 4 操作 DOM在上一个例子中，仅仅是注册了全局函数 fibFunc，事件注册，调用，对 DOM 元素的操作都是在 HTML中通过原生的 JavaScript 函数实现的。这些事情，能不能全部在 Go 语言中完成呢？答案可以。 首先修改 index.html，删除事件注册部分和 对 DOM 元素的操作部分。 &lt;html&gt; ... &lt;body&gt; &lt;input id=&quot;num&quot; type=&quot;number&quot; /&gt; &lt;button id=&quot;btn&quot;&gt;Click&lt;/button&gt; &lt;p id=&quot;ans&quot;&gt;1&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 修改 main.go： package main import ( &quot;strconv&quot; &quot;syscall/js&quot; ) func fib(i int) int &#123; if i == 0 || i == 1 &#123; return 1 &#125; return fib(i-1) + fib(i-2) &#125; var ( document = js.Global().Get(&quot;document&quot;) numEle = document.Call(&quot;getElementById&quot;, &quot;num&quot;) ansEle = document.Call(&quot;getElementById&quot;, &quot;ans&quot;) btnEle = js.Global().Get(&quot;btn&quot;) ) func fibFunc(this js.Value, args []js.Value) interface&#123;&#125; &#123; v := numEle.Get(&quot;value&quot;) if num, err := strconv.Atoi(v.String()); err == nil &#123; ansEle.Set(&quot;innerHTML&quot;, js.ValueOf(fib(num))) &#125; return nil &#125; func main() &#123; done := make(chan int, 0) btnEle.Call(&quot;addEventListener&quot;, &quot;click&quot;, js.FuncOf(fibFunc)) &lt;-done &#125; 通过 js.Global().Get(&quot;btn&quot;) 或 document.Call(&quot;getElementById&quot;, &quot;num&quot;) 两种方式获取到 DOM 元素。 btnEle 调用 addEventListener 为 btn 绑定点击事件 fibFunc。 在 fibFunc 中使用 numEle.Get(&quot;value&quot;) 获取到 numEle 的值（字符串），转为整型并调用 fib 计算出结果。 ansEle 调用 Set(&quot;innerHTML&quot;, ...) 渲染计算结果。 重新编译 main.go，访问 localhost:9999，效果与之前是一致的。 5 回调函数(Callback Functions)在 JavaScript 中，异步+回调是非常常见的，比如请求一个 Restful API，注册一个回调函数，待数据获取到，再执行回调函数的逻辑，这个期间程序可以继续做其他的事情。Go 语言可以通过协程实现异步。 假设 fib 的计算非常耗时，那么可以启动注册一个回调函数，待 fib 计算完成后，再把计算结果显示出来。 我们先修改 main.go，使得 fibFunc 支持传入回调函数。 package main import ( &quot;syscall/js&quot; &quot;time&quot; ) func fib(i int) int &#123; if i == 0 || i == 1 &#123; return 1 &#125; return fib(i-1) + fib(i-2) &#125; func fibFunc(this js.Value, args []js.Value) interface&#123;&#125; &#123; callback := args[len(args)-1] go func() &#123; time.Sleep(3 * time.Second) v := fib(args[0].Int()) callback.Invoke(v) &#125;() js.Global().Get(&quot;ans&quot;).Set(&quot;innerHTML&quot;, &quot;Waiting 3s...&quot;) return nil &#125; func main() &#123; done := make(chan int, 0) js.Global().Set(&quot;fibFunc&quot;, js.FuncOf(fibFunc)) &lt;-done &#125; 假设调用 fibFunc 时，回调函数作为最后一个参数，那么通过 args[len(args)-1] 便可以获取到该函数。这与其他类型参数的传递并无区别。 使用 go func() 启动子协程，调用 fib 计算结果，计算结束后，调用回调函数 callback，并将计算结果传递给回调函数，使用 time.Sleep() 模拟 3s 的耗时操作。 计算结果出来前，先在界面上显示 Waiting 3s... 接下来我们修改 index.html，为按钮添加点击事件，调用 fibFunc &lt;html&gt; ... &lt;body&gt; &lt;input id=&quot;num&quot; type=&quot;number&quot; /&gt; &lt;button id=&quot;btn&quot; onclick=&quot;fibFunc(num.value * 1, (v)=&gt; ans.innerHTML=v)&quot;&gt;Click&lt;/button&gt; &lt;p id=&quot;ans&quot;&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 为 btn 注册了点击事件，第一个参数是待计算的数字，从 num 输入框获取。 第二个参数是一个回调函数，将参数 v 显示在 ans 文本框中。 接下来，重新编译 main.go，访问 localhost:9999，随便输入一个数字，点击 Click。页面会先显示 Waiting 3s...，3s过后显示计算结果。 6 进一步的尝试6.1 工具框架 WebAssembly 的二进制分析工具 WebAssembly Code Explorer 使用NodeJs 或浏览器测试 Go Wasm 代码 Github Wiki 借鉴 Vue 实现的 Golang WebAssembly 前端框架 Vugu，完全使用 Go，不用写任何的 JavaScript 代码。 6.2 Demo/项目 使用 Go Assembly 前端渲染的一些例子 jsgo 这个项目汇聚一些小而精的项目，包括 2048，俄罗斯方块等游戏，还有证明 Go 可以完整开发前端项目的 TodoMVC 6.3 相关文档 syscall/js 官方文档 - golang.org Go WebAssembly 官方文档 - github.com","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"Go WebAssembly","slug":"Go-WebAssembly","permalink":"https://ysluckly.github.io/tags/Go-WebAssembly/"},{"name":"wasm","slug":"wasm","permalink":"https://ysluckly.github.io/tags/wasm/"},{"name":"gopherjs","slug":"gopherjs","permalink":"https://ysluckly.github.io/tags/gopherjs/"}]},{"title":"Go Protobuf 简明教程","slug":"back-end/quick-go-protobuf","date":"2022-01-16T13:59:10.000Z","updated":"2022-02-20T13:37:12.952Z","comments":true,"path":"2022/01/16/go/","link":"","permalink":"https://ysluckly.github.io/2022/01/16/go/","excerpt":"","text":"1 Protocol Buffers 简介protobuf 即 Protocol Buffers，是一种轻便高效的结构化数据存储格式，与语言、平台无关，可扩展可序列化。protobuf 性能和效率大幅度优于 JSON、XML 等其他的结构化数据格式。protobuf 是以二进制方式存储的，占用空间小，但也带来了可读性差的缺点。protobuf 在通信协议和数据存储等领域应用广泛。例如著名的分布式缓存工具 Memcached 的 Go 语言版本groupcache 就使用了 protobuf 作为其 RPC 数据格式。 Protobuf 在 .proto 定义需要处理的结构化数据，可以通过 protoc 工具，将 .proto 文件转换为 C、C++、Golang、Java、Python 等多种语言的代码，兼容性好，易于使用。 2 安装2.1 protoc从 Protobuf Releases 下载最先版本的发布包安装。如果是 Ubuntu，可以按照如下步骤操作（以3.11.2为例）。 # 下载安装包 $ wget https://github.com/protocolbuffers/protobuf/releases/download/v3.11.2/protoc-3.11.2-linux-x86_64.zip # 解压到 /usr/local 目录下 $ sudo 7z x protoc-3.11.2-linux-x86_64.zip -o/usr/local 如果不想安装在 /usr/local 目录下，可以解压到其他的其他，并把解压路径下的 bin 目录 加入到环境变量即可。 如果能正常显示版本，则表示安装成功。 $ protoc --version libprotoc 3.11.2 2.2 protoc-gen-go我们需要在 Golang 中使用 protobuf，还需要安装 protoc-gen-go，这个工具用来将 .proto 文件转换为 Golang 代码。 go get -u github.com/golang/protobuf/protoc-gen-go protoc-gen-go 将自动安装到 $GOPATH/bin 目录下，也需要将这个目录加入到环境变量中。 3 定义消息类型接下来，我们创建一个非常简单的示例，student.proto syntax = &quot;proto3&quot;; package main; // this is a comment message Student &#123; string name = 1; bool male = 2; repeated int32 scores = 3; &#125; 在当前目录下执行： $ protoc --go_out=. *.proto $ ls student.pb.go student.proto 即是，将该目录下的所有的 .proto 文件转换为 Go 代码，我们可以看到该目录下多出了一个 Go 文件 student.pb.go。这个文件内部定义了一个结构体 Student，以及相关的方法： type Student struct &#123; Name string `protobuf:&quot;bytes,1,opt,name=name,proto3&quot; json:&quot;name,omitempty&quot;` Male bool `protobuf:&quot;varint,2,opt,name=male,proto3&quot; json:&quot;male,omitempty&quot;` Scores []int32 `protobuf:&quot;varint,3,rep,packed,name=scores,proto3&quot; json:&quot;scores,omitempty&quot;` ... &#125; 逐行解读student.proto protobuf 有2个版本，默认版本是 proto2，如果需要 proto3，则需要在非空非注释第一行使用 syntax = &quot;proto3&quot; 标明版本。 package，即包名声明符是可选的，用来防止不同的消息类型有命名冲突。 消息类型 使用 message 关键字定义，Student 是类型名，name, male, scores 是该类型的 3 个字段，类型分别为 string, bool 和 []int32。字段可以是标量类型，也可以是合成类型。 每个字段的修饰符默认是 singular，一般省略不写，repeated 表示字段可重复，即用来表示 Go 语言中的数组类型。 每个字符 =后面的数字称为标识符，每个字段都需要提供一个唯一的标识符。标识符用来在消息的二进制格式中识别各个字段，一旦使用就不能够再改变，标识符的取值范围为 [1, 2^29 - 1] 。 .proto 文件可以写注释，单行注释 //，多行注释 /* ... */ 一个 .proto 文件中可以写多个消息类型，即对应多个结构体(struct)。 接下来，就可以在项目代码中直接使用了，以下是一个非常简单的例子，即证明被序列化的和反序列化后的实例，包含相同的数据。 package main import ( &quot;log&quot; &quot;github.com/golang/protobuf/proto&quot; ) func main() &#123; test := &amp;Student&#123; Name: &quot;geektutu&quot;, Male: true, Scores: []int32&#123;98, 85, 88&#125;, &#125; data, err := proto.Marshal(test) if err != nil &#123; log.Fatal(&quot;marshaling error: &quot;, err) &#125; newTest := &amp;Student&#123;&#125; err = proto.Unmarshal(data, newTest) if err != nil &#123; log.Fatal(&quot;unmarshaling error: &quot;, err) &#125; // Now test and newTest contain the same data. if test.GetName() != newTest.GetName() &#123; log.Fatalf(&quot;data mismatch %q != %q&quot;, test.GetName(), newTest.GetName()) &#125; &#125; 保留字段(Reserved Field) 更新消息类型时，可能会将某些字段/标识符删除。这些被删掉的字段/标识符可能被重新使用，如果加载老版本的数据时，可能会造成数据冲突，在升级时，可以将这些字段/标识符保留(reserved)，这样就不会被重新使用了，protoc 会检查。 message Foo &#123; reserved 2, 15, 9 to 11; reserved &quot;foo&quot;, &quot;bar&quot;; &#125; 4 字段类型4.1 标量类型(Scalar) proto类型 go类型 备注 proto类型 go类型 备注 double float64 float float32 int32 int32 int64 int64 uint32 uint32 uint64 uint64 sint32 int32 适合负数 sint64 int64 适合负数 fixed32 uint32 固长编码，适合大于2^28的值 fixed64 uint64 固长编码，适合大于2^56的值 sfixed32 int32 固长编码 sfixed64 int64 固长编码 bool bool string string UTF8 编码，长度不超过 2^32 bytes []byte 任意字节序列，长度不超过 2^32 标量类型如果没有被赋值，则不会被序列化，解析时，会赋予默认值。 strings：空字符串 bytes：空序列 bools：false 数值类型：0 4.2 枚举(Enumerations)枚举类型适用于提供一组预定义的值，选择其中一个。例如我们将性别定义为枚举类型。 message Student &#123; string name = 1; enum Gender &#123; FEMALE = 0; MALE = 1; &#125; Gender gender = 2; repeated int32 scores = 3; &#125; 枚举类型的第一个选项的标识符必须是0，这也是枚举类型的默认值。 别名（Alias），允许为不同的枚举值赋予相同的标识符，称之为别名，需要打开allow_alias选项。 message EnumAllowAlias &#123; enum Status &#123; option allow_alias = true; UNKOWN = 0; STARTED = 1; RUNNING = 1; &#125; &#125; 4.3 使用其他消息类型Result是另一个消息类型，在 SearchReponse 作为一个消息字段类型使用。 message SearchResponse &#123; repeated Result results = 1; &#125; message Result &#123; string url = 1; string title = 2; repeated string snippets = 3; &#125; 嵌套写也是支持的： message SearchResponse &#123; message Result &#123; string url = 1; string title = 2; repeated string snippets = 3; &#125; repeated Result results = 1; &#125; 如果定义在其他文件中，可以导入其他消息类型来使用： import &quot;myproject/other_protos.proto&quot;; 4.4 任意类型(Any)Any 可以表示不在 .proto 中定义任意的内置类型。 import &quot;google/protobuf/any.proto&quot;; message ErrorStatus &#123; string message = 1; repeated google.protobuf.Any details = 2; &#125; 4.5 oneofmessage SampleMessage &#123; oneof test_oneof &#123; string name = 4; SubMessage sub_message = 9; &#125; &#125; 4.6 mapmessage MapRequest &#123; map&lt;string, int32&gt; points = 1; &#125; 5 定义服务(Services)如果消息类型是用来远程通信的(Remote Procedure Call, RPC)，可以在 .proto 文件中定义 RPC 服务接口。例如我们定义了一个名为 SearchService 的 RPC 服务，提供了 Search 接口，入参是 SearchRequest 类型，返回类型是 SearchResponse service SearchService &#123; rpc Search (SearchRequest) returns (SearchResponse); &#125; 官方仓库也提供了一个插件列表，帮助开发基于 Protocol Buffer 的 RPC 服务。 6 protoc 其他参数命令行使用方法 protoc --proto_path=IMPORT_PATH --&lt;lang&gt;_out=DST_DIR path/to/file.proto --proto_path=IMPORT_PATH：可以在 .proto 文件中 import 其他的 .proto 文件，proto_path 即用来指定其他 .proto 文件的查找目录。如果没有引入其他的 .proto 文件，该参数可以省略。 --&lt;lang&gt;_out=DST_DIR：指定生成代码的目标文件夹，例如 –go_out=. 即生成 GO 代码在当前文件夹，另外支持 cpp/java/python/ruby/objc/csharp/php 等语言 7 推荐风格 文件(Files) 文件名使用小写下划线的命名风格，例如 lower_snake_case.proto 每行不超过 80 字符 使用 2 个空格缩进 包(Packages) 包名应该和目录结构对应，例如文件在my/package/目录下，包名应为 my.package 消息和字段(Messages &amp; Fields) 消息名使用首字母大写驼峰风格(CamelCase)，例如message StudentRequest &#123; ... &#125; 字段名使用小写下划线的风格，例如 string status_code = 1 枚举类型，枚举名使用首字母大写驼峰风格，例如 enum FooBar，枚举值使用全大写下划线隔开的风格(CAPITALS_WITH_UNDERSCORES )，例如 FOO_DEFAULT=1 服务(Services) RPC 服务名和方法名，均使用首字母大写驼峰风格，例如service FooService&#123; rpc GetSomething() &#125; 附：参考 protobuf 代码仓库 - github.com golang protobuf 代码仓库 - github.com Remote procedure call 远程过程调用 - wikipedia.org Groupcache Go语言版 memcached - github.com Language Guide (proto3) 官方指南 - google.com Proto Style Guide 代码风格指南 - google.com Protocol Buffer 插件列表 - github.com","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"Protocol Buffers","slug":"Protocol-Buffers","permalink":"https://ysluckly.github.io/tags/Protocol-Buffers/"},{"name":"Protobuf","slug":"Protobuf","permalink":"https://ysluckly.github.io/tags/Protobuf/"},{"name":"Golang","slug":"Golang","permalink":"https://ysluckly.github.io/tags/Golang/"},{"name":"RPC","slug":"RPC","permalink":"https://ysluckly.github.io/tags/RPC/"}]},{"title":"Go RPC & TLS 鉴权简明教程","slug":"back-end/quick-go-rpc","date":"2022-01-16T13:59:10.000Z","updated":"2022-02-20T13:37:43.335Z","comments":true,"path":"2022/01/16/go/","link":"","permalink":"https://ysluckly.github.io/2022/01/16/go/","excerpt":"","text":"本文介绍了 Go 语言远程过程调用(Remote Procedure Call, RPC)的使用方式，示例基于 Golang 标准库 net/rpc，同时介绍了如何基于 TLS/SSL 实现服务器端和客户端的单向鉴权、双向鉴权。 1 RPC 简介 远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。RPC是一种服务器-客户端（Client/Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。– 远程过程调用 - Wikipedia.org 划重点：程序员就像调用本地程序一样，无需关注细节 RPC 协议假定某种传输协议(TCP, UDP)存在，为通信程序之间携带信息数据。使用 RPC 协议，无需关注底层网络技术协议，调用远程方法就像在调用本地方法一样。 RPC 流程： RPC 模型是一个典型的客户端-服务器模型(Client-Server, CS)，相比于调用本地的接口，RPC 还需要知道的是服务器端的地址信息。本地调用，好比两个人面对面说话，而 RPC 好比打电话，需要知道对方的电话号码，但是并不需要关心语音是怎么编码，如何传输，又如何解码的。 接下来我们将展示如何将一个简单的本地调用的程序一步步地改造一个 RPC 服务。 示例使用 Go 语言，RPC 使用 Golang 提供的net/rpc 标准库 2 一个简单的计算二次方的程序不考虑 RPC 调用，仅考虑本地调用的场景，程序实现如下： // main.go package main import &quot;log&quot; type Result struct &#123; Num, Ans int &#125; type Cal int func (cal *Cal) Square(num int) *Result &#123; return &amp;Result&#123; Num: num, Ans: num * num, &#125; &#125; func main() &#123; cal := new(Cal) result := cal.Square(12) log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans) &#125; 在这个20行的程序中，我们做了以下几件事： Cal 结构体，提供了 Square 方法，用于计算传入参数 num 的 二次方。 Result 结构体，包含 Num 和 Ans 两个字段，Ans 是计算后的值，Num 是待计算的值。 main 函数，测试我们实现的 Square 方法。 运行 main.go，将会输出 $ go run main.go 2020/01/13 20:27:08 12^2 = 144 3 RPC 需要满足什么条件虽然说，远程过程调用并不需要我们关心如何编解码，如何通信，但是最基本的，如果一个方法需要支持远程过程调用，需要满足一定的约束和规范。不同 RPC 框架的约束和规范是不同的，如果使用 Golang 的标准库 net/rpc，方法需要长这个样子： func (t *T) MethodName(argType T1, replyType *T2) error 即需要满足以下 5 个条件： 方法类型（T）是导出的（首字母大写） 方法名（MethodName）是导出的 方法有2个参数(argType T1, replyType *T2)，均为导出/内置类型 方法的第2个参数一个指针(replyType *T2) 方法的返回值类型是 error net/rpc 对参数个数的限制比较严格，仅能有2个，第一个参数是调用者提供的请求参数，第二个参数是返回给调用者的响应参数，也就是说，服务端需要将计算结果写在第二个参数中。如果调用过程中发生错误，会返回 error 给调用者。 接下来，我们改造下 Square 函数，以满足上述 5 个条件。 func (cal *Cal) Square(num int, result *Result) error &#123; result.Num = num result.Ans = num * num return nil &#125; func main() &#123; cal := new(Cal) var result Result cal.Square(11, &amp;result) log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans) &#125; Cal 和 Square 均为导出类型，满足条件 1) 和 2) 2 个参数，num int 为内置类型，result *Result 为导出类型，满足条件 3) 第2个参数 result *Result 是一个指针，满足条件 4) 返回值类型是 error，满足条件 5) 至此，方法 Cal.Square 满足了 RPC 调用的5个条件。 4 RPC 服务与调用4.1 基于HTTP，启动 RPC 服务RPC 是一个典型的客户端-服务器(Client-Server, CS) 架构模型，很显然，需要将 Cal.Square 方法放在服务端。服务端需要提供一个套接字服务，处理客户端发送的请求。通常可以基于 HTTP 协议，监听一个端口，等待 HTTP 请求。 接下来我们新建一个文件夹 server，将 Cal.Square 方法移动到 server/main.go 中，并在 main 函数中启动 RPC 服务。 // server/main.go package main import ( &quot;log&quot; &quot;net&quot; &quot;net/http&quot; &quot;net/rpc&quot; ) type Result struct &#123; Num, Ans int &#125; type Cal int func (cal *Cal) Square(num int, result *Result) error &#123; result.Num = num result.Ans = num * num return nil &#125; func main() &#123; rpc.Register(new(Cal)) rpc.HandleHTTP() log.Printf(&quot;Serving RPC server on port %d&quot;, 1234) if err := http.ListenAndServe(&quot;:1234&quot;, nil); err != nil &#123; log.Fatal(&quot;Error serving: &quot;, err) &#125; &#125; 使用 rpc.Register，发布 Cal 中满足 RPC 注册条件的方法（Cal.Square） 使用 rpc.HandleHTTP 注册用于处理 RPC 消息的 HTTP Handler 使用 http.ListenAndServe 监听 1234 端口，等待 RPC 请求。 我们在 server 目录下，执行 $ go run main.go 2020/01/13 20:59:22 Serving RPC server on port 1234 此时，RPC 服务已经启动，等待客户端的调用。 4.2 实现客户端我们在 client 目录中新建文件 client/main.go，创建 HTTP 客户端，调用 Cal.Square 方法。 // client/main.go package main import ( &quot;log&quot; &quot;net/rpc&quot; ) type Result struct &#123; Num, Ans int &#125; func main() &#123; client, _ := rpc.DialHTTP(&quot;tcp&quot;, &quot;localhost:1234&quot;) var result Result if err := client.Call(&quot;Cal.Square&quot;, 12, &amp;result); err != nil &#123; log.Fatal(&quot;Failed to call Cal.Square. &quot;, err) &#125; log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans) &#125; 在客户端的实现中，因为要用到 Result 类型，简单起见，我们拷贝了 Result 的定义。 使用 rpc.DialHTTP 创建了 HTTP 客户端 client，并且创建了与 localhost:1234 的链接，1234 恰好是 RPC 服务监听的端口。 使用 rpc.Call 调用远程方法，第1个参数是方法名 Cal.Square，后两个参数与 Cal.Square 的定义的参数相对应。 我们在 client 目录下，执行 2020/01/13 21:17:45 12^2 = 144 如果能够返回计算的结果，说明调用成功。 4.3 异步调用client.Call 是同步调用的方式，会阻塞当前的程序，直到结果返回。如果有异步调用的需求，可以考虑使用client.Go，如下 func main() &#123; client, _ := rpc.DialHTTP(&quot;tcp&quot;, &quot;localhost:1234&quot;) var result Result asyncCall := client.Go(&quot;Cal.Square&quot;, 12, &amp;result, nil) log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans) &lt;-asyncCall.Done log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans) &#125; 执行结果如下： 2020/01/13 21:34:26 0^2 = 0 2020/01/13 21:34:26 12^2 = 144 因为 client.Go 是异步调用，因此第一次打印 result，result 没有被赋值。而通过调用 &lt;-asyncCall.Done，阻塞当前程序直到 RPC 调用结束，因此第二次打印 result 时，能够看到正确的赋值。 5 证书鉴权(TLS/SSL)5.1 客户端对服务器端鉴权HTTP 协议默认是不加密的，我们可以使用证书来保证通信过程的安全。 生成私钥和自签名的证书，并将 server.key 权限设置为只读，保证私钥的安全。 # 生成私钥 openssl genrsa -out server.key 2048 # 生成证书 openssl req -new -x509 -key server.key -out server.crt -days 3650 # 只读权限 chmod 400 server.key 执行完，当前文件夹下多出了 server.crt 和 server.key 2 个文件。 服务器端可以使用生成的 server.crt 和 server.key 文件启动 TLS 的端口监听。 // server/main.go import ( &quot;crypto/tls&quot; &quot;log&quot; &quot;net/rpc&quot; ) func main() &#123; rpc.Register(new(Cal)) cert, _ := tls.LoadX509KeyPair(&quot;server.crt&quot;, &quot;server.key&quot;) config := &amp;tls.Config&#123; Certificates: []tls.Certificate&#123;cert&#125;, &#125; listener, _ := tls.Listen(&quot;tcp&quot;, &quot;:1234&quot;, config) log.Printf(&quot;Serving RPC server on port %d&quot;, 1234) for &#123; conn, _ := listener.Accept() defer conn.Close() go rpc.ServeConn(conn) &#125; &#125; 客户端也需要做相应的修改，使用 tls.Dial 代替 rpc.DialHTTP 连接服务端，如果客户端不需要对服务端鉴权，那么可以设置 InsecureSkipVerify:true，即可跳过对服务端的鉴权，例如： // client/main.go import ( &quot;crypto/tls&quot; &quot;log&quot; &quot;net/rpc&quot; ) func main() &#123; config := &amp;tls.Config&#123; InsecureSkipVerify: true, &#125; conn, _ := tls.Dial(&quot;tcp&quot;, &quot;localhost:1234&quot;, config) defer conn.Close() client := rpc.NewClient(conn) var result Result if err := client.Call(&quot;Cal.Square&quot;, 12, &amp;result); err != nil &#123; log.Fatal(&quot;Failed to call Cal.Square. &quot;, err) &#125; log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans) &#125; 如果需要对服务器端鉴权，那么需要将服务端的证书添加到信任证书池中，如下： // client/main.go func main() &#123; certPool := x509.NewCertPool() certBytes, err := ioutil.ReadFile(&quot;../server/server.crt&quot;) if err != nil &#123; log.Fatal(&quot;Failed to read server.crt&quot;) &#125; certPool.AppendCertsFromPEM(certBytes) config := &amp;tls.Config&#123; RootCAs: certPool, &#125; conn, _ := tls.Dial(&quot;tcp&quot;, &quot;localhost:1234&quot;, config) defer conn.Close() client := rpc.NewClient(conn) var result Result if err := client.Call(&quot;Cal.Square&quot;, 12, &amp;result); err != nil &#123; log.Fatal(&quot;Failed to call Cal.Square. &quot;, err) &#125; log.Printf(&quot;%d^2 = %d&quot;, result.Num, result.Ans) &#125; 5.2 服务器端对客户端的鉴权服务器端对客户端的鉴权是类似的，核心在于 tls.Config 的配置： 把对方的证书添加到自己的信任证书池 RootCAs(客户端配置)，ClientCAs(服务器端配置) 中。 创建链接时，配置自己的证书 Certificates。 客户端的 config 作如下修改： // client/main.go cert, _ := tls.LoadX509KeyPair(&quot;client.crt&quot;, &quot;client.key&quot;) certPool := x509.NewCertPool() certBytes, _ := ioutil.ReadFile(&quot;../server/server.crt&quot;) certPool.AppendCertsFromPEM(certBytes) config := &amp;tls.Config&#123; Certificates: []tls.Certificate&#123;cert&#125;, RootCAs: certPool, &#125; 服务器端的 config 作如下修改： // server/main.go cert, _ := tls.LoadX509KeyPair(&quot;server.crt&quot;, &quot;server.key&quot;) certPool := x509.NewCertPool() certBytes, _ := ioutil.ReadFile(&quot;../client/client.crt&quot;) certPool.AppendCertsFromPEM(certBytes) config := &amp;tls.Config&#123; Certificates: []tls.Certificate&#123;cert&#125;, ClientAuth: tls.RequireAndVerifyClientCert, ClientCAs: certPool, &#125; 附：参考 Golang net/rpc 官方文档 - golang.org Golang TLS 配置 - github.com","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://ysluckly.github.io/tags/Golang/"},{"name":"RPC","slug":"RPC","permalink":"https://ysluckly.github.io/tags/RPC/"},{"name":"TLS","slug":"TLS","permalink":"https://ysluckly.github.io/tags/TLS/"},{"name":"证书","slug":"证书","permalink":"https://ysluckly.github.io/tags/%E8%AF%81%E4%B9%A6/"},{"name":"鉴权","slug":"鉴权","permalink":"https://ysluckly.github.io/tags/%E9%89%B4%E6%9D%83/"}]},{"title":"Go Test 单元测试简明教程","slug":"back-end/quick-go-test","date":"2022-01-16T13:59:10.000Z","updated":"2022-02-20T13:38:12.755Z","comments":true,"path":"2022/01/16/go/","link":"","permalink":"https://ysluckly.github.io/2022/01/16/go/","excerpt":"","text":"1 如何写好单元测试单元测试(Unit Tests, UT) 是一个优秀项目不可或缺的一部分，特别是在一些频繁变动和多人合作开发的项目中尤为重要。你或多或少都会有因为自己的提交，导致应用挂掉或服务宕机的经历。如果这个时候你的修改导致测试用例失败，你再重新审视自己的修改，发现之前的修改还有一些特殊场景没有包含，恭喜你减少了一次上库失误。也会有这样的情况，项目很大，启动环境很复杂，你优化了一个函数的性能，或是添加了某个新的特性，如果部署在正式环境上之后再进行测试，成本太高。对于这种场景，几个小小的测试用例或许就能够覆盖大部分的测试场景。而且在开发过程中，效率最高的莫过于所见即所得了，单元测试也能够帮助你做到这一点，试想一下，假如你一口气写完一千行代码，debug 的过程也不会轻松，如果在这个过程中，对于一些逻辑较为复杂的函数，同时添加一些测试用例，即时确保正确性，最后集成的时候，会是另外一番体验。 如何写好单元测试呢？ 首先，学会写测试用例。比如如何测试单个函数/方法；比如如何做基准测试；比如如何写出简洁精炼的测试代码；再比如遇到数据库访问等的方法调用时，如何 mock。 然后，写可测试的代码。高内聚，低耦合是软件工程的原则，同样，对测试而言，函数/方法写法不同，测试难度也是不一样的。职责单一，参数类型简单，与其他函数耦合度低的函数往往更容易测试。我们经常会说，“这种代码没法测试”，这种时候，就得思考函数的写法可不可以改得更好一些。为了代码可测试而重构是值得的。 接下来将介绍如何使用 Go 语言的标准库 testing 进行单元测试。 2 一个简单例子Go 语言推荐测试文件和源代码文件放在一块，测试文件以 _test.go 结尾。比如，当前 package 有 calc.go 一个文件，我们想测试 calc.go 中的 Add 和 Mul 函数，那么应该新建 calc_test.go 作为测试文件。 example/ |--calc.go |--calc_test.go 假如 calc.go 的代码如下： package main func Add(a int, b int) int &#123; return a + b &#125; func Mul(a int, b int) int &#123; return a * b &#125; 那么 calc_test.go 中的测试用例可以这么写： package main import &quot;testing&quot; func TestAdd(t *testing.T) &#123; if ans := Add(1, 2); ans != 3 &#123; t.Errorf(&quot;1 + 2 expected be 3, but %d got&quot;, ans) &#125; if ans := Add(-10, -20); ans != -30 &#123; t.Errorf(&quot;-10 + -20 expected be -30, but %d got&quot;, ans) &#125; &#125; 测试用例名称一般命名为 Test 加上待测试的方法名。 测试用的参数有且只有一个，在这里是 t *testing.T。 基准测试(benchmark)的参数是 *testing.B，TestMain 的参数是 *testing.M 类型。 运行 go test，该 package 下所有的测试用例都会被执行。 $ go test ok example 0.009s 或 go test -v，-v 参数会显示每个用例的测试结果，另外 -cover 参数可以查看覆盖率。 $ go test -v === RUN TestAdd --- PASS: TestAdd (0.00s) === RUN TestMul --- PASS: TestMul (0.00s) PASS ok example 0.007s 如果只想运行其中的一个用例，例如 TestAdd，可以用 -run 参数指定，该参数支持通配符 *，和部分正则表达式，例如 ^、$。 $ go test -run TestAdd -v === RUN TestAdd --- PASS: TestAdd (0.00s) PASS ok example 0.007s 3 子测试(Subtests)子测试是 Go 语言内置支持的，可以在某个测试用例中，根据测试场景使用 t.Run创建不同的子测试用例： // calc_test.go func TestMul(t *testing.T) &#123; t.Run(&quot;pos&quot;, func(t *testing.T) &#123; if Mul(2, 3) != 6 &#123; t.Fatal(&quot;fail&quot;) &#125; &#125;) t.Run(&quot;neg&quot;, func(t *testing.T) &#123; if Mul(2, -3) != -6 &#123; t.Fatal(&quot;fail&quot;) &#125; &#125;) &#125; 之前的例子测试失败时使用 t.Error/t.Errorf，这个例子中使用 t.Fatal/t.Fatalf，区别在于前者遇错不停，还会继续执行其他的测试用例，后者遇错即停。 运行某个测试用例的子测试： $ go test -run TestMul/pos -v === RUN TestMul === RUN TestMul/pos --- PASS: TestMul (0.00s) --- PASS: TestMul/pos (0.00s) PASS ok example 0.008s 对于多个子测试的场景，更推荐如下的写法(table-driven tests)： // calc_test.go func TestMul(t *testing.T) &#123; cases := []struct &#123; Name string A, B, Expected int &#125;&#123; &#123;&quot;pos&quot;, 2, 3, 6&#125;, &#123;&quot;neg&quot;, 2, -3, -6&#125;, &#123;&quot;zero&quot;, 2, 0, 0&#125;, &#125; for _, c := range cases &#123; t.Run(c.Name, func(t *testing.T) &#123; if ans := Mul(c.A, c.B); ans != c.Expected &#123; t.Fatalf(&quot;%d * %d expected %d, but %d got&quot;, c.A, c.B, c.Expected, ans) &#125; &#125;) &#125; &#125; 所有用例的数据组织在切片 cases 中，看起来就像一张表，借助循环创建子测试。这样写的好处有： 新增用例非常简单，只需给 cases 新增一条测试数据即可。 测试代码可读性好，直观地能够看到每个子测试的参数和期待的返回值。 用例失败时，报错信息的格式比较统一，测试报告易于阅读。 如果数据量较大，或是一些二进制数据，推荐使用相对路径从文件中读取。 4 帮助函数(helpers)对一些重复的逻辑，抽取出来作为公共的帮助函数(helpers)，可以增加测试代码的可读性和可维护性。 借助帮助函数，可以让测试用例的主逻辑看起来更清晰。 例如，我们可以将创建子测试的逻辑抽取出来： // calc_test.go package main import &quot;testing&quot; type calcCase struct&#123; A, B, Expected int &#125; func createMulTestCase(t *testing.T, c *calcCase) &#123; // t.Helper() if ans := Mul(c.A, c.B); ans != c.Expected &#123; t.Fatalf(&quot;%d * %d expected %d, but %d got&quot;, c.A, c.B, c.Expected, ans) &#125; &#125; func TestMul(t *testing.T) &#123; createMulTestCase(t, &amp;calcCase&#123;2, 3, 6&#125;) createMulTestCase(t, &amp;calcCase&#123;2, -3, -6&#125;) createMulTestCase(t, &amp;calcCase&#123;2, 0, 1&#125;) // wrong case &#125; 在这里，我们故意创建了一个错误的测试用例，运行 go test，用例失败，会报告错误发生的文件和行号信息： $ go test --- FAIL: TestMul (0.00s) calc_test.go:11: 2 * 0 expected 1, but 0 got FAIL exit status 1 FAIL example 0.007s 可以看到，错误发生在第11行，也就是帮助函数 createMulTestCase 内部。18, 19, 20行都调用了该方法，我们第一时间并不能够确定是哪一行发生了错误。有些帮助函数还可能在不同的函数中被调用，报错信息都在同一处，不方便问题定位。因此，Go 语言在 1.9 版本中引入了 t.Helper()，用于标注该函数是帮助函数，报错时将输出帮助函数调用者的信息，而不是帮助函数的内部信息。 修改 createMulTestCase，调用 t.Helper() func createMulTestCase(c *calcCase, t *testing.T) &#123; t.Helper() t.Run(c.Name, func(t *testing.T) &#123; if ans := Mul(c.A, c.B); ans != c.Expected &#123; t.Fatalf(&quot;%d * %d expected %d, but %d got&quot;, c.A, c.B, c.Expected, ans) &#125; &#125;) &#125; 运行 go test，报错信息如下，可以非常清晰地知道，错误发生在第 20 行。 $ go test --- FAIL: TestMul (0.00s) calc_test.go:20: 2 * 0 expected 1, but 0 got FAIL exit status 1 FAIL example 0.006s 关于 helper 函数的 2 个建议： 不要返回错误， 帮助函数内部直接使用 t.Error 或 t.Fatal 即可，在用例主逻辑中不会因为太多的错误处理代码，影响可读性。 调用 t.Helper() 让报错信息更准确，有助于定位。 5 setup 和 teardown如果在同一个测试文件中，每一个测试用例运行前后的逻辑是相同的，一般会写在 setup 和 teardown 函数中。例如执行前需要实例化待测试的对象，如果这个对象比较复杂，很适合将这一部分逻辑提取出来；执行后，可能会做一些资源回收类的工作，例如关闭网络连接，释放文件等。标准库 testing 提供了这样的机制： func setup() &#123; fmt.Println(&quot;Before all tests&quot;) &#125; func teardown() &#123; fmt.Println(&quot;After all tests&quot;) &#125; func Test1(t *testing.T) &#123; fmt.Println(&quot;I&#39;m test1&quot;) &#125; func Test2(t *testing.T) &#123; fmt.Println(&quot;I&#39;m test2&quot;) &#125; func TestMain(m *testing.M) &#123; setup() code := m.Run() teardown() os.Exit(code) &#125; 在这个测试文件中，包含有2个测试用例，Test1 和 Test2。 如果测试文件中包含函数 TestMain，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。 调用 m.Run() 触发所有测试用例的执行，并使用 os.Exit() 处理返回的状态码，如果不为0，说明有用例失败。 因此可以在调用 m.Run() 前后做一些额外的准备(setup)和回收(teardown)工作。 执行 go test，将会输出 $ go test Before all tests I&#39;m test1 I&#39;m test2 PASS After all tests ok example 0.006s 6 网络测试(Network)6.1 TCP/HTTP假设需要测试某个 API 接口的 handler 能够正常工作，例如 helloHandler func helloHandler(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(&quot;hello world&quot;)) &#125; 那我们可以创建真实的网络连接进行测试： // test code import ( &quot;io/ioutil&quot; &quot;net&quot; &quot;net/http&quot; &quot;testing&quot; ) func handleError(t *testing.T, err error) &#123; t.Helper() if err != nil &#123; t.Fatal(&quot;failed&quot;, err) &#125; &#125; func TestConn(t *testing.T) &#123; ln, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:0&quot;) handleError(t, err) defer ln.Close() http.HandleFunc(&quot;/hello&quot;, helloHandler) go http.Serve(ln, nil) resp, err := http.Get(&quot;http://&quot; + ln.Addr().String() + &quot;/hello&quot;) handleError(t, err) defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) handleError(t, err) if string(body) != &quot;hello world&quot; &#123; t.Fatal(&quot;expected hello world, but got&quot;, string(body)) &#125; &#125; net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:0&quot;)：监听一个未被占用的端口，并返回 Listener。 调用 http.Serve(ln, nil) 启动 http 服务。 使用 http.Get 发起一个 Get 请求，检查返回值是否正确。 尽量不对 http 和 net 库使用 mock，这样可以覆盖较为真实的场景。 6.2 httptest针对 http 开发的场景，使用标准库 net/http/httptest 进行测试更为高效。 上述的测试用例改写如下： // test code import ( &quot;io/ioutil&quot; &quot;net/http&quot; &quot;net/http/httptest&quot; &quot;testing&quot; ) func TestConn(t *testing.T) &#123; req := httptest.NewRequest(&quot;GET&quot;, &quot;http://example.com/foo&quot;, nil) w := httptest.NewRecorder() helloHandler(w, req) bytes, _ := ioutil.ReadAll(w.Result().Body) if string(bytes) != &quot;hello world&quot; &#123; t.Fatal(&quot;expected hello world, but got&quot;, string(bytes)) &#125; &#125; 使用 httptest 模拟请求对象(req)和响应对象(w)，达到了相同的目的。 7 Benchmark 基准测试基准测试用例的定义如下： func BenchmarkName(b *testing.B)&#123; // ... &#125; 函数名必须以 Benchmark 开头，后面一般跟待测试的函数名 参数为 b *testing.B。 执行基准测试时，需要添加 -bench 参数。 例如： func BenchmarkHello(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; fmt.Sprintf(&quot;hello&quot;) &#125; &#125; $ go test -benchmem -bench . ... BenchmarkHello-16 15991854 71.6 ns/op 5 B/op 1 allocs/op ... 基准测试报告每一列值对应的含义如下： type BenchmarkResult struct &#123; N int // 迭代次数 T time.Duration // 基准测试花费的时间 Bytes int64 // 一次迭代处理的字节数 MemAllocs uint64 // 总的分配内存的次数 MemBytes uint64 // 总的分配内存的字节数 &#125; 如果在运行前基准测试需要一些耗时的配置，则可以使用 b.ResetTimer() 先重置定时器，例如： func BenchmarkHello(b *testing.B) &#123; ... // 耗时操作 b.ResetTimer() for i := 0; i &lt; b.N; i++ &#123; fmt.Sprintf(&quot;hello&quot;) &#125; &#125; 使用 RunParallel 测试并发性能 func BenchmarkParallel(b *testing.B) &#123; templ := template.Must(template.New(&quot;test&quot;).Parse(&quot;Hello, &#123;&#123;.&#125;&#125;!&quot;)) b.RunParallel(func(pb *testing.PB) &#123; var buf bytes.Buffer for pb.Next() &#123; // 所有 goroutine 一起，循环一共执行 b.N 次 buf.Reset() templ.Execute(&amp;buf, &quot;World&quot;) &#125; &#125;) &#125; $ go test -benchmem -bench . ... BenchmarkParallel-16 3325430 375 ns/op 272 B/op 8 allocs/op ... 附 参考 Go Mock (gomock) 简明教程 testing - golang.org Advanced Testing in Go - sourcegraph.com","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"golang test","slug":"golang-test","permalink":"https://ysluckly.github.io/tags/golang-test/"},{"name":"unit tests","slug":"unit-tests","permalink":"https://ysluckly.github.io/tags/unit-tests/"},{"name":"golang testing","slug":"golang-testing","permalink":"https://ysluckly.github.io/tags/golang-testing/"}]},{"title":"Go库之goquery","slug":"back-end/1645851577858","date":"2022-01-09T07:29:32.000Z","updated":"2022-02-26T05:59:30.761Z","comments":true,"path":"2022/01/09/golang/","link":"","permalink":"https://ysluckly.github.io/2022/01/09/golang/","excerpt":"","text":"本文参考 飞雪无痕 的 《golang goquery selector(选择器) 示例大全》 概述相信很多小伙伴对爬虫有着很大的兴趣,今天我们就来说下go语言的爬虫利器goquery，有使用过jquery的小伙伴是不是看着这个很眼熟？goquery类似jquery，它是jquery的go版本实现，使用它，可以很方便的对HTML进行处理。 goquery是基于 Go net/htm包和css选择器库 cascadia。由于net/htm解析器返回的是DOM节点,而不是完整的DOM树,因此, jQuery的状态操作函数没有实现(像height(), css(), detach) 注意：goquery只支持utf-8编码，其他编码需要转换。 安装在终端输入命令安装goquery。 go get github.com/PuerkitoBio/goquery 简单使用我们首先通过一个小例子来介绍goqery。 func main() &#123; html := `&lt;html&gt; &lt;body&gt; &lt;h1 id=&quot;title&quot;&gt;春晓&lt;/h1&gt; &lt;p class=&quot;content1&quot;&gt; 春眠不觉晓， 处处闻啼鸟。 夜来风雨声， 花落知多少。 &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; ` dom,err:=goquery.NewDocumentFromReader(strings.NewReader(html)) if err!=nil&#123; log.Fatalln(err) &#125; dom.Find(&quot;p&quot;).Each(func(i int, selection *goquery.Selection) &#123; fmt.Println(selection.Text()) &#125;) &#125; 得到结果： 春眠不觉晓， 处处闻啼鸟。 夜来风雨声， 花落知多少。 NewDocumentFromReader() 返回了一个*Document和error。Document代表一个将要被操作的HTML文档。 Find()是获取当前匹配元素集中每个元素的子代，参数是x选择器 ，它返回一个包含这些匹配元素的新选择对象。在例子中我们使用的是元素选择器P，它会帮我们匹配出所有的p标签 。 Each() 是迭代器，它会循环遍历选择的节点，它的参数是一个匿名函数，匿名函数拥有2个参数，一个是元素的索引位置，还有一个就是选择的结果集匹配到的内容都在它的里面。 Text() 则是获取匹配元素集中的文本内容。 选择器上面的例子中，我们使用了元素选择器,goquery跟jquery一样都支持很多选择器，我们简单的介绍下常用的选择器： 基于HTML Element 元素的选择器 就是基于a,p等这些HTML的基本元素进行选择。 使用方法 ：使用语法为 dom.Find(&quot;p&quot;)，匹配文档中所有的p标签。 ID 选择器 ID选择器是我们使用最频繁的，假如我们有2个p元素，其实我们只需要其中的一个，那么我们只需要给这个标记一个唯一的id即可，这样我们就可以使用id选择器，精确定位了。 使用方法 ：id选择器以#开头，紧跟着元素id的值，使用语法为dom.Find(&quot;#title&quot;) ，匹配文档中所有的 id=title的内容 如果多个标签的ID都是title，我们可以指定某一个标签,如dom.Find(&quot;p#title&quot;) Class选择器 类选择跟ID选择器一样都是使用很频繁的，我们可以通过类选择器快速筛选到需要的内容。 使用方法 ： id选择器以.开头，紧跟着元素class的值，使用语法为dom.Find(&quot;.content1&quot;)，匹配文档中所有的 id=title的元素。 类选择权器跟ID选择器一样,也可以指定某一个标签dom.Find(&quot;div.content1&quot;) 属性选择器 一个HTML元素都有自己的属性以及属性值，所以我们也可以通过属性和值筛选元素。 使用方法 ：我们可以通过元素的属性和属性值来筛选数据，使用语法为dom.Find(&quot;p[class=content1]，匹配文档中所有的 p标签的class属性是content1的元素。 当然我们这里以class属性为例，还可以用其他属性，比如href等很多，自定义属性也是可以的。 刚刚我们使用的是完全相等的匹配方式，属性选择器还要很多匹配方式。 选择器 说明 Find(“div[my]“) 筛选含有my属性的div元素 Find(“div[my=zh]“) 筛选my属性为zh的div元素 Find(“div[my!=zh]“) 筛选my属性不等于zh的div元素 Find(“div[my¦=zh]“) 筛选my属性为zh或者zh-开头的div元素 Find(“div[my*=zh]“) 筛选my属性包含zh这个字符串的div元素 Find(“div[my~=zh]“) 筛选my属性包含zh这个单词的div元素，单词以空格分开的 Find(“div[my$=zh]“) 筛选my属性以zh结尾的div元素，区分大小写 Find(“div[my^=zh]“) 筛选my属性以zh开头的div元素，区分大小写 parent &gt; child选择器 筛选出某个元素下的子元素。 使用方法：使用&gt;符号连接，使用语法 dom.Find(&quot;div&gt;p&quot;) ， 筛选div标签下的p标签 element + next 相邻选择器 如果要筛选的元素没有规律，但是该元素的上一个元素有规律，我们就可以使用这种下一个相邻选择器来进行选择。 如： &lt;div&gt; &lt;p my=&quot;a&quot;&gt;a&lt;/p&gt; &lt;p&gt;b&lt;/p&gt; &lt;p&gt;c&lt;/p&gt; &lt;div&gt; 我想筛选出b所在的标签 使用方法：dom.Find(&quot;p[my=a]+p&quot;)筛选出p标签属性my的值为a的相邻p标签。 element~next 兄弟选择器 有时候我们需要筛选同一父元素下，不相邻的标签，可以使用兄弟选择器 比如我想筛选出 b 和c 所在标签使用方法：dom.Find(&quot;p[my=a]~p&quot;)，筛选出p标签属性my的值为a的兄弟p标签。 过滤器有时候我们选择出来的结果，并不是我们心目中的最优结果，我们希望对其进行过滤。 :contains过滤器 筛选出的元素要包含指定的文本，比如我想筛选出包含a的p标签 使用方法：dom.Find(&quot;p:contains(a)&quot;)，筛选出内容包含a的p标签 Find(“:has(selector)”)和contains差不多，只不过这个是包含的是元素节点。 此外还有Find(“:empty”)表示筛选出的元素都不能有子元素（包括文本元素），只筛选那些不包含任何子元素的元素。 :first-child过滤器 和:first-of-type过滤器 筛选出的元素要是他们的父元素的第一个子元素，如果不是，则不会被筛选出来。 使用方法：语法为Find(“p:first-child”)，筛选出第一个p标签 :first-child选择器限制的比较死，必须得是第一个子元素，如果该元素前有其他在前面，就不能用:first-child了，这时候:first-of-type就派上用场了，它要求只要是这个类型的第一个就可以。 :last-child 和:last-of-type过滤器 这两个正好和上面的:first-child、:first-of-type相反 :nth-child(n) 过滤器 筛选出的元素是其父元素的第n个元素，n以1开始。所以我们可以知道:first-child和:nth-child(1)是相等的。通过指定n，我们就很灵活的筛选出我们需要的元素。 :nth-of-type(n) 过滤器 :nth-of-type(n)和 :nth-child(n) 类似，只不过它表示的是同类型元素的第n个,所以:nth-of-type(1) 和 :first-of-type是相等的。 :nth-last-child(n) 和:nth-last-of-type(n) 过滤器 这两个和上面的类似，只不过是倒序开始计算的，最后一个元素被当成了第一个 :only-child 过滤器 和 :only-of-type 过滤器 筛选出父元素中，只有它自己的一个的元素。 常用方法 类似函数的位置操作 Find(selection) *Selection //根据选择器查找节点集 Eq(index int) *Selection //根据索引获取某个节点集 First() *Selection //获取第一个子节点集 Last() *Selection //获取最后一个子节点集 Next() *Selection //获取下一个兄弟节点集 NextAll() *Selection //获取后面所有兄弟节点集 Prev() *Selection //前一个兄弟节点集 Get(index int) *html.Node //根据索引获取一个节点 Index() int //返回选择对象中第一个元素的位置 Slice(start, end int) *Selection //根据起始位置获取子节点集 循环遍历选择的节点 Each(f func(int, *Selection)) *Selection //遍历 EachWithBreak(f func(int, *Selection) bool) *Selection //可中断遍历 Map(f func(int, *Selection) string) (result []string) //返回字符串数组 检测或获取节点属性值 Attr(), RemoveAttr(), SetAttr() //获取，移除，设置属性的值 AddClass(), HasClass(), RemoveClass(), ToggleClass() Html() //获取该节点的html Length() //返回该Selection的元素个数 Text() //获取该节点的文本值 在文档树之间来回跳转（常用的查找节点方法） Children() //返回selection中各个节点下的孩子节点 Contents() //获取当前节点下的所有节点 Find() //查找获取当前匹配的元素 Next() //下一个元素 Prev() //上一个元素 总结goquery 是解析HTML网页必备的利器，在爬虫抓取网页的过程中，灵活的使用goquery不同的选择器，可以让我们的抓取工作事半功倍，大大提升爬虫的效率。 本文转自 https://blog.csdn.net/yang731227/article/details/89338745，如有侵权，请联系删除。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"Go爬虫","slug":"Go爬虫","permalink":"https://ysluckly.github.io/tags/Go%E7%88%AC%E8%99%AB/"},{"name":"goquery","slug":"goquery","permalink":"https://ysluckly.github.io/tags/goquery/"}]},{"title":"【Go项目】爬取CSDN文章保存本地","slug":"back-end/1645850306458","date":"2022-01-08T07:29:32.000Z","updated":"2022-02-26T05:58:30.577Z","comments":true,"path":"2022/01/08/golang/","link":"","permalink":"https://ysluckly.github.io/2022/01/08/golang/","excerpt":"","text":"背景我一直想把在CSDN上面发布的文章保存到本地，然后迁移到简书上，但是CSDN比较闭塞的就是不提供迁移接口。所以我只能寻找第三方工具，但是发现要么已经失效，要么就是使用不太友好（对我个人而言），所以我用go语言花了半小时自己撸了一个导出工具。 分析我们先来分析如何获取到文章信息： 1.获取文章地址首先我们通过文章列表获取文章的地址。 &lt;h4 class=&quot;&quot;&gt; &lt;a href=&quot;https://blog.csdn.net/yang731227/article/details/103007106&quot; target=&quot;_blank&quot;&gt; &lt;span class=&quot;article-type type-1 float-none&quot;&gt;原创&lt;/span&gt; Beego脱坑（六）——使用模板获取数据 &lt;/a&gt; &lt;/h4&gt; 可以发现 每篇的文章地址 在 h4标签 下面的a 标签中。 2.获取文章内容接着我们获取文章的具体内容，CSDN的文章类型有两种，一种是富文本类型，还有一种是markdown。因此我先查看它们显示的方式是否一样 首先我查看的是富文本格式的文章，发现内容是在&lt;article class=&quot;baidu_pl&quot;&gt;标签里面： &lt;article class=&quot;baidu_pl&quot;&gt; &lt;!--忽略文章内容--&gt; &lt;/article&gt;` 接着我们在找一篇markdown格式编写的文章查看下,发现内容依然是在&lt;article class=&quot;baidu_pl&quot;&gt;标签里面。 3.查找接口找到文章内容在什么标签内还没完事，我这人比较喜欢搞事情。因为我希望能到把博客导成md格式，但是现在网页上爬取的内容都是html，也就是富文本格式。因此我去寻找go语言 html转markdown 的库，但是不幸的是没有找到。虽然又工具可以帮我完成这份工作，但是我比较懒希望能减少工作就减少一点。 然后我的思维又开始拐弯，如果是md格式的文章，我们在文章的编辑界面不是可以直接获取到md文本吗？我在编辑页面把所有的md文章，都直接保存为md不就能省很多功夫？ 但是接下来我去查看编辑页面源代码的时候，没有发现文章的内容。这时候不要慌！那么它肯定是通过某个接口来加载数据的，查看下XHR果然发现了一个接口，参数是文章ID。https://mp.csdn.net/mdeditor/getArticle?id=103007106 (该接口富文本内容已失效) 新的接口为： https://blog-console-api.csdn.net/v1/editor/getArticle?id=103007106 以此类推，我再去打开富文本文章的编辑界面，我希望它也是通过接口加载数据的，这样在进行数据处理的时候我就能够省很多代码。然鹅富文本格式并没有接口数据。 但是我这个人比较轴，我就想试下，我把接口ID改成富文本文章的ID，看看它是否能够为我传来数据，果然有的时候搞开发就要有折腾的精神，我成功得到了文章内容 。https://mp.csdn.net/mdeditor/getArticle?id=82253319 https://blog-console-api.csdn.net/v1/editor/getArticle?id=82253319 两个数据不一样的地方就是，如果是md文章，它 markdowncontent 里面的内容是 md文本，如果是富文本的文章，它markdowncontent属性就为空，因此我们在导出文本的时候，如果遇到markdowncontent不为空就获取markdowncontent的内容并保存为.md ,如果遇到为空的情况，就获取content内容并保存为.html 4.整理现在我们已知 https://blog-console-api.csdn.net/v1/editor/getArticle?id=xxxx这个接口可以获取到文章的信息，参数是文章ID。所以接下来我们需要做的就是，通过爬虫模拟csdn登录状态，获取所爬的博客中每篇文章的ID,传递给接口，获取文章标题和内容，并根据格式保存不同的文件。 实现代码使用到的第三方库 使用goconfig库，来加载配置信息，用来获取博客地址、文章列表页数和Cookie。 使用goquery 进行爬虫 model.gopackage models import ( &quot;CSDN/utils&quot; &quot;github.com/Unknwon/goconfig&quot; ) var ArrDetailID []string //保存文章ID var BlogUrl string // 配置博客地址 var Cookie string // 配置Cookie var TotalPage int // 博客文章列表总页数 type Article struct &#123; //用来解析json Data struct &#123; // ID string `json:&quot;id&quot;` Title string `json:&quot;title&quot;` // Articleedittype int `json:&quot;articleedittype&quot;` // Description string `json:&quot;description&quot;` Content string `json:&quot;content&quot;` Markdowncontent string `json:&quot;markdowncontent&quot;` /* Tags string `json:&quot;tags&quot;` Categories string `json:&quot;categories&quot;` Channel string `json:&quot;channel&quot;` Type string `json:&quot;type&quot;` Status int `json:&quot;status&quot;` ReadType string `json:&quot;readType&quot;` UseVipView int `json:&quot;use_vip_view&quot;` UseFansView int `json:&quot;use_fans_view&quot;` Reason string `json:&quot;reason&quot;` ResourceURL string `json:&quot;resource_url&quot;` OriginalLink string `json:&quot;original_link&quot;` AuthorizedStatus bool `json:&quot;authorized_status&quot;` CheckOriginal bool `json:&quot;check_original&quot;` SelfRecommend bool `json:&quot;selfRecommend&quot;` */ &#125; `json:&quot;data&quot;` &#125; func init() &#123; runpath := utils.GetRunPath() cfg, err := goconfig.LoadConfigFile(runpath + &quot;/conf/conf.ini&quot;) if err != nil &#123; panic(&quot;没有加载到配置文件&quot;) &#125; BlogUrl, err = cfg.GetValue(&quot;csdn&quot;, &quot;blogurl&quot;) if err != nil &#123; panic(&quot;blogurl错误&quot;) &#125; Cookie, err = cfg.GetValue(&quot;csdn&quot;, &quot;cookie&quot;) if err != nil &#123; panic(&quot;cookie错误&quot;) &#125; TotalPage, err = cfg.Int(&quot;csdn&quot;, &quot;totalpage&quot;) if err != nil &#123; panic(&quot;totalpage错误&quot;) &#125; &#125; csdn.gopackage transaction import ( &quot;CSDN/models&quot; &quot;encoding/json&quot; &quot;github.com/PuerkitoBio/goquery&quot; &quot;io/ioutil&quot; &quot;log&quot; &quot;net/http&quot; &quot;strings&quot; &quot;time&quot; ) func GetHtml(url string) *http.Response &#123; client := &amp;http.Client&#123; //要管理HTTP客户端的头域、重定向策略和其他设置，创建一个Client Timeout: time.Second * 2, &#125; req, err := http.NewRequest(&quot;GET&quot;, url, nil) //NewRequest使用指定的方法、网址和可选的主题创建并返回一个新的*Request。 if err != nil &#123; log.Println(err) &#125; req.Header.Add(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36&quot;) //模拟浏览器User-Agent req.Header.Add(&quot;Cookie&quot;, models.Cookie) resp, err := client.Do(req) //Do方法发送请求，返回HTTP回复 if err != nil &#123; log.Println(err) &#125; return resp //返回网页响应 &#125; func GetdetailID(resp *http.Response) &#123; defer resp.Body.Close() dom, err := goquery.NewDocumentFromReader(resp.Body) if err != nil &#123; log.Fatalln(err) &#125; dom.Find(&quot;h4&quot;).Each(func(i int, selection *goquery.Selection) &#123; time.Sleep(1 * time.Second) //防止访问次数过于频繁 detailurl, _ := selection.Find(&quot;a&quot;).Attr(&quot;href&quot;) index := strings.LastIndex(detailurl, &quot;/&quot;) models.ArrDetailID = append(models.ArrDetailID, detailurl[index+1:]) &#125;) &#125; func ParseArticleJson(jsonurl string) (string, string) &#123; resp := GetHtml(jsonurl) defer resp.Body.Close() resp_byte, _ := ioutil.ReadAll(resp.Body) respHtml := string(resp_byte) var article models.Article json.Unmarshal([]byte(respHtml), &amp;article) title := article.Data.Title content := article.Data.Content markdown := article.Data.Markdowncontent if markdown == &quot;&quot; &#123; return title + &quot;.html&quot;, content &#125; else &#123; return title + &quot;.md&quot;, markdown &#125; &#125; utils.gopackage utils import ( &quot;fmt&quot; &quot;io/ioutil&quot; &quot;os&quot; &quot;os/exec&quot; &quot;path/filepath&quot; &quot;strings&quot; ) func WriteWithIoutil(name, content string) &#123; data := []byte(content) if ioutil.WriteFile(name, data, 0644) == nil &#123; fmt.Println(&quot;导出成功:&quot;, name) &#125; &#125; // 获取程序当前运行路径 func GetRunPath() string&#123; file, _ := exec.LookPath(os.Args[0]) path, _ := filepath.Abs(file) index := strings.LastIndex(path, string(os.PathSeparator)) runpath :=path[:index] return runpath &#125; main.gopackage main import ( &quot;CSDN/models&quot; &quot;CSDN/transaction&quot; &quot;CSDN/utils&quot; &quot;fmt&quot; &quot;time&quot; ) func main() &#123; fmt.Println(&quot;设置成功，开始导出blog,时间较长请等待！！&quot;) for i := 1; i &lt;= models.TotalPage; i++ &#123; time.Sleep(800) //设置延时 url := fmt.Sprintf(&quot;%s/article/list/%d&quot;, models.BlogUrl, i) resq := transaction.GetHtml(url) transaction.GetdetailID(resq) &#125; runpath := utils.GetRunPath() for i := 0; i &lt; len(models.ArrDetailID); i++ &#123; //jsonurl := fmt.Sprintf(&quot;https://mp.csdn.net/mdeditor/getArticle?id=%s&quot;, models.ArrDetailID[i]) jsonurl := fmt.Sprintf(&quot;https://blog-console-api.csdn.net/v1/editor/getArticle?id=%s&quot;, models.ArrDetailID[i]) name, content := transaction.ParseArticleJson(jsonurl) utils.WriteWithIoutil(runpath+&quot;/&quot;+name, content) time.Sleep(1000) //设置延时 &#125; &#125; conf.ini 配置文件[csdn] blogurl = https://blog.csdn.net/yang731227 ;博客地址 totalpage = 7 ;博客文章列表数 cookie = ;爬取账号的cookie 导出效果 下载土豪通道： win: https://download.csdn.net/download/yang731227/12157060 mac :https://download.csdn.net/download/yang731227/12154880 或者直接到github上面下载：https://github.com/Clown95/CSDN-Blog-Export 如果你觉得对你有帮助给个star呗 本文转自 https://blog.csdn.net/yang731227/article/details/103098189，如有侵权，请联系删除。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"Go爬虫","slug":"Go爬虫","permalink":"https://ysluckly.github.io/tags/Go%E7%88%AC%E8%99%AB/"},{"name":"goquery","slug":"goquery","permalink":"https://ysluckly.github.io/tags/goquery/"}]},{"title":"Go全栈面试题（2）-Go进阶面试题","slug":"back-end/1645851784606","date":"2022-01-07T07:29:32.000Z","updated":"2022-02-26T05:56:51.954Z","comments":true,"path":"2022/01/07/golang/","link":"","permalink":"https://ysluckly.github.io/2022/01/07/golang/","excerpt":"","text":"Golang进阶面试题Go的堆栈使用 每个goroutine维护着一个栈空间，默认最大为4KB. 当goroutine的栈空间不足时，golang会调用runtime.morestack(汇编实现：asm_xxx.s)来进行动态扩容. 连续栈：当栈空间不足的时候申请一个2倍于当前大小的新栈，并把所有数据拷贝到新栈， 接下来的所有调用执行都发生在新栈上. 每个function维护着各自的栈帧(stack frame)，当function退出时会释放栈帧. Go运行时内存分配的策略对于小对象（&lt;=32kb），go runtime首先从,Cache开始，然后是Cental，最后Heap。对于大对象（&gt;32KB），直接从堆中获取。 heap: 全局根对象。负责向操作系统申请内存,管理由垃圾回收器收回的空闲 span 内存块。 central: 从 heap 获取空闲 span,并按需要将其切分成 object 块。heap 管理着多个central 对象,每个 central 负责处理一一种等级的内存分配需求。 cache: 运行行期,每个 cache 都与某个具体线程相绑定,实现无无锁内存分配操作。其内部有个以等级为序号的数组,持有多个切分好的 span 对象。缺少空间时,向等级对应的 central 获取新的 span 即可。 运行时何时从堆中分配内存，何时从堆栈中分配内存？ 对于生命周期仅在堆栈帧内的小对象，将分配栈内存。 对于将通过堆栈帧传递的小对象，堆内存。 对于大对象（&gt;32KB），堆内存。 对于可以转义到堆但实际上是内联的小对象，栈内存。 Go运行时是否维护Map元素的遍历顺序？不维护，Go白皮书明确提到映射元素的迭代顺序是未定义的。 所以对于同一个映射值，它的一个遍历过程和下一个遍历过程中的元素呈现次序不保证是相同的。 对于标准编译器，映射元素的遍历顺序是随机的。 如果你需要固定的映射元素遍历顺序，那么你就需要自己来维护这个顺序。 但是请注意：从Go 1.12开始，标准库包中的各个打印函数的结果中，映射条目总是排了序的。 函数返回局部变量的指针是否安全？是的，在Go中这是绝对安全的。支持栈的Go编译器将会对每个局部变量进行逃逸分析。 如果编译器发现某个局部变量开辟在栈上不是绝对安全的，则此局部变量将被开辟在堆上。 goroutine是怎么样调度的？Golang中调度器的主要有4个重要部分，分别是G、P、M、Sched： G (goroutine) G代表一个goroutine对象，每次go调用的时候，都会创建一个G对象,包括了调用栈，重要的调度信息，例如channel等。 P (processor) 衔接M和G的调度上下文，它负责将等待执行的G与M对接。P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行。 M (work thread) 代表一个线程，每次创建一个M的时候，都会有一个底层线程创建；所有的G任务，最终还是在M上执行 Sched是调度实现中使用的数据结构,大多数需要的信息都已放在了结构体M、G和P中，Sched结构体只是一个壳。Sched结构体中的Lock是非常必须的，如果M或P等做一些非局部的操作，它们一般需要先锁住调度器。 每次go调用的时候，都会： 创建一个G对象，加入到本地队列或者全局队列 如果还有空闲的P，则创建一个M M会启动一个底层线程，循环执行能找到的G任务 G任务的执行顺序是，先从本地队列找，本地没有则从全局队列找（一次性转移(全局G个数/P个数）个，再去其它P中找（一次性转移一半）， 以上的G任务执行是按照队列顺序（也就是go调用的顺序）执行的。 G是顺序执行的是不是有点奇怪，跟我们实际了解到情况不一样。原因是，启动的时候，会专门创建一个线程sysmon，用来监控和管理，在内部是一个循环： 记录所有P的G任务计数schedtick，（schedtick会在每执行一个G任务后递增） 如果检查到 schedtick一直没有递增，说明这个P一直在执行同一个G任务，如果超过一定的时间（10ms），就在这个G任务的栈信息里面加一个标记。 然后这个G任务在执行的时候，如果遇到非内联函数调用，就会检查一次这个标记，然后中断自己，把自己加到队列末尾，执行下一个G 。 如果没有遇到非内联函数（有时候正常的小函数会被优化成内联函数）调用的话，那就惨了，会一直执行这个G任务，直到它自己结束； 如何等待所有goroutine的退出？Go中的goroutines和channel提供了一种优雅而独特的结构化并发软件的方法，我们可以利用通道(channel)的特性，来实现当前等待goroutine的操作。但是channel并不是当前这个场景的最佳方案，用它来实现的方式是稍显笨拙的，需要知道确定个数的goroutine，同时稍不注意就极易产生死锁,但事实上比较优雅的方式是使用go标准库sync，其中提供了专门的解决方案sync.WaitGroup用于等待一个goroutines集合的结束。 怎么限制Goroutine的数量?在Golang中，Goroutine虽然很好，但是数量太多了，往往会带来很多麻烦，比如耗尽系统资源导致程序崩溃，或者CPU使用率过高导致系统忙不过来。所以我们可以限制下Goroutine的数量,这样就需要在每一次执行go之前判断goroutine的数量，如果数量超了，就要阻塞go的执行。第一时间想到的就是使用通道。每次执行的go之前向通道写入值，直到通道满的时候就阻塞了， package main import &quot;fmt&quot; var ch chan int func elegance()&#123; &lt;-ch fmt.Println(&quot;the ch value receive&quot;,ch) &#125; func main()&#123; ch = make(chan int,5) for i:=0;i&lt;10;i++&#123; ch &lt;-1 fmt.Println(&quot;the ch value send&quot;,ch) go elegance() fmt.Println(&quot;the result i&quot;,i) &#125; &#125; 运行: &gt; go run goroutine.go the ch value send 0xc00009c000 the result i 0 the ch value send 0xc00009c000 the result i 1 the ch value send 0xc00009c000 the result i 2 the ch value send 0xc00009c000 the result i 3 the ch value send 0xc00009c000 the result i 4 the ch value send 0xc00009c000 the result i 5 the ch value send 0xc00009c000 the ch value receive 0xc00009c000 the result i 6 the ch value receive 0xc00009c000 the ch value send 0xc00009c000 the result i 7 the ch value send 0xc00009c000 the result i 8 the ch value send 0xc00009c000 the result i 9 the ch value send 0xc00009c000 the ch value receive 0xc00009c000 the ch value receive 0xc00009c000 the ch value receive 0xc00009c000 the result i 10 the ch value send 0xc00009c000 the result i 11 the ch value send 0xc00009c000 the result i 12 the ch value send 0xc00009c000 the result i 13 the ch value send 0xc00009c000 the ch value receive 0xc00009c000 the ch value receive 0xc00009c000 the ch value receive 0xc00009c000 the ch value receive 0xc00009c000 the result i 14 the ch value receive 0xc00009c000 &gt; go run goroutine.go the ch value send 0xc00007e000 the result i 0 the ch value send 0xc00007e000 the result i 1 the ch value send 0xc00007e000 the result i 2 the ch value send 0xc00007e000 the result i 3 the ch value send 0xc00007e000 the ch value receive 0xc00007e000 the result i 4 the ch value send 0xc00007e000 the ch value receive 0xc00007e000 the result i 5 the ch value send 0xc00007e000 the ch value receive 0xc00007e000 the result i 6 the ch value send 0xc00007e000 the result i 7 the ch value send 0xc00007e000 the ch value receive 0xc00007e000 the ch value receive 0xc00007e000 the ch value receive 0xc00007e000 the result i 8 the ch value send 0xc00007e000 the result i 9 这样每次同时运行的goroutine就被限制为5个了。但是新的问题于是就出现了，因为并不是所有的goroutine都执行完了，在main函数退出之后，还有一些goroutine没有执行完就被强制结束了。这个时候我们就需要用到sync.WaitGroup。使用WaitGroup等待所有的goroutine退出。 package main import ( &quot;fmt&quot; &quot;runtime&quot; &quot;sync&quot; &quot;time&quot; ) // Pool Goroutine Pool type Pool struct &#123; queue chan int wg *sync.WaitGroup &#125; // New 新建一个协程池 func NewPool(size int) *Pool&#123; if size &lt;=0&#123; size = 1 &#125; return &amp;Pool&#123; queue:make(chan int,size), wg:&amp;sync.WaitGroup&#123;&#125;, &#125; &#125; // Add 新增一个执行 func (p *Pool)Add(delta int)&#123; // delta为正数就添加 for i :=0;i&lt;delta;i++&#123; p.queue &lt;-1 &#125; // delta为负数就减少 for i:=0;i&gt;delta;i--&#123; &lt;-p.queue &#125; p.wg.Add(delta) &#125; // Done 执行完成减一 func (p *Pool) Done()&#123; &lt;-p.queue p.wg.Done() &#125; // Wait 等待Goroutine执行完毕 func (p *Pool) Wait()&#123; p.wg.Wait() &#125; func main()&#123; // 这里限制5个并发 pool := NewPool(5) fmt.Println(&quot;the NumGoroutine begin is:&quot;,runtime.NumGoroutine()) for i:=0;i&lt;20;i++&#123; pool.Add(1) go func(i int) &#123; time.Sleep(time.Second) fmt.Println(&quot;the NumGoroutine continue is:&quot;,runtime.NumGoroutine()) pool.Done() &#125;(i) &#125; pool.Wait() fmt.Println(&quot;the NumGoroutine done is:&quot;,runtime.NumGoroutine()) &#125; 运行: the NumGoroutine begin is: 1 the NumGoroutine continue is: 6 the NumGoroutine continue is: 7 the NumGoroutine continue is: 6 the NumGoroutine continue is: 6 the NumGoroutine continue is: 6 the NumGoroutine continue is: 6 the NumGoroutine continue is: 6 the NumGoroutine continue is: 6 the NumGoroutine continue is: 6 the NumGoroutine continue is: 6 the NumGoroutine continue is: 6 the NumGoroutine continue is: 6 the NumGoroutine continue is: 6 the NumGoroutine continue is: 6 the NumGoroutine continue is: 6 the NumGoroutine continue is: 6 the NumGoroutine continue is: 6 the NumGoroutine continue is: 6 the NumGoroutine continue is: 3 the NumGoroutine continue is: 2 the NumGoroutine done is: 1 其中，Go的GOMAXPROCS默认值已经设置为CPU的核数， 这里允许我们的Go程序充分使用机器的每一个CPU,最大程度的提高我们程序的并发性能。runtime.NumGoroutine函数在被调用后，会返回系统中的处于特定状态的Goroutine的数量。这里的特指是指Grunnable\\Gruning\\Gsyscall\\Gwaition。处于这些状态的Groutine即被看做是活跃的或者说正在被调度。 这里需要注意下：垃圾回收所在Groutine的状态也处于这个范围内的话，也会被纳入该计数器。 Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？Golang中Goroutine 可以通过 Channel 进行安全读写共享变量。 Golang 中常用的并发模型？Golang 中常用的并发模型有三种: 通过channel通知实现并发控制 无缓冲的通道指的是通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送 goroutine 和接收 goroutine 同时准备好，才可以完成发送和接收操作。 从上面无缓冲的通道定义来看，发送 goroutine 和接收 gouroutine 必须是同步的，同时准备后，如果没有同时准备好的话，先执行的操作就会阻塞等待，直到另一个相对应的操作准备好为止。这种无缓冲的通道我们也称之为同步通道。 func main() &#123; ch := make(chan struct&#123;&#125;) go func() &#123; fmt.Println(&quot;start working&quot;) time.Sleep(time.Second * 1) ch &lt;- struct&#123;&#125;&#123;&#125; &#125;() &lt;-ch fmt.Println(&quot;finished&quot;) &#125; 当主 goroutine 运行到 &lt;-ch 接受 channel 的值的时候，如果该 channel 中没有数据，就会一直阻塞等待，直到有值。 这样就可以简单实现并发控制 通过sync包中的WaitGroup实现并发控制 Goroutine是异步执行的，有的时候为了防止在结束mian函数的时候结束掉Goroutine，所以需要同步等待，这个时候就需要用 WaitGroup了，在 sync 包中，提供了 WaitGroup ，它会等待它收集的所有 goroutine 任务全部完成。在WaitGroup里主要有三个方法: Add, 可以添加或减少 goroutine的数量. Done, 相当于Add(-1). Wait, 执行后会堵塞主线程，直到WaitGroup 里的值减至0. 在主 goroutine 中 Add(delta int) 索要等待goroutine 的数量。在每一个 goroutine 完成后 Done() 表示这一个goroutine 已经完成，当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回返回。 func main()&#123; var wg sync.WaitGroup var urls = []string&#123; &quot;http://www.golang.org/&quot;, &quot;http://www.google.com/&quot;, &#125; for _, url := range urls &#123; wg.Add(1) go func(url string) &#123; defer wg.Done() http.Get(url) &#125;(url) &#125; wg.Wait() &#125; 在Golang官网中对于WaitGroup介绍是A WaitGroup must not be copied after first use,在 WaitGroup 第一次使用后，不能被拷贝 应用示例: func main()&#123; wg := sync.WaitGroup&#123;&#125; for i := 0; i &lt; 5; i++ &#123; wg.Add(1) go func(wg sync.WaitGroup, i int) &#123; fmt.Printf(&quot;i:%d&quot;, i) wg.Done() &#125;(wg, i) &#125; wg.Wait() fmt.Println(&quot;exit&quot;) &#125; 运行: i:1i:3i:2i:0i:4fatal error: all goroutines are asleep - deadlock! goroutine 1 [semacquire]: sync.runtime_Semacquire(0xc000094018) /home/keke/soft/go/src/runtime/sema.go:56 +0x39 sync.(*WaitGroup).Wait(0xc000094010) /home/keke/soft/go/src/sync/waitgroup.go:130 +0x64 main.main() /home/keke/go/Test/wait.go:17 +0xab exit status 2 它提示所有的 goroutine 都已经睡眠了，出现了死锁。这是因为 wg 给拷贝传递到了 goroutine 中，导致只有 Add 操作，其实 Done操作是在 wg 的副本执行的。 因此 Wait 就死锁了。 这个第一个修改方式:将匿名函数中 wg 的传入类型改为 *sync.WaitGrou,这样就能引用到正确的WaitGroup了。这个第二个修改方式:将匿名函数中的 wg 的传入参数去掉，因为Go支持闭包类型，在匿名函数中可以直接使用外面的 wg 变量 在Go 1.7 以后引进的强大的Context上下文，实现并发控制 通常,在一些简单场景下使用 channel 和 WaitGroup 已经足够了，但是当面临一些复杂多变的网络并发场景下 channel 和 WaitGroup 显得有些力不从心了。比如一个网络请求 Request，每个 Request 都需要开启一个 goroutine 做一些事情，这些 goroutine 又可能会开启其他的 goroutine，比如数据库和RPC服务。所以我们需要一种可以跟踪 goroutine 的方案，才可以达到控制他们的目的，这就是Golang为我们提供的 Context，称之为上下文非常贴切，它就是goroutine 的上下文。它是包括一个程序的运行环境、现场和快照等。每个程序要运行时，都需要知道当前程序的运行状态，通常Go 将这些封装在一个 Context 里，再将它传给要执行的 goroutine 。 context 包主要是用来处理多个 goroutine 之间共享数据，及多个 goroutine 的管理。 context 包的核心是 struct Context，接口声明如下： // A Context carries a deadline, cancelation signal, and request-scoped values // across API boundaries. Its methods are safe for simultaneous use by multiple // goroutines. type Context interface &#123; // Done returns a channel that is closed when this `Context` is canceled // or times out. Done() &lt;-chan struct&#123;&#125; // Err indicates why this Context was canceled, after the Done channel // is closed. Err() error // Deadline returns the time when this Context will be canceled, if any. Deadline() (deadline time.Time, ok bool) // Value returns the value associated with key or nil if none. Value(key interface&#123;&#125;) interface&#123;&#125; &#125; Done() 返回一个只能接受数据的channel类型，当该context关闭或者超时时间到了的时候，该channel就会有一个取消信号 Err() 在Done() 之后，返回context 取消的原因。 Deadline() 设置该context cancel的时间点 Value() 方法允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。 Context 对象是线程安全的，你可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。 一个 Context 不能拥有 Cancel 方法，同时我们也只能 Done channel 接收数据。其中的原因是一致的：接收取消信号的函数和发送信号的函数通常不是一个。典型的场景是：父操作为子操作操作启动 goroutine，子操作也就不能取消父操作。 Goroutine和Channel的作用分别是什么?进程是内存资源管理和cpu调度的执行单元。为了有效利用多核处理器的优势，将进程进一步细分，允许一个进程里存在多个线程，这多个线程还是共享同一片内存空间，但cpu调度的最小单元变成了线程。 那协程又是什么呢，以及与线程的差异性?? 协程，可以看作是轻量级的线程。但与线程不同的是，线程的切换是由操作系统控制的，而协程的切换则是由用户控制的。 最早支持协程的程序语言应该是lisp方言scheme里的continuation（续延），续延允许scheme保存任意函数调用的现场，保存起来并重新执行。Lua,C#,python等语言也有自己的协程实现。 Go中的goroutinue就是协程,可以实现并行，多个协程可以在多个处理器同时跑。而协程同一时刻只能在一个处理器上跑（可以把宿主语言想象成单线程的就好了）。然而,多个goroutine之间的通信是通过channel，而协程的通信是通过yield和resume()操作。 goroutine非常简单，只需要在函数的调用前面加关键字go即可，例如: go elegance() 我们也可以启动5个goroutines分别打印索引。 func main() &#123; for i:=1;i&lt;5;i++ &#123; go func(i int) &#123; fmt.Println(i) &#125;(i) &#125; // 停歇5s，保证打印全部结束 time.Sleep(5*time.Second) &#125; 在分析goroutine执行的随机性和并发性，启动了5个goroutine，再加上main函数的主goroutine，总共有6个goroutines。由于goroutine类似于”守护线程“，异步执行的,如果主goroutine不等待片刻，可能程序就没有输出打印了。 在Golang中channel则是goroutinues之间进行通信的渠道。 可以把channel形象比喻为工厂里的传送带,一头的生产者goroutine往传输带放东西,另一头的消费者goroutinue则从输送带取东西。channel实际上是一个有类型的消息队列,遵循先进先出的特点。 channel的操作符号 ch &lt;- data 表示data被发送给channel ch； data &lt;- ch 表示从channel ch取一个值，然后赋给data。 阻塞式channel channel默认是没有缓冲区的，也就是说，通信是阻塞的。send操作必须等到有消费者accept才算完成。 应用示例: func main() &#123; ch1 := make(chan int) go pump(ch1) // pump hangs fmt.Println(&lt;-ch1) // prints only 1 &#125; func pump(ch chan int) &#123; for i:= 1; ; i++ &#123; ch &lt;- i &#125; &#125; 在函数pump()里的channel在接受到第一个元素后就被阻塞了，直到主goroutinue取走了数据。最终channel阻塞在接受第二个元素，程序只打印 1。 没有缓冲(buffer)的channel只能容纳一个元素，而带有缓冲(buffer)channel则可以非阻塞容纳N个元素。发送数据到缓冲(buffer) channel不会被阻塞，除非channel已满；同样的，从缓冲(buffer) channel取数据也不会被阻塞，除非channel空了。 怎么查看Goroutine的数量?在Golang中,GOMAXPROCS中控制的是未被阻塞的所有Goroutine,可以被Multiplex到多少个线程上运行,通过GOMAXPROCS可以查看Goroutine的数量。 如何测试代码是否有goroutine泄漏的?使用runtime.Stack在测试代码运行前后计算goroutine数量，当然我理解测试代码运行完成之后是会触发gc的。如果触发gc之后，发现还有goroutine没有被回收，那么这个goroutine很有可能是被泄漏的。 堆栈将调用goroutine的堆栈跟踪格式化为buf 并返回写入buf的字节数。如果全部为真，则在当前goroutine的跟踪之后，Stack格式化所有其他goroutine的跟踪到buf中。 func Stack(buf []byte, all bool) int &#123; if all &#123; stopTheWorld(&quot;stack trace&quot;) &#125; n := 0 if len(buf) &gt; 0 &#123; gp := getg() sp := getcallersp() pc := getcallerpc() systemstack(func() &#123; g0 := getg() // Force traceback=1 to override GOTRACEBACK setting, // so that Stack&#39;s results are consistent. // GOTRACEBACK is only about crash dumps. g0.m.traceback = 1 g0.writebuf = buf[0:0:len(buf)] goroutineheader(gp) traceback(pc, sp, 0, gp) if all &#123; tracebackothers(gp) &#125; g0.m.traceback = 0 n = len(g0.writebuf) g0.writebuf = nil &#125;) &#125; if all &#123; startTheWorld() &#125; return n &#125; 如何使map能够安全的并发？map并发读写是不安全的。map属于引用类型，并发读写时多个协程见是通过指针访问同一个地址，即访问共享变量，此时同时读写资源存在竞争关系。利用读写锁可实现对map的安全访问。 实现阻塞读且并发安全的mapGO里面MAP如何实现key不存在 get操作等待 直到key存在或者超时，保证并发安全，且需要实现以下接口： type sp interface &#123; Out(key string, val interface&#123;&#125;) //存入key /val，如果该key读取的goroutine挂起，则唤醒。此方法不会阻塞，时刻都可以立即执行并返回 Rd(key string, timeout time.Duration) interface&#123;&#125; //读取一个key，如果key不存在阻塞，等待key存在或者超时 &#125; 解析： 看到阻塞协程第一个想到的就是channel，题目中要求并发安全，那么必须用锁，还要实现多个goroutine读的时候如果值不存在则阻塞，直到写入值，那么每个键值需要有一个阻塞goroutine 的 channel。 实现如下： type Map struct &#123; c map[string]*entry rmx *sync.RWMutex &#125; type entry struct &#123; ch chan struct&#123;&#125; value interface&#123;&#125; isExist bool &#125; func (m *Map) Out(key string, val interface&#123;&#125;) &#123; m.rmx.Lock() defer m.rmx.Unlock() if e, ok := m.c[key]; ok &#123; e.value = val e.isExist = true close(e.ch) &#125; else &#123; e = &amp;entry&#123;ch: make(chan struct&#123;&#125;), isExist: true,value:val&#125; m.c[key] = e close(e.ch) &#125; &#125; func (m *Map) Rd(key string, timeout time.Duration) interface&#123;&#125; &#123; m.rmx.Lock() if e, ok := m.c[key]; ok &amp;&amp; e.isExist &#123; m.rmx.Unlock() return e.value &#125; else if !ok &#123; e = &amp;entry&#123;ch: make(chan struct&#123;&#125;), isExist: false&#125; m.c[key] = e m.rmx.Unlock() fmt.Println(&quot;协程阻塞 -&gt; &quot;, key) select &#123; case &lt;-e.ch: return e.value case &lt;-time.After(timeout): fmt.Println(&quot;协程超时 -&gt; &quot;, key) return nil &#125; &#125; else &#123; m.rmx.Unlock() fmt.Println(&quot;协程阻塞 -&gt; &quot;, key) select &#123; case &lt;-e.ch: return e.value case &lt;-time.After(timeout): fmt.Println(&quot;协程超时 -&gt; &quot;, key) return nil &#125; &#125; &#125; 主协程如何等其余协程完再操作? 使用管道实现同步，协程结束后发送信号给主协程。 最理想的方案是使用sync.WaitGroup,WaitGroup内部实现了一个计数器，用来记录未完成的操作个数，它提供了三个方法，Add()用来添加计数。Done()用来在操作结束时调用，使计数减一。Wait()用来等待所有的操作结束，即计数变为0，该函数会在计数不为0时等待，在计数为0时立即返回。 Go并发：利用sync.WaitGroup实现协程同步 简述go语言的CSP并发模型Actor模型是多线程通过共享内存来通信，它是”通过内存共享来进行通讯”，CSP不同于Actor模型，它讲究的是“以通信的方式来共享内存”。GSP用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。Golang中使用 CSP中 channel 这个概念。channel 是被单独创建并且可以在进程之间传递，它的通信模式类似于 boss-worker 模式的，一个实体通过将消息发送到channel 中，然后又监听这个 channel 的实体处理，两个实体之间是匿名的，这个就实现实体中间的解耦，其中 channel 是同步的一个消息被发送到 channel 中，最终是一定要被另外的实体消费掉的，在实现原理上其实是一个阻塞的消息队列。Golang的CSP并发模型，是通过Goroutine和Channel来实现的。Goroutine 是Golang中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。 Channel是Golang中各个并发结构体(Goroutine)之前的通信机制。通常Channel，是各个Goroutine之间通信的”管道“，有点类似于Linux中的管道。通信机制channel也很方便，传数据用channel &lt;- data，取数据用&lt;-channel。在通信过程中，传数据channel &lt;- data和取数据&lt;-channel必然会成对出现，因为这边传，那边取，两个goroutine之间才会实现通信。而且不管传还是取，必阻塞，直到另外的goroutine传或者取为止。 context包的用途是什么?context包的主要用途是用于控制并发，可以有效的避免goroutine泄露。在实际的业务种，我们可能会有这么一种场景：需要我们主动的通知某一个goroutine结束。比如我们开启一个后台goroutine一直做事情，比如监控，现在不需要了，就需要通知这个监控goroutine结束，不然它会一直跑，就泄漏了。所以我们需要一种可以跟踪goroutine的方案，才可以达到控制他们的目的，这就是Golang为我们提供的Context，称之为上下文非常贴切，它就是goroutine的上下文。 Context 使用原则 不要把 Context 放在结构体中，要以参数的方式传递 以 Context 作为参数的函数方法，应该把 Context 作为第一个参数，放在第一位。 给一个函数方法传递 Context 的时候，不要传递 nil，如果不知道传递什么，就使用 context.TODO Context 的 Value 相关方法应该传递必须的数据，不要什么数据都使用这个传递 Context 是线程安全的，可以放心的在多个 goroutine 中传递 互斥锁，读写锁，死锁问题是怎么解决。 互斥锁 互斥锁就是互斥变量mutex，用来锁住临界区的. 条件锁就是条件变量，当进程的某些资源要求不满足时就进入休眠，也就是锁住了。当资源被分配到了，条件锁打开，进程继续运行；读写锁，也类似，用于缓冲区等临界资源能互斥访问的。 读写锁 通常有些公共数据修改的机会很少，但其读的机会很多。并且在读的过程中会伴随着查找，给这种代码加锁会降低我们的程序效率。读写锁可以解决这个问题。注意：写独占，读共享，写锁优先级高 死锁 一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）。另外一种情况是：若线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。 死锁产生的四个必要条件: 互斥条件：一个资源每次只能被一个进程使用 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 预防死锁可以把资源一次性分配：（破坏请求和保持条件） 然后剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件） 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件） 避免死锁预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。 检测死锁首先为每个进程和每个资源指定一个唯一的号码,然后建立资源分配表和进程等待表. 解除死锁当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有. 剥夺资源 从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态. 撤消进程 可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止.所谓代价是指优先级、运行代价、进程的重要性和价值等。 说下Go中的锁有哪些?Go中的三种锁包括:互斥锁,读写锁,sync.Map的安全的锁. 互斥锁 Go并发程序对共享资源进行访问控制的主要手段，由标准库代码包中sync中的Mutex结构体表示。 //Mutex 是互斥锁， 零值是解锁的互斥锁， 首次使用后不得复制互斥锁。 type Mutex struct &#123; state int32 sema uint32 &#125; sync.Mutex包中的类型只有两个公开的指针方法Lock和Unlock。 //Locker表示可以锁定和解锁的对象。 type Locker interface &#123; Lock() Unlock() &#125; //锁定当前的互斥量 //如果锁已被使用，则调用goroutine //阻塞直到互斥锁可用。 func (m *Mutex) Lock() //对当前互斥量进行解锁 //如果在进入解锁时未锁定m，则为运行时错误。 //锁定的互斥锁与特定的goroutine无关。 //允许一个goroutine锁定Mutex然后安排另一个goroutine来解锁它。 func (m *Mutex) Unlock() 声明一个互斥锁： var mutex sync.Mutex 不像C或Java的锁类工具，我们可能会犯一个错误：忘记及时解开已被锁住的锁，从而导致流程异常。但Go由于存在defer，所以此类问题出现的概率极低。关于defer解锁的方式如下： var mutex sync.Mutex func Write() &#123; mutex.Lock() defer mutex.Unlock() &#125; 如果对一个已经上锁的对象再次上锁，那么就会导致该锁定操作被阻塞，直到该互斥锁回到被解锁状态. fpackage main import ( &quot;fmt&quot; &quot;sync&quot; &quot;time&quot; ) func main() &#123; var mutex sync.Mutex fmt.Println(&quot;begin lock&quot;) mutex.Lock() fmt.Println(&quot;get locked&quot;) for i := 1; i &lt;= 3; i++ &#123; go func(i int) &#123; fmt.Println(&quot;begin lock &quot;, i) mutex.Lock() fmt.Println(&quot;get locked &quot;, i) &#125;(i) &#125; time.Sleep(time.Second) fmt.Println(&quot;Unlock the lock&quot;) mutex.Unlock() fmt.Println(&quot;get unlocked&quot;) time.Sleep(time.Second) &#125; 我们在for循环之前开始加锁，然后在每一次循环中创建一个协程，并对其加锁，但是由于之前已经加锁了，所以这个for循环中的加锁会陷入阻塞直到main中的锁被解锁， time.Sleep(time.Second) 是为了能让系统有足够的时间运行for循环，输出结果如下： &gt; go run mutex.go begin lock get locked begin lock 3 begin lock 1 begin lock 2 Unlock the lock get unlocked get locked 3 这里可以看到解锁后，三个协程会重新抢夺互斥锁权，最终协程3获胜。 互斥锁锁定操作的逆操作并不会导致协程阻塞，但是有可能导致引发一个无法恢复的运行时的panic，比如对一个未锁定的互斥锁进行解锁时就会发生panic。避免这种情况的最有效方式就是使用defer。 我们知道如果遇到panic，可以使用recover方法进行恢复，但是如果对重复解锁互斥锁引发的panic却是无用的（Go 1.8及以后）。 package main import ( &quot;fmt&quot; &quot;sync&quot; ) func main() &#123; defer func() &#123; fmt.Println(&quot;Try to recover the panic&quot;) if p := recover(); p != nil &#123; fmt.Println(&quot;recover the panic : &quot;, p) &#125; &#125;() var mutex sync.Mutex fmt.Println(&quot;begin lock&quot;) mutex.Lock() fmt.Println(&quot;get locked&quot;) fmt.Println(&quot;unlock lock&quot;) mutex.Unlock() fmt.Println(&quot;lock is unlocked&quot;) fmt.Println(&quot;unlock lock again&quot;) mutex.Unlock() &#125; 运行: &gt; go run mutex.go begin lock get locked unlock lock lock is unlocked unlock lock again fatal error: sync: unlock of unlocked mutex goroutine 1 [running]: runtime.throw(0x4bc1a8, 0x1e) /home/keke/soft/go/src/runtime/panic.go:617 +0x72 fp=0xc000084ea8 sp=0xc000084e78 pc=0x427ba2 sync.throw(0x4bc1a8, 0x1e) /home/keke/soft/go/src/runtime/panic.go:603 +0x35 fp=0xc000084ec8 sp=0xc000084ea8 pc=0x427b25 sync.(*Mutex).Unlock(0xc00001a0c8) /home/keke/soft/go/src/sync/mutex.go:184 +0xc1 fp=0xc000084ef0 sp=0xc000084ec8 pc=0x45f821 main.main() /home/keke/go/Test/mutex.go:25 +0x25f fp=0xc000084f98 sp=0xc000084ef0 pc=0x486c1f runtime.main() /home/keke/soft/go/src/runtime/proc.go:200 +0x20c fp=0xc000084fe0 sp=0xc000084f98 pc=0x4294ec runtime.goexit() /home/keke/soft/go/src/runtime/asm_amd64.s:1337 +0x1 fp=0xc000084fe8 sp=0xc000084fe0 pc=0x450ad1 exit status 2 这里试图对重复解锁引发的panic进行recover，但是我们发现操作失败，虽然互斥锁可以被多个协程共享，但还是建议将对同一个互斥锁的加锁解锁操作放在同一个层次的代码中。 读写锁 读写锁是针对读写操作的互斥锁，可以分别针对读操作与写操作进行锁定和解锁操作 。 读写锁的访问控制规则如下： ① 多个写操作之间是互斥的② 写操作与读操作之间也是互斥的③ 多个读操作之间不是互斥的 在这样的控制规则下，读写锁可以大大降低性能损耗。 在Go的标准库代码包中sync中的RWMutex结构体表示为: // RWMutex是一个读/写互斥锁，可以由任意数量的读操作或单个写操作持有。 // RWMutex的零值是未锁定的互斥锁。 //首次使用后，不得复制RWMutex。 //如果goroutine持有RWMutex进行读取而另一个goroutine可能会调用Lock，那么在释放初始读锁之前，goroutine不应该期望能够获取读锁定。 //特别是，这种禁止递归读锁定。 这是为了确保锁最终变得可用; 阻止的锁定会阻止新读操作获取锁定。 type RWMutex struct &#123; w Mutex //如果有待处理的写操作就持有 writerSem uint32 // 写操作等待读操作完成的信号量 readerSem uint32 //读操作等待写操作完成的信号量 readerCount int32 // 待处理的读操作数量 readerWait int32 // number of departing readers &#125; sync中的RWMutex有以下几种方法： //对读操作的锁定 func (rw *RWMutex) RLock() //对读操作的解锁 func (rw *RWMutex) RUnlock() //对写操作的锁定 func (rw *RWMutex) Lock() //对写操作的解锁 func (rw *RWMutex) Unlock() //返回一个实现了sync.Locker接口类型的值，实际上是回调rw.RLock and rw.RUnlock. func (rw *RWMutex) RLocker() Locker Unlock方法会试图唤醒所有想进行读锁定而被阻塞的协程，而 RUnlock方法只会在已无任何读锁定的情况下，试图唤醒一个因欲进行写锁定而被阻塞的协程。若对一个未被写锁定的读写锁进行写解锁，就会引发一个不可恢复的panic，同理对一个未被读锁定的读写锁进行读写锁也会如此。 由于读写锁控制下的多个读操作之间不是互斥的，因此对于读解锁更容易被忽视。对于同一个读写锁，添加多少个读锁定，就必要有等量的读解锁，这样才能其他协程有机会进行操作。 package main import ( &quot;fmt&quot; &quot;sync&quot; &quot;time&quot; ) func main() &#123; var rwm sync.RWMutex for i := 0; i &lt; 5; i++ &#123; go func(i int) &#123; fmt.Println(&quot;try to lock read &quot;, i) rwm.RLock() fmt.Println(&quot;get locked &quot;, i) time.Sleep(time.Second * 2) fmt.Println(&quot;try to unlock for reading &quot;, i) rwm.RUnlock() fmt.Println(&quot;unlocked for reading &quot;, i) &#125;(i) &#125; time.Sleep(time.Millisecond * 1000) fmt.Println(&quot;try to lock for writing&quot;) rwm.Lock() fmt.Println(&quot;locked for writing&quot;) &#125; 运行: &gt; go run rwmutex.go try to lock read 0 get locked 0 try to lock read 4 get locked 4 try to lock read 3 get locked 3 try to lock read 1 get locked 1 try to lock read 2 get locked 2 try to lock for writing try to unlock for reading 0 unlocked for reading 0 try to unlock for reading 2 unlocked for reading 2 try to unlock for reading 1 unlocked for reading 1 try to unlock for reading 3 unlocked for reading 3 try to unlock for reading 4 unlocked for reading 4 locked for writing 这里可以看到创建了五个协程用于对读写锁的读锁定与读解锁操作。在 rwm.Lock()种会对main中协程进行写锁定，但是for循环中的读解锁尚未完成，因此会造成mian中的协程阻塞。当for循环中的读解锁操作都完成后就会试图唤醒main中阻塞的协程，main中的写锁定才会完成。 sync.Map安全锁 golang中的sync.Map是并发安全的，其实也就是sync包中golang自定义的一个名叫Map的结构体。 应用示例: package main import ( &quot;sync&quot; &quot;fmt&quot; ) func main() &#123; //开箱即用 var sm sync.Map //store 方法,添加元素 sm.Store(1,&quot;a&quot;) //Load 方法，获得value if v,ok:=sm.Load(1);ok&#123; fmt.Println(v) &#125; //LoadOrStore方法，获取或者保存 //参数是一对key：value，如果该key存在且没有被标记删除则返回原先的value（不更新）和true；不存在则store，返回该value 和false if vv,ok:=sm.LoadOrStore(1,&quot;c&quot;);ok&#123; fmt.Println(vv) &#125; if vv,ok:=sm.LoadOrStore(2,&quot;c&quot;);!ok&#123; fmt.Println(vv) &#125; //遍历该map，参数是个函数，该函数参的两个参数是遍历获得的key和value，返回一个bool值，当返回false时，遍历立刻结束。 sm.Range(func(k,v interface&#123;&#125;)bool&#123; fmt.Print(k) fmt.Print(&quot;:&quot;) fmt.Print(v) fmt.Println() return true &#125;) &#125; 运行 : a a c 1:a 2:c sync.Map的数据结构: type Map struct &#123; // 该锁用来保护dirty mu Mutex // 存读的数据，因为是atomic.value类型，只读类型，所以它的读是并发安全的 read atomic.Value // readOnly //包含最新的写入的数据，并且在写的时候，会把read 中未被删除的数据拷贝到该dirty中，因为是普通的map存在并发安全问题，需要用到上面的mu字段。 dirty map[interface&#123;&#125;]*entry // 从read读数据的时候，会将该字段+1，当等于len（dirty）的时候，会将dirty拷贝到read中（从而提升读的性能）。 misses int &#125; read的数据结构是： type readOnly struct &#123; m map[interface&#123;&#125;]*entry // 如果Map.dirty的数据和m 中的数据不一样是为true amended bool &#125; entry的数据结构： type entry struct &#123; //可见value是个指针类型，虽然read和dirty存在冗余情况（amended=false），但是由于是指针类型，存储的空间应该不是问题 p unsafe.Pointer // *interface&#123;&#125; &#125; Delete 方法: func (m *Map) Delete(key interface&#123;&#125;) &#123; read, _ := m.read.Load().(readOnly) e, ok := read.m[key] //如果read中没有，并且dirty中有新元素，那么就去dirty中去找 if !ok &amp;&amp; read.amended &#123; m.mu.Lock() //这是双检查（上面的if判断和锁不是一个原子性操作） read, _ = m.read.Load().(readOnly) e, ok = read.m[key] if !ok &amp;&amp; read.amended &#123; //直接删除 delete(m.dirty, key) &#125; m.mu.Unlock() &#125; if ok &#123; //如果read中存在该key，则将该value 赋值nil（采用标记的方式删除！） e.delete() &#125; &#125; func (e *entry) delete() (hadValue bool) &#123; for &#123; p := atomic.LoadPointer(&amp;e.p) if p == nil || p == expunged &#123; return false &#125; if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) &#123; return true &#125; &#125; &#125; Store 方法: func (m *Map) Store(key, value interface&#123;&#125;) &#123; // 如果m.read存在这个key，并且没有被标记删除，则尝试更新。 read, _ := m.read.Load().(readOnly) if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123; return &#125; // 如果read不存在或者已经被标记删除 m.mu.Lock() read, _ = m.read.Load().(readOnly) if e, ok := read.m[key]; ok &#123; //如果entry被标记expunge，则表明dirty没有key，可添加入dirty，并更新entry if e.unexpungeLocked() &#123; //加入dirty中 m.dirty[key] = e &#125; //更新value值 e.storeLocked(&amp;value) //dirty 存在该key，更新 &#125; else if e, ok := m.dirty[key]; ok &#123; e.storeLocked(&amp;value) //read 和dirty都没有，新添加一条 &#125; else &#123; //dirty中没有新的数据，往dirty中增加第一个新键 if !read.amended &#123; //将read中未删除的数据加入到dirty中 m.dirtyLocked() m.read.Store(readOnly&#123;m: read.m, amended: true&#125;) &#125; m.dirty[key] = newEntry(value) &#125; m.mu.Unlock() &#125; //将read中未删除的数据加入到dirty中 func (m *Map) dirtyLocked() &#123; if m.dirty != nil &#123; return &#125; read, _ := m.read.Load().(readOnly) m.dirty = make(map[interface&#123;&#125;]*entry, len(read.m)) //read如果较大的话，可能影响性能 for k, e := range read.m &#123; //通过此次操作，dirty中的元素都是未被删除的，可见expunge的元素不在dirty中 if !e.tryExpungeLocked() &#123; m.dirty[k] = e &#125; &#125; &#125; //判断entry是否被标记删除，并且将标记为nil的entry更新标记为expunge func (e *entry) tryExpungeLocked() (isExpunged bool) &#123; p := atomic.LoadPointer(&amp;e.p) for p == nil &#123; // 将已经删除标记为nil的数据标记为expunged if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) &#123; return true &#125; p = atomic.LoadPointer(&amp;e.p) &#125; return p == expunged &#125; //对entry 尝试更新 func (e *entry) tryStore(i *interface&#123;&#125;) bool &#123; p := atomic.LoadPointer(&amp;e.p) if p == expunged &#123; return false &#125; for &#123; if atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123; return true &#125; p = atomic.LoadPointer(&amp;e.p) if p == expunged &#123; return false &#125; &#125; &#125; //read里 将标记为expunge的更新为nil func (e *entry) unexpungeLocked() (wasExpunged bool) &#123; return atomic.CompareAndSwapPointer(&amp;e.p, expunged, nil) &#125; //更新entry func (e *entry) storeLocked(i *interface&#123;&#125;) &#123; atomic.StorePointer(&amp;e.p, unsafe.Pointer(i)) &#125; 因此，每次操作先检查read，因为read 并发安全，性能好些；read不满足，则加锁检查dirty，一旦是新的键值，dirty会被read更新。 Load方法: Load方法是一个加载方法，查找key。 func (m *Map) Load(key interface&#123;&#125;) (value interface&#123;&#125;, ok bool) &#123; //因read只读，线程安全，先查看是否满足条件 read, _ := m.read.Load().(readOnly) e, ok := read.m[key] //如果read没有，并且dirty有新数据，那从dirty中查找，由于dirty是普通map，线程不安全，这个时候用到互斥锁了 if !ok &amp;&amp; read.amended &#123; m.mu.Lock() // 双重检查 read, _ = m.read.Load().(readOnly) e, ok = read.m[key] // 如果read中还是不存在，并且dirty中有新数据 if !ok &amp;&amp; read.amended &#123; e, ok = m.dirty[key] // mssLocked（）函数是性能是sync.Map 性能得以保证的重要函数，目的讲有锁的dirty数据，替换到只读线程安全的read里 m.missLocked() &#125; m.mu.Unlock() &#125; if !ok &#123; return nil, false &#125; return e.load() &#125; //dirty 提升至read 关键函数，当misses 经过多次因为load之后，大小等于len（dirty）时候，讲dirty替换到read里，以此达到性能提升。 func (m *Map) missLocked() &#123; m.misses++ if m.misses &lt; len(m.dirty) &#123; return &#125; //原子操作，耗时很小 m.read.Store(readOnly&#123;m: m.dirty&#125;) m.dirty = nil m.misses = 0 &#125; sync.Map是通过冗余的两个数据结构(read、dirty),实现性能的提升。为了提升性能，load、delete、store等操作尽量使用只读的read；为了提高read的key击中概率，采用动态调整，将dirty数据提升为read；对于数据的删除，采用延迟标记删除法，只有在提升dirty的时候才删除。 死锁条件，如何避免？死锁产生的四个必要条件: 互斥条件：一个资源每次只能被一个进程使用 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 预防死锁 可以把资源一次性分配：（破坏请求和保持条件） 然后剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件） 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件） 避免死锁 预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。 常见的GC模式 引用计数（reference counting）每个对象维护一个引用计数器，当引用该对象的对象被销毁或者更新的时候，被引用对象的引用计数器自动减 1，当被应用的对象被创建，或者赋值给其他对象时，引用 +1，引用为 0 的时候回收，思路简单，但是频繁更新引用计数器降低性能，存在循环以引用（php，Python所使用的） 标记清除（mark and sweep）就是 golang 所使用的，从根变量来时遍历所有被引用对象，标记之后进行清除操作，对未标记对象进行回收，缺点：每次垃圾回收的时候都会暂停所有的正常运行的代码，系统的响应能力会大大降低，各种 mark&amp;swamp 变种（三色标记法），缓解性能问题。 分代搜集（generation）jvm 就使用的分代回收的思路。在面向对象编程语言中，绝大多数对象的生命周期都非常短。分代收集的基本思想是，将堆划分为两个或多个称为代（generation）的空间。新创建的对象存放在称为新生代（young generation）中（一般来说，新生代的大小会比 老年代小很多），随着垃圾回收的重复执行，生命周期较长的对象会被提升（promotion）到老年代中（这里用到了一个分类的思路，这个是也是科学思考的一个基本思路）。 Go 触发GC机制 在申请内存的时候，检查当前当前已分配的内存是否大于上次GC后的内存的2倍，若是则触发（主GC线程为当前M） 监控线程发现上次GC的时间已经超过两分钟了，触发；将一个G任务放到全局G队列中去。（主GC线程为执行这个G任务的M） Golang GC 时会发生什么?Golang 1.5后，采取的是“非分代的、非移动的、并发的、三色的”标记清除垃圾回收算法。golang 中的 gc 基本上是标记清除的过程： gc的过程一共分为四个阶段： 栈扫描（开始时STW（Stop the world）） 第一次标记（并发） 第二次标记（STW） 清除（并发） 整个进程空间里申请每个对象占据的内存可以视为一个图，初始状态下每个内存对象都是白色标记。 先STW，做一些准备工作，比如 enable write barrier。然后取消STW，将扫描任务作为多个并发的goroutine立即入队给调度器，进而被CPU处理 第一轮先扫描root对象，包括全局指针和 goroutine 栈上的指针，标记为灰色放入队列 第二轮将第一步队列中的对象引用的对象置为灰色加入队列，一个对象引用的所有对象都置灰并加入队列后，这个对象才能置为黑色并从队列之中取出。循环往复，最后队列为空时，整个图剩下的白色内存空间即不可到达的对象，即没有被引用的对象； 第三轮再次STW，将第二轮过程中新增对象申请的内存进行标记（灰色），这里使用了write barrier（写屏障）去记录 Golang gc 优化的核心就是尽量使得 STW(Stop The World) 的时间越来越短。 怎么设计orm，让你写,你会怎么写?对象关系映射（Object Relational Mapping，简称ORM），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的–“虚拟对象数据库”。 通常来讲,ORM就是将数据库中的表映射成一个对象实体A，对A进行操作，就相对对数据库进行操作，完成这个过程，其实只要你好好想想你是怎么操作数据库的，然后将类似的行为换成对象即可。 要设计一个ORM，我们需要几步操作： 先准备好一个对象A和数据库中某张表对应T（A-&gt;T) 我们知道当你创建一个表时，一般使用create命令如下： CREATE TABLE database_name.table_name( column1 datatype PRIMARY KEY(one or more columns), column2 datatype, column3 datatype, ….. columnN datatype, ); 从这里我们可以看就对应着表名，表字段名，字段类型，是否是主键等，此时我们需要如何根据A中成员变量，而知道T的这些内容？如果你能根据A能够转化成T，那此时你就已经将A映射到了T了. 映射过程完成后，接下来就是要具备表的四种操作：增,删,改,查. SELECT * FROM T WHERE field1 &gt;= ？ OR field2 &gt;= ？; 这个过程其实是构建where语句的过程，我们可以根据一些条件，构建where语句，然后映射到成一个sql语句，根据sql语句我们就可以查询到一组符合条件的数据（cursor），然后就是将cursor数据转化成A. 现在总结下第三步操作的两个过程：condition -&gt;sql语句；cursor reslut-&gt;A 完成这三部，基本上就完成了一个ORM的设计，如果后面需要对性能，细节进行优化，就可以慢慢来。毕竟主功能已具备。 注意：如果想线程安全进行数据库操作可以考虑 db.enableWriteAheadLogging(); 设计orm过程就是: 根据A得到 T; 根据condition构建where,拼接成sql; 根据sql从T中查出cursors； cursor转化成A. 本文转自 https://blog.csdn.net/yang731227/article/details/90637510，如有侵权，请联系删除。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"Go进阶面试题","slug":"Go进阶面试题","permalink":"https://ysluckly.github.io/tags/Go%E8%BF%9B%E9%98%B6%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"【Go项目】用Go生成和识别二维码","slug":"back-end/1645852315391","date":"2022-01-06T07:29:32.000Z","updated":"2022-02-26T05:55:25.517Z","comments":true,"path":"2022/01/06/golang/","link":"","permalink":"https://ysluckly.github.io/2022/01/06/golang/","excerpt":"","text":"我们在做go web开发的时候，应该都遇到生成二维码分享的应用场景，下面我将介绍下使用go如何生成二维码。 安装 go-qrcode我们不得不庆幸go的生态已经越来越丰富，有很多大牛已经帮我们写好了库，我们不必造轮子，直接拿过来用就好。 首先，我们安装我们用到的go-qrcode库。 go get -u github.com/skip2/go-qrcode/… 生成普通二维码使用了这个库，你会发现二维码生成原来是如此的简单，现在我们就来演示一下。 package main import &quot;github.com/skip2/go-qrcode&quot; func main() &#123; qrcode.WriteFile(&quot;https://blog.csdn.net/yang731227&quot;,qrcode.Medium,256,&quot;./qrcode.png&quot;) &#125; 这样我们就可以生成了一个二维码。 我们首先看下func WriteFile(content string, level RecoveryLevel, size int, filename string) error的参数。 content string 简单明了，这个是二维码内容 level RecoveryLevel 这个是二维码容错等级，取值有Low、Medium、High、Highest。 size int 不用说都知道这个是定义二维码大小 filename string 二维码的保存路径 生成有前后背景颜色的二维码刚刚我们生成了一个前黑后白的二维码，这次我们想搞点花样，生成一个花花绿绿的二维码，我们直接上代码 package main import ( &quot;github.com/skip2/go-qrcode&quot; &quot;image/color&quot; ) func main() &#123; //qrcode.WriteFile(&quot;https://blog.csdn.net/yang731227&quot;,qrcode.High,200,&quot;./qrcode.png&quot;) qrcode.WriteColorFile(&quot;https://blog.csdn.net/yang731227&quot;, qrcode.High, 256, color.Black, color.White, &quot;./qrcode.png&quot;) &#125; 我们来看下func WriteColorFile(content string, level RecoveryLevel, size int, background, foreground color.Color, filename string) error的参数，比WriteFile 多了两个参数 background, foreground color.Color 。我们可以从字面意思就知道，background 是背景颜色，foreground是前景颜色。 颜色我们可以使用 color定义 ，它为我们定义了两个默认颜色，Black和White。如果我们想用其他颜色怎么办呢？它为我们提供了color.RGBA() 这个方法，RGBA()有4个参数 分别是RGB的值和透明值。 例如： b:=color.RGBA&#123;100,100,100,255&#125; f:=color.RGBA&#123;200,200,200,255&#125; qrcode.WriteColorFile(&quot;https://blog.csdn.net/yang731227&quot;, qrcode.High, 256, b, f, &quot;./qrcode1.png&quot;) 识别二维码上面我们讲了怎么生成二维，现在我们来实习解析二维码，当然我们还是需要借助别人写的库。 首先我们安装库go get github.com/tuotoo/qrcode 然后我们直接上代码 package main import ( &quot;fmt&quot; &quot;os&quot; &quot;github.com/tuotoo/qrcode&quot; ) func main() &#123; fi, err := os.Open(&quot;./qrcode.png&quot;) if err != nil &#123; fmt.Println(err.Error()) return &#125; defer fi.Close() qrmatrix, err := qrcode.Decode(fi) if err != nil &#123; fmt.Println(err.Error()) return &#125; fmt.Println(qrmatrix.Content) &#125; 本文转自 https://blog.csdn.net/yang731227/article/details/88542480，如有侵权，请联系删除。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"go-qrcode","slug":"go-qrcode","permalink":"https://ysluckly.github.io/tags/go-qrcode/"},{"name":"二维码","slug":"二维码","permalink":"https://ysluckly.github.io/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"}]},{"title":"Go全栈面试题（6）-数据结构与算法面试题","slug":"back-end/1645851844703","date":"2022-01-05T07:29:32.000Z","updated":"2022-02-26T05:54:27.580Z","comments":true,"path":"2022/01/05/golang/","link":"","permalink":"https://ysluckly.github.io/2022/01/05/golang/","excerpt":"","text":"数据结构与算法面试题基本排序，哪些是稳定的. 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法， 冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法. 简述算法的概念以及特征算法是求解一个问题所需要的步骤所形成的解决方法，每一步包括一个或者多个操作。无论是现实生活中还是计算机中，解决同一个问题的方法可能有很多种，在这N多种算法中，肯定存在一个执行效率最快的方法，那么这个方法就是最优算法。 算法具有五个基本特征：输入、输出、有穷性、确定性和可行性。 算法的设计要求是什么？ 正确性 对于合法输入能够得到满足的结果,算法能够处理非法处理，并得到合理结果.算法对于边界数据和压力数据都能得到满足的结果。 可读性 算法要方便阅读，理解和交流，只有自己能看得懂，其它人都看不懂，谈和好算法。 健壮性 通俗的讲,一个好的算法应该具有捕获异常/处理异常的能力。另外，对于测试人员的压力测试、边界值测试等刁难的测试手段，算法应该能够轻松的扛过去。 高性价比 利用最少的时间和资源得到满足要求的结果，可以通过(时间复杂度和空间复杂度来判定)。 快速排序快速排序: func main() &#123; var arr = []int&#123;19,8,16,15,23,34,6,3,1,0,2,9,7&#125; quickAscendingSort(arr, 0, len(arr)-1) fmt.Println(&quot;quickAscendingSort:&quot;,arr) quickDescendingSort(arr, 0, len(arr)-1) fmt.Println(&quot;quickDescendingSort:&quot;,arr) &#125; //升序 func quickAscendingSort(arr []int, start, end int) &#123; if (start &lt; end) &#123; i, j := start, end key := arr[(start + end)/2] for i &lt;= j &#123; for arr[i] &lt; key &#123; i++ &#125; for arr[j] &gt; key &#123; j-- &#125; if i &lt;= j &#123; arr[i], arr[j] = arr[j], arr[i] i++ j-- &#125; &#125; if start &lt; j &#123; quickAscendingSort(arr, start, j) &#125; if end &gt; i &#123; quickAscendingSort(arr, i, end) &#125; &#125; &#125; //降序 func quickDescendingSort(arr []int, start, end int) &#123; if (start &lt; end) &#123; i, j := start, end key := arr[(start + end)/2] for i &lt;= j &#123; for arr[i] &gt; key &#123; i++ &#125; for arr[j] &lt; key &#123; j-- &#125; if i &lt;= j &#123; arr[i], arr[j] = arr[j], arr[i] i++ j-- &#125; &#125; if start &lt; j &#123; quickDescendingSort(arr, start, j) &#125; if end &gt; i &#123; quickDescendingSort(arr, i, end) &#125; &#125; &#125; 冒泡排序// BubbleSort n^2 // 冒泡排序的大错觉： 是j 和 j+1 的对比，而不是i和j的比较 func BubbleSort(nums []int) []int &#123; for i := 0; i &lt; len(nums); i++ &#123; for j := 0; j &lt; len(nums)-1; j++ &#123; if nums[j] &gt; nums[j+1] &#123; nums[j+1], nums[j] = nums[j], nums[j+1] &#125; &#125; &#125; return nums &#125; 选择排序// SelectSort 选择排序 n^2 // SelectSort 是 min 和 j 比， min 和 i 换 // 假设i是最小的那个数，然后向后比较，一旦发现比i小的数字，则用min记录，最终将min和i交换 // j 只是用于记录sorted 和 unsorted 的界限 func SelectSort(nums []int) []int &#123; for i := 0; i &lt; len(nums); i++ &#123; var min int = i for j := i; j &lt; len(nums); j++ &#123; if nums[min] &gt; nums[j] &#123; min = j &#125; &#125; nums[i], nums[min] = nums[min], nums[i] &#125; return nums &#125; 归并排序// Merge Sort n*log(n) // MergeSort = Merge将两个array合并 + MergeSort func MergeSort(nums []int) []int &#123; if len(nums) == 1 &#123; return nums &#125; left := nums[:len(nums)/2] right := nums[len(nums)/2:] return merge(MergeSort(left), MergeSort(right)) &#125; func merge(left, right []int) []int &#123; var result []int var l, r = 0, 0 for &#123; if left[l] &lt; right[r] &#123; result = append(result, left[l]) l++ &#125; else &#123; result = append(result, right[r]) r++ &#125; if l == len(left) &#123; result = append(result, right[r:]...) return result &#125; if r == len(right) &#123; result = append(result, left[l:]...) return result &#125; &#125; &#125; 实现队列main.go package main import ( &quot;errors&quot; &quot;fmt&quot; ) // 队列 // 面试中有可能会问到，如何用golang实现一个队列 // 要实现队列，首先要指导队列是什么？ // 表现特征：FIFO // 含有的方法： Enqueue , Dequeue // 下面实现一个 int 的 queue type Queue interface &#123; // 将 i 添加到 队尾 Enqueue(i int) // 返回队首的i, 如果队空，则返回error Dequeue() (i int, err error) &#125; type queue struct &#123; slice []int &#125; func (q *queue) Enqueue(i int) &#123; q.slice = append(q.slice, i) &#125; func (q *queue) Dequeue() (i int, err error) &#123; if len(q.slice) == 0 &#123; return 0, errors.New(&quot;no int in queue&quot;) &#125; // 获取队首 i = q.slice[0] // 删除队首 q.slice = q.slice[1:] return &#125; func (q *queue) String() string &#123; return fmt.Sprintf(&quot;%#v&quot;, q.slice) &#125; test_main.go package main import ( &quot;fmt&quot; &quot;testing&quot; ) func Test(t *testing.T) &#123; q := new(queue) q.Enqueue(1) q.Enqueue(12) q.Enqueue(123) fmt.Println(q) fmt.Println(q.Dequeue()) fmt.Println(q) fmt.Println(q.Dequeue()) fmt.Println(q) fmt.Println(q.Dequeue()) &#125; 实现栈main.go package main import &quot;errors&quot; type Stack interface &#123; Push(i int) Pop() (i int, err error) &#125; type stack struct &#123; slice []int &#125; func (s *stack) Push(i int) &#123; s.slice = append(s.slice, i) &#125; func (s *stack) Pop() (i int, err error) &#123; if len(s.slice) == 0 &#123; return i, errors.New(&quot;no int in stack&quot;) &#125; i = s.slice[len(s.slice)-1] s.slice = s.slice[:len(s.slice)-1] return &#125; test_main.go package main import ( &quot;fmt&quot; &quot;testing&quot; ) func Test(t *testing.T) &#123; s := new(stack) s.Push(1) s.Push(12) s.Push(123) fmt.Println(s) fmt.Println(s.Pop()) fmt.Println(s) fmt.Println(s.Pop()) fmt.Println(s) fmt.Println(s.Pop()) &#125; 实现链表mian.go package linked_list import ( &quot;fmt&quot; &quot;strings&quot; ) // 最常在面试中出现的数据结构 // 如何实现一个linked list type Node struct &#123; Data interface&#123;&#125; Next *Node &#125; func NewNode(data interface&#123;&#125;, nextNode *Node) *Node &#123; return &amp;Node&#123; Data: data, Next: nextNode, &#125; &#125; // 整理一下实现一个LinkedList，要考虑的各种特殊情况： // 1. 新增即换头 // 2. 头很重要： 对head是否等于nil的判断，对于 删除，新增操作等 // 3. 头尾一体的特殊情况： 在删除尾巴的时候，如果头尾一体，即只有一个节点，也要当作特殊情况处理 // 3. size 方法，如果不是用遍历的方式，则对应所有的新增和删除都要添加对size的操作 // 4. 带有index都要考虑到3种情况，头，尾，中间，并且遍历的时候，要找index-1的位置，这个位置是操作位置 type LinkedList struct &#123; head *Node size int &#125; func NewLinkedList() *LinkedList &#123; return &amp;LinkedList&#123;&#125; &#125; func (l *LinkedList) InsertFirst(data interface&#123;&#125;) &#123; newNode := NewNode(data, nil) if l.head != nil &#123; newNode.Next = l.head &#125; l.head = newNode l.size += 1 &#125; // InsertLast 和size一样，有两种实现方式： // O(n) 的方式是，每次遍历到最后一个节点，然后进行新增 // O(1) 的方法是，保存一个tail的标记，但是则需要在 Insert,Remove 等多个方法中维护这个标记,就会很复杂 func (l *LinkedList) InsertLast(data interface&#123;&#125;) &#123; newNode := NewNode(data, nil) if l.head == nil &#123; l.head = newNode return &#125; node := l.head for node.Next != nil &#123; node = node.Next &#125; node.Next = newNode l.size += 1 &#125; func (l *LinkedList) GetFirst() interface&#123;&#125; &#123; // 记住要判断head是否为nil if l.head == nil &#123; return nil &#125; return l.head.Data &#125; func (l *LinkedList) GetLast() interface&#123;&#125; &#123; node := l.head if node == nil &#123; return nil &#125; for node.Next != nil &#123; node = node.Next &#125; return node.Data &#125; func (l *LinkedList) Head() *Node &#123; return l.head &#125; func (l *LinkedList) Size() int &#123; // 用遍历的一边的方式获取linked的大小 //size := 0 //var node *Node //node = l.head //for node != nil &#123; // size += 1 // node = node.Next //&#125; return l.size &#125; func (l *LinkedList) Clear() &#123; node := l.head if node == nil &#123; return &#125; for node != nil &#123; nextnode := node.Next node.Next = nil node = nextnode &#125; // 将 head 设置为空（重要）,同时要将 size 设置为 0 l.head = nil l.size = 0 &#125; func (l *LinkedList) RemoveFirst() &#123; if l.head == nil &#123; return &#125; oldhead := l.head l.head = oldhead.Next oldhead.Next = nil l.size -= 1 &#125; func (l *LinkedList) RemoveLast() &#123; defer func() &#123; l.size -= 1 &#125;() if l.head == nil &#123; return &#125; // 只有一个节点的情况 if l.head.Next == nil &#123; l.head = nil return &#125; node := l.head // 重要，不能这么写，应为当只有一个node的时候，不存在倒数第二个node // 永远只找倒数第一，不找倒数第二 for node.Next.Next != nil &#123; node = node.Next &#125; node.Next = nil &#125; func (l *LinkedList) GetAt(index int) (data interface&#123;&#125;) &#123; if l.size == 0 || index &gt; l.size-1 || index &lt; 0 &#123; return nil &#125; node := l.head count := 0 for node.Next != nil &#123; if count == index &#123; break &#125; node = node.Next count += 1 &#125; return node.Data &#125; func (l *LinkedList) RemoveAt(index int) &#123; if l.size == 0 || index &gt; l.size-1 || index &lt; 0 &#123; return &#125; // 2种情况 // 1. 有一个节点 // 2. 有多个节点 defer func() &#123; l.size -= 1 &#125;() // 只有一个节点 if index == 0 &amp;&amp; l.size == 1 &#123; l.RemoveFirst() return &#125; // 有多个节点 // 1. 删除头 if index == 0 &#123; l.RemoveFirst() return &#125; // 2. 删除尾 if index == l.size-1 &#123; l.RemoveLast() return &#125; // 3. 删除其他,找到index之前的那个节点 node := l.head count := 0 for node.Next != nil &#123; if count == index-1 &#123; break &#125; node = node.Next count += 1 &#125; removeedNode := node.Next node.Next = node.Next.Next removeedNode.Next = nil return &#125; func (l *LinkedList) String() string &#123; var result []string var node *Node node = l.head for node != nil &#123; result = append(result, fmt.Sprintf(&quot;%#v&quot;, node.Data)) node = node.Next &#125; return strings.Join(result, &quot; -&gt; &quot;) &#125; mian_test.go package linked_list import ( &quot;fmt&quot; &quot;testing&quot; ) // 插入测试 func TestLinkedList_InsertFirst(t *testing.T) &#123; list := NewLinkedList() list.InsertFirst(1) fmt.Println(list, list.Size()) list.InsertFirst(2) fmt.Println(list, list.Size()) list.InsertFirst(3) fmt.Println(list, list.Size()) fmt.Println(list.GetFirst()) fmt.Println(list.GetLast()) list.Clear() fmt.Println(list) &#125; // 插入尾测试 func TestLinkedList_InsertLast(t *testing.T) &#123; list := NewLinkedList() list.InsertLast(1) fmt.Println(list, list.Size()) list.InsertLast(2) fmt.Println(list, list.Size()) list.InsertLast(3) fmt.Println(list, list.Size()) fmt.Println(list.GetFirst()) fmt.Println(list.GetLast()) list.Clear() fmt.Println(list) &#125; // 删除头测试 func TestLinkedList_RemoveFirst(t *testing.T) &#123; list := NewLinkedList() list.InsertFirst(1) fmt.Println(list, list.Size()) list.InsertFirst(2) fmt.Println(list, list.Size()) list.InsertFirst(3) fmt.Println(list, list.Size()) list.RemoveFirst() fmt.Println(list, list.Size()) list.RemoveFirst() fmt.Println(list, list.Size()) list.RemoveFirst() &#125; // 删除尾测试 func TestLinkedList_RemoveLast(t *testing.T) &#123; list := NewLinkedList() fmt.Println(list, list.Size()) list.InsertFirst(1) fmt.Println(list, list.Size()) list.InsertFirst(2) fmt.Println(list, list.Size()) list.InsertFirst(3) fmt.Println(list, list.Size()) list.RemoveLast() fmt.Println(list, list.Size()) list.RemoveLast() fmt.Println(list, list.Size()) list.RemoveLast() fmt.Println(list, list.Size()) &#125; // 获取第X个的测试 func TestLinkedList_GetAt(t *testing.T) &#123; list := NewLinkedList() list.InsertFirst(1) list.InsertFirst(2) list.InsertFirst(3) fmt.Println(list.GetAt(0)) fmt.Println(list.GetAt(1)) fmt.Println(list.GetAt(2)) fmt.Println(list, list.Size()) &#125; // 删除第X个的测试 func TestLinkedList_RemoveAt(t *testing.T) &#123; list := NewLinkedList() list.InsertFirst(1) list.InsertFirst(2) list.InsertFirst(3) fmt.Println(list, list.Size()) list.RemoveAt(1) fmt.Println(list, list.Size()) &#125; 字符串反转mian.go package main // 遍历字符串 // golang 中没有build-in的例如js中的 reverse()的方法对数组进行反转，所以得手写一个反转数组的方法 // 为什么这里使用了 rune ,而不是 byte ? // byte 是 8bit // rune 是 32bit // 在utf-8编码中，对于 中文字符 而言，一个字符占 3个字节, 使用 byte 是放不下的 // 常见的 range 也是对str进行了隐式的 unicode 解码, 而 str[i] 并不一定和我们看到的字符串对应 // 同理，如果只是序列化和反序列化，可以通过byte进行操作，但是如果涉及字符串中的反转，截断等操作，则使用rune func reverse02(str string) string &#123; runes := []rune(str) for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 &#123; runes[i], runes[j] = runes[j], runes[i] &#125; return string(runes) &#125; // 使用byte进行反转字符串的话，仅会对字母和数字有效，一旦加入中文字符串，结果就无法满足预期了 func reverseByByte(str string) string &#123; bs := []byte(str) for i, j := 0, len(str)-1; i &lt; j; i, j = i+1, j-1 &#123; bs[i], bs[j] = bs[j], bs[i] &#125; return string(bs) &#125; mian_test.go package main import &quot;testing&quot; func Test(t *testing.T) &#123; testcases := []struct &#123; str1 string str2 string &#125;&#123; &#123;&quot;cda54321&quot;, &quot;12345adc&quot;&#125;, &#123;&quot;hello 世界&quot;, &quot;界世 olleh&quot;&#125;, &#125; getResult := func(do func(str1 string) string) &#123; for _, testcase := range testcases &#123; if testcase.str2 != do(testcase.str1) &#123; t.Error(&quot;except&quot;, testcase.str2, &quot;get&quot;, do(testcase.str1)) &#125; &#125; &#125; getResult(reverse02) getResult(reverseByByte) &#125; 如何通过递归反转单链表?链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。 使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。链表可以在多种编程语言中实现。像Lisp和Scheme这样的语言的内建数据类型中就包含了链表的存取和操作。 package main import &quot;fmt&quot; // 通过递归反转单链表 type Node struct &#123; Value int NextNode *Node &#125; func Param(node *Node)&#123; for node !=nil&#123; fmt.Print(node.Value,&quot;---&gt;&quot;) node = node.NextNode &#125; fmt.Println() &#125; func reverse(headNode *Node) *Node&#123; if headNode ==nil &#123; return headNode &#125; if headNode.NextNode == nil&#123; return headNode &#125; var newNode = reverse(headNode.NextNode) headNode.NextNode.NextNode = headNode headNode.NextNode = nil return newNode &#125; func main() &#123; var node1 = &amp;Node&#123;&#125; node1.Value = 1 node2 := new(Node) node2.Value = 2 node3 := new(Node) node3.Value = 3 node4 := new(Node) node4.Value = 4 node1.NextNode = node2 node2.NextNode = node3 node3.NextNode = node4 Param(node1) reverseNode := reverse(node1) Param(reverseNode) 运行: 1---&gt;2---&gt;3---&gt;4---&gt; 4---&gt;3---&gt;2---&gt;1---&gt; 输出金字塔main.go package _0_pyramid import &quot;fmt&quot; // 和上一个阶梯类似，输出金字塔型的# // 例如输出3 // &quot; # &quot; // &quot; ### &quot; // &quot;#####&quot; // 首当其冲就是递归 // 用递归，每一层和每一层之间的关系非常清晰 // 比迭代要简单的多 func pyamid(n int) &#123; // 最底层的#数 printPy(n*2-1, 0) &#125; // i = # 数量 // j = 每边的&lt;space&gt;数量 func printPy(i, j int) &#123; if i &lt;= 0 &#123; return &#125; printPy(i-2, j+1) // 每天上一层，#数量减少2，空格数量每边加1 for index := 0; index &lt; j; index++ &#123; fmt.Print(&quot; &quot;) &#125; for index := 0; index &lt; i; index++ &#123; fmt.Print(&quot;#&quot;) &#125; for index := 0; index &lt; j; index++ &#123; fmt.Print(&quot; &quot;) &#125; fmt.Println(&quot;&quot;) &#125; main_test.go package _0_pyramid import &quot;testing&quot; func Test(t *testing.T) &#123; testcases := []struct &#123; num int &#125;&#123; &#123;2&#125;, &#123;3&#125;, &#123;5&#125;, &#125; getResult := func(do func(int)) &#123; for _, testcase := range testcases &#123; do(testcase.num) &#125; &#125; getResult(pyamid) &#125; 两个数组求交集思路：把两个数组合并成一个数组，然后通过 hash 表找出数组中重复的元素 package main import &quot;fmt&quot; func ArrayIntersection(arr []int, arr1 []int) []int &#123; var intersection []int arr = append(arr, arr1...) sameElem := make(map[int]int) for _, v := range arr &#123; if _, ok := sameElem[v]; ok &#123; intersection = append(intersection, v) &#125; else &#123; sameElem[v] = 1 &#125; &#125; return intersection &#125; func main() &#123; arr1 := []int&#123;1, 2, 3, 4, 5, 6&#125; arr2 := []int&#123;5, 6, 7, 8, 9, 0&#125; fmt.Println(ArrayIntersection(arr1, arr2)) &#125; 寻找最长含有不重复字符的字串长度大小package main import &quot;fmt&quot; func lengthOfNonRepeatingSubStr(s string) int &#123; lastOccurred := make(map[rune]int) start := 0 maxLength := 0 for i, ch := range []rune(s) &#123; if lastI, ok := lastOccurred[ch]; ok &amp;&amp; lastI &gt;= start &#123; start = lastOccurred[ch] + 1 &#125; if i-start+1 &gt; maxLength &#123; maxLength = i - start + 1 &#125; lastOccurred[ch] = i &#125; return maxLength &#125; func main() &#123; fmt.Println(lengthOfNonRepeatingSubStr(&quot;hello 世界!&quot;)) &#125; 链表反转 type Node struct &#123; value int next *Node &#125; func reverse(head *Node) *Node &#123; var pre *Node = nil for head != nil &#123; temp := head.next head.next = pre pre = head head = temp &#125; return pre &#125; func printNode(head *Node) &#123; for head != nil &#123; fmt.Println(head.value) head = head.next &#125; &#125; 大整数加法func stringReverse(str string) string &#123; reverse := []rune(str) strLen := len(str) for i, j := 0, strLen-1; i &lt; j; i, j = i+1, j-1 &#123; reverse[i], reverse[j] = reverse[j], reverse[i] &#125; return string(reverse) &#125; func add(str1 string, str2 string) string &#123; if len(str1) &lt; len(str2) &#123; str1 = strings.Repeat(&quot;0&quot;, len(str2)-len(str1)) + str1 &#125; else if len(str1) &gt; len(str2) &#123; str2 = strings.Repeat(&quot;0&quot;, len(str1)-len(str2)) + str2 &#125; str1 = stringReverse(str1) str2 = stringReverse(str2) count := len(str1) nums := make([]byte, count) carry := false for i := 0; i &lt; count; i++ &#123; sum := str1[i] - &#39;0&#39; + str2[i] - &#39;0&#39; if carry &#123; sum++ &#125; if sum &gt; 9 &#123; sum = sum - 10 carry = true &#125; else &#123; carry = false &#125; nums[i] = sum + &#39;0&#39; &#125; result := stringReverse(string(nums)) if carry &#123; result = &quot;1&quot; + result &#125; return result &#125; 查找不重复最长字串package main import &quot;fmt&quot; func lengthOfNonRepeatingSubStr(s string) int &#123; lastOccurred := make(map[rune]int) start := 0 maxLength := 0 for i, ch := range []rune(s) &#123; if lastI, ok := lastOccurred[ch]; ok &amp;&amp; lastI &gt;= start &#123; start = lastOccurred[ch] + 1 &#125; if i-start+1 &gt; maxLength &#123; maxLength = i - start + 1 &#125; lastOccurred[ch] = i &#125; return maxLength &#125; func main() &#123; fmt.Println(lengthOfNonRepeatingSubStr(&quot;abcabcbb&quot;)) fmt.Println(lengthOfNonRepeatingSubStr(&quot;bbbbb&quot;)) fmt.Println(lengthOfNonRepeatingSubStr(&quot;黑化肥发黑会挥发&quot;)) &#125; 本文转自 https://blog.csdn.net/yang731227/article/details/90637604，如有侵权，请联系删除。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://ysluckly.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Go面试题","slug":"Go面试题","permalink":"https://ysluckly.github.io/tags/Go%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Go全栈面试题（1）-Go基础语法面试题","slug":"back-end/1645851767812","date":"2022-01-04T07:29:32.000Z","updated":"2022-02-26T05:53:52.040Z","comments":true,"path":"2022/01/04/golang/","link":"","permalink":"https://ysluckly.github.io/2022/01/04/golang/","excerpt":"","text":"Golang基础面试使用Go编程有什么好处？以下是使用Go编程的好处 ： 支持环境采用类似于动态语言的模式。例如，类型推断（x：= 0是int类型的变量x的有效声明）。 编译时间很快。 InBuilt并发支持：轻量级进程（通过goroutines），通道，select语句。 简洁，简洁，安全。 支持接口和类型嵌入。 生成静态链接的本机二进制文件，没有外部依赖项。 一个包是否可以在一个源文件里面多次引用？一个Go源文件可以多次引入同一个包。但是每次的引入名称必须不同。这些相同的包引入引用着同一个包实例。 简述内置的print和println函数与fmt和log标准库包中相应的打印函数有什么区别？ 内置的print/println函数总是写入标准错误。 fmt标准包里的打印函数总是写入标准输出。 log标准包里的打印函数会默认写入标准错误，然而也可以通过log.SetOutput函数来配置。 内置print/println函数的调用不能接受数组和结构体参数。 对于组合类型的参数，内置的print/println函数将输出参数的底层值部的地址，而fmt和log标准库包中的打印函数将输出参数的字面值。 目前（Go 1.12），对于标准编译器，调用内置的print/println函数不会使调用参数引用的值逃逸到堆上，而fmt和log标准库包中的的打印函数将使调用参数引用的值逃逸到堆上。 如果一个实参有String() string或Error() string方法，那么fmt和log标准库包里的打印函数在打印参数时会调用这两个方法，而内置的print/println函数则会忽略参数的这些方法。 内置的print/println函数不保证在未来的Go版本中继续存在。 什么是byte？什么是rune？ 如何将[]byte和[]rune类型的值转换为字符串？在Golang里，byte是uint8类型的一个别名。 换言之，byte 和 uint8是相同的类型。 rune和int32属于同样类似的关系。一个rune通常被用来存储一个Unicode码点。[]byte和[]rune类型的值可以被显式地直接转换成字符串，反之亦然。 Golang中数组和切片之间的区别？Slices是Golang中数组的包装器。 总是优先使用切片而不是数组。 极少数情况下数组会有益。一种情况是数组的大小是固定的（比如存储IPv4地址）还有一种是当我们不希望函数修改原始副本时，我们可能会使用数组。但是即使在这种情况下，也应该有一种传递切片的方法。 在以下两个切片声明中有什么区别（如果有的话），哪一个更可取？var a []int 和 a := []int&#123;&#125; 如果未使用切片，则第一个声明不会分配内存，因此首选此声明方法。 什么可以/不可以作为方法的接收者?结构体，指向结构体的指针，甚至内置类型的别名，如’type myIntType int’。都可以充当接收者。甚至函数也可以是接收器。 我们不能使用以下东西作为接收类型: 方法，如果我们在对象类型上定义方法，它就不能像普通函数一样用作接收方类型。 接口，在Go中，接口为类型定义了一组可能的操作。它们没有定义实际的实现。因此它们不能用作方法的接收者，因为方法是关于实现的。 值接收者和指针接收者的区别?方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是值接收者，也可以是指针接收者。 在调用方法的时候，值类型既可以调用值接收者的方法，也可以调用指针接收者的方法；指针类型既可以调用指针接收者的方法，也可以调用值接收者的方法。 也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。 package main import &quot;fmt&quot; type Person struct &#123; age int &#125; func (p Person) Elegance() int &#123; return p.age &#125; func (p *Person) GetAge() &#123; p.age += 1 &#125; func main() &#123; // p1 是值类型 p := Person&#123;age: 18&#125; // 值类型 调用接收者也是值类型的方法 fmt.Println(p.howOld()) // 值类型 调用接收者是指针类型的方法 p.GetAge() fmt.Println(p.GetAge()) // ---------------------- // p2 是指针类型 p2 := &amp;Person&#123;age: 100&#125; // 指针类型 调用接收者是值类型的方法 fmt.Println(p2.GetAge()) // 指针类型 调用接收者也是指针类型的方法 p2.GetAge() fmt.Println(p2.GetAge()) &#125; 运行 18 19 100 101 函数和方法 值接收者 指针接收者 值类型调用者 方法会使用调用者的一个副本，类似于“传值” 使用值的引用来调用方法，上例中，p1.GetAge() 实际上是 (&amp;p1).GetAge() 指针类型调用者 指针被解引用为值，上例中，p2.GetAge()实际上是 (*p1).GetAge() 实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针 如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。 如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。 通常我们使用指针作为方法的接收者的理由： 使用指针方法能够修改接收者指向的值。 可以避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。 因而呢,我们是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的本质。 如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 header， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 header，而 header 本身就是为复制设计的。 如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份实体。 接口值的零值是指动态类型和动态值都为 nil。当仅且当这两部分的值都为 nil 的情况下，这个接口值就才会被认为 接口值 == nil。 哪些类型不支持比较？ 映射（map） 切片 函数 包含不可比较字段的结构体类型 元素类型为不可比较类型的数组类型 不支持比较的类型不能用做映射类型的键值类型。 请注意：尽管映射，切片和函数值不支持比较，但是它们的值可以与类型不确定的nil标识符比较。如果两个接口值的动态类型相同且不可比较，那么在运行时比较这两个接口的值会产生一个恐慌。 go语言中哪些类型的值可以被取地址，哪些不可以被取地址？以下的值是不可以寻址的： 字符串的字节元素 映射元素 接口值的动态值（类型断言的结果） 常量值 字面值 声明的包级别函数 方法（用做函数值） 中间结果值 函数调用 显式值转换 各种操作，不包含指针解引用（dereference）操作，但是包含： 数据通道接收操作 子字符串操作 子切片操作 加法、减法、乘法、以及除法等等。 请注意：&amp;T{}在Go里是一个语法糖，它是tmp := T{}; (&amp;tmp)的简写形式。 所以&amp;T{}是合法的,并不代表字面值T{}是可寻址的。 以下的值是可寻址的，因此可以被取地址： 变量 可寻址的结构体的字段 可寻址的数组的元素 任意切片的元素（无论是可寻址切片或不可寻址切片） 指针解引用（dereference）操作 为什么映射元素不可被取地址？如果映射元素可以被取地址，则每个映射元素的地址在它的生命期内必须保持不变。 这阻碍了Go编译器在实现映射时使用更加有效率的算法。 对于标准编译器，映射元素的内部地址在运行时刻有可能发生改变。 为什么非空切片的元素总是可被取地址，即便对于不可寻址的切片也是如此？切片的内部类型是一个结构体，类似于 struct &#123; elements unsafe.Pointer // 引用着一个元素序列 length int capacity int &#125; 每一个切片间接引用一个元素序列。 尽管一个非空切片是不可取地址的，它的内部元素序列需要开辟在内存中的某处，因而必须是可取地址的。 取一个切片的元素地址事实上是取内部元素序列上的元素地址。 这就是为什么不可寻址的非空切片的元素是也可以被取地址的。 哪些类型是值类型，那些是引用类型? 值类型：基本数据类型，int,float,bool,string,以及数组和struct 引用类型：指针，slice，map，chan等都是引用类型 go struct能不能比较？ 相同struct类型的可以比较 不同struct类型的不可以比较,编译都不过，类型不匹配 为什么使用空 struct{}?如果要保存一些内存，可以使用空结构。空结构不会为其值获取任何内存。 a := struct&#123;&#125;&#123;&#125; println(unsafe.Sizeof(a)) // Output: 0 如果使用的是map，而且map又很长，通常会节省不少资源 空struct{}也在向别人表明，这里并不需要一个值。 以下是一些有用的示例： 在map里节省资源的用途： set := make(map[string]struct&#123;&#125;) for _, value := range []string&#123;&quot;apple&quot;, &quot;orange&quot;, &quot;apple&quot;&#125; &#123; set[value] = struct&#123;&#125;&#123;&#125; &#125; fmt.Println(set) // Output: map[orange:&#123;&#125; apple:&#123;&#125;] 使用seen哈希，就像遍历MAP时一样： seen := make(map[string]struct&#123;&#125;) for _, ok := seen[v]; ok &#123; // First time visiting a vertex. seen[v] = struct&#123;&#125;&#123;&#125; &#125; 构建对象时，只对一组方法感兴趣而没有中间数据，或者当您不打算保留对象状态时。在下面的示例中，无论方法是在相同的情况下调用（情况＃1）还是在两个不同的对象上调用（情况＃2），它都没有区别： type Lamp struct&#123;&#125; func (l Lamp) On() &#123; println(&quot;On&quot;) &#125; func (l Lamp) Off() &#123; println(&quot;Off&quot;) &#125; func main() &#123; // Case #1. var lamp Lamp lamp.On() lamp.Off() // Output: // on // off // Case #2. Lamp&#123;&#125;.On() Lamp&#123;&#125;.Off() // Output: // on // off &#125; 当您需要一个通道来发出事件信号时，却不需要发送任何数据。这个事件也不是最后一个，在这种情况下，您将使用close(ch)内置函数。 func worker(ch chan struct&#123;&#125;) &#123; // Receive a message from the main program. &lt;-ch println(&quot;roger&quot;) // Send a message to the main program. close(ch) &#125; func main() &#123; ch := make(chan struct&#123;&#125;) go worker(ch) // Send a message to a worker. ch &lt;- struct&#123;&#125;&#123;&#125; // Receive a message from the worker. &lt;-ch println(“roger&quot;) // Output: // roger // roger &#125; slice的len，cap，扩容，共享。一个切片是一个数组片段的描述。它包含了指向数组的指针，片段的长度， 和容量（片段的最大长度）。 len切片的长度是它所包含的元素个数。 cap切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。 append新建对象，s2指向了新对象，函数退出新对象释放。 在函数内用append时，append会自动以倍增的方式扩展slice_2的容量，但是扩展也仅仅是函数内slice_2的长度和容量，slice_1的长度和容量是没变的，所以在函数外打印时看起来就是没变。原来的s1还是s1，append没有影响，但是s2修改的操作有影响，因为s2直接操作了s1的内存。slice被设计为指向数组的指针，在需要扩容时，会将底层数组上的值复制到一个更大的数组上然后指向这个新数组。slice有个特性是允许多个slice指向同一个底层数组，这是一个有用的特性，在很多场景下都能通过这个特性实现 no copy 而提高效率。但共享同时意味着不安全。 func main() &#123; a := make([]int, 2, 2) a[0], a[1] = 1, 2 b := append(a[0:1], 3) c := append(a[1:2], 4) fmt.Println(b,c) &#125; 比如说这段代码我们期望的值是[1 3] [2 4]，但是却变成了[1 3] [3 4]。那么怎么解决数据共享的问题？ make出一个新slice，然后先copy前缀到新数组上再追加。 利用go中slice的一个小众语法，a[0:1:1] (源[起始index，终止index，cap终止index])，强迫追加时复制到新数组。 map如何顺序读取?可以通过sort中的排序包进行对map中的key进行排序 package main import ( &quot;fmt&quot; &quot;sort&quot; ) func main() &#123; var m = map[string]int&#123; &quot;hello&quot;: 0, &quot;morning&quot;: 1, &quot;my&quot;: 2, &quot;girl&quot;: 3, &#125; var keys []string for k := range m &#123; keys = append(keys, k) &#125; sort.Strings(keys) for _, k := range keys &#123; fmt.Println(&quot;Key:&quot;, k, &quot;Value:&quot;, m[k]) &#125; &#125; 使用range修改结构体切片的元素的值会发生什么情况？怎么避免这种情况？因为for遍历时，使用的是副本，每次遍历仅进行struct值拷贝，而不是指向值的指针。 我们可以通过指针更改元素,通过指针更改元素，如果不设置中间变量的话，又会照成所有的map的值都是一样的。 Go中的零指针是什么？如果您没有要分配的确切地址，Go编译器会将Nil值分配给指针变量。这是在变量声明时完成的。指定为nil的指针称为nil指针。nil指针是一个常量，在几个标准库中定义了零值。 如何使用go实现set？根据go中map的keys的无序性和唯一性，可以将其作为set 如何比较两个结构体？如何比较两个接口？可以使用==操作符比较两个结构体，就像使用其他简单类型一样。只要确保它们不包含任何片、映射或函数，有这些情况下代码将不会被编译。 type Foo struct &#123; A int B string C interface&#123;&#125; &#125; a := Foo&#123;A: 1, B: &quot;one&quot;, C: &quot;two&quot;&#125; b := Foo&#123;A: 1, B: &quot;one&quot;, C: &quot;two&quot;&#125; println(a == b) // Output: true type Bar struct &#123; A []int &#125; a := Bar&#123;A: []int&#123;1&#125;&#125; b := Bar&#123;A: []int&#123;1&#125;&#125; println(a == b) // Output: invalid operation: a == b (struct containing []int cannot be compared) 只要底层类型“简单”且相同，就可以使用==运算符比较两个接口。否则，否则代码会在运行时出现恐慌: var a interface&#123;&#125; var b interface&#123;&#125; a = 10 b = 10 println(a == b) // Output: true a = []int&#123;1&#125; b = []int&#123;2&#125; println(a == b) // Output: panic: runtime error: comparing uncomparable type []int 包含映射、切片(但不包含函数)的结构和接口，都可以使用reflect.DeepEqual()函数进行比较: var a interface&#123;&#125; var b interface&#123;&#125; a = []int&#123;1&#125; b = []int&#123;1&#125; println(reflect.DeepEqual(a, b)) // Output: true a = map[string]string&#123;&quot;A&quot;: &quot;B&quot;&#125; b = map[string]string&#123;&quot;A&quot;: &quot;B&quot;&#125; println(reflect.DeepEqual(a, b)) // Output: true temp := func() &#123;&#125; a = temp b = temp println(reflect.DeepEqual(a, b)) // Output: false 为了比较字节片，在bytes包中有很好的助手函数：bytes.equal()、bytes.compare()和bytes.equalfold()。后者用于比较忽略大小写的文本字符串，这比reflect.deepequal()快得多。 为什么两个nil值有时候会不相等？一个接口值可以看作是一个包裹非接口值的盒子。被包裹在一个接口值中的非接口值的类型必须实现了此接口值的类型。 在Go中，很多种类型的类型的零值都是用nil来表示的。 一个什么都没包裹的接口值为一个零值接口值，即nil接口值。 一个包裹着其它非接口类型的nil值的接口值并非什么都没包裹，所以它不是（或者说它不等于）一个nil接口值。 当对一个nil接口值和一个nil非接口值进行比较时（假设它们可以比较），此nil非接口值将先被转换为nil接口值的类型，然后再进行比较； 此转换的结果为一个包裹了此nil非接口值的一个副本的接口值，此接口值不是（或者说它不等于）一个nil接口值，所以此比较不相等。 Go中切片，map，struct 在64位机器中占用字节是多少?在64位系统下，Golang的切片占用字节是24位，map和struct都是8位. 简述go语言中make和new的区别。 new 它只接受一个参数，这个参数是一个类型，分配好内存后，返回一个指向该类型内存地址的指针。同时请注意它同时把分配的内存置为零，也就是类型的零值。 make也是用于内存分配的，但是和new不同，它只用于chan、map以及切片的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。 注意，因为这三种类型是引用类型，所以必须得初始化，但是不是置为零值，这个和new是不一样的。 switch流程控制代码块中的case表达式能重复吗？switch流程控制代码块中的数字常量case表达式不能重复，但是布尔常量case表达式可以重复。 简述go中的main和init函数的区别。Go里面有两个保留的函数：init函数和main函数。下边就来比较一下两个函数的异同。 相同点：两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。 不同点：init可以应用于任意包中，且可以重复定义多个。main函数只能用于main包中，且只能定义一个。 两个函数的执行顺序： 对同一个go文件的init()调用顺序是从上到下的 对同一个package中不同文件是按文件名字符串比较“从小到大”顺序调用各文件中的init()函数 对不同的package，如果不相互依赖的话，按照main包中”先import的后调用”的顺序调用其包中的init() 如果package存在依赖，则先调用最早被依赖的package中的init() 最后调用main函数 简述go中的deferdefer函数属延迟执行，延迟到调用者函数执行 return 命令前被执行。多个defer之间按LIFO先进后出顺序执行。 若函数中有多个 defer，其执行顺序为 先进后出，可以理解为栈。 return 会做几件事： 给返回值赋值 调用 defer 表达式 返回给调用函数 若 defer 表达式有返回值，将会被丢弃。 在实际开发中，defer 的使用经常伴随着闭包与匿名函数的使用。小心踩坑： package main import &quot;fmt&quot; func main() &#123; for i := 0; i &lt; 5; i++ &#123; defer func() &#123; fmt.Println(i) &#125;() &#125; &#125; Output: 5 5 5 5 5 解释一下，defer 表达式中的 i 是对 for 循环中 i 的引用。到最后，i 加到 5，故最后全部打印 5。如果将 i 作为参数传入 defer 表达式中，在传入最初就会进行求值保存，只是没有执行延迟函数而已。 for i := 0; i &lt; 5; i++ &#123; defer func(idx int) &#123; fmt.Println(idx) &#125;(i) // 传入的 i，会立即被求值保存为 idx &#125; Go中的defer函数使用下面的两种情况下结果是多少，为什么? a := 1 defer fmt.Println(&quot;the value of a1:&quot;,a) a++ defer func() &#123; fmt.Println(&quot;the value of a2:&quot;,a) &#125;() 运行: the value of a1: 1 the value of a1: 2 第一种情况： defer fmt.Println(&quot;the value of a1:&quot;,a) defer延迟函数调用的fmt.Println(a)函数的参数值在defer语句出现时就已经确定了，所以无论后面如何修改a变量都不会影响延迟函数。 第二种情况: defer func() &#123; fmt.Println(&quot;the value of a2:&quot;,a) &#125;() defer延迟函数调用的函数参数的值在defer定义时候就确定了，而defer延迟函数内部所使用的值需要在这个函数运行时候才确定。 每个测试文件必须以什么结尾？每个测试文件必须导入什么包？功能测试函数必须以什么为前缀？ 要执行压力测试需要带上什么参数？在压力测试用例中,要在循环体内使用什么?以使测试可以正常的运行。 测试文件必须以“_test.go”结尾 必须import testing这个包 所有的测试用例函数必须是Test开头 测试函数TestXxx()的参数是testing.T ,执行压力测试需要带上参数-bench 压力测试循环体内要使用 b.N 无缓冲和缓冲通道之间有什么区别？无缓冲的channel是同步的，而有缓冲的channel是非同步。无缓冲的通道指的是通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送 goroutine 和接收 goroutine 同时准备好，才可以完成发送和接收操作。 channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据。 channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。 select可以用于什么?Go的select主要是处理多个channel的操作. 为请求设置超时时间 在 golang 1.7 之前， http 包并没有引入 context 支持，通过 http.Client 向一个坏掉的服务发送请求会导致响应缓慢。类似的场景下，我们可以使用 select 控制服务响应时间。 完成 channel 它可以用于保证流水线上每个阶段goroutine 的退出。 退出 channel 在很多场景下，quit channel 和 done channel 是一个概念。在并发程序中，通常 main routine 将任务分给其它 go routine 去完成，而自身只是起到调度作用。这种情况下，main 函数无法知道 其它goroutine 任务是否完成，此时我们需要 quit channel； selcet是怎么执行的？ select中的case语句必须是一个channel操作 select中的default子句总是可运行的,速度非常快。 如果有多个case都可以运行，select会随机公平地选出一个执行，其他不会执行。 如果没有可运行的case语句，且有default语句，那么就会执行default的动作。 如果没有可运行的case语句，且没有default语句，select将阻塞，直到某个case通信可以运行 JSON 标准库对 nil slice 和 空 slice 的处理是一致的吗？首先JSON 标准库对 nil slice 和 空 slice 的处理是不一致.通常错误的用法，会报数组越界的错误，因为只是声明了slice，却没有给实例化的对象。 var slice []int slice[1] = 0 此时slice的值是nil，这种情况可以用于需要返回slice的函数，当函数出现异常的时候，保证函数依然会有nil的返回值。empty slice 是指slice不为nil，但是slice没有值，slice的底层的空间是空的，此时的定义如下： slice := make([]int,0） slice := []int&#123;&#125; 当我们查询或者处理一个空的列表的时候，这非常有用，它会告诉我们返回的是一个列表，但是列表内没有任何值。总之，nil slice 和 empty slice是不同的东西,需要我们加以区分的. 并发编程概念是什么？并行是指两个或者多个事件在同一时刻发生；并发是指两个或多个事件在同一时间间隔发生。并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上的“同时执行”。并发编程是指在一台处理器上“同时”处理多个任务。并发是在同一实体上的多个事件。多个事件在同一时间间隔发生。并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。 简述协程，线程，进程的区别。 进程 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。 线程 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。 协程 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。 一个应用程序一般对应一个进程，一个进程一般有一个主线程，还有若干个辅助线程，线程之间是平行运行的，在线程里面可以开启协程，让程序在特定的时间内运行。协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。 如何复制silce、map、interface{} ?您可以使用内置copy()函数复制切片： a := []int&#123;1, 2&#125; b := []int&#123;3, 4&#125; check := a copy(a, b) fmt.Println(a, b, check) // Output: [3 4] [3 4] [3 4] 这里，check变量用于保存对原始切片描述的引用，以确保它真正被复制。另一方面，在下一个示例中，操作不复制切片内容，只复制切片描述： a := []int&#123;1, 2&#125; b := []int&#123;3, 4&#125; check := a a = b fmt.Println(a, b, check) // Output: [3 4] [3 4] [1 2] 您可以通过遍历其键来复制Map。是的，不幸的是，这是在Go中复制Map的最简单方法： a := map[string]bool&#123;&quot;A&quot;: true, &quot;B&quot;: true&#125; b := make(map[string]bool) for key, value := range a &#123; b[key] = value &#125; 以下示例仅复制map的描述： a := map[string]bool&#123;&quot;A&quot;: true, &quot;B&quot;: true&#125; b := map[string]bool&#123;&quot;C&quot;: true, &quot;D&quot;: true&#125; check := a a = b fmt.Println(a, b, check) // Output: map[C:true D:true] map[C:true D:true] map[A:true B:true] Go中没有内置方式来复制接口。不，该reflect.DeepCopy()功能不存在。 Golang的内存模型，为什么小对象多了会造成gc压力。通常小对象过多会导致GC三色法消耗过多的GPU。优化思路是，减少对象分配. 数据竞争(Data Race)问题怎么解决？能不能不加锁解决这个问题？同步访问共享数据是处理数据竞争的一种有效的方法.golang在1.1之后引入了竞争检测机制，可以使用 go run -race 或者 go build -race来进行静态检测。其在内部的实现是,开启多个协程执行同一个命令， 并且记录下每个变量的状态. 竞争检测器基于C/C++的ThreadSanitizer 运行时库，该库在Google内部代码基地和Chromium找到许多错误。这个技术在2012年九月集成到Go中，从那时开始，它已经在标准库中检测到42个竞争条件。现在，它已经是我们持续构建过程的一部分，当竞争条件出现时，它会继续捕捉到这些错误。 竞争检测器已经完全集成到Go工具链中，仅仅添加-race标志到命令行就使用了检测器。 $ go test -race mypkg // 测试包 $ go run -race mysrc.go // 编译和运行程序 $ go build -race mycmd // 构建程序 $ go install -race mypkg // 安装程序 要想解决数据竞争的问题可以使用互斥锁sync.Mutex,解决数据竞争(Data race),也可以使用管道解决,使用管道的效率要比互斥锁高. 什么是channel，为什么它可以做到线程安全？Channel是Go中的一个核心类型，可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication),Channel也可以理解是一个先进先出的队列，通过管道进行通信。 Golang的Channel,发送一个数据到Channel 和 从Channel接收一个数据 都是 原子性的。而且Go的设计思想就是:不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁，后者就是Channel。也就是说，设计Channel的主要目的就是在多任务间传递数据的，这当然是安全的。 赋值是原子操作吗？对于标准编译器来说，赋值不是原子操作。 函数调用time.Sleep(d)和数据通道接收&lt;-time.After(d)操作之间有何区别？两者都会将当前的goroutine执行暂停一段时间。 区别在于time.Sleep(d)函数调用将使当前的协程进入睡眠字状态，但是当前协程的（主）状态依然为运行状态； 而数据通道接收&lt;-time.After(d)操作将使当前协程进入阻塞状态 64位整数值的地址是否能保证总是64位对齐的，以便可以被安全地原子访问？传递给sync/atomic标准库包中的64位函数的地址必须是64位对齐的，否则调用这些函数将在运行时导致恐慌产生。对于标准编译器和gccgo编译器，在64位架构下，64位整数的地址将保证总是64位对齐的。 所以它们总是可以被安全地原子访问。 但在32位架构下，64位整数的地址仅保证是32位对齐的。 所以原子访问某些64位整数可能会导致恐慌。 分布式锁实现原理，用过吗？在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件： 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行； 高可用的获取锁与释放锁； 高性能的获取锁与释放锁； 具备可重入特性； 具备锁失效机制，防止死锁； 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。 分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。 通常分布式锁以单独的服务方式实现，目前比较常用的分布式锁实现有三种： 基于数据库实现分布式锁。 基于缓存（redis，memcached，tair）实现分布式锁。 基于Zookeeper实现分布式锁。 尽管有这三种方案，但是不同的业务也要根据自己的情况进行选型，他们之间没有最好只有更适合！ 基于数据库的实现方式 基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。 创建一个表： DROP TABLE IF EXISTS `method_lock`; CREATE TABLE `method_lock` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;, `method_name` varchar(64) NOT NULL COMMENT &#39;锁定的方法名&#39;, `desc` varchar(255) NOT NULL COMMENT &#39;备注信息&#39;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`), UNIQUE KEY `uidx_method_name` (`method_name`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT=&#39;锁定中的方法&#39;; 想要执行某个方法，就使用这个方法名向表中插入数据： INSERT INTO method_lock (method_name, desc) VALUES (&#39;methodName&#39;, &#39;测试的methodName&#39;); 因为我们对method_name做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。 成功插入则获取锁，执行完成后删除对应的行数据释放锁： delete from method_lock where method_name =&#39;methodName&#39;; 注意：这里只是使用基于数据库的一种方法，使用数据库实现分布式锁还有很多其他的用法可以实现！ 使用基于数据库的这种实现方式很简单，但是对于分布式锁应该具备的条件来说，它有一些问题需要解决及优化： 1、因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换； 2、不具备可重入的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁； 3、没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据； 4、不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。 5、在实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑。 基于Redis的实现方式 选用Redis实现分布式锁原因： Redis有很高的性能； Redis命令对此支持较好，实现起来比较方便 主要实现方式: SET lock currentTime+expireTime EX 600 NX，使用set设置lock值，并设置过期时间为600秒，如果成功，则获取锁； 获取锁后，如果该节点掉线，则到过期时间ock值自动失效； 释放锁时，使用del删除lock键值； 使用redis单机来做分布式锁服务，可能会出现单点问题，导致服务可用性差，因此在服务稳定性要求高的场合，官方建议使用redis集群（例如5台，成功请求锁超过3台就认为获取锁），来实现redis分布式锁。详见RedLock。 优点:性能高，redis可持久化，也能保证数据不易丢失,redis集群方式提高稳定性。 缺点:使用redis主从切换时可能丢失部分数据。 基于ZooKeeper的实现方式 ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下： 创建一个目录mylock； 线程A想获取锁就在mylock目录下创建临时顺序节点； 获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁； 线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点； 线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。 这里推荐一个Apache的开源库Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。 优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。 缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。 上面的三种实现方式，没有在所有场合都是完美的，所以，应根据不同的应用场景选择最适合的实现方式。 在分布式环境中，对资源进行上锁有时候是很重要的，比如抢购某一资源，这时候使用分布式锁就可以很好地控制资源。 读写锁或者互斥锁读的时候能写吗?Go中读写锁包括读锁和写锁，多个读线程可以同时访问共享数据；写线程必须等待所有读线程都释放锁以后，才能取得锁；同样的，读线程必须等待写线程释放锁后，才能取得锁，也就是说读写锁要确保的是如下互斥关系，可以同时读，但是读-写，写-写都是互斥的。 Channel是同步的还是异步的.Channel是异步进行的。channel存在3种状态： nil，未初始化的状态，只进行了声明，或者手动赋值为nil active，正常的channel，可读或者可写 closed，已关闭，千万不要误认为关闭channel后，channel的值是nil 说一下异步和非阻塞的区别? 异步和非阻塞的区别: 异步：调用在发出之后，这个调用就直接返回，不管有无结果；异步是过程。 非阻塞：关注的是程序在等待调用结果（消息，返回值）时的状态，指在不能立刻得到结果之前，该调用不会阻塞当前线程。 同步和异步的区别： 步：一个服务的完成需要依赖其他服务时，只有等待被依赖的服务完成后，才算完成，这是一种可靠的服务序列。要么成功都成功，失败都失败，服务的状态可以保持一致。 异步：一个服务的完成需要依赖其他服务时，只通知其他依赖服务开始执行，而不需要等待被依赖的服务完成，此时该服务就算完成了。被依赖的服务是否最终完成无法确定，一次它是一个不可靠的服务序列。 消息通知中的同步和异步： 同步：当一个同步调用发出后，调用者要一直等待返回消息（或者调用结果）通知后，才能进行后续的执行。 异步：当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果）。在调用结束之后，通过消息回调来通知调用者是否调用成功。 阻塞与非阻塞的区别： 阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务,函数只有在得到结果之后才会返回。 非阻塞：非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。 同步与异步是对应的，它们是线程之间的关系，两个线程之间要么是同步的，要么是异步的。 阻塞与非阻塞是对同一个线程来说的，在某个时刻，线程要么处于阻塞，要么处于非阻塞。 阻塞是使用同步机制的结果，非阻塞则是使用异步机制的结果。 Goroutine和线程的区别?从调度上看，goroutine的调度开销远远小于线程调度开销。 OS的线程由OS内核调度，每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用一个调度器内核函数。这个函数暂停当前正在运行的线程，把他的寄存器信息保存到内存中，查看线程列表并决定接下来运行哪一个线程，再从内存中恢复线程的注册表信息，最后继续执行选中的线程。这种线程切换需要一个完整的上下文切换：即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。某种意义上，这种操作还是很慢的。 Go运行的时候包涵一个自己的调度器，这个调度器使用一个称为一个M:N调度技术，m个goroutine到n个os线程（可以用GOMAXPROCS来控制n的数量），Go的调度器不是由硬件时钟来定期触发的，而是由特定的go语言结构来触发的，他不需要切换到内核语境，所以调度一个goroutine比调度一个线程的成本低很多。 从栈空间上，goroutine的栈空间更加动态灵活。 每个OS的线程都有一个固定大小的栈内存，通常是2MB，栈内存用于保存在其他函数调用期间哪些正在执行或者临时暂停的函数的局部变量。这个固定的栈大小，如果对于goroutine来说，可能是一种巨大的浪费。作为对比goroutine在生命周期开始只有一个很小的栈，典型情况是2KB, 在go程序中，一次创建十万左右的goroutine也不罕见（2KB*100,000=200MB）。而且goroutine的栈不是固定大小，它可以按需增大和缩小，最大限制可以到1GB。 goroutine没有一个特定的标识。 在大部分支持多线程的操作系统和编程语言中，线程有一个独特的标识，通常是一个整数或者指针，这个特性可以让我们构建一个线程的局部存储，本质是一个全局的map，以线程的标识作为键，这样每个线程可以独立使用这个map存储和获取值，不受其他线程干扰。 goroutine中没有可供程序员访问的标识，原因是一种纯函数的理念，不希望滥用线程局部存储导致一个不健康的超距作用，即函数的行为不仅取决于它的参数，还取决于运行它的线程标识。 如何实现消息队列（多生产者，多消费者）？根据Goroutine和channel的读写可以实现消息队列 。 package main import ( &quot;fmt&quot; &quot;time&quot; ) func consumer(cname string, ch chan int) &#123; //可以循环 for i := range ch 来不断从 channel 接收值，直到它被关闭。 for i := range ch &#123; fmt.Println(&quot;consumer-----------&quot;, cname, &quot;:&quot;, i) &#125; fmt.Println(&quot;ch closed.&quot;) &#125; func producer(pname string, ch chan int) &#123; for i := 0; i &lt; 4; i++ &#123; fmt.Println(&quot;producer--&quot;, pname, &quot;:&quot;, i) ch &lt;- i &#125; &#125; func main() &#123; //用channel来传递&quot;产品&quot;, 不再需要自己去加锁维护一个全局的阻塞队列 ch := make(chan int) go producer(&quot;生产者1&quot;, ch) go producer(&quot;生产者2&quot;, ch) go consumer(&quot;消费者1&quot;, ch) go consumer(&quot;消费者2&quot;, ch) time.Sleep(10 * time.Second) close(ch) time.Sleep(10 * time.Second) &#125; 如何进行大文件排序？设想你有一个20GB的文件，每行一个字符串，说明如何对这个文件进行排序。内存肯定没有20GB大，所以不可能采用传统排序法。但是可以将文件分成许多块,针对每个快各自进行排序，存回文件系统。然后将这些块逐一合并，最终得到全部排好序的文件。 孤儿进程，僵尸进程 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。 本文转自 https://blog.csdn.net/yang731227/article/details/90637487，如有侵权，请联系删除。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"Go总结","slug":"Go总结","permalink":"https://ysluckly.github.io/tags/Go%E6%80%BB%E7%BB%93/"},{"name":"Go面试题","slug":"Go面试题","permalink":"https://ysluckly.github.io/tags/Go%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"【Go项目】实现推箱子游戏","slug":"back-end/1645852279829","date":"2022-01-03T07:29:32.000Z","updated":"2022-02-26T05:53:02.306Z","comments":true,"path":"2022/01/03/golang/","link":"","permalink":"https://ysluckly.github.io/2022/01/03/golang/","excerpt":"","text":"相信大家都玩过推箱子这个游戏，本文我们就将用go语言实现一个推箱子游戏。 地图构建首先我随便找了一个推箱子的关卡，并且用坐标的方式展现出来。 我们可以看到其实这个地图就是个二维数组。因此我们先声明一个二维数组。 const ( W = 10 H = 7 ) var GameMap = [H][W]int&#123;&#125; 我们用二维数组存储的内容来表示不同的物体，用0 表示空地，用1表示墙，用2表示小人，用3表示箱子，用4表示箱子推放的地点。现在我们来对刚刚到数组初始化下。 var GameMap = [H][W]int&#123; &#123;0, 0, 0, 1, 1, 1, 1, 1, 1, 0&#125;, &#123;0, 1, 1, 1, 0, 0, 0, 0, 1, 0&#125;, &#123;1, 1, 4, 0, 3, 1, 1, 0, 1, 1&#125;, &#123;1, 4, 4, 3, 0, 3, 0, 0, 2, 1&#125;, &#123;1, 4, 4, 0, 3, 0, 3, 0, 1, 1&#125;, &#123;1, 1, 1, 1, 1, 1, 0, 0, 1, 0&#125;, &#123;0, 0, 0, 0, 0, 1, 1, 1, 1, 0&#125;, &#125; 地图显示地图构建好了，我们现在再来设置地图的显示,我们通过二维数组遍历的方法，来打印地图。 func initMap() &#123; for i := 0; i &lt; H; i++ &#123; for j := 0; j &lt; W; j++ &#123; switch (GameMap[i][j]) &#123; case 0: fmt.Printf(&quot; &quot;)//空地 case 1: fmt.Printf(&quot;▒&quot;) //墙 case 2: fmt.Printf(&quot;♘&quot;) //人 case 3: fmt.Printf(&quot;✩&quot;) //箱子 case 4: fmt.Printf(&quot;⊙&quot;) //箱子推放的终点 case 6: fmt.Printf(&quot;♞&quot;) //人物走到箱子存放点显示 case 7: fmt.Printf(&quot;✭&quot;) //箱子推到存放点显示 &#125; &#125; fmt.Println() &#125; &#125; 1 2 3 4 的内容没什么好说的，我们具体的说下6和7, 就是当人物和箱子和4（箱子存放点）重叠的时候，起到变色效果。 接收键盘事件因为go语言没有像c语言一样，给我们提供无缓冲输入getch。所以我们需要借助一个开源包来帮我实现键盘接收功能。使用下面的命令安装库: go get github.com/nsf/termbox-go 有一点需要注意一下，使用go run 直接在控制台中会编译错误。最好使用go build 打包后运行。 我们需要在main函数中添加这个初始化代码 for true &#123; err := termbox.Init() if err != nil &#123; panic(err) &#125; defer termbox.Close() func control() &#123; /******键盘事件代码*******/ switch ev := termbox.PollEvent(); ev.Type &#123; case termbox.EventKey: switch ev.Key &#123; case termbox.KeyArrowUp: //小键盘向上 case termbox.KeyArrowDown://小键盘向下 case termbox.KeyArrowLeft://小键盘向左 case termbox.KeyArrowRight://小键盘向右 case termbox.KeyF5://F5 用来重置地图 &#125; &#125; 逻辑判断我们首先设置小人向上移动，我们之前说过，地图其实就是个二维数组，我们想要向上移动，只需要把小人的纵坐标减一个单位就行。我们的地图只有小人和箱子可以移动，但是箱子的移动又是依靠小人的推动。所以我们的给小人的位置设置成2个变量。 var col, row int // col row 是人物所在坐标变量 我们简单说下人物向上的逻辑： 想要人物向上移动，就需要先判断人物上一个坐标是不是空地，能不能走； 人物向上移动的时候，我们需要把人物原来所在地位置变为空地，然后把上面的空地变成人物； 如果人物的上面是箱子，并且箱子的上面是空地，那么我们就以人物现在的位置为参照点，把人物移动一个单位长度，把箱子移动2个单位长度； 箱子跟人物一样都想要重新设置位置，把原来箱子的位置设置为小人，然后把箱子上面的空地重新设置为箱子； 当我走错想要重新开始的时候，只需要把GameMap重新初始化就行 然后其他的键盘事件，如向下、向左、向右事件都是类似的，都是参考小人的当前坐标来的。 小人向下 纵坐标加1 小人向左 横坐标减1 小人向右 横坐标加1 func control() &#123; var col, row int // col row 是人物所在坐标变量 for i := 0; i &lt; H; i++ &#123; for j := 0; j &lt; W; j++ &#123; if GameMap[i][j] == 2 || GameMap[i][j] == 6 &#123; col = i row = j &#125; &#125; &#125; //ch, _ := getch.Getch() switch ev := termbox.PollEvent(); ev.Type &#123; case termbox.EventKey: switch ev.Key &#123; case termbox.KeyArrowUp: if GameMap[col-1][row] == 0 || GameMap[col-1][row] == 4 &#123; //col-1 就是 Y坐标-1 就是往上 GameMap[col][row] -= 2; //因为要移动人物，所以我们要在移动人物的时候 把人物原来的位置重新绘图 GameMap[col-1][row] += 2; // 让上一个坐标的位置 等于2 绘制出 人物 // 如果往上是箱子 &#125; else if GameMap[col-1][row] == 3 || GameMap[col-1][row] == 7 &#123; if GameMap[col-2][row] == 0 || GameMap[col-2][row] == 4 &#123; //因为人要推箱子，所以Y坐标-2，如果箱子上面是空地 GameMap[col][row] -= 2; // 重新绘图人物 col =1 row =5 GameMap[col-1][row] -= 1; // 往上再减1 就是 1-1 =0 5-1 =4 设置箱子原来位置为空地 GameMap[col-2][row] += 3; // 重新设置箱子的位置 &#125; &#125; case termbox.KeyArrowDown: if GameMap[col+1][row] == 0 || GameMap[col+1][row] == 4 &#123; GameMap[col][row] -= 2; GameMap[col+1][row] += 2; &#125; else if GameMap[col+2][row] == 0 || GameMap[col+2][row] == 4 &#123; if GameMap[col+1][row] == 3 || GameMap[col+1][row] == 7 &#123; GameMap[col][row] -= 2; GameMap[col+1][row] -= 1; GameMap[col+2][row] += 3; &#125; &#125; case termbox.KeyArrowLeft: if (GameMap[col][row-1] == 0 || GameMap[col][row-1] == 4) &#123; GameMap[col][row] -= 2; GameMap[col][row-1] += 2; &#125; else if (GameMap[col][row-2] == 0 || GameMap[col][row-2] == 4) &#123; if (GameMap[col][row-1] == 3 || GameMap[col][row-1] == 7) &#123; GameMap[col][row] -= 2; GameMap[col][row-1] -= 1; GameMap[col][row-2] += 3; &#125; &#125; case termbox.KeyArrowRight: if (GameMap[col][row+1] == 0 || GameMap[col][row+1] == 4) &#123; GameMap[col][row] -= 2; GameMap[col][row+1] += 2; &#125; else if (GameMap[col][row+2] == 0 || GameMap[col][row+2] == 4) &#123; if (GameMap[col][row+1] == 3 || GameMap[col][row+1] == 7) &#123; GameMap[col][row] -= 2; GameMap[col][row+1] -= 1; GameMap[col][row+2] += 3; &#125; &#125; case termbox.KeyF5: GameMap = [H][W]int&#123; &#123;0, 0, 0, 1, 1, 1, 1, 1, 1, 0&#125;, &#123;0, 1, 1, 1, 0, 0, 0, 0, 1, 0&#125;, &#123;1, 1, 4, 0, 3, 1, 1, 0, 1, 1&#125;, &#123;1, 4, 4, 3, 0, 3, 0, 0, 2, 1&#125;, &#123;1, 4, 4, 0, 3, 0, 3, 0, 1, 1&#125;, &#123;1, 1, 1, 1, 1, 1, 0, 0, 1, 0&#125;, &#123;0, 0, 0, 0, 0, 1, 1, 1, 1, 0&#125;, &#125; &#125; &#125; &#125; 有一点需要注意，需要设置小人坐标越界处理。 比如说小人一直向左走，横坐标会一直减-1，如果超出二维数组的范围，就会产生数组越界。 打印处理因为我们的游戏是通过控制台循环打印来实现的，这种方法如果不做一些处理，屏幕会不断的下滚，打印N次，因此我们需要每次打印前都清空下控制台。使用控制台打印还存在一个问题，如果我们不设置下打印时间等待，就会造成游戏一直闪烁。 func main() &#123; for true &#123; err := termbox.Init() if err != nil &#123; panic(err) &#125; defer termbox.Close() //清空控制台。 cmd := exec.Command(&quot;clear&quot;) //mac的清屏命令 //exec.Command(&quot;cmd&quot;, &quot;/c&quot;, &quot;cls&quot;) //如果是win使用该调命令 cmd.Stdout = os.Stdout cmd.Run() initMap() control() time.Sleep(100) &#125; &#125; 通关判断没有推到存放点的箱子，我们是通过二维数组值为3来定义的，存放倒终点的箱子是通过7来定义的。我们可以遍历数组，当二维数组中的值没有3，那说明箱子已经全部存放倒终点，说明过关。 总结我们已经实现的推箱子的基本功能，你可以再次基础上添加背景音乐，多重关卡，步数显示等功能。 本文转自 https://blog.csdn.net/yang731227/article/details/88914718，如有侵权，请联系删除。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"推箱子游戏","slug":"推箱子游戏","permalink":"https://ysluckly.github.io/tags/%E6%8E%A8%E7%AE%B1%E5%AD%90%E6%B8%B8%E6%88%8F/"},{"name":"Go项目","slug":"Go项目","permalink":"https://ysluckly.github.io/tags/Go%E9%A1%B9%E7%9B%AE/"}]},{"title":"MySQL 基础教程","slug":"database/quick-mysql","date":"2021-12-31T14:00:42.000Z","updated":"2022-02-20T13:42:53.249Z","comments":true,"path":"2021/12/31/mysql/","link":"","permalink":"https://ysluckly.github.io/2021/12/31/mysql/","excerpt":"","text":"mysql资源 mysql5.1中文参考手册mysql管理 基于linux使用mysql二进制包安装mysql5.5 mysql client命令行选项 mysqld服务器系统变量和状态变量 mysql SQL服务器模式 mysql 账户管理 mysql日志文件 mysql列类型 mysql数据库操作 mysql创建和删除表 mysql修改表 mysql索引操作 mysql索引详解&nbsp; mysql select操作 mysql insert操作 mysql load操作 mysql update操作 mysql 删除操作 mysql join操作 mysql子查询 mysql函数&nbsp; mysql show操作 mysql flush操作 mysql kill操作 mysql表维护操作 mysql导入导出 分析MySQL慢日志mysql使用 MySQL类型转换 MySQL：日期函数、时间函数总结&nbsp; mysql调优 MySQL执行计划解读 MySQL Profiling 的使用&nbsp; &nbsp;mysql常见sql优化 mysql日志设置优化 MySQL缓存参数优化 MySQL表结构优化 MySQL 索引优化&nbsp; MySQL SQL优化 MySQ 存储引擎选择&nbsp; MySQL硬件瓶颈分析 硬件环境对系统性能的影响&nbsp; MySQL内存使用-全局共享 MySQL内存使用-线程独享 mysql数据库锁定机制 Join的实现原理及优化思路 mysql ORDER BY,GROUP BY 和DISTINCT原理 MySQL索引背后的数据结构及算法原理mysql架构 mysql主要应用场景 MySQL Server系统架构 MySQL Replication 常用架构 可扩展性设计之数据切分 可扩展性设计之Cache与Search的利用&nbsp; MySQL key/value存储方案db 互联网 DBA 需要做那些事 列式数据库nosql NoSQL数据库笔谈 如何“打败”CAP定理 NoSQL 在腾讯应用实践memcached memcached简介 memcached应用场景&nbsp; Linux下memcached的安装和启动 在Java中使用Memcached&nbsp;redis文档 redis官方文档 redis中文官方文档 Redis命令参考中文版翻译redis入门资料 redis中文入门手册 redis深入浅出redis应用 Redis作者谈Redis应用场景 Redis容量及使用规划 Redis几个认识误区(转) 浅谈Redis数据库的键值设计 案例:用Redis来存储关注关系(php版)","categories":[{"name":"数据库","slug":"数据库","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://ysluckly.github.io/tags/mysql/"}]},{"title":"Go Gin 简明教程","slug":"back-end/quick-go-gin","date":"2021-12-26T13:59:10.000Z","updated":"2022-02-20T13:34:56.295Z","comments":true,"path":"2021/12/26/go/","link":"","permalink":"https://ysluckly.github.io/2021/12/26/go/","excerpt":"","text":"关键字：Gin教程 Gin中文文档 Go语言Web框架 Go环境搭建 Gin 简介 Gin is a HTTP web framework written in Go (Golang). It features a Martini-like API with much better performance – up to 40 times faster. If you need smashing performance, get yourself some Gin. Gin 是使用 Go/golang 语言实现的 HTTP Web 框架。接口简洁，性能极高。截止 1.4.0 版本，包含测试代码，仅14K，其中测试代码 9K 左右，也就是说框架源码仅 5K 左右。 $ find . -name &quot;*_test.go&quot; | xargs cat | wc -l 8657 $ find . -name &quot;*.go&quot; | xargs cat | wc -l 14115 Gin 特性 快速：路由不使用反射，基于Radix树，内存占用少。 中间件：HTTP请求，可先经过一系列中间件处理，例如：Logger，Authorization，GZIP等。这个特性和 NodeJs 的 Koa 框架很像。中间件机制也极大地提高了框架的可扩展性。 异常处理：服务始终可用，不会宕机。Gin 可以捕获 panic，并恢复。而且有极为便利的机制处理HTTP请求过程中发生的错误。 JSON：Gin可以解析并验证请求的JSON。这个特性对Restful API的开发尤其有用。 路由分组：例如将需要授权和不需要授权的API分组，不同版本的API分组。而且分组可嵌套，且性能不受影响。 渲染内置：原生支持JSON，XML和HTML的渲染。 安装Go &amp; Gin 初学者建议先阅读 Go 语言简明教程。一篇文章介绍了 Go 基本类型，结构体，单元测试，并发编程，依赖管理等内容。Go 1.13 以上版本的安装推荐该教程的方式。 安装 Go (Ubuntu) $ sudo apt-get install golang-go $ go version # go version go1.6.2 linux/amd64 Ubuntu自带版本太老了，安装新版可以使用如下命令。 $ sudo add-apt-repository ppa:gophers/archive $ sudo apt-get update $ sudo apt-get install golang-1.11-go 默认安装在/usr/lib/go-1.11，需要将/usr/lib/go-1.11/bin手动加入环境变量。在 .bashrc 中添加下面的配置，并 source ~/.bashrc export PATH=$PATH:/usr/lib/go-1.11/bin 参考：Golang Ubuntu - Github 安装 Go (Mac) $ brew install go $ go version # go version go1.12.5 darwin/amd64 设置环境变量 在 ~/.bashrc 中添加 GOPATH 变量 export GOPATH=~/go export PATH=$PATH:$GOPATH/bin 添加完后，source ~/.bashrc 安装一些辅助的工具库 由于网络原因，不能够直接访问 golang.org，但相关的库已经镜像到 Golang - Github 例如，直接安装 go-outline 时会报网络错误，因为golang.org/x/tools是go-outline的依赖库。 $ go get -u -v github.com/ramya-rao-a/go-outline github.com/ramya-rao-a/go-outline (download) Fetching https://golang.org/x/tools/go/buildutil?go-get=1 https fetch failed: Get https://golang.org/x/tools/go/buildutil?go-get=1: dial tcp 216.239.37.1:443: i/o timeout 因此，可以先从 Github 手动安装好，再安装 go-outline 和 goreturns。 git clone https://github.com/golang/tools.git $GOPATH/src/golang.org/x/tools go get -v github.com/ramya-rao-a/go-outline go get -v github.com/sqs/goreturns go get -v github.com/rogpeppe/godef Go语言有大量的辅助工具，如果你使用VSCode，将会提示你将必要的工具，例如静态检查、自动补全等工具依次安装完毕。 安装 Gin go get -u -v github.com/gin-gonic/gin -v：打印出被构建的代码包的名字-u：已存在相关的代码包，强行更新代码包及其依赖包 第一个Gin程序在一个空文件夹里新建文件main.go。 // geektutu.com // main.go package main import &quot;github.com/gin-gonic/gin&quot; func main() &#123; r := gin.Default() r.GET(&quot;/&quot;, func(c *gin.Context) &#123; c.String(200, &quot;Hello, Geektutu&quot;) &#125;) r.Run() // listen and serve on 0.0.0.0:8080 &#125; 首先，我们使用了gin.Default()生成了一个实例，这个实例即 WSGI 应用程序。 接下来，我们使用r.Get(&quot;/&quot;, ...)声明了一个路由，告诉 Gin 什么样的URL 能触发传入的函数，这个函数返回我们想要显示在用户浏览器中的信息。 最后用 r.Run()函数来让应用运行在本地服务器上，默认监听端口是 _8080_，可以传入参数设置端口，例如r.Run(&quot;:9999&quot;)即运行在 _9999_端口。 运行 $ go run main.go [GIN-debug] GET / --&gt; main.main.func1 (3 handlers) [GIN-debug] Environment variable PORT is undefined. Using port :8080 by default [GIN-debug] Listening and serving HTTP on :8080 浏览器访问 http://localhost:8080 路由(Route)路由方法有 GET, POST, PUT, PATCH, DELETE 和 OPTIONS，还有Any，可匹配以上任意类型的请求。 无参数// 无参数 r.GET(&quot;/&quot;, func(c *gin.Context) &#123; c.String(http.StatusOK, &quot;Who are you?&quot;) &#125;) $ curl http://localhost:9999/ Who are you? curl参数可参考https://man.linuxde.net/curl 解析路径参数有时候我们需要动态的路由，如 /user/:name，通过调用不同的 url 来传入不同的 name。/user/:name/*role，* 代表可选。 // 匹配 /user/geektutu r.GET(&quot;/user/:name&quot;, func(c *gin.Context) &#123; name := c.Param(&quot;name&quot;) c.String(http.StatusOK, &quot;Hello %s&quot;, name) &#125;) $ curl http://localhost:9999/user/geektutu Hello geektutu 获取Query参数// 匹配users?name=xxx&amp;role=xxx，role可选 r.GET(&quot;/users&quot;, func(c *gin.Context) &#123; name := c.Query(&quot;name&quot;) role := c.DefaultQuery(&quot;role&quot;, &quot;teacher&quot;) c.String(http.StatusOK, &quot;%s is a %s&quot;, name, role) &#125;) $ curl &quot;http://localhost:9999/users?name=Tom&amp;role=student&quot; Tom is a student 获取POST参数// POST r.POST(&quot;/form&quot;, func(c *gin.Context) &#123; username := c.PostForm(&quot;username&quot;) password := c.DefaultPostForm(&quot;password&quot;, &quot;000000&quot;) // 可设置默认值 c.JSON(http.StatusOK, gin.H&#123; &quot;username&quot;: username, &quot;password&quot;: password, &#125;) &#125;) $ curl http://localhost:9999/form -X POST -d &#39;username=geektutu&amp;password=1234&#39; &#123;&quot;password&quot;:&quot;1234&quot;,&quot;username&quot;:&quot;geektutu&quot;&#125; Query和POST混合参数// GET 和 POST 混合 r.POST(&quot;/posts&quot;, func(c *gin.Context) &#123; id := c.Query(&quot;id&quot;) page := c.DefaultQuery(&quot;page&quot;, &quot;0&quot;) username := c.PostForm(&quot;username&quot;) password := c.DefaultPostForm(&quot;username&quot;, &quot;000000&quot;) // 可设置默认值 c.JSON(http.StatusOK, gin.H&#123; &quot;id&quot;: id, &quot;page&quot;: page, &quot;username&quot;: username, &quot;password&quot;: password, &#125;) &#125;) $ curl &quot;http://localhost:9999/posts?id=9876&amp;page=7&quot; -X POST -d &#39;username=geektutu&amp;password=1234&#39; &#123;&quot;id&quot;:&quot;9876&quot;,&quot;page&quot;:&quot;7&quot;,&quot;password&quot;:&quot;1234&quot;,&quot;username&quot;:&quot;geektutu&quot;&#125; Map参数(字典参数)r.POST(&quot;/post&quot;, func(c *gin.Context) &#123; ids := c.QueryMap(&quot;ids&quot;) names := c.PostFormMap(&quot;names&quot;) c.JSON(http.StatusOK, gin.H&#123; &quot;ids&quot;: ids, &quot;names&quot;: names, &#125;) &#125;) $ curl -g &quot;http://localhost:9999/post?ids[Jack]=001&amp;ids[Tom]=002&quot; -X POST -d &#39;names[a]=Sam&amp;names[b]=David&#39; &#123;&quot;ids&quot;:&#123;&quot;Jack&quot;:&quot;001&quot;,&quot;Tom&quot;:&quot;002&quot;&#125;,&quot;names&quot;:&#123;&quot;a&quot;:&quot;Sam&quot;,&quot;b&quot;:&quot;David&quot;&#125;&#125; 重定向(Redirect)r.GET(&quot;/redirect&quot;, func(c *gin.Context) &#123; c.Redirect(http.StatusMovedPermanently, &quot;/index&quot;) &#125;) r.GET(&quot;/goindex&quot;, func(c *gin.Context) &#123; c.Request.URL.Path = &quot;/&quot; r.HandleContext(c) &#125;) $ curl -i http://localhost:9999/redirect HTTP/1.1 301 Moved Permanently Content-Type: text/html; charset=utf-8 Location: / Date: Thu, 08 Aug 2019 17:22:14 GMT Content-Length: 36 &lt;a href=&quot;/&quot;&gt;Moved Permanently&lt;/a&gt;. $ curl &quot;http://localhost:9999/goindex&quot; Who are you? 分组路由(Grouping Routes)如果有一组路由，前缀都是/api/v1开头，是否每个路由都需要加上/api/v1这个前缀呢？答案是不需要，分组路由可以解决这个问题。利用分组路由还可以更好地实现权限控制，例如将需要登录鉴权的路由放到同一分组中去，简化权限控制。 // group routes 分组路由 defaultHandler := func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;path&quot;: c.FullPath(), &#125;) &#125; // group: v1 v1 := r.Group(&quot;/v1&quot;) &#123; v1.GET(&quot;/posts&quot;, defaultHandler) v1.GET(&quot;/series&quot;, defaultHandler) &#125; // group: v2 v2 := r.Group(&quot;/v2&quot;) &#123; v2.GET(&quot;/posts&quot;, defaultHandler) v2.GET(&quot;/series&quot;, defaultHandler) &#125; $ curl http://localhost:9999/v1/posts &#123;&quot;path&quot;:&quot;/v1/posts&quot;&#125; $ curl http://localhost:9999/v2/posts &#123;&quot;path&quot;:&quot;/v2/posts&quot;&#125; 上传文件单个文件r.POST(&quot;/upload1&quot;, func(c *gin.Context) &#123; file, _ := c.FormFile(&quot;file&quot;) // c.SaveUploadedFile(file, dst) c.String(http.StatusOK, &quot;%s uploaded!&quot;, file.Filename) &#125;) 多个文件r.POST(&quot;/upload2&quot;, func(c *gin.Context) &#123; // Multipart form form, _ := c.MultipartForm() files := form.File[&quot;upload[]&quot;] for _, file := range files &#123; log.Println(file.Filename) // c.SaveUploadedFile(file, dst) &#125; c.String(http.StatusOK, &quot;%d files uploaded!&quot;, len(files)) &#125;) HTML模板(Template)type student struct &#123; Name string Age int8 &#125; r.LoadHTMLGlob(&quot;templates/*&quot;) stu1 := &amp;student&#123;Name: &quot;Geektutu&quot;, Age: 20&#125; stu2 := &amp;student&#123;Name: &quot;Jack&quot;, Age: 22&#125; r.GET(&quot;/arr&quot;, func(c *gin.Context) &#123; c.HTML(http.StatusOK, &quot;arr.tmpl&quot;, gin.H&#123; &quot;title&quot;: &quot;Gin&quot;, &quot;stuArr&quot;: [2]*student&#123;stu1, stu2&#125;, &#125;) &#125;) &lt;!-- templates/arr.tmpl --&gt; &lt;html&gt; &lt;body&gt; &lt;p&gt;hello, &#123;&#123;.title&#125;&#125;&lt;/p&gt; &#123;&#123;range $index, $ele := .stuArr &#125;&#125; &lt;p&gt;&#123;&#123; $index &#125;&#125;: &#123;&#123; $ele.Name &#125;&#125; is &#123;&#123; $ele.Age &#125;&#125; years old&lt;/p&gt; &#123;&#123; end &#125;&#125; &lt;/body&gt; &lt;/html&gt; $ curl http://localhost:9999/arr &lt;html&gt; &lt;body&gt; &lt;p&gt;hello, Gin&lt;/p&gt; &lt;p&gt;0: Geektutu is 20 years old&lt;/p&gt; &lt;p&gt;1: Jack is 22 years old&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; Gin默认使用模板Go语言标准库的模板text/template和html/template，语法与标准库一致，支持各种复杂场景的渲染。 参考官方文档text/template，html/template 中间件(Middleware)// 作用于全局 r.Use(gin.Logger()) r.Use(gin.Recovery()) // 作用于单个路由 r.GET(&quot;/benchmark&quot;, MyBenchLogger(), benchEndpoint) // 作用于某个组 authorized := r.Group(&quot;/&quot;) authorized.Use(AuthRequired()) &#123; authorized.POST(&quot;/login&quot;, loginEndpoint) authorized.POST(&quot;/submit&quot;, submitEndpoint) &#125; 如何自定义中间件呢？ func Logger() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; t := time.Now() // 给Context实例设置一个值 c.Set(&quot;geektutu&quot;, &quot;1111&quot;) // 请求前 c.Next() // 请求后 latency := time.Since(t) log.Print(latency) &#125; &#125; 热加载调试 Hot ReloadPython 的 Flask框架，有 debug 模式，启动时传入 debug=True 就可以热加载(Hot Reload, Live Reload)了。即更改源码，保存后，自动触发更新，浏览器上刷新即可。免去了杀进程、重新启动之苦。 Gin 原生不支持，但有很多额外的库可以支持。例如 github.com/codegangsta/gin github.com/pilu/fresh 这次，我们采用 github.com/pilu/fresh 。 go get -v -u github.com/pilu/fresh 安装好后，只需要将go run main.go命令换成fresh即可。每次更改源文件，代码将自动重新编译(Auto Compile)。 参考 github.com/pilu/fresh - Github 相关链接 Golang Gin - Github Gin Web Framework - 英文官方网站","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"Gin","slug":"Gin","permalink":"https://ysluckly.github.io/tags/Gin/"}]},{"title":"Go Context 并发编程简明教程","slug":"back-end/quick-go-context","date":"2021-12-25T13:59:10.000Z","updated":"2022-02-20T13:33:13.572Z","comments":true,"path":"2021/12/25/go/","link":"","permalink":"https://ysluckly.github.io/2021/12/25/go/","excerpt":"","text":"1 为什么需要 ContextWaitGroup 和信道(channel)是常见的 2 种并发控制的方式。 如果并发启动了多个子协程，需要等待所有的子协程完成任务，WaitGroup 非常适合于这类场景，例如下面的例子： var wg sync.WaitGroup func doTask(n int) &#123; time.Sleep(time.Duration(n)) fmt.Printf(&quot;Task %d Done\\n&quot;, n) wg.Done() &#125; func main() &#123; for i := 0; i &lt; 3; i++ &#123; wg.Add(1) go doTask(i + 1) &#125; wg.Wait() fmt.Println(&quot;All Task Done&quot;) &#125; wg.Wait() 会等待所有的子协程任务全部完成，所有子协程结束后，才会执行 wg.Wait() 后面的代码。 Task 3 Done Task 1 Done Task 2 Done All Task Done WaitGroup 只是傻傻地等待子协程结束，但是并不能主动通知子协程退出。假如开启了一个定时轮询的子协程，有没有什么办法，通知该子协程退出呢？这种场景下，可以使用 select+chan 的机制。 var stop chan bool func reqTask(name string) &#123; for &#123; select &#123; case &lt;-stop: fmt.Println(&quot;stop&quot;, name) return default: fmt.Println(name, &quot;send request&quot;) time.Sleep(1 * time.Second) &#125; &#125; &#125; func main() &#123; stop = make(chan bool) go reqTask(&quot;worker1&quot;) time.Sleep(3 * time.Second) stop &lt;- true time.Sleep(3 * time.Second) &#125; 子协程使用 for 循环定时轮询，如果 stop 信道有值，则退出，否则继续轮询。 worker1 send request worker1 send request worker1 send request stop worker1 更复杂的场景如何做并发控制呢？比如子协程中开启了新的子协程，或者需要同时控制多个子协程。这种场景下，select+chan的方式就显得力不从心了。 Go 语言提供了 Context 标准库可以解决这类场景的问题，Context 的作用和它的名字很像，上下文，即子协程的下上文。Context 有两个主要的功能： 通知子协程退出（正常退出，超时退出等）； 传递必要的参数。 2 context.WithCancelcontext.WithCancel() 创建可取消的 Context 对象，即可以主动通知子协程退出。 2.1 控制单个协程使用 Context 改写上述的例子，效果与 select+chan 相同。 func reqTask(ctx context.Context, name string) &#123; for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(&quot;stop&quot;, name) return default: fmt.Println(name, &quot;send request&quot;) time.Sleep(1 * time.Second) &#125; &#125; &#125; func main() &#123; ctx, cancel := context.WithCancel(context.Background()) go reqTask(ctx, &quot;worker1&quot;) time.Sleep(3 * time.Second) cancel() time.Sleep(3 * time.Second) &#125; context.Backgroud() 创建根 Context，通常在 main 函数、初始化和测试代码中创建，作为顶层 Context。 context.WithCancel(parent) 创建可取消的子 Context，同时返回函数 cancel。 在子协程中，使用 select 调用 &lt;-ctx.Done() 判断是否需要退出。 主协程中，调用 cancel() 函数通知子协程退出。 2.2 控制多个协程func main() &#123; ctx, cancel := context.WithCancel(context.Background()) go reqTask(ctx, &quot;worker1&quot;) go reqTask(ctx, &quot;worker2&quot;) time.Sleep(3 * time.Second) cancel() time.Sleep(3 * time.Second) &#125; 为每个子协程传递相同的上下文 ctx 即可，调用 cancel() 函数后该 Context 控制的所有子协程都会退出。 worker1 send request worker2 send request worker1 send request worker2 send request worker1 send request worker2 send request stop worker1 stop worker2 3 context.WithValue如果需要往子协程中传递参数，可以使用 context.WithValue()。 type Options struct&#123; Interval time.Duration &#125; func reqTask(ctx context.Context, name string) &#123; for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(&quot;stop&quot;, name) return default: fmt.Println(name, &quot;send request&quot;) op := ctx.Value(&quot;options&quot;).(*Options) time.Sleep(op.Interval * time.Second) &#125; &#125; &#125; func main() &#123; ctx, cancel := context.WithCancel(context.Background()) vCtx := context.WithValue(ctx, &quot;options&quot;, &amp;Options&#123;1&#125;) go reqTask(vCtx, &quot;worker1&quot;) go reqTask(vCtx, &quot;worker2&quot;) time.Sleep(3 * time.Second) cancel() time.Sleep(3 * time.Second) &#125; context.WithValue() 创建了一个基于 ctx 的子 Context，并携带了值 options。 在子协程中，使用 ctx.Value(&quot;options&quot;) 获取到传递的值，读取/修改该值。 4 context.WithTimeout如果需要控制子协程的执行时间，可以使用 context.WithTimeout 创建具有超时通知机制的 Context 对象。 func main() &#123; ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second) go reqTask(ctx, &quot;worker1&quot;) go reqTask(ctx, &quot;worker2&quot;) time.Sleep(3 * time.Second) fmt.Println(&quot;before cancel&quot;) cancel() time.Sleep(3 * time.Second) &#125; WithTimeout()的使用与 WithCancel() 类似，多了一个参数，用于设置超时时间。执行结果如下： worker2 send request worker1 send request worker1 send request worker2 send request stop worker2 stop worker1 before cancel 因为超时时间设置为 2s，但是 main 函数中，3s 后才会调用 cancel()，因此，在调用 cancel() 函数前，子协程因为超时已经退出了。 5 context.WithDeadline超时退出可以控制子协程的最长执行时间，那 context.WithDeadline() 则可以控制子协程的最迟退出时间。 func reqTask(ctx context.Context, name string) &#123; for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(&quot;stop&quot;, name, ctx.Err()) return default: fmt.Println(name, &quot;send request&quot;) time.Sleep(1 * time.Second) &#125; &#125; &#125; func main() &#123; ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(1*time.Second)) go reqTask(ctx, &quot;worker1&quot;) go reqTask(ctx, &quot;worker2&quot;) time.Sleep(3 * time.Second) fmt.Println(&quot;before cancel&quot;) cancel() time.Sleep(3 * time.Second) &#125; WithDeadline 用于设置截止时间。在这个例子中，将截止时间设置为1s后，cancel() 函数在 3s 后调用，因此子协程将在调用 cancel() 函数前结束。 在子协程中，可以通过 ctx.Err() 获取到子协程退出的错误原因。 运行结果如下： worker2 send request worker1 send request stop worker2 context deadline exceeded stop worker1 context deadline exceeded before cancel 可以看到，子协程 worker1 和 worker2 均是因为截止时间到了而退出。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://ysluckly.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"上下文","slug":"上下文","permalink":"https://ysluckly.github.io/tags/%E4%B8%8A%E4%B8%8B%E6%96%87/"},{"name":"信道","slug":"信道","permalink":"https://ysluckly.github.io/tags/%E4%BF%A1%E9%81%93/"},{"name":"超时退出","slug":"超时退出","permalink":"https://ysluckly.github.io/tags/%E8%B6%85%E6%97%B6%E9%80%80%E5%87%BA/"},{"name":"golang","slug":"golang","permalink":"https://ysluckly.github.io/tags/golang/"}]},{"title":"Go2 新特性简明教程","slug":"back-end/quick-go2","date":"2021-12-24T13:59:10.000Z","updated":"2022-02-20T13:32:23.306Z","comments":true,"path":"2021/12/24/go/","link":"","permalink":"https://ysluckly.github.io/2021/12/24/go/","excerpt":"","text":"图片引用自udemy.com Go 的演进Go语言/golang 诞生于2007年，经过12年的发展，Go逐渐成为了云计算领域新一代的开发语言。Go语言在牺牲很少性能的情况下，语法简洁，功能强大。我是Python的重度用户，在学习Go时，却有一种在学习Python的感觉。并非语法相似，而是Go语言作为一门编译型语言，竟然能够像Python一样，少量的代码就能够完成尽可能多的事情。Go语言仿佛是C和Python的结合体。 Go是如何火起来的呢？我觉得有几个主要的原因，除了语言本身性能好，语法简单，易上手外。Go语言原生支持Goroutine和Channel，极大地降低了并发和异步编程的复杂度。对于服务端编程，并发和异步尤其重要，相比之下，C++，Java等语言的并发和异步控制逻辑过于复杂。另外，杀手级应用Docker的出现起到了很大的推动作用。 Go语言也有很多令人诟病的地方，例如包管理机制，Go直到v1.6才默认开启了vendor机制，vendor机制非常简陋，简单说就是在项目目录下增加一个vendor文件夹，里面放第三方依赖。vendor机制是没有版本概念的，而且不能解决vendor目录嵌套的问题以及同名包函数冲突问题。后来社区涌现了大量的包管理工具，仅官方推荐的包管理工具就有15种之多，应用比较广泛的，如dep、govendor。直到v1.11，官方增加了Go modules机制，才算较为完整地解决了包管理的问题。 Go2 可以说是Go语言一个非常重要的里程碑，Go1 目前虽然已经到了1.12版本，事实上每一个版本很少涉及语法层面的变化，而且每个版本都是向前兼容的。较大的改动如下： Go1.2 切片操作 var a = make([]int, 10) var b = a[i:j:k] Go1.4 for语言加强 // &lt;= 1.3 for i, v := range x &#123; // ... &#125; for i := range x &#123; // ... &#125; // 1.4 新增 var times [5][0]int for i := 0; i &lt; len(times); i++ &#123; // ... &#125; for _ = range times &#123; // ... &#125; Go1.9 类型别名 type T1 = T2 Go 2 设计草案为了进一步完善Go语言，提供更好的体验。Go语言社区目前发布了三类重要的设计草案，分别是错误处理(Error handling)、错误值(Error values)、泛型(Generics)，这几个草案代表了社区重点关注的完善方向，但并不代表最终的实现。 错误处理(Error Handling)Go1 的错误处理机制非常简单，通过返回值的方式，强迫调用者对错误进行处理，这种设计导致会在代码中写大量的if判断。例如： func CopyFile(src, dst string) &#123; r := os.Open(src) defer r.Close() w := os.Create(dst) io.Copy(w, r) w.Close() &#125; IO操作容易引发错误，文件打开失败，创建失败，拷贝失败等都会产生错误。如果要对这个函数进行完整的错误处理，代码将变成这样： func CopyFile(src, dst string) error &#123; r, err := os.Open(src) if err != nil &#123; return err &#125; defer r.Close() w, err := os.Create(dst) if err != nil &#123; return err &#125; defer w.Close() if _, err := io.Copy(w, r); err != nil &#123; return err &#125; if err := w.Close(); err != nil &#123; return err &#125; &#125; 看似逻辑清晰，但不够优雅，充斥了大量重复的逻辑。这是Go错误处理机制的缺陷。同时，因为错误处理机制的繁琐，很多开发者在开发应用时，很少去检查并处理错误，程序的健壮性得不到保证。 为了解决这个问题，Go2 发布了一个设计草案供社区讨论，Go2将会完善错误处理机制，错误处理的语法将会简洁很多。 这个提案引入了handle err和check关键字，上面的函数可以简化成： func CopyFile(src, dst string) error &#123; handle err &#123; return fmt.Errorf(&quot;copy %s %s: %v&quot;, src, dst, err) &#125; r := check os.Open(src) defer r.Close() w := check os.Create(dst) check io.Copy(w, r) check w.Close() &#125; 为什么不使用被Java、Python等语言采用的try关键字呢？比如写成： data := try parseHexdump(string(hex)) 上面的写法看似和谐，但try关键字直接应用在 error values 时，可读性就没那么好了： data, err := parseHexdump(string(hex)) if err == ErrBadHex &#123; ... special handling ... &#125; try err 很明显，在这种场景下，check err显然比try err更有意义。 错误值(Error values)同样由于错误处理机制设计得较为简陋，Go语言对Error values支持有限。任何值，只要实现了error接口，都是错误类型。由于缺少细粒度的设计，在各种库当中，判断是否产生错误以及产生了哪类错误的方式多种多样，例如io.EOF，os.IsNotExist，err.Error()等，。另外，Go语言目前没有机制追溯到完整的错误链条。例如， func funcB() error &#123; if v, err := funcA(); if err != nil &#123; return fmt.Errorf(&quot;connect to db: %v&quot;, err) &#125; &#125; func funcC() error &#123; v, err := funcB() if err != nil &#123; return fmt.Errorf(&quot;write users database: %v&quot;, err) &#125; &#125; funcC返回的错误信息是： write users database: connect to db: open /etc/xx.conf: permission denied 每一层，用额外的字符串对错误进行封装，是目前最常用的方法，除了通过字符串解析，很难还原出完整的错误链条。 为了解决Error values缺少标准的问题，有2个提案，分别针对Error inspection和Error formatting。 针对 Error inspection ，为error定义了一个可选的接口Unwrap，用来返回错误链上的下一个错误。 package errors type Wrapper interface &#123; Unwrap() error &#125; 例如， // WriteError 实现 Unwrap 接口 func (e *WriteError) Unwrap() error &#123; return e.Err &#125; 针对 Error format，定义了一个可选的接口Format，用来返回错误信息。 package errors type Formatter interface &#123; Format(p Printer) (next error) &#125; 例如， func (e *WriteError) Format(p errors.Printer) (next error) &#123; p.Printf(&quot;write %s database&quot;, e.Database) if p.Detail() &#123; p.Printf(&quot;more detail here&quot;) &#125; return e.Err &#125; 泛型(Generics)Go语言当前可使用inferface&#123;&#125;，允许函数参数和返回值是任何类型的值。但这过于灵活，很多时候需要在获取参数后使用类型断言，进而决定下一步的处理。对比C++/Java的标准容器，Go语言在泛型方面有很大不足，因此针对泛型的提案即希望弥补这方面的不足。提案希望能够支持以下功能： type List(type T) []T // 返回map的键 func Keys(type K, V)(m map[K]V) []K // 去重过滤 func Uniq(&lt;-chan T) &lt;-chan T // 合并 func Merge(chans ...&lt;-chan T) &lt;-chan T // 使用自定义排序函数排序 func SortSlice(data []T, less func(x, y T) bool) 例如，我们需要返回一个map对象中所有的键，而希望这个键的类型可以是任意类型。 var ints List(int) keysA := Keys(int, string)(map[int]string&#123;1:&quot;one&quot;, 2: &quot;two&quot;&#125;) keysB := Keys(string, string)(map[string]string&#123;&quot;name&quot;:&quot;geektutu&quot;, &quot;age&quot;: &quot;twenty&quot;&#125;) // [1, 2] 参考：Go2 wiki - Github Go 2 新特性Go2还未正式发布，发布后更新","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80/"},{"name":"GO2","slug":"GO2","permalink":"https://ysluckly.github.io/tags/GO2/"},{"name":"泛型","slug":"泛型","permalink":"https://ysluckly.github.io/tags/%E6%B3%9B%E5%9E%8B/"}]},{"title":"TCP/IP 基础教程","slug":"back-end/quick-ltcpip","date":"2021-12-17T14:00:42.000Z","updated":"2022-02-20T13:42:14.489Z","comments":true,"path":"2021/12/17/tcp/ip/","link":"","permalink":"https://ysluckly.github.io/2021/12/17/tcp/ip/","excerpt":"","text":"基础 TCP Implementation in Linux: A Brief Tutorial 基于tcpdump实例讲解TCP/IP协议 tcp-ip-状态详解 纳格算法 TCP延迟确认 糊涂窗口综合症 TCP慢启动算法 拥塞避免算法 TCP的超时与重传 快速重传与快速恢复算法 TCP的坚持定时器 编程 TCP客户端和服务端入门 Linux/Unix服务端和客户端Socket编程入门实例 IO复用 Linux/Unix IO多路复用之select网络编程 Linux/Unix IO多路复用之poll网络编程 Linux IO多路复用之epoll网络编程 套接字选项 Socket选项概览 网络编程中Nagle算法和Delayed ACK的测试 原始套接字 C++ Ping源码","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"网络编程","slug":"后端/网络编程","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"tcp/ip","slug":"tcp-ip","permalink":"https://ysluckly.github.io/tags/tcp-ip/"}]},{"title":"Redis 2021最新 超详解 教程（狂神笔记+个人总结+代码+截图）","slug":"back-end/1645801399466","date":"2021-12-08T02:44:30.000Z","updated":"2022-02-25T15:04:20.560Z","comments":true,"path":"2021/12/08/redis/","link":"","permalink":"https://ysluckly.github.io/2021/12/08/redis/","excerpt":"","text":"文章目录 一.NoSQL 简介 1.数据库演化 2.为什么使用NoSQL 3.NoSQL特点 4.NoSQL分类 5.电商的数据存储 商品的基本信息 商品的描述、评论（文字较多） 图片 商品关键字（搜索） 商品热门信息 商品的交易，外部支付接口 二、Redis 简介 1.简介 2.为什么需要Redis 3.Redis帮我们解决什么 4.学习途径 5.下载 三、Redis 安装 1.windows环境 启动服务端 启动客户端 2.Linux安装 下载 环境 安装 配置文件 启动 关闭 3.测试性能 分析结果 四、Redis 基础知识 基础指令* [Redis单线程](about:blank#Redis_290) 1.五大数据类型 Redis-Key String(字符串) List（列表） Set（集合） Hash（HashMap集合、散列表、链表数组） Zset（有序集合） 2.三种特殊数据类型 geospatial Hyperloglogs Bitmaps 3.Redis 事务 4.Redis实现乐观锁 五、Java 操作 Redis 1.Jedis 官方原生API 概念 项目、依赖 连接、测试 常用API Key操作 String类型 List集合 Set集合 Hash Jedis 事务 2.SpringBoot 整合 Redis 项目准备 Redis测试 序列化问题 自己写工具类 六、Redis 高级 1.redis.conf 配置文件 2.Redis 持久化 RDB（Redis DataBase） AOF（Append Only File） Redis 持久化总结 3.Redis 发布订阅 4.Redis 主从复制 概念 配置 启动 主从链路 5.哨兵模式（重点） 概念 模型 配置 测试 6.Redis 缓存穿透、击穿、雪崩（面试重点） 缓存穿透 概念 布隆过滤器 缓存空对象 缓存击穿 概念 设置热点数据永不过期 加互斥锁 缓存雪崩 概念 Redis高可用 限流降级 数据预热 一.NoSQL 简介1.数据库演化早期网站访问量不大，单个数据够用，多数为静态网页，服务器没有太大压力，网站瓶颈主要在 数据量过大，一台机器放不下 数据索引（B+Tree）内存也放不下 访问量读写混合，一个服务器承受不了 为了解决以上问题，开始使用 Memcached（缓存）+MySQL+垂直拆分（读写分离） 开始没有MyCat中间件，为了确保多个数据库服务器数据同步，所以数据库采用了读写分离的方式 网站的主要消耗在读操作，所以经常使用的数据使用缓存来保证查询效率 进一步优化结构，采用 分库分表+水平拆分+MySQL集群 核心问题在解决数据库的 读、写 数据量进一步增长，需要保存较大的文件，如博客、图片等，MySQL开始力不从心，效率低下，到了近期技术需要进一步提升，由转恩的数据库来处理。比如，一个几亿条数据的表，需要加一个列，很难想象。 2.为什么使用NoSQL用户个人信息、社交网络、地理位置、用户自己产生的数据、用户日志等数据量巨大，这些类型数据存储不需要固定的格式，也就是行列，不需要操作就可以横向扩展， 需要新型的专门数据库出里，随之出现了NoSQL NoSQL=Not Only SQL 3.NoSQL特点 方便扩展，数据之间没有关系，方便扩展 大数据量高性能，读写速度快，是细粒度缓存 数据类型多样，不需要事先设计数据库，随取随用，数据量庞大的表很不好设计 传统的关系型数据库RDBMS 结构化组织 语言SQL 数据和关系都存在单独的表中 操作，数据定义语言 严格的一致性 基础的事务 NoSQL 存储不仅仅是数据 没有固定的查询语言 键值对存储，列存储，文档存储，图形数据库（社交关系） 最终一致性（最终一致即可） CAP定理和BASE 高性能，高可用，高可扩展 4.NoSQL分类 泛指非关系型数据库，为了和关系型数据库做区分，Redis就是一款NoSQL 主流分为四大类： 1.Key-Value型：Redis Tair memecache 2.文档型：ElasticSearch Solr MongoDB（非关系型数据库中最像关系型数据库的） 3.面向列：Hbase Cassandra 4.图形化：Neo4j，不是存图片，而是存关系图形化的 简单的理解：关系型数据库以外的都是非关系型数据库，因为它不采用表结构 5.电商的数据存储商品的基本信息名称、价格、商家等信息，采用关系型数据库，MySQL、Oracle 商品的描述、评论（文字较多）文档型数据库，如MongoDB 图片分布式文件系统，FastDFS 淘宝自研技术，TFS Google：GFS Hadoop：HDFS 阿里云：OSS 商品关键字（搜索）早期搜索引擎：solr elasticsearch 淘宝使用：ISearch 商品热门信息内存数据库：Redis，Tair，Memache 商品的交易，外部支付接口第三方应用如银行 二、Redis 简介1.简介 Redis全称Remote Dictionary Server，即远程字典服务，由C语言编写，所以不需要安装Java环境，是一款基于K-V的NoSQL，使用起来就像map一样，免费，开源，也叫结构化数据库 一个意大利人需要开发一款LLOOGG统计页面，因为MySQL性能不好，所以自己研发一款非关系型数据库，并命名为Redis 基于内存存储数据，读写速度快，性能达到110000次/s读数据，81000次/s写数据，但是内存存储不持久，所以Redis提供了持久化机制 Redis还提供了主从、哨兵以及集群的搭建方式，可以更方便的横向扩展以及垂直扩展 新浪有全世界最大的Redis集群，数据量大的服务器基本都需要Redis，他是后台开发人员的必备技能之一 2.为什么需要Redis 由于用户量增大，请求数量增大，数据压力过大，服务器集群能承受住，数据库无法承受 多台服务器之间存在数据不同步，比如，上次登录的服务器有session，这次登录的服务器没有session 多台服务器之间的锁已经不具备互斥性，各论各的 3.Redis帮我们解决什么 针对热点数据添加缓存，存到Redis中，Redis基于内存存储、读取数据，读写效率非常高 将之前存储在session中的共享数据统一存放Redis中 Redis基于接收用户请求的是单线程的 可以实现持久化 可以发布订阅，实现消息队列功能 可以地图信息分析 支持计时器、计数器，比如支持浏览量 提供多种语言API 特性：多样的数据类型、持久化、集群、事务 4.学习途径官网：https://redis.io/ 中文网：http://www.redis.cn/、 论坛 5.下载windows版本在Github上下载，很久没有更新，Redis官方推荐使用Linux版本 三、Redis 安装1.windows环境github下载，放在指定的目录下，直接解压文件，Redis很小，只有几兆 redis-server.exe：启动服务端 redis-cli.exe：启动客户端 redis-check-aof.pdb：检查持久化文件是否正确 redis-benchmark.exe：测试性能 启动服务端双击redis-server，启动服务端，Redis默认端口号6379， 如果启动服务端发现闪退，可能是重复启动导致的，进入任务管理器关闭旧的即可 启动客户端双击redis-cli，默认连接6379端口，使用ping测试是否连接正常 测试存储，设置一个k-v，并获取值，如， set name jack get name window下使用很简单，但是Redis推荐我们使用Linux环境使用！官方已经不维护了，只是微软在维护而已windows环境下也可以使用RedisDesktopManager来作为客户端界面， 2.Linux安装下载官网下载：https://redis.io/download 使用VMware启动Linux，MobaXterm连接Linux将Redis压缩包上传到Linux中，进入到上传目录，解压Redis压缩包，将程序移动到opt目录下（推荐放在此处）， tar -zxvf redis-6.2.0.tar.gz mv redis-6.2.0 /opt 环境Redis运行需要C++环境，安装C++，查看C++版本状态 yum install gcc-c++ gcc-v 安装进入Redis解压缩的目录，执行make命令，开始安装Redis（需要一段时间），make insall确认一下 cd redis-6.2.0/ make make install Redis默认安装目录在/usr/local/bin中，这里的目录就相当于windows中解压缩后进入的目录 配置文件在当前目录下新建一个配置文件目录，将Redis解压文件中的redis.con配置文件复制到其中 以后使用这个复制的配置文件启动Redis mkdir rconfig cp /opt/redis-6.2.0/redis.conf rconfig/ 启动Redis默认不是后台启动，将其修改为后台启动，编辑配置文件， vim命令不好使的，需要在线安装vim，自行百度搜方法 vim redis.conf i开始插入编辑，这里修改为yes表示可以后台启动，esc退出编辑，:wq退出配置文件回到bin目录，通过配置文件启动Redis服务端 redis-server rconfig/redis.conf 启动客户端，连接服务 redis-cli -p 6379 测试连接，测试存储查看Redis进程命令 ps -ef|grep redis 关闭在客户端连接中，使用命令shutdown关闭服务端，退出客户端即可 shutdown exit 3.测试性能bin目录下的redis-benchmark，官方自带 如，测试100个并发，100000个并发请求 确保客户端连接服务，再开启一个新的连接窗口，进入到bin目录新窗口bin目录中执行测试命令 redis-benchmark -h localhost -p 6379 -c 100 -n 100000 分析结果写入测试，100000个请求，0.84秒完成，100个并发，每次写入3字节，保持1个连接完成多少百分比的请求量所消耗的时间计算结果，每秒处理119189.52个请求 四、Redis 基础知识Redis默认16个数据库，默认使用的是第一个数据库，select *指令可以切换，配置文件中可以查看到， 基础指令以下指令在客户端连接状态下使用 #切换数据库 select num(0-15) #查看数据库大小 dbsize #查看数据库所有的key keys * #清空当前数据库 flushdb #清除所有数据库 flushall Redis单线程Redis速度很快，基于内存操作，性能瓶颈不在CPU，而是内存和网络带宽，我们使用Redis用单线程即可 多线程的CPU上下文切换比较耗时，所有对于Redis来说，单线程效率最高 1.五大数据类型提示：五大基本数据类型的操作使用需要熟练掌握，因为Java操作Redis的API都是基于Redis原生操作来定义的 Redis-Keykey泛指键，value泛指值，以实际为准 查看所有key keys * 判断某一个key是否存在 exist key 将数据移动到指定的数据库中 move key num(数据库编号) 设置某一条数据的过期时间,t的单位是秒 expire key t 查看某条数据的剩余生命时长，-2表示没了 ttl key 查看key的类型 type key String(字符串)赋值、取值、追加、长度 set key value get key #向key对应的值后面追加value，如果当前key不存在，则相当于set key value append key value #查看key对应的值的长度 strlen key 自增减、步长 #给key的值+1，常用于计数，如网页浏览量 incr key #将key的值-1 decr key #增减时设置增减步长 incrby key num decrby key num 截取 #截取字符串，从num1-num2，0到-1表示查看全部字符串 getrange key num1 num2 替换 #替换字符串，从offset处开始 setrange key offset value 判断，分布式锁中经常使用 #如果key存在，则设置过期时间和key的值 setex key seconds value #如果key不存在，则创建新的key和value，如果这个key存在，那么也不会设置成功，值也不会覆盖 批量处理，原子性 #批量设置键值对k1-v1,k2-v2,k3-v3 mset k1 v1 k2 2 k3 v3 #批量获取值 mget k1 k2 k3 #批量设置，如果不存在，则设置k-v，只要其中有一个是存在的，则整体设置不成功，体现出原子性 msetnx k1 v1 k2 v2 k3 v3 利用Redis批量设置，可以这样保存json格式的对象 对象名:对象id:属性名 作为Redis的key，属性值 作为Redis的value先get再set，不存在则返回nil并设置新的值，如果存在则返回旧的值并设置新的值 #先get再set，返回的是get的值，值会被覆盖 getset key value 总结：Redis String类型可以用作计数器、统计多单位数量、浏览量、对象缓存等 List（列表）基本数据类型，列表 Redis中，可以将list当做栈、队列、阻塞队列来使用，所有的list命令都用l开头 很多命令都是左右对称可以使用的，我们主要以左侧举例，右侧镜像可以自行测试 从头部（左侧）操作，赋值、取值，先进后出 #向key列表赋值,按照入栈顺序 listpush key element #从key列表取值,按照出栈顺序,0到-1表示所有 lrange key start stop 从尾部（右侧）操作 lrange list start stop 当做数组使用，使用下标 #从数组key中取值，下标为index lindex key index 获取队列长度， 同一个队列中可以有重复的值 移除队列中指定的值，如果这个值在队列中只有一个，移除个数就是1，如果有多个，可以指定移除多个这样的值 #移除队列中的值，可以指定移除个数 lrem list count element 截取指定区间的元素，通过下标，永久性修改了队列 ltrim list start stop 组合命令，可以实现上述功能组合后的效果 移除列表最后一个元素，或者说从右侧弹出一个元素，放到新的队列中，返回值就是弹出的那个元素 #移除最后（右侧）的元素，放在新的队列中，左侧入栈 rpoplpush source destination 判断队列是否存在，如果存在则，如果不存在则 #判断是否存在队列 exists key #如果队列存在，则将指定索引出的值进行更新，如果队列不存在，则没有效果，如果队列存在索引不存在，也报错 lset list index element 在指定的元素（值，不是索引）处插入一个值，指定在前面插入，或在后面插入 linsert key before|after pivot element 总结： list实际上是一个链表，before node after，left，right 都可以插入值 如果key不存在，则创建新链表 如果key存在，则新增内容 如果移除所有值，成为空链表，代表不存在， 对于链表而言，在两端的值操作值效率最高，对中间的值操作效率略低 消息排队，lpush rpop 表示左进右出，相当于消息队列，lpush lpop 表示左进左出，相当于栈 Set（集合）因为无序，所以存储的值不可重复，命令以s开头 添加集合元素，查看集合元素，判断某个元素是否存在 #向名为key的集合添加元素member sadd key member #显示集合key中所有元素 smembers key #判断集合key中是否存在元素member sismember key member 获取集合中元素个数 #获取集合key中元素的个数 scard key 移除集合中的指定元素 #移除集合key中的指定元素member srem key member 随机取出指定个数的元素 #随机从集合key中抽选指定个数的元素，没有指定个数就是默认1 srandmember key [count] 删除元素 #随机移除指定个数的元素，没有指定个数就是默认1 spop key [count] 将集合中元素移动到另一个集合中 #将集合key中的元素member移动到新的集合destination中 smove key destination member 两个集合之间的运算，应用在比如，共同通讯好友，共同关注上 #集合key1中减去集合key2与集合key1的交集，得到的剩余部分，如果key2没有指定得到的还是完整的key1 sdiff key1 [key2] #集合key1与集合key2做交集，如果key2没有指定，则得到完整的key1 sinter key1 [key2] #集合key1与集合key2做并集，如果key2没有指定，则得到完整的key1 sunion key1 [key2] Hash（HashMap集合、散列表、链表数组）与String类型类似，只不过每个元素变成了一个键值对 Hash类型的命令以h开头 赋值、取值、键不可重复，如果键相同则新值覆盖旧值 #向集合key中存入键值对，键为field，值为value hset key field value #向集合key中存入多个键值对，field1-value1，field2-value2... hmset key field1 value1 field2 value2 #根据键获取集合key中的多个值 hmget key field1 field2 #获取集合Key中的所有的键值对 hgetall key 删除 #根据键field删除集合key中的指定键值对 hdel key field 长度 #查看集合key的长度，元素个数 hlen key 判断 #根据键field判断集合key中是否存在该键值对 hexists key field 只获取键，只获取值 #只获取集合Key中的键 hkeys key #只获取集合key中的值 hvals key 自增长 #设置集合key中的键值对中的值增长，并指定步长increment hincrby key field increment 判断元素如果存在，如果不存在 #判断指定的键是否存在，如果不存在，则指定值，如果存在，则设置不成功 hsetnx key field value 存储对象，可变更数据，对象信息的保存，前面String类型也可以存对象，但是推荐使用Hash类型存储对象 如，将对象名:对象id作为集合，属性名作为键，属性值作为值，可以同时给集合添加多个属性名、属性值 对象名:id 只是一种规范，自己也可设置其他规范 Zset（有序集合）还是集合，在Set类型基础上，增加一个值score，值可以用来实现排序，命令以z开头 赋值、 #集合key添加元素member，元素的值为score zadd key score member #添加多个元素 zadd key score1 member1 score2 member2 #获取范围内的值，0到-1为全部的值，这里的范围编号和score不同，注意区分 zrange key start stop #降序 zrevrange key start stop 排序 #根据score的大小，展示范围内的元素，-inf +inf 表示正无穷、负无穷，这个范围代表集合中的所有元素 #m默认升序，withscores表示结果中包含scores值 zrangebyscore key min max [witscores] [limit offset count] 移除， #移除集合key中的元素member zrem key member 统计 #统计集合key总的元素个数 zcard key #根据score的区间范围，统计元素个数，范围含头含尾 zcount key min max 使用场景：需要set排序，如成绩表，薪资表，需要使用权重判断，排行榜等 2.三种特殊数据类型geospatial定位、附近人、地理位置推算距离， http://www.redis.cn/commands/geoadd.html 添加地理位置，南北极无法直接添加，通常会下载城市数据直接导入 地理数据与实际地图吻合不可乱写，否则会计算错误 有效的经度从-180度到180度。 有效的纬度从-85.05112878度到85.05112878度。 当坐标位置超出上述指定范围时，该命令将会返回一个错误。 #向集合key中添加元素member的经度longitude、纬度latitude，可以一次添加多个位置 geoadd key longitude latitude member #获取地理位置 geopos key member 定位之间距离 m 表示单位为米。 km 表示单位为千米。 mi 表示单位为英里。 ft 表示单位为英尺 #返回两个位置之间的距离 geodist key member1 member2 [m|km|mi|ft] 获取半径内的元素 #以给定经纬度longitude latitude为中心，找出半径radius内的元素， #可以选择是否返回元素到中心的距离、经纬度、限制查询的个数 georadius key longitude latitude radius [m|km|mi|ft] [withdist] [withcoord] [count count] 根据已有的元素，筛选范围内其他元素 #给定一个元素，查找半径内的其他元素 #可以选择是否返回查找的元素到中心的距离、经纬度、限制查询的个数 georadiusbymember key member radius [m|km|mi|ft] [withdist] [withcoord] [count count] 返回元素的Hash，该命令将返回11个字符的Geohash字符串，不常用 geohash key member1 member2 geo底层实现原理还是zset，所以可也以使用zset命令来操作地理位置，如查看全部元素、移除元素 Hyperloglogs基数：指一个集合中不重复的元素的个数 Redis HyperLogLog 是用来做基数统计的算法 用途：同一个人访问多次，可以算作一个访问人。 传统的方式使用set集合，统计id，如果用户数据量很大就会比较麻烦，消耗资源， 而Redis HyperLogLog 底层数据结构就是去重统计基数，占用内存非常小，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数，但是有0.81%的错误率，统计UV时可以忽略不计 新增，统计 #添加元素 pfadd key member [member] #统计集合元素个数 pfcount key #统计多个集合总的元素个数，也会自动去重 pfcount key [key] 合并，去重 #合并多个集合，自动去重复元素,合并之后的集合替换掉destkey,sourcekey不变 pfmerge destkey sourcekey [sourcekey] Bitmaps在开发中，可能会遇到这种情况：需要统计用户的某些信息，如活跃或不活跃，登录或者不登录；又如需要记录用户一年的打卡情况，打卡了是1， 没有打卡是0，如果使用普通的 key/value存储，则要记录365条记录，如果用户量很大，需要的空间也会很大，所以 Redis 提供了 Bitmap 位图这中数据结构，Bitmap 就是通过操作二进制位来进行记录，即为 0 和 1；如果要记录 365 天的打卡情况，使用 Bitmap 表示的形式大概如下：0101000111000111…，这样有什么好处呢？当然就是节约内存了，365 天相当于 365 bit，又 1 字节 = 8 bit , 所以相当于使用 46 个字节即可 通俗理解： 当我们使用标记存储两种状态时，如果用一个变量存一个标记太浪费资源，现在将所有标记统一放在一条二进制数据上，每一位都用0或1对应一个标记，大大节约空间 bitmap位图这种数据结构，使用二进制操作数据， 新增、查看、统计 #向key中存入数据，offet相当于下标，记录位置，从0开始，value只能是0和1，对应我们所需的状态 setbit key offet value #查看指定位置的状态 getbit key offet #统计二进制数据上1的个数，可以加范围,start 和 end 参数的设置和 GETRANGE 命令类似,都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，以此类推 bitcount key [start end] 3.Redis 事务事物的本质是一组命令一块执行，事务执行是，里面的命令按照顺序执行，一次性，顺序性，排他性 Redis事务没有隔离级别的概念，因为所有命令在事务中没有直接执行，只有发起命令的时候才会执行exec Redis单条命令保证原子性，但Redis整个事务不保证原子性，原因见下面 开启事务 multi 命令入队 执行事务 exec 放弃事务 discard 编译异常 开启事务后，当出现代码异常，直至提交事务，这段期间的命令都不会执行， 这种情况在Java中比较少见，因为Java操作Redis基本不会出现代码异常 运行异常 开启事务后，执行命令，提交事务，如果运行期间出现问题，除了异常命令，其他命令正常执行 所以说，Redis单条命名保证原子性，但整个Redis事务无法保证原子性结论： Redis单条命令保证原子性，因为Redis是单线程 Redis整个事务不保证原子性，因为开启事务时并没有执行命令，而是提交之后统一执行 这与MySQL截然不同，注意区分 4.Redis实现乐观锁悲观锁：一开始就认为会出现问题，所以什么时候都加锁 乐观锁：认为不会出现问题，只有在需要的时候才会判断是否有必要加锁 Redis使用监视命令 watch ，配合Redis事务一起使用 正常执行成功时 模拟多线程问题 第一个线程，监视数据，开启事务，但没有提交打开新窗口，新客户端同样连接6379，模拟多线程操作，修改被监视的数据 然后第一个线程提交事务，发现被监视的元素被篡改，返回nil表示当前线程的整个事务提交失败 数据按照另一个线程修改为准 Redis的这种监视事务的机制，相当于实现了Redis乐观锁 当监视出现事务执行失败后，先取消监视unwatch key ，再去重新开始监视，开启事务 五、Java 操作 Redis1.Jedis 官方原生API概念Redis官方推荐的Java开发工具，实际中可能不常用，但是与Redis原生API关联非常紧密，一定要熟练掌握 项目、依赖在maven项目中导入Jedis依赖，maven镜像搜索坐标，地址：https://mvnrepository.com/ 导入jedis fastjson 依赖 &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.70&lt;/version&gt; &lt;/dependency&gt; 连接、测试开启redis服务端，默认端口号6379创建Jedis对象，添加连接参数，测试连接 注意：如果是连接Linux中的Redis，先将redis.conf配置文件中的IP绑定注释掉，保护模式关闭，Jedis才能正产连接 public class demo1 &#123; public static void main(String[] args) &#123; //创建对象,连接 Jedis jedis = new Jedis(&quot;192.168.126.130&quot;, 6379); //连接测试 System.out.println(jedis.ping()); &#125; &#125; 常用APIJedis的所有命令都是基于Redis原生命令，在这里命令变成了方法 Key操作public class demo2 &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.126.130&quot;, 6379); System.out.println(&quot;清空当前数据库: &quot;+jedis.flushDB()); System.out.println(&quot;判断: &quot;+jedis.exists(&quot;k1&quot;)); System.out.println(&quot;添加: &quot;+jedis.set(&quot;k1&quot;, &quot;v1&quot;)); System.out.println(&quot;添加: &quot;+jedis.set(&quot;k2&quot;, &quot;v2&quot;)); Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;); System.out.println(&quot;列出所有key: &quot;+keys); System.out.println(&quot;删除: &quot;+jedis.del(&quot;k1&quot;)); System.out.println(&quot;判断: &quot;+jedis.exists(&quot;k1&quot;)); System.out.println(&quot;查看键对应的值的类型: &quot;+jedis.type(&quot;k2&quot;)); System.out.println(&quot;随机返回一个key: &quot;+jedis.randomKey()); System.out.println(&quot;重命名key: &quot;+jedis.rename(&quot;k2&quot;, &quot;k3&quot;)); System.out.println(&quot;获取元素: &quot;+jedis.get(&quot;k3&quot;)); System.out.println(&quot;根据索引查询: &quot;+jedis.select(0)); System.out.println(&quot;清空当前数据库: &quot;+jedis.flushDB()); System.out.println(&quot;数据库key数量: &quot;+jedis.dbSize()); System.out.println(&quot;清空所有数据库的key: &quot;+jedis.flushAll()); &#125; &#125; String类型public class demo3 &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.126.130&quot;, 6379); System.out.println(&quot;添加元素&quot;); System.out.println(jedis.set(&quot;k1&quot;, &quot;v1&quot;)); System.out.println(jedis.set(&quot;k2&quot;, &quot;v2&quot;)); System.out.println(jedis.set(&quot;k3&quot;, &quot;v3&quot;)); System.out.println(&quot;删除: &quot;+jedis.del(&quot;k2&quot;)); System.out.println(&quot;取值: &quot;+jedis.get(&quot;k2&quot;)); System.out.println(&quot;修改值: &quot;+jedis.set(&quot;k1&quot;, &quot;v11&quot;)); System.out.println(&quot;取值: &quot;+jedis.get(&quot;k1&quot;)); System.out.println(&quot;追加值: &quot;+jedis.append(&quot;k3&quot;, &quot;end&quot;)); System.out.println(&quot;取值: &quot;+jedis.get(&quot;k3&quot;)); System.out.println(&quot;添加多个元素: &quot;+jedis.mset(&quot;k4&quot;,&quot;v4&quot;,&quot;k5&quot;,&quot;v5&quot;)); System.out.println(&quot;获取多个值: &quot;+jedis.mget(&quot;k4&quot;,&quot;k5&quot;,&quot;k6&quot;)); System.out.println(&quot;删除多个元素: &quot;+jedis.del(&quot;k4&quot;,&quot;k5&quot;)); System.out.println(&quot;获取多个值: &quot;+jedis.mget(&quot;k3&quot;,&quot;k4&quot;,&quot;k5&quot;)); System.out.println(&quot;清空: &quot;+jedis.flushDB()); System.out.println(&quot;新增键值对,防止被覆盖&quot;); System.out.println(&quot;第一次赋值: &quot;+jedis.setnx(&quot;k1&quot;, &quot;v1&quot;)); System.out.println(&quot;第一次赋值: &quot;+jedis.setnx(&quot;k2&quot;, &quot;v2&quot;)); System.out.println(&quot;覆盖原值: &quot;+jedis.setnx(&quot;k2&quot;, &quot;v2new&quot;)); System.out.println(&quot;取值: &quot;+jedis.get(&quot;k1&quot;)); System.out.println(&quot;取值: &quot;+jedis.get(&quot;k2&quot;)); System.out.println(&quot;添加元素设置生命周期: &quot;+jedis.setex(&quot;k3&quot;, 2, &quot;v3&quot;)); System.out.println(&quot;取值: &quot;+jedis.get(&quot;k3&quot;)); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;过期后取值: &quot;+jedis.get(&quot;k3&quot;)); System.out.println(&quot;获取原值,并更新: &quot;+jedis.getSet(&quot;k2&quot;, &quot;v2abc&quot;)); System.out.println(&quot;获取新的值: &quot;+jedis.get(&quot;k2&quot;)); System.out.println(&quot;截取部分字符串: &quot;+jedis.getrange(&quot;k2&quot;, 2, 4)); &#125; &#125; List集合public class demo4 &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.126.130&quot;, 6379); System.out.println(&quot;清空数据: &quot;+jedis.flushDB()); System.out.println(&quot;新增元素&quot;); System.out.println(jedis.lpush(&quot;list&quot;, &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;)); System.out.println(jedis.lpush(&quot;list&quot;, &quot;d&quot;)); System.out.println(jedis.lpush(&quot;list&quot;, &quot;e&quot;)); System.out.println(jedis.lpush(&quot;list&quot;, &quot;f&quot;)); System.out.println(&quot;查看所有: &quot;+jedis.lrange(&quot;list&quot;, 0, -1)); System.out.println(&quot;查看区间数据: &quot;+jedis.lrange(&quot;list&quot;, 0, 3)); System.out.println(&quot;删除列表中指定的值,第二参数为删除的个数(有重复时),后进先出原则,相当于出栈&quot;); System.out.println(&quot;删除指定值的元素: &quot;+jedis.lrem(&quot;list&quot;, 2, &quot;d&quot;)); System.out.println(&quot;查看所有: &quot;+jedis.lrange(&quot;list&quot;, 0, -1)); System.out.println(&quot;删除区间以外的元素: &quot;+jedis.ltrim(&quot;list&quot;, 0, 3)); System.out.println(&quot;查看所有: &quot;+jedis.lrange(&quot;list&quot;, 0, -1)); System.out.println(&quot;左侧弹出: &quot;+jedis.lpop(&quot;list&quot;)); System.out.println(&quot;查看所有: &quot;+jedis.lrange(&quot;list&quot;, 0, -1)); System.out.println(&quot;右侧新增: &quot;+jedis.rpush(&quot;list&quot;, &quot;g&quot;)); System.out.println(&quot;查看所有: &quot;+jedis.lrange(&quot;list&quot;, 0, -1)); System.out.println(&quot;右侧弹出: &quot;+jedis.rpop(&quot;list&quot;)); System.out.println(&quot;查看所有: &quot;+jedis.lrange(&quot;list&quot;, 0, -1)); System.out.println(&quot;修改指定下标元素: &quot;+jedis.lset(&quot;list&quot;, 1, &quot;new&quot;)); System.out.println(&quot;查看所有: &quot;+jedis.lrange(&quot;list&quot;, 0, -1)); System.out.println(&quot;队列长度: &quot;+jedis.llen(&quot;list&quot;)); System.out.println(&quot;获取指定下标元素: &quot;+jedis.lindex(&quot;list&quot;, 2)); System.out.println(&quot;新增元素: &quot;+jedis.lpush(&quot;list1&quot;, &quot;4&quot;,&quot;2&quot;,&quot;0&quot;,&quot;6&quot;,&quot;5&quot;,&quot;8&quot;)); System.out.println(&quot;查看所有: &quot;+jedis.lrange(&quot;list1&quot;, 0, -1)); System.out.println(&quot;排序: &quot;+jedis.sort(&quot;list1&quot;)); System.out.println(&quot;查看所有: &quot;+jedis.lrange(&quot;list1&quot;, 0, -1)); &#125; &#125; Set集合public class demo5 &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.126.130&quot;,6379); jedis.flushDB(); System.out.println(&quot;新增元素,不可重复&quot;); System.out.println(jedis.sadd(&quot;set1&quot;, &quot;s0&quot;,&quot;s1&quot;,&quot;s2&quot;,&quot;s3&quot;,&quot;s4&quot;,&quot;s5&quot;,&quot;s7&quot;,&quot;s8&quot;)); System.out.println(jedis.sadd(&quot;set1&quot;, &quot;s6&quot;)); System.out.println(jedis.sadd(&quot;set1&quot;, &quot;s6&quot;)); System.out.println(&quot;列出所有元素: &quot;+jedis.smembers(&quot;set1&quot;)); System.out.println(&quot;删除一个元素: &quot;+jedis.srem(&quot;set1&quot;, &quot;s0&quot;)); System.out.println(&quot;列出所有元素: &quot;+jedis.smembers(&quot;set1&quot;)); System.out.println(&quot;删除元素: &quot;+jedis.srem(&quot;set1&quot;, &quot;s6&quot;,&quot;s7&quot;)); System.out.println(&quot;随机移除一个元素: &quot;+jedis.spop(&quot;set1&quot;)); System.out.println(&quot;随机移除一个元素: &quot;+jedis.spop(&quot;set1&quot;)); System.out.println(&quot;列出所有元素: &quot;+jedis.smembers(&quot;set1&quot;)); System.out.println(&quot;查看元素个数: &quot;+jedis.scard(&quot;set1&quot;)); System.out.println(&quot;判断是否存在某个元素: &quot;+jedis.sismember(&quot;set1&quot;, &quot;s3&quot;)); System.out.println(&quot;判断某个元素是否存在: &quot;+jedis.sismember(&quot;set1&quot;, &quot;s1&quot;)); System.out.println(jedis.sismember(&quot;set1&quot;, &quot;s5&quot;)); System.out.println(&quot;================&quot;); System.out.println(&quot;新增: &quot;+jedis.sadd(&quot;set2&quot;, &quot;s0&quot;,&quot;s1&quot;,&quot;s2&quot;,&quot;s4&quot;,&quot;s5&quot;,&quot;s7&quot;,&quot;s8&quot;)); System.out.println(&quot;新增: &quot;+jedis.sadd(&quot;set3&quot;, &quot;s0&quot;,&quot;s1&quot;,&quot;s2&quot;,&quot;s4&quot;,&quot;s8&quot;)); System.out.println(&quot;set2中删除,并存到另一集合上 : &quot;+jedis.smove(&quot;set2&quot;, &quot;set3&quot;, &quot;s1&quot;)); System.out.println(&quot;set2中删除,并存到另一集合上 : &quot;+jedis.smove(&quot;set2&quot;, &quot;set3&quot;, &quot;s1&quot;)); System.out.println(&quot;删除元素并放在新集合中 :&quot;+jedis.smove(&quot;set2&quot;, &quot;set3&quot;, &quot;s2&quot;)); System.out.println(&quot;列出所有元素: &quot;+jedis.smembers(&quot;set2&quot;)); System.out.println(&quot;列出所有元素: &quot;+jedis.smembers(&quot;set3&quot;)); System.out.println(&quot;交集: &quot;+jedis.sinter(&quot;set2&quot;,&quot;set3&quot;)); System.out.println(&quot;并集: &quot;+jedis.sunion(&quot;set2&quot;,&quot;set3&quot;)); System.out.println(&quot;差集: &quot;+jedis.sdiff(&quot;set2&quot;,&quot;set3&quot;)); System.out.println(&quot;交集保存到集合中: &quot;+jedis.sinterstore(&quot;set4&quot;, &quot;set2&quot;,&quot;set3&quot;)); System.out.println(&quot;列出所有元素: &quot;+jedis.smembers(&quot;set4&quot;)); &#125; &#125; Hashpublic class demo6 &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.126.130&quot;,6379); System.out.println(&quot;清空当前数据库&quot;); jedis.flushDB(); Map&lt;String,String&gt; map = new HashMap(); map.put(&quot;k1&quot;, &quot;v1&quot;); map.put(&quot;k2&quot;, &quot;v2&quot;); map.put(&quot;k3&quot;, &quot;v3&quot;); map.put(&quot;k4&quot;, &quot;v4&quot;); System.out.println(&quot;添加map集合&quot;); jedis.hmset(&quot;hash&quot;, map); System.out.println(&quot;添加元素: &quot;+jedis.hset(&quot;hash&quot;, &quot;k5&quot;,&quot;v5&quot;)); System.out.println(&quot;所有键值对: &quot;+jedis.hgetAll(&quot;hash&quot;)); System.out.println(&quot;所有键: &quot;+jedis.hkeys(&quot;hash&quot;)); System.out.println(&quot;所有值: &quot;+jedis.hvals(&quot;hash&quot;)); System.out.println(&quot;给一个键保存整数,如果该键不存在则添加: &quot;+jedis.hincrBy(&quot;hash&quot;, &quot;k6&quot;, 6)); System.out.println(&quot;所有键值对: &quot;+jedis.hgetAll(&quot;hash&quot;)); System.out.println(&quot;添加或修改: &quot;+jedis.hincrBy(&quot;hash&quot;, &quot;k6&quot;, 60)); System.out.println(&quot;所有键值对: &quot;+jedis.hgetAll(&quot;hash&quot;)); System.out.println(&quot;删除一个或多个元素: &quot;+jedis.hdel(&quot;hash&quot;, &quot;k2&quot;)); System.out.println(&quot;所有元素: &quot;+jedis.hgetAll(&quot;hash&quot;)); System.out.println(&quot;元素个数: &quot;+jedis.hlen(&quot;hash&quot;)); System.out.println(&quot;判断元素是否存在: &quot;+jedis.hexists(&quot;hash&quot;, &quot;k2&quot;)); System.out.println(&quot;判断元素是否存在: &quot;+jedis.hexists(&quot;hash&quot;, &quot;k3&quot;)); System.out.println(&quot;根据键获取值: &quot;+jedis.hmget(&quot;hash&quot;, &quot;k3&quot;)); System.out.println(&quot;根据键获取值: &quot;+jedis.hmget(&quot;hash&quot;, &quot;k3&quot;,&quot;k4&quot;)); &#125; &#125; Jedis 事务使用 multi 方法 public class demo7 &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.126.130&quot;,6379); JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;hello&quot;, &quot;world&quot;); jsonObject.put(&quot;hi&quot;, &quot;Java&quot;); jedis.flushDB(); System.out.println(&quot;开启事务&quot;); Transaction multi = jedis.multi(); String result = jsonObject.toJSONString(); try &#123; multi.set(&quot;k1&quot;, result); multi.set(&quot;k2&quot;, result); // 模拟异常 // int i = 1/0; multi.exec();//提交事务 &#125; catch (Exception e) &#123; multi.discard();//回滚事务 e.printStackTrace(); &#125; finally &#123; System.out.println(jedis.get(&quot;k1&quot;)); System.out.println(jedis.get(&quot;k2&quot;)); jedis.close();//关闭连接 &#125; &#125; &#125; 成功 失败如果使用watch方法，可以监控，在try catch中进行判断监控结果，根据情况抛异常 2.SpringBoot 整合 RedisSpringData 用来操作各种数据库的整合 项目准备新建springboot项目模块，勾选Redis依赖，其他根据需要 删除模块里的这些文件，暂时不需要pom文件依赖 java web, redis, fastjson 注意： 有些版本springboot连接redis使用jedis，有些使用lettuce jedis采用直连，多个线程下不安全，使用连接池可以解决 采用netty，实例可以在多个线程中共享，没有现成安全情况，像NIO模式，性能高一些 使用连接池尽量选用lecttuce的，功能更强大，支持的类更多 主配置文件 Redis地址，端口号 Redis测试先通过redistemplate对象调出所需的Redis操作对象，再进一步调用数据库方法API 进入Redistemplate源码，可以看到所有的操作API 序列化问题对象存入Redis之前需要序列化，否则可能出现中文乱码 使用jdk自带序列化方案 @Component @AllArgsConstructor @NoArgsConstructor @Data public class User implements Serializable &#123; private Integer age; private String name; &#125; 测试存入Redis @Test void test1() throws Exception&#123; User user = new User(18,&quot;螺蛳粉&quot;); String jsonUser = new ObjectMapper().writeValueAsString(user);//对象转json字符串 redisTemplate.opsForValue().set(&quot;user&quot;, jsonUser);//存入set集合 Object user1 = redisTemplate.opsForValue().get(&quot;user&quot;); System.out.println(user1); &#125; 自己配置序列化方案，准备配置类，自己配置bean对象，公司常用这个模板 @Configuration public class RedisConfig &#123; //手动修改redisTemplate,常见的固定模板 @Bean public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; // 连接 RedisTemplate&lt;String,Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); // 创建json的序列化配置 Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // 创建string的序配置 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); // key采用string序列化配置 template.setKeySerializer(stringRedisSerializer); // value采用jackson序列化配置 template.setValueSerializer(jackson2JsonRedisSerializer); // hash key采用string序列化配置 template.setHashKeySerializer(stringRedisSerializer); // hash value采用value序列化方案 template.setHashValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; &#125; &#125; 注入RedisTemplate时选择我们配置的Bean对象运行测试，查看Redis数据库，这样使用我们自己定义的Redis序列化配置，更好用，如果不配置默认使用jdk自带序列化方案，可能会出现中文乱码或者转义斜杠等问题 自己写工具类 实际生产中通常不直接使用RedisTemplate原生API，而是自己准备RedisUtils工具类，需要使用时直接注入属性，调用方法 如， @Component public class RedisUtil &#123; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; // 设置失效时间 public boolean expire(String key, long time) &#123; try &#123; if (time&gt;0) &#123; redisTemplate.expire(key, time, TimeUnit.SECONDS); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; // 获取过期时间 public long getExpire(String key) &#123; return redisTemplate.getExpire(key, TimeUnit.SECONDS); &#125; // 判断key是否存在 public boolean hasKey(String key) &#123; try &#123; return redisTemplate.hasKey(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; // 删除缓存 public void del(String... key) &#123; if (key != null &amp;&amp; key.length&gt;0) &#123; if (key.length == 1) &#123; redisTemplate.delete(key[0]); &#125; else &#123; redisTemplate.delete(String.valueOf(CollectionUtils.arrayToList(key))); &#125; &#125; &#125; // 添加值 public boolean set(String key, Object value) &#123; try &#123; redisTemplate.opsForValue().set(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; // 取值 public Object get(String key, Object value) &#123; return key == null ? null : redisTemplate.opsForValue().get(key); &#125; // 存入普通缓存设置时间 public boolean set(String key, Object value, long time) &#123; try &#123; if (time &gt; 0) &#123; redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS); &#125; else &#123; set(key, value); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; // 设置递增 public long incr(String key, long delta) &#123; if (delta &lt; 0) &#123; throw new RuntimeException(); &#125; return redisTemplate.opsForValue().increment(key, delta); &#125; // 设置递减 public long decr(String key, long delta) &#123; if (delta &lt; 0) &#123; throw new RuntimeException(); &#125; return redisTemplate.opsForValue().increment(key, -delta); &#125; // Hash get public Object hget(String key, String item) &#123; return redisTemplate.opsForHash().get(key, item); &#125; // Hash get 获取对应的所有值 public Map&lt;Object,Object&gt; hmget(String key) &#123; return redisTemplate.opsForHash().entries(key); &#125; // Hash set public boolean hmset(String key, Map&lt;String, Object&gt; map) &#123; try &#123; redisTemplate.opsForHash().putAll(key, map); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; // Hash set 并设置时间 public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) &#123; try &#123; redisTemplate.opsForHash().putAll(key, map); if (time &gt; 0) &#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; // 存入数据，如果不存在则新增 public boolean hset(String key, String item, Object value) &#123; try &#123; redisTemplate.opsForHash().put(key, item, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; // 存入数据，设置时间，如果不存在则新增 public boolean hset(String key, String item, Object value, long time) &#123; try &#123; redisTemplate.opsForHash().put(key, item, value); if (time &gt; 0) &#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; // 删除 public void hdel(String key, Object... item)&#123; redisTemplate.opsForHash().delete(key, item); &#125; // 判断是否有该值 public boolean hHasKey(String key, String item) &#123; return redisTemplate.opsForHash().hasKey(key, item); &#125; // 存入值，如果不存在则新增，并设置时间 public double hincr(String key, String item, double by) &#123; return redisTemplate.opsForHash().increment(key, item, by); &#125; // 设置递减 public double hdecr(String key, String item, double by) &#123; return redisTemplate.opsForHash().increment(key, item, -by); &#125; // set 获取值 public Set&lt;Object&gt; sGet(String key) &#123; try &#123; return redisTemplate.opsForSet().members(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; // 查询是否存在 public boolean sHasKey(String key, Object value) &#123; try &#123; return redisTemplate.opsForSet().isMember(key, value); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; // 存入值 public long sSet(String key, Object... values) &#123; try &#123; return redisTemplate.opsForSet().add(key, values); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; // 存入职，并设置时间 public long sSet(String key, long time, Object... values) &#123; try &#123; long count = redisTemplate.opsForSet().add(key, values); if (time &gt; 0) &#123; expire(key, time); &#125; return count; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; // 获取值的数量 public long sGetSetSize(String key) &#123; try &#123; return redisTemplate.opsForSet().size(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; // 移除值 public long setRemove(String key, Object... values) &#123; try &#123; long count = redisTemplate.opsForSet().remove(key, values); return count; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; // list相关API &#125; 六、Redis 高级1.redis.conf 配置文件redis.conf 配置了Redis的详细参数，Redis启动需要使用配置文件 进入 redis.conf 编辑状态，分析配置参数，vim redis.conf 规定单位，单位书写对大小写不敏感可以包含其他配置文件，将多个配置文件组合起来NETWORK 网络配置，重点绑定IP，只能使用指定的IP地址链接 bind 127.0.0.1 保护模式 yes/no，保护模式下只能本机连接 protected-mode no 连接端口号 port 6379 GENERAL 通用配置，是否后台运行 yes/no daemonize yes 管理守护进程的，一般不用动 # supervised auto 如果选择后台运行，则指定一个pid进程文件 pidfile /var/run/redis_6379.pid 日志级别，注释里有详解极少各个级别的用途 loglevel notice 生成日志的位置，空则使用默认 logfile &quot;&quot; 默认数据库数量 16 databases 16 是否显示启动logo always-show-logo no SNAPSHOTTING 快照持久化策略，如，这里表示， save 900 1 #900秒内，至少有一个key发生修改，则进行持久化操作 save 300 10 #300秒内，至少有10个key发生修改，则进行持久化 save 60 10000 #60秒内，至少有10000个key发生修改，则进行持久化 持久化出现错误，是否继续工作 stop-writes-on-bgsave-error yes 是否压缩rdb文件，会消耗一定cpu资源 rdbcompression yes 保存rdb文件时，是否进行校验 rdbchecksum yes 持久化文件存放目录，默认在当前文件目录 dir ./ REPLICATION 主从复制，后面详解SECURITY 安全 设置密码，默认没有 # requirepass foobared 在Redis客户单，执行命令可以操作当前密码， 如果设置密码后发现操作无权限，只需要在客户端验证密码即可 auth 密码CLIENTS 客户端设置最大客户端连接数，默认10000 # maxclients 10000 MEMORY MANAGEMENT 内存设置Redis最大内存 # maxmemory &lt;bytes&gt; 内存达到上限的处理策略 volatile-lru：只对设置了过期时间的key进行LRU（默认值） allkeys-lru ： 删除lru算法的key volatile-random：随机删除即将过期key allkeys-random：随机删除 volatile-ttl ： 删除即将过期的 noeviction ： 永不过期，返回错误 # maxmemory-policy noeviction APPEND ONLY MODE aof的持久化配置，后面详解默认不开启aof，而是使用了 rdb appendonly no 持久化文件名 appendfilename &quot;appendonly.aof&quot; 同步的频率，always每次修改都同步，比较消耗性能，everysec每秒一次，也可能有数据丢失，no不同步 # appendfsync always appendfsync everysec # appendfsync no 2.Redis 持久化RDB（Redis DataBase）根据配置文件的持久化参数，定期将内存数据写入磁盘，即定期拍快照，恢复时将快照读到内存中 Redis持久化使用一个单独的子进程fork，主进程不进行任何IO操作，确保了Redis的高性能，因此RDB模式效率更高，对于数据完整性不是很敏感的情况下大多使用RDB持久化策略。 唯一的缺点就是在拍快照的间隙如果出现宕机，可能会有数据丢失 rdb保存文件，默认名dump.rdb，与redis.conf在同一个目录 生产环境下，我们会定期备份RDB文件 配置RDB持久化策略 触发机制 save规则满足条件下，可以触发 执行flushdb，可以触发 退出redis，可以触发 恢复数据 只需将rdb文件放在redis启动目录下，redis启动时可以自动识别读取 查看启动目录，在客户端执行config get dir 优点 适合大规模数据恢复 对数据完整性要求不高 缺点 持久化操作有时间间隔，如果redis以外宕机，最后一次操作修改的数据会丢失 fork进程运行时，会占用一定内存空间 AOF（Append Only File） 直译，追加文件，将所有命令记录下来，恢复时将里面的命令全部执行一遍，所以Redis重启就会将该持久化记录里面的指令从到位执行一遍，比较麻烦 配置文件默认不开启，手动开启，需要设置 appendonly yes 默认声明文件名 appendfilename &quot;appendonly.aof&quot; 追加记录的频率 # appendfsync always appendfsync everysec # appendfsync no 其他配置一般使用默认，有需要可以查询 修改配置文件，开启AOF，重启Redis服务端，即可生效，持久化文件默认保存在Redis启动目录下， 执行一段Redis数据命令，查看文件目录，打开持久化文件如果我们修改了这个日志文件，会影响数据的恢复，可以使用 自动检测修复aof文件， 执行命令 redis-check-aof --fix appendonly.aof 重写规则，当aof文件超过配置参数的大小（这里是64mb），Redis就会开启一个新的进程，重写一个新的aof文件 aof配置中默认文件无限追加，会导致文件越来越大 no-appendfsync-on-rewrite no 如果配置重写，可以指定文件多大触发重写新的aof auto-aof-rewrite-min-size 64mb 优点 每次修改都记录，确保文件完整性，注意需要将持久化策略改为always 缺点 持久化文件远大于RDB文件，修复速度也更慢 开启AOF持久化策略下，Redis运行效率也会比RDB模式慢 使用策略 实际生产中会开启主从复制，rdb策略放在从机上，用来起到备份作用 Redis 持久化总结1.RDB持久化方式能够在指定的时间间隔内对数据进行快照存储 2.AOF持久化方式记录每次对服务器写的操作，当服务器重启时会重新执行这些命令来恢复原始数据，AOF命令以Redis协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，避免AOF文件体积过大 3.如果只是使用Redis作为服务器运行的缓存，其实也可以不必使用持久化 4.同时开启两种持久化方式 Redis重启会优先载入AOF文件来恢复原始数据，因为保存的数据更完整 RDB的数据不实时，但是也推荐开启。因RDB更适合用于备份数据库，AOF不断变化不好备份，RDB重启速度快，没有AOF潜在的bug 5.性能建议 RDB文件通常作为后备，建议只在Slave上持久化RDB文件，而且只需要15分钟备份一次就够了，只保留save 900 1这条规则 如果开启AOF，好处是在最糟糕的情况下，也只会丢失不超过2秒的数据，启动脚本也简单；但是产生了一个持续的IO，还有，在rewrite重写过程中，将新的数据写入新文件不可避免会造成阻塞，所以只要硬盘允许，尽量减小重写频率，默认是64mb，可以设置到5g以上，超过原大小100%触发重写也可以适当提升数值 如果不使用AOF，只靠Master-Slave Replication 时间高可用性也可以，性能节省一大笔IO，减少rewrite带来的波动，代价是，如果主机从机同时宕机，会丢失十几分钟的数据，启动脚本也会比较主机从机中的RDB文件，选择比较新的 3.Redis 发布订阅Redis发布订阅是一种消息通信模式，发送者发送消息，订阅者接收消息 Redis客户端可以接收任意数量的频道 要素：消息发送者、频道、消息接收者命令描述测试使用 订阅频道，c1开启一个新的窗口，连接服务端，发送消息接收端会实时接收消息，并显示总结 发布者向频道发送消息 接收者订阅频道，实施接收频道消息 redis-server底层维护一个字典，字典的键就是每个频道，字典的值是一个链表，链表中保存了所有订阅这个频道的客户端，当字典的一个键上发布消息后，值对应的所有客户端都会接收消息，最明显的用法就是具有实时性，如，即时聊天，群聊、关注等， 进一步复杂的场景一般使用消息中间件 MQ 4.Redis 主从复制概念默认情况下，每台Redis服务器都一个主节点 通常主节点用来读操作，从机用来写操作， 主从复制作用： 数据冗余，实现了数据双击热备，是持久化之外的一种冗余方式 故障恢复，主节点出现问题，从节节点可以提供服务，快速恢复 负载均衡，多个从节点可以实现负载均衡，分担访问压力，提高Redis服务器的并发量 高可用，主从复制是哨兵模式、Redis集群实施的前提 结构上，Redis服务器可能发生故障，一台服务器不够用，且访问压力大； 容量上，单台服务器内存容量有限，也不应当将所有内存用作Redis存储，通常，单台Redis最大使用内存不应超过20G 配置只需要配置从机，主机默认就是，不需要单独配置 以默认方式启动Redis服务，连接客户端，查看主从复制信息 可得知当前服务身份为主机，从机连接数为0， Redis集群的搭建至少需要三台服务器 Redis的启动需要配置文件，因此我们准备多个不同的配置文件，分别根据各个配置文件启动，就可以得到多个Redis服务器 准备四个连接窗口，一个观察，三个模拟三台Redis服务器拷贝redis.conf配置文件， 分别进入各个配置文件，修改配置信息，这里以redis79.conf为例 端口号后台运行 pid日志rdb保存退出，80，81根据各自端口号修改 启动修改完配置文件，分别用6379，6380，6381配置文件启动Redis服务端当前状态每台服务器都是主节点 三个窗口分别连接6379，6380，6381客户端，查看连接信息通常，从机不用改，只需配置从机，指定从机的主机即可 给从机指定主机，从机客户端中使用命令,80,81都执行 slaveof 127.0.0.1 6379 查看主机信息，多了两个从机以上方式通过命令搭建主从，这是暂时的，实际生产中应该通过配置文件搭建主从，这是永久操作，开机即按照主从信息启动 注意事项 主机可以写，从机不能写只能读，写了也会报错 主从复制状态下，主机中的所有信息和数据，都会自动被从机保存 测试 主机宕机，主从关系没有变化，从机依旧无法写，主机恢复，主从关系不变，从机依旧无法写 从机宕机，重启后变回主机，如果重新指定成刚才的从机，依旧可以获取主机所有数据，包括宕机期间主机的操作 复制原理 slave启动成功连接到master后会发送一个sync同步命令 master接到命令，启动后台存盘进程，同时收集所有接收到的修改数据的命令，后台进程执行完毕后，master将传送整个数据文件给slave，并完成一次完全同步 全量复制：slave在接收到数据库文件数据后，将其存盘并加载到内存中 增量复制：master继续将新的所有手机到的修改命令一次传给slave，完成同步 只要是重新连接master，一次完全同步（全量复制）就会自动执行，从机恢复所有数据 主从链路79做主机，80做79的从机，81做80的从机 此时的80依旧是从机，但是81依旧可以获取全部数据这个模型下，如果79宕机，可以指定其中一个从机成为主机，进入一个从机客户端，执行命令，这个从机就会成为主机 slaveof no one 然后，其他从机再指定这个新的主机 最初的主机重新启动，也失去之前那些从机了 5.哨兵模式（重点）概念之前的主从切换，当主机宕机后，需要手动将一台服务器切换为主机，费事费力，服务器也会有一段时间不可用， Redis从2.8开始出现哨兵模式，Redis提供了哨兵命令，哨兵是一个独立的进程，会独立运行，哨兵通过发送命令，等待Redis服务器响应，从而监控多个Redis实例 后台监控主机是否故障，如果宕机，将根据投票自动将从机切换为主机 模型基本模型为了确保哨兵也高可用，可以使用多哨兵模式如果主机宕机，哨兵1先发现，系统不会马上进行切换，只是哨兵1主观认为，这个现象叫做主观下线。如果后续其他哨兵也发现主机不可用，且数量达到一定值时，哨兵之间就会进行投票，投票结果由一个哨兵发起，进行故障转移操作，切换成功后，通过发布订阅模式，通知各个哨兵把监控的从机切换为主机，者叫客观下线。 配置当前主从状态，79主机，80，81从机 在配置文件的目录中，新建哨兵配置文件sentinel.conf sentinel monitor不能变，sen1是名字自己取，127.0.0.1 6379 是监控的主机，1表示如果主机宕机，哨兵会进行投票 这是最基本的配置，完成后，保存退出 sentinel monitor sen1 127.0.0.1 6379 1 启动哨兵 哨兵启动，根据配置文件，当前监控的6379成为主机，还有两个从机6380，6381 测试打开新窗口，模拟主机6379宕机，进入6379客户端，shutdown过一段时间，哨兵会通过心跳检测机制发现主机宕机，开始投票，推选出新的主机，这个例子中6381成了新主机 查看6381服务器信息，也验证了6381是新主机这里投票的机制，我们暂且不讨论，但是一定会从生下的从机选出主机 如果之前的主机6379重新连接，发现自己只能作为6381的从机，观察哨兵的投票记录我们可以看到，其实6379下线时，就已经沦为从机的位置了 登录6379客户端，查看信息优点： 哨兵集群，基于主从复制模式，拥有其全部优点 可以主从切换，实现故障转移 哨兵模式就是主从模式的升级版，实现自动切换，更加健壮 缺点 Redis不好实现在线扩容，集群容量一旦到达上限，在线扩容十分困难 实现哨兵模式配置的过程其实比较麻烦，我们的举例只是最简单的 真正的全部配置，有很多，如果有哨兵集群更加复杂， 后续补充哨兵的详细配置 6.Redis 缓存穿透、击穿、雪崩（面试重点）缓存穿透概念 用户查询数据，发现Redis内存数据库中没有，也就是缓存没有命中，请求就会想持久层数据库查询，也没有，查询失败； 当用户量很大，或者恶意攻击，大量的请求进入到持久层数据库，会给数据库造成很大的压力，形成了缓存穿透 解决方案 布隆过滤器布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先校验，不符合则丢弃，避免对底层数据库直接查询具体原理可以自行查询 缓存空对象当存储层不命中后，即使返回一个空对象，也可以将其缓存起来，同时设置一个过期时间，在一定时间内也可以将请求拦截在缓存中缺点 存储空对象，以为这缓存中需要存储更多的键值对，浪费资源 即使空对象缓存有生命周期，到了过期时间，仍然会出现缓存层和存储层数据不一致，对业务也有影响 缓存击穿概念某些数据key非常热点，不停抗住大量并发，由于某种原因（宕机或过期），当这个key在失效的瞬间，持续大量的并发会将缓存击穿，直接请求数据库，导致数据库瞬间压力过大 缓存穿透与缓存击穿区别：穿透是查不到，击穿是本来能查到，突然失效了，发生穿透 解决方案 设置热点数据永不过期也有缺点，最终还是需要定期处理 加互斥锁分布式锁：使用分布式锁，确保每个key同时只有一个线程去查询后端服务，其他线程没有获取分布式锁的权限，只能等待，这种方式将高并发的压力转移到了分布式锁上面，对分布式锁的考验很大 缓存雪崩概念在某一个时间段内，大量缓存集中失效（比如宕机、过期），导致访问查询都落到数据库上，对于数据库而言，产生了周期性的压力波峰，存储层调用量暴增，造成存储层挂掉 解决方案 Redis高可用搭建Redis集群 大厂比如阿里，在双十一会停掉部分业务，保障主业务 限流降级在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量，如，一个key只允许一个线程查询和写缓存，其他线程等待 数据预热正式部署之前，先把可能的数据访问一遍，可以使一大部分访问的数据加载到缓存中，提前加载不同的数据； 设置不同的过期时间，让缓存失效的时间均匀分散 本文转自 https://blog.csdn.net/weixin_47257749/article/details/114044856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164580136416780261920323%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164580136416780261920323&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allbaidu_landing_v2~default-1-114044856.pc_search_result_positive&amp;utm_term=redis+2021&amp;spm=1018.2226.3001.4187，如有侵权，请联系删除。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Redis","slug":"后端/Redis","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://ysluckly.github.io/tags/Redis/"},{"name":"教程","slug":"教程","permalink":"https://ysluckly.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"图解Go读写锁实现与核心原理分析","slug":"back-end/go-rwlock","date":"2021-11-24T15:59:10.000Z","updated":"2022-02-20T13:30:59.936Z","comments":true,"path":"2021/11/24/go/","link":"","permalink":"https://ysluckly.github.io/2021/11/24/go/","excerpt":"","text":"- 简介读写锁区别与互斥锁的主要区别就是读锁之间是共享的，多个goroutine可以同时加读锁，但是写锁与写锁、写锁与读锁之间则是互斥的 - 写锁饥饿问题因为读锁是共享的，所以如果当前已经有读锁，那后续goroutine继续加读锁正常情况下是可以加锁成功，但是如果一直有读锁进行加锁，那尝试加写锁的goroutine则可能会长期获取不到锁，这就是因为读锁而导致的写锁饥饿问题 基于高低位与等待队列的实现 image.png 在说golang之前介绍一种JAVA里面的实现，在JAVA中ReentrantReadWriteLock实现采用一个state的高低位来进行读写锁的计数，其中高16位存储读的计数，低16位存储写的计数，并配合一个AQS来实现排队等待机制，同时AQS中的每个waiter都会有一个status，用来标识自己的状态 golang的读写锁的实现成员变量 image.png 结构体Copytype RWMutex struct &#123; w Mutex // held if there are pending writers writerSem uint32 // 用于writer等待读完成排队的信号量 readerSem uint32 // 用于reader等待写完成排队的信号量 readerCount int32 // 读锁的计数器 readerWait int32 // 等待读锁释放的数量&#125; 写锁计数读写锁中允许加读锁的最大数量是4294967296，在go里面对写锁的计数采用了负值进行，通过递减最大允许加读锁的数量从而进行写锁对读锁的抢占 Copyconst rwmutexMaxReaders = 1 &lt;&lt; 30 读锁实现读锁加锁逻辑 image.png Copyfunc (rw *RWMutex) RLock() &#123; if race.Enabled &#123; _ = rw.w.state race.Disable() &#125; // 累加reader计数器，如果小于0则表明有writer正在等待 if atomic.AddInt32(&amp;rw.readerCount, 1) &lt; 0 &#123; // 当前有writer正在等待读锁，读锁就加入排队 runtime_SemacquireMutex(&amp;rw.readerSem, false) &#125; if race.Enabled &#123; race.Enable() race.Acquire(unsafe.Pointer(&amp;rw.readerSem)) &#125;&#125; 读锁释放逻辑 image.png Copyfunc (rw *RWMutex) RUnlock() &#123; if race.Enabled &#123; _ = rw.w.state race.ReleaseMerge(unsafe.Pointer(&amp;rw.writerSem)) race.Disable() &#125; // 如果小于0，则表明当前有writer正在等待 if r := atomic.AddInt32(&amp;rw.readerCount, -1); r &lt; 0 &#123; if r+1 == 0 || r+1 == -rwmutexMaxReaders &#123; race.Enable() throw(&quot;sync: RUnlock of unlocked RWMutex&quot;) &#125; // 将等待reader的计数减1，证明当前是已经有一个读的，如果值==0，则进行唤醒等待的 if atomic.AddInt32(&amp;rw.readerWait, -1) == 0 &#123; // The last reader unblocks the writer. runtime_Semrelease(&amp;rw.writerSem, false) &#125; &#125; if race.Enabled &#123; race.Enable() &#125;&#125; 写锁实现加写锁实现 image.png Copyfunc (rw *RWMutex) Lock() &#123; if race.Enabled &#123; _ = rw.w.state race.Disable() &#125; // 首先获取mutex锁，同时多个goroutine只有一个可以进入到下面的逻辑 rw.w.Lock() // 对readerCounter进行进行抢占，通过递减rwmutexMaxReaders允许最大读的数量 // 来实现写锁对读锁的抢占 r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders // 记录需要等待多少个reader完成,如果发现不为0，则表明当前有reader正在读取，当前goroutine // 需要进行排队等待 if r != 0 &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != 0 &#123; runtime_SemacquireMutex(&amp;rw.writerSem, false) &#125; if race.Enabled &#123; race.Enable() race.Acquire(unsafe.Pointer(&amp;rw.readerSem)) race.Acquire(unsafe.Pointer(&amp;rw.writerSem)) &#125;&#125; 释放写锁 image.png Copyfunc (rw *RWMutex) Unlock() &#123; if race.Enabled &#123; _ = rw.w.state race.Release(unsafe.Pointer(&amp;rw.readerSem)) race.Disable() &#125; // 将reader计数器复位，上面减去了一个rwmutexMaxReaders现在再重新加回去即可复位 r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders) if r &gt;= rwmutexMaxReaders &#123; race.Enable() throw(&quot;sync: Unlock of unlocked RWMutex&quot;) &#125; // 唤醒所有的读锁 for i := 0; i &lt; int(r); i++ &#123; runtime_Semrelease(&amp;rw.readerSem, false) &#125; // 释放mutex rw.w.Unlock() if race.Enabled &#123; race.Enable() &#125;&#125; 关键核心机制写锁对读锁的抢占加写锁的抢占 Copy// 在加写锁的时候通过将readerCount递减最大允许加读锁的数量，来实现对加读锁的抢占r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders 加读锁的抢占检测 Copy// 如果没有写锁的情况下读锁的readerCount进行Add后一定是一个&gt;0的数字，这里通过检测值为负数//就实现了读锁对写锁抢占的检测if atomic.AddInt32(&amp;rw.readerCount, 1) &lt; 0 &#123; // A writer is pending, wait for it. runtime_SemacquireMutex(&amp;rw.readerSem, false) &#125; 写锁抢占读锁后后续的读锁就会加锁失败，但是如果想加写锁成功还要继续对已经加读锁成功的进行等待 Copyif r != 0 &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != 0 &#123; // 写锁发现需要等待的读锁释放的数量不为0，就自己自己去休眠了 runtime_SemacquireMutex(&amp;rw.writerSem, false)&#125; 写锁既然休眠了，则必定要有一种唤醒机制其实就是每次释放锁的时候，当检查到有加写锁的情况下，就递减readerWait，并由最后一个释放reader lock的goroutine来实现唤醒写锁 Copyif atomic.AddInt32(&amp;rw.readerWait, -1) == 0 &#123; // The last reader unblocks the writer. runtime_Semrelease(&amp;rw.writerSem, false)&#125; 写锁的公平性在加写锁的时候必须先进行mutex的加锁，而mutex本身在普通模式下是非公平的，只有在饥饿模式下才是公平的 Copyrw.w.Lock() 写锁与读锁的公平性在加读锁和写锁的工程中都使用atomic.AddInt32来进行递增，而该指令在底层是会通过LOCK来进行CPU总线加锁的，因此多个CPU同时执行readerCount其实只会有一个成功，从这上面看其实是写锁与读锁之间是相对公平的，谁先达到谁先被CPU调度执行，进行LOCK锁cache line成功，谁就加成功锁 可见性与原子性问题在并发场景中特别是JAVA中通常会提到并发里面的两个问题：可见性与内存屏障、原子性， 其中可见性通常是指在cpu多级缓存下如何保证缓存的一致性，即在一个CPU上修改了了某个数据在其他的CPU上不会继续读取旧的数据，内存屏障通常是为了CPU为了提高流水线性能，而对指令进行重排序而来，而原子性则是指的执行某个操作的过程的不可分割 底层实现的CPU指令go里面并没有volatile这种关键字，那如何能保证上面的AddInt32这个操作可以满足上面的两个问题呢， 其实关键就在于底层的2条指令，通过LOCK指令配合CPU的MESI协议，实现可见性和内存屏障，同时通过XADDL则用来保证原子性，从而解决上面提到的可见性与原子性问题","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"读写锁实现","slug":"读写锁实现","permalink":"https://ysluckly.github.io/tags/%E8%AF%BB%E5%86%99%E9%94%81%E5%AE%9E%E7%8E%B0/"},{"name":"核心原理","slug":"核心原理","permalink":"https://ysluckly.github.io/tags/%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"}]},{"title":"Python 简明教程","slug":"back-end/quick-python","date":"2021-11-24T15:59:10.000Z","updated":"2022-02-20T13:29:02.475Z","comments":true,"path":"2021/11/24/python3/","link":"","permalink":"https://ysluckly.github.io/2021/11/24/python3/","excerpt":"","text":"Python is a programming language that lets you work more quickly and integrate your systems more effectively. – python.org 0 安装可以直接从官网 python.org/downloads 下载安装，最新版本是 3.9.0。安装过程和普通的 Windows 软件一致。安装完成后，需将安装路径添加到环境变量中。 如果你使用的是 Ubuntu 等 Linux 发行版或 MacOS 系统，操作系统将自带 Python，无需安装。如果操作系统上只有 Python2，在 Debian 和 Ubuntu 上可通过如下方式安装 Python3： sudo apt-get update &amp;&amp; sudo apt-get install python3 在 MacOS 上，可通过如下方式安装 brew install python3 若安装成功，命令行运行 python -V 或 python3 -V，你将看到： $ python3 -V Python 3.7.5 1 Hello WorldPython 有两种运行方式：交互式和源文件。在命令行中键入 python3 并回车，则进入了 Python 解释器的交互模式： $ python3 Python 3.7.5 (default, Nov 7 2019, 10:50:52) [GCC 8.3.0] on linux Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; 接下来，我们接着输入：print(&quot;hello world&quot;)，按下回车： &gt;&gt;&gt; print(&quot;hello world&quot;) hello world &gt;&gt;&gt; 这样就完成了我们的第一个 Python 程序，向世界问好。print() 是 Python 中的一个内置函数，用来在标准输出中打印信息。 在交互模式下，每输入一行代码，按下回车，运行结果就会打印在屏幕上。因此，我们可以将 Python 当做一个简单的计算器，例如： &gt;&gt;&gt; 1 + 2 * 100 201 &gt;&gt;&gt; 1 + 2 ** 3 9 ** 是 Python 中的指数运算符，这里表示 2 的 3 次方。 我们在桌面新建文件夹 test，在 test 文件夹中新建文件 main.py，写入： print(&quot;1 + 2 =&quot;, 1 + 2) 保存后，在命令行中切换到 test 文件夹，执行 python main.py，将会看到： $ python3 main.py 1 + 2 = 3 一般我们使用 IDE，例如 VSCode 或 PyCharm 写 Python 程序。IDE 集成了代码高亮、提示、命令行等功能，能够极大地提升代码的学习和开发效率。 2 基本语法ok = True # 布尔值，表示真假，True 或 False a = 2 b = 3.56 c = &quot;hello world&quot; d = a * b # 求 a 和 b 的积 print(&quot;c =&quot;, c) print(&#39;&#123;0&#125; + &#123;1&#125; = &#123;2&#125;&#39;.format(a, b, d)) 运行这段程序： python3 main.py c = hello world 2 + 3.56 = 7.12 单行注释以符号 # 开头。 变量一般由数字、字母、下划线构成，但只能以字母或下划线开头。 ok = True，表示将字面量，即布尔值 True 赋值给变量 ok。 a = 2，表示将字面量，即整数 2 赋值给变量 a b = 3.56，表示将字面量，即浮点数 3.56 赋值给变量 b c = &quot;hello world&quot;，表示将字符串 hello world 赋值给变量 c。 单行字符串一般使用双引号 &quot;，也可以使用单引号 &#39;，多行字符串通常使用三个单引号或三个双引号。例如： a = &quot;I&#39;m 极客兔兔&quot; b = &#39;c = &quot;hello world&quot;&#39; d = &quot;&quot;&quot;这是一个多行字符串； 这是第二行； 这是第三行。 &quot;&quot;&quot; print(a) print(b) print(d) 执行结果为： $ python3 main.py I&#39;m 极客兔兔 c = &quot;hello world&quot; 这是一个多行字符串， 这是第二行 这是第三行 format 可以格式化字符串，&#123;0&#125; 表示用 format 的第一个参数的值替代，&#123;1&#125; 表示用第二个值替代，以此类推。 format 还有其他使用方式，省略序号或使用键值对： name, age = &quot;小明&quot;, 13 # 一行中可以声明多个变量 print(&quot;&#123;&#125;今年 &#123;&#125; 岁&quot;.format(name, age)) # 按顺序使用，&#123;&#125;可省略序号 print(&quot;&#123;name&#125;明年 &#123;age&#125; 岁&quot;.format(name=name, age=age+1)) # 使用键值对 执行结果： $ python3 main.py 小明今年 13 岁 小明明年 14 岁 如果代码写的有问题，Python 执行时将会报错，例如这段： age = 13 print(&quot;今年 &#123; 岁\\n明年 &#123;&#125; 岁&quot;.format(age, age+1)) # \\n 表示换行打印 python3 main.py Traceback (most recent call last): File &quot;main.py&quot;, line 2, in &lt;module&gt; print(&quot;今年 &#123; 岁\\n明年 &#123;&#125; 岁&quot;.format(age, age+1)) ValueError: unexpected &#39;&#123;&#39; in field name 报错时打印了发生错误的堆栈信息： File &quot;main.py&quot;, line 2 表示错误发生在 main.py 的第 2 行。 ValueError: unexpected &#39;&#123;&#39; in field name 表示错误原因是 &#123; 括号使用有误。在这里，我们没有成对使用大括号作为占位符，导致报错。 3 运算符与表达式3.1 运算符常见的加减乘除运算： &gt;&gt;&gt; 1 + 2 # 加 3 &gt;&gt;&gt; 4 - 6 # 减 -2 &gt;&gt;&gt; 2 * 3 # 乘 6 &gt;&gt;&gt; 6 / 4 # 除 1.5 &gt;&gt;&gt; 6 // 4 # 除取整 1 &gt;&gt;&gt; 6 + 2 * (1 + 3) # 运算顺序和正常的数学运算一致，先乘除，后加减，括号优先 14 &gt;&gt;&gt; 2 ** 4 # 指数，2 的 4 次方 16 &gt;&gt;&gt; 6 % 4 # 取模/余数 2 大小比较运算： &gt;&gt;&gt; 12 &lt; 18 # 小于 True &gt;&gt;&gt; 12 &lt;= 18 # 小于等于 True &gt;&gt;&gt; 1.2 &gt; 3.4 # 大于 False &gt;&gt;&gt; 1.2 &gt;= 3.4 # 大于等于 False &gt;&gt;&gt; 12 == 18 # 等于 False &gt;&gt;&gt; 12 != 18 # 不等于 True 逻辑运算符： &gt;&gt;&gt; 12 &gt;= 8 and 5 &gt; 6 # and 布尔与/且，全真为真，有假为假 False &gt;&gt;&gt; 12 &gt;= 8 or 5 &gt; 6 # or 布尔或，全假为假，有真为真 True &gt;&gt;&gt; not 5 &gt; 6 # not 布尔非 True 此外还支持 &lt;&lt; (左移)、&gt;&gt; (右移)、&amp; (按位与)、| (按位或)、^ (按位异或)、~ (按位取反) 等位运算符。 赋值运算符 =，将 = 右侧的值赋值给左侧，左侧需要一个变量。 a = 2 a = a * (3 + 4) # 将 a * (3 + 4) 的值 14 赋值给 a。 对一个变量进行计算，将计算的结果赋值给该变量，可以简写为： a = 2 a *= 3 + 4 3.2 表达式Python中，值、变量和运算符共同组成的整体称为表达式，通常我们所写出的程序语句包含若干个表达式。例如上述的 3 + 4 即构成了一个简单的表达式。值和变量也被称作为操作数，运算符也被称为操作符。 4 控制流Python 语句是自上而下执行的，如果在这个过程中，我们希望通过一些条件判断，执行不同的逻辑怎么办呢？可以通过控制流语句实现，Python 中一共有 if、for、while 三个控制流语句。 4.1 if 语句if 用于检查条件是否为真，如果为真则执行，通常与 else，elif (else if) 结合使用。例如： age = 13 if age &gt;= 18: print(&#39;adult&#39;) if age &lt; 18: print(&#39;child&#39;) Python 使用缩进代表不同的代码块，一般缩进使用 4 个空格表示。你可以看到 print() 前有 4 个空格。 上述代码可以简化成： age = 13 if age &gt;= 18: print(&#39;adult&#39;) else: print(&#39;child&#39;) 如果我们有多个条件判断分支时，elif 就能派上用场了： age = 45 if age &lt; 18: print(&#39;小孩&#39;) elif age &lt; 60: print(&#39;中年人&#39;) else: print(&#39;老人&#39;) 4.2 for 语句有些代码块需要执行多次，这种情况我们可以使用 for 循环语句，例如打印数字 1 - 5： # main.py for i in range(5): # 0, 1, 2, 3, 4 从0开始，不包含 5 print(i + 1, end=&#39; &#39;) 执行结果为： python3 main.py 1 2 3 4 5 print() 函数默认以换行符结尾，如果我们希望替换成空格，只需要将参数 end 设置为空格即可。 range() 也是一个内置函数，用于生成数字序列，常用于 for 循环语句中。若只传入一个参数 N，代表生成 [0, N) 的整数序列，从 0 开始，不包含N。如果我们不想从 0 开始怎么办呢？range() 也支持传入多个参数，例如： for i in range(2, 5): # [2, 5) print(&quot;&#123;0&#125; * &#123;0&#125; = &#123;1&#125;&quot;.format(i, i ** 2)) # 结果如下 # 2 * 2 = 4 # 3 * 3 = 9 # 4 * 4 = 16 for i in range(1, 10, 2): # 第三个参数为步长 step，从1开始，每次加 2 print(i, end=&#39; &#39;) # 1 3 5 7 9 for i in range(10, 2, -2): # 步长-2，从10开始，每次加-2 print(i, end=&#39; &#39;) # 10 8 6 4 那如果在 for 循环中，遇到某个条件想退出循环呢？通常 for 还与 break 和 continue 结合使用： for i in range(100): if i &lt;= 3: continue # i &lt;= 3，继续循环，不执行下面的语句 if i &gt;= 10: break # i &gt;= 10 时，终止循环 print(i, end=&#39; &#39;) # 4 5 6 7 8 9 continue 语句用来跳过当前循环语句块中的其余部分，然后继续执行循环的下一个迭代。 break 语句用来终止循环。 因此，i &lt;= 3 时，跳过了 print 语句，i &gt;= 10 时循环被终止，那么这个程序将会打印出数字 4 5 6 7 8 9。 4.3 while 语句与 for 循环语句类似，while 通常也用于循环表达式中。while 后面跟一个条件，条件为真时，执行 while 代码块；条件为假时，终止循环。一般 while 可以替代 for 循环，刚才我们使用 for 打印了数字 1 - 5，接下来用 while 改写： i = 0 while i &lt; 5: # 第1次迭代i==0，满足条件，第6次迭代时，i==5，不满足条件 i += 1 print(i, end=&#39;,&#39;) # 1,2,3,4,5, 同样的，continue 和 break 语句也能在 while 语句中使用。例如我们实现一个简单的功能，用户每输入一个数字，打印这个数字的平方，直到输入 0 时结束。 while True: num = input(&#39;请输入一个数字: &#39;) num = int(num) if num == 0: print(&#39;结束&#39;) break print(&quot;&#123;&#125;^2 = &#123;&#125;&quot;.format(num, num ** 2)) 运行结果： python3 main.py 请输入一个数字: 12 12^2 = 144 请输入一个数字: 18 18^2 = 324 请输入一个数字: 0 结束 while True 代表进入无限循环，只有通过 break 语句才能结束。 input() 是一个内置函数，用于接受用户的输入，返回一个字符串。input 可以传入一个字符串，作为输入的提示语句。 num = int(num) 是将 num 转换为整型，因为字符串不能计算平方，只有数字才行。 5 函数在之前的例子中，我们已经使用了 print、range、input 等 Python 常用的内置函数，对函数已经不陌生了。那函数是什么呢？函数可以理解为一块可以复用的代码块，可以为这个代码块起一个名字（函数名），也可以定义传入的参数（形参），以及返回结果（返回值）。函数定义一般长这个样子：关键字 def 作为函数的标识符，紧接着是函数名，函数名的命名规范与变量一致，通常由数字、字母和下划线构成，以字母或下划线开头。函数名后面有一对小括号和一个冒号 :，里面可以定义参数列表，也可以没有参数。接下来便是一个语句块作为函数体。 def 函数名(参数名1, 参数名2, ...): body 函数体，函数体同样通过缩进来体现 那比如我们实现一个函数 area，用于计算长方形的面积，接受 2 个参数长 length 和宽 width，返回一个值，即面积。 def area(length, width): return length * width print(&#39;area1: &#39;, area(10, 8)) # area1: 80，第一次调用 print(&#39;area2: &#39;, area(6, 8)) # area2: 48，第二次调用 return 是 Python 中的一个关键字，用于函数体中，即跳出这个函数，不再执行。 return 可以跟一个或多个值作为返回值，也可以没有返回值。 没有返回值时，return 事实上等价于 return None，None 是一个关键字，表示空。 如果函数没有 return 语句，系统会自动在函数的结尾添加 return None 语句。 def calc(a, b): return a // b, a % b # 多个返回值，事实上是一个元组(tuple)类型，后面章节会介绍 print(calc(8, 3)) # (2, 2) x, y = calc(8, 5) # 两个返回值分别赋值给变量 x, y print(x, y) # 1, 3 def log(mode): if mode == &#39;debug&#39;: print(&#39;debug mode&#39;) return print(&#39;release mode&#39;) print(log(&#39;release&#39;)) # release mode # None 5.1 局部变量与全局变量x = 10 # x 是全局变量，可在其他函数中使用 def print_global(): print(x) def print_local(): x = 100 # x 是局部变量，不影响全局变量中的 x print(x) print_global() # 10 print_local() # 100 print_global() # 10 我们定义了全局变量 x，在 print_local 中定义了与全局变量同名的局部变量 x，并将 100 赋值给 x，在这里修改的是局部变量的值，局部变量只在这个函数内部有效，全局变量不会受到影响。因此，两次 print_global 的结果都是 10。 定义局部变量的好处在于，控制变量的作用域范围，减少各个函数之间的干扰。全局变量可以在多个函数之间共享，一般建议仅将只读的变量设置为全局变量，比如圆周率 π 的值。那如果我们想修改全局变量怎么办呢？可以使用 global 关键字： x = 10 # x 是全局变量，可在其他函数中使用 def print_global(): print(x) def print_local(): global x x = 100 print(x) print_global() # 10 print_local() # 100 print_global() # 100 在 print_local 中，使用 global x 告诉 Python x 是一个全局变量，而非局部变量。因此 x = 100 将修改全局变量 x 的值。所以第二个 print_global() 将打印 100。 5.2 可选参数与默认值如果有多个参数，那能不能给某些参数设置默认值，这样用户可以选择性地传入或不传入该参数的值呢？答案是可以的，Python 允许给参数设置默认值，在使用者看来，就像是实现了C++的函数重载一样。 重载函数是函数的一种特殊情况，为方便使用，C++允许在同一范围中声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，也就是说用同一个函数完成不同的功能，这就是重载函数。 def greet(msg, times=1): for i in range(times): print(msg) greet(&#39;Hi, Jack&#39;) greet(&#39;Hello, Mr Dai&#39;, 3) 执行结果： Hi, Jack Hi, Tom Hi, Tom Hi, Tom greet 函数的功能是打印 msg，默认是1次，但可以通过参数 times 控制。 带默认值的参数只能位于参数列表的末尾，不能位于非默认值参数前面。例如 def greet(times=1, msg) 是不允许的。 默认值参数可以有 0 或多个。 Python 中，参数的传递还可以更加地灵活，除了按顺序传入以外，还可以通过键值对的方式传入： greet(&#39;Hi, Jack&#39;, times=2) # 混合方式 greet(msg=&#39;Hi, Tom&#39;, times=3) greet(times=3, msg=&#39;Hi, Tom&#39;) # 均为键值对的情况下，顺序没有关系 键值对传参特别适用于参数列表非常多，且大部分均有默认参数的情况。无需关注参数的顺序，而只需将需要设置的几个参数传入即可。 5.3 可变参数Python 还支持可变参数。函数定义时如果参数的个数是不确定的，那么就适合使用可变参数来代替。可变参数有 2 种，元组式(tuple，元组可以认为是一个不可变的有序集合)和字典式(dict)。元组式可变参数用 *参数名 表示，传入的实际参数会构成一个元组，例如： # 实现一个求和函数，支持传入任意个数字 def sum_n(*nums): s = 0 for num in nums: s += num return s print(sum_n(1, 2, 3)) # 6 print(sum_n(1, 2, 3, 4, 5)) # 15 字典式(键值对式)可变参数用**参数名表示，传入的实际参数会构成一个字典(dict)，例如： def print_student(**students): for name, age in students.items(): print(&#39;&#123;&#125;今年 &#123;&#125; 岁&#39;.format(name, age)) print_student(小明=8, 小红=7) 执行结果： 小明今年 8 岁 小红今年 7 岁 元组(tuple) 和 字典(dict) 都是 Python 内置的数据结构，我们在下一章节会讲到。 5.4 文档字符串 __doc__给每一个函数写文档是编程的好习惯，在 Python 中，对每个函数来说，有一个内置的属性 __doc__ 保存了函数的说明文档，Python 中称之为 DocStrings。那怎么定义这个属性呢？ def print_student(**students): &#39;&#39;&#39;Prints name and age for every student. key is name, and value is age.&#39;&#39;&#39; for name, age in students.items(): print(&#39;&#123;&#125;今年 &#123;&#125; 岁&#39;.format(name, age)) print_student(小明=8, 小红=7) print(print_student.__doc__) # 打印 __doc__ 的值 help(print_student) 函数体一开始使用三个单引号&#39;&#39;&#39;标志 DocStrings 的开始。 第一行描述函数的作用，首字母大写。第二行为空行，第三行是详细的描述，可以包括函数每一个参数的介绍等。 执行结果： 小明今年 8 岁 小红今年 7 岁 Prints name and age for every student. key is name, and value is age. Help on function print_student in module __main__: print_student(**students) Prints name and age for every student. key is name, and value is age. help() 函数也是 Python 的内置函数，提供一种更优美的方式查看某个函数的 DocStrings，通常在交互模式下使用。 6 数据结构Python 内置了常用的几种数据结构：列表(list)、元组(tuple)、字典(dict) 和集合(set)，几乎所有程序都会用到这几种数据结构。 6.1 字符串(string)字符串可以说是最常用的数据类型了。字符串可以使用 &quot;、&#39;、&quot;&quot;&quot;、&#39;&#39;&#39; 表示。三引号通常用于表示多行字符串。字符串是字符序列，在 Python 中，序列支持下标索引、for 循环、切片等系列操作，后面提到的列表(list)、元组(tuple)也都属于序列。字符串是不可变数据类型，不支持修改。 s = &quot;I&#39;m geektutu&quot; print(len(s)) # 12 print(s[0], s[-1]) # I u [] 操作符可以按照下标索引到元素的值，下标从 0 开始，支持负数，-1 表示最后一个元素，以此类推。[] 除了可以用于下标索引外，还可以用来切片，例如： s = &quot;I&#39;m geektutu&quot; print(s[:-3]) # I&#39;m geekt，等价于 s[0:-3] print(s[4:]) # geektutu，等价于 print(s[4:len(s)]) print(s[4::2]) # gett print(s[::-1]) # tutkeeg m&#39;I 切片能够快速截取序列中的一部分，使用方式可以表示为 [start:end:step]，与 range 类似，包含开始，不包含结束。 start 默认值为 0，如果为 0，可以省略不写。 end 默认值为列表的长度，如果为列表长度，可以省略不写。 step 默认值为 1，如果为1，可以省略不写。 6.2 列表(list)list 是一种表示有序项集合的数据结构。有序且允许重复，支持增删查改，是一种可变数据类型。 persons = list() # 声明一个空列表 persons = [] # 声明一个空列表 persons = [&#39;Tom&#39;, &#39;Jack&#39;, &#39;Jack&#39;, &#39;Sam&#39;] # 声明一个非空列表 persons.append(&#39;KangKang&#39;) # 添加一个元素 print(persons[1]) # Jack 打印第1个元素，下标从 0 开始。 persons.remove(&#39;Jack&#39;) # 删除 Jack，只删除第一次出现的位置 print(persons) # [&#39;Tom&#39;, &#39;Jack&#39;, &#39;Sam&#39;, &#39;KangKang&#39;] del persons[-2] # 删除倒数第二个元组 Sam print(persons) # [&#39;Tom&#39;, &#39;Jack&#39;, &#39;KangKang&#39;] persons.sort() # 排序 # 遍历列表 for name in persons: print(name, end=&#39; &#39;) # Jack KangKang Tom append 添加元素，remove 按值删除某个元素，del 按下标删除元素。 sort() 用于给列表排序。 列表和字符串一样，是一种序列，因此也支持切片。 numbers = [2, 4, 6, 8, 10] print(len(numbers)) # 长度 5 print(numbers[:3]) # 2 4 6 print(numbers[0:3]) # 2 4 6 print(numbers[1:-1]) # 4 6 8 print(numbers[1:]) # 4 6 8 10 print(numbers[1:5:2]) # 4 8 print(numbers[1::2]) # 4 8 列表的值可以是任意类型，而且一个列表中允许不同类型的值存在，当然也允许嵌套列表存在。 a = [1, 1.3, &quot;Student&quot;, [1, 2, 3]] 判断一个值是否在一个列表中，可以使用 in： print(&quot;Student&quot; in a) # True 列表与字符串有一个非常常用的处理组合 split 和 join： s = &quot;1,5,2,4,3&quot; parts = s.split(&#39;,&#39;) print(parts) # [&#39;1&#39;, &#39;5&#39;, &#39;2&#39;, &#39;4&#39;, &#39;3&#39;] parts.sort() print(&#39;:&#39;.join(parts)) # 1:2:3:4:5 split 用于将字符串按照某个分隔符切割成列表。 join 用于将字符串列表按照某个分隔符合并在一起。 关于列表的更多操作参考 list - Python官方文档 6.2 元组(tuple)元组也是有序集合，用小括号表示。很多特性与列表(list) 一致，不同点在于元组是不可变数据类型，即不允许增删改。 students = (&#39;Tom&#39;, 18, &#39;Jack&#39;, 20) print(len(students)) # 4 print(students[1:3]) # 切片：(18, &#39;Jack&#39;) 如果尝试修改元组，会出现如下报错： students[0] = &#39;KangKang&#39; Traceback (most recent call last): File &quot;main.py&quot;, line 4, in &lt;module&gt; students[0] = &#39;KangKang&#39; TypeError: &#39;tuple&#39; object does not support item assignment 关于元组的更多操作参考 tuple - Python官方文档 6.4 字典(dict)字典由若干个键值对构成，能够快速地根据键(key)查找到对应的值(value)，在一个字典中，键是不能重复的。字典是可变数据类型，支持增删查改。 students = &#123;&#125; # 声明空字典 students = dict() # 声明空字典 students = &#123; &#39;Tom&#39;: 18, &#39;Jack&#39;: 20, &#39;Same&#39;: 19 &#125; students[&#39;KangKang&#39;] = 17 # 新增 students[&#39;Tom&#39;] = 20 # 修改 print(students[&#39;Tom&#39;]) # 20, 通过 key 索引 del students[&#39;Jack&#39;] # 删除 # 遍历 for name, age in students.items(): print(name, age) # Tom 20 # Same 19 # KangKang 17 items() 可以同时获取键和值，除此之外，字典还支持仅获取所有键 keys()，所有值values()等方法，字典是无序的，这三个方法返回值的顺序是不能保证的。 判断字典中是否包含某个键，同样可以使用 in，例如 if &#39;Tom&#39; in students。 获取字典的键值对个数，可以使用 len，例如len(students)。 关于字典的更多操作参考 dict - Python官方文档 6.4 集合(set)Python 中的集合与数学中的集合类似，特点是无序且不重复。 s = set() # 定义空集合 s1 = set([1, 2, 2, 2, 3]) # 非空集合 s1.add(2) # 添加元素，重复则不添加 s1.add(10) s1.remove(3) # 删除 print(s1) # &#123;10, 1, 2&#125; s2 = set([5, 6, 10]) print(s1 | s2) # 并集 &#123;1, 2, 5, 6, 10&#125; print(s1 &amp; s2) # 交集 &#123;10&#125; print(s1 - s2) # 差集 &#123;1, 2&#125; set([1, 2, 2, 2, 3]) 将列表转换为集合，自动去重，同样也可以使用 list() 将集合转换为列表。 关于集合的更多操作参考 数据结构 set - Python官方文档 7 输入输出之前的例子我们使用了标准输入输出函数 input 和 output 实现了简单的功能。Python 常用于数据挖掘分析，文本处理是最基本的能力，使用 Python 进行文件读写也非常简单。 下面是一个非常简单的例子：将字符串 s 写入文件 1.txt s = &#39;&#39;&#39;第一行 第二行 第三行&#39;&#39;&#39; f = open(&#39;1.txt&#39;, &#39;w&#39;) f.write(s) f.close() open 是 Python 用于读取文件的内置函数，第一个参数是文件路径，第二个参数是打开模式，w 代表写模式， r代表只读模式。w 模式打开文件后，文件会被清空，如果需要追加写，则需要以w+模式打开文件。 如果打开文件成功，open会返回一个文件句柄，我们可以使用这个句柄对文件进行操作。 操作完毕后，需要将文件关闭。 Python 还提供了另一种更安全、简单的方式 with as： s = &#39;&#39;&#39;第一行 第二行 第三行&#39;&#39;&#39; with open(&#39;1.txt&#39;, &#39;w&#39;) as f: f.write(s) with 语句会在 with 内部的代码块执行完毕后，执行资源回收的操作，对于文件来说即关闭文件。 读取文件，并统计字数： with open(&#39;1.txt&#39;, &#39;r&#39;) as f: s = f.read() print(len(s)) # 11 我们也可以使用 readlines() 读取文件的所有行： with open(&#39;1.txt&#39;, &#39;r&#39;) as f: s = f.readlines() for line in s: print(line, end=&#39;&#39;) 还有一种更高效的方式，直接遍历文件句柄 f： with open(&#39;1.txt&#39;, &#39;r&#39;) as f: for line in f: print(line, end=&#39;&#39;) 8 异常尽管我们想要将代码写得尽善尽美，但是出现异常还是难免的。如果我们不对异常做任何的处理，程序会立即退出。Python 提供了 try except finally 机制，给开发者提供了一个处理异常的机会。 # main.py with open(&#39;2.txt&#39;, &#39;r&#39;) as f: print(f.read()) print(&#39;done&#39;) 如果我们执行上述程序，会出现如下错误： Traceback (most recent call last): File &quot;main.py&quot;, line 2, in &lt;module&gt; with open(&#39;2.txt&#39;, &#39;r&#39;) as f: FileNotFoundError: [Errno 2] No such file or directory: &#39;2.txt&#39; 程序在第二行就退出了，错误原因是 2.txt 不存在。那我们如何捕获到这个错误并处理呢？ # main.py try: with open(&#39;2.txt&#39;, &#39;r&#39;) as f: print(f.read()) except Exception as e: print(e) finally: print(&#39;done&#39;) 程序正常执行结束： [Errno 2] No such file or directory: &#39;2.txt&#39; done try 语句块中包含可能发生异常的代码，如果发生异常，将跳转到 except 语句块执行。 无论是否发生异常，finally 中的代码都会得到执行，finally 是可选的。 我们也可以在 except 中处理完毕之后，继续将异常抛出，留给调用方处理。 # main.py try: with open(&#39;2.txt&#39;, &#39;r&#39;) as f: print(f.read()) except Exception as e: print(e) raise e finally: print(&#39;done&#39;) 执行结果： [Errno 2] No such file or directory: &#39;2.txt&#39; done Traceback (most recent call last): File &quot;main.py&quot;, line 7, in &lt;module&gt; raise e File &quot;main.py&quot;, line 3, in &lt;module&gt; with open(&#39;2.txt&#39;, &#39;r&#39;) as f: FileNotFoundError: [Errno 2] No such file or directory: &#39;2.txt&#39; 9 模块9.1 使用标准库模块Python 标准库内置了大量的模块，提供了非常丰富的功能。比如数学库 math： import math print(math.__name__) # 模块名 math print(math.ceil(4.3)) # 向上取整 5 print(math.floor(4.8)) # 向下取整 4 使用 import 导入标准库 math，并调用了 math 的 ceil 和 floor 函数。 每一个模块有一个内置属性 __name__，表示模块的名称，如果开发者正在独立运行该模块，则模块名称将是 __main__。 例如，执行 main.py # main.py print(__name__) if __name__ == &#39;__main__&#39;: print(&#39;正在独立运行该模块&#39;) 将会输出： __main__ 正在独立运行该模块 如果我们导入的模块名有冲突，可以使用 as 为导入的模块起一个别名 import math as math2 print(math2.__name__) # 模块名 math print(math2.ceil(4.3)) # 向上取整 5 print(math2.floor(4.8)) # 向下取整 4 有时候，导入的模块名路径很深，可以使用 from xxx import xxx来简化导入的路径： import os print(os.path.join(&#39;/tmp&#39;, &#39;a&#39;, &#39;b&#39;)) # 可以替换为 from os import path print(path.join(&#39;/tmp&#39;, &#39;a&#39;, &#39;b&#39;)) 9.2 使用自己实现的模块新建一个文件 calc.py，在里面实现如下的函数： def area(length, width): return length * width print(&#39;this is calc module&#39;) if __name__ == &#39;__main__&#39;: assert(area(3, 4) == 12) print(&#39;test done&#39;) 执行 python calc.py，将会输出： this is calc module test done 在 main.py 中我们可以导入模块 calc 并使用，在 Python 中一个 .py 文件就可以被视为一个模块： import calc if __name__ == &#39;__main__&#39;: print(calc.__name__) print(calc.area(5, 10)) 执行 python main.py，将会输出： this is calc module calc 50 当模块被导入时会执行该模块的代码，因此也打印了 this is calc module，但没有打印 test done。 当 calc.py 作为一个模块导入时，属性 __name__ 与文件名相同，即等于 calc，因此没有进入到 if 分支中，而被独立执行时，__name__ 的值是 __main__，因此进入到了 if 分支，打印了 test done。 因此，我们可以利用这个特性，在模块被独立执行时运行一些代码，比如简单的测试逻辑，但不影响被导入时的执行逻辑。 9.3 使用第三方模块Python 拥有非常丰富的第三方模块，比如著名的爬虫框架 scrapy，数学基础库 numpy、数据处理利器 pandas 等。如果我们想使用第三方模块，只需要使用 pip 命令安装即可。 例如安装 numpy： pip3 install numpy 如果你的机器上同时安装了 Python2 和 Python3，给特定的 Python 版本安装可以使用： python3 -m pip install numpy 如果国内下载网速过慢，可以通过 -i 选项指定下载源： pip3 install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple 安装完成后，就可以像使用标准库一样使用 numpy 了： import numpy as np a = np.array([[1, 2, 3], [4, 5, 6]]) b = np.array([[1, 5, 8], [2, 5, 6]]) print (a - b) # 两个矩阵相减 # [[ 0 -3 -5] # [ 2 0 0]] 10 面向对象编程Python 是一门既支持过程式编程，又支持面向对象编程的一门语言。 面向对象是相对于面向过程来讲的，面向对象方法，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。 面向对象编程的三大特性： 封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式。 继承： 子类从父类继承方法，使得子类具有父类相同的行为。 多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。 10.1 类与对象Python 中使用关键字 class 声明一个类，一般继承基类 object： class Student(object): def __init__(self, name, age): self.name = name self.age = age def hello(self): print(&#39;你好，我是&#123;&#125;，今年&#123;&#125;岁&#39;.format(self.name, self.age)) if __name__ == &#39;__main__&#39;: jack = Student(&#39;Jack&#39;, 18) jack.hello() 类内部声明的方法默认是实例方法，第一个参数是 self，代表实例本身，调用时省略。 __init__ 是一个类的构造方法，第一个参数是 self，后面的参数根据需要声明，使用时使用 类名(参数) 可创建出一个属于该类的一个实例对象。name 和 age 都属于实例变量，实例变量属于该实例，不与其他实例共享。 其他方法的声明与普通的函数实现类似，唯一不同点在于实例方法可以通过参数 self 获取实例的属性或调用实例的其他方法。 10.2 类方法与类变量实例方法和实例变量是针对对象实例而言的，与实例方法和实例变量相对应的是类方法和类变量，属于该类的所有实例都可以共享，可以通过类.方法 或 实例.方法 的方式使用。 class Student(object): school = &#39;东方小学&#39; # 类变量 def __init__(self, name, age): self.name = name # 实例变量 self.age = age # 实例变量 def hello(self): print(&#39;你好，我是&#123;&#125;，今年&#123;&#125;岁&#39;.format(self.name, self.age)) @classmethod def print_school(cls): # 类方法 print(cls.school) if __name__ == &#39;__main__&#39;: jack = Student(&#39;Jack&#39;, 18) tom = Student(&#39;Tom&#39;, 20) jack.print_school() tom.print_school() Student.school = &#39;东明小学&#39; # 修改类变量 jack.print_school() # 东明小学 tom.print_school() # 东明小学 实例变量在构造函数 __init__ 内部声明，类变量在外部声明。 类内部声明的方法默认为实例方法，使用 @classmethod 声明类方法，第一个参数cls 代表类自己。 10.3 静态方法还有一类方法，既不会访问实例变量和方法，也不会访问类变量和方法，仅仅是一个辅助函数，比如因为某个实例方法实现过长，想把其中的一部分代码抽取出来独立成一个方法，提高代码可读性。而这个辅助函数仅对这个类有用，对其他类没有用。这种情况下，我们通常会将其声明为静态方法。 class Student(object): def __init__(self, name, age): self.name = name # 实例变量 self.age = age # 实例变量 def hello(self): print(&#39;你好，我是&#123;&#125;，今年&#123;&#125;岁&#39;.format(self.name, self.age)) @staticmethod def help_func(): print(&#39;我是一个静态方法&#39;) if __name__ == &#39;__main__&#39;: jack = Student(&#39;Jack&#39;, 18) Student.help_func() jack.help_func() 静态方法使用 @staticmethod 声明，与普通的全局函数没有任何区别，可以通过类.方法 或 实例.方法 的方式使用。与实例方法和类型方法相比，没有 self 或cls 参数。 10.4 继承class Rectangle(object): def __init__(self, length, width): self.length = length self.width = width def area(self): return self.length * self.width class Square(Rectangle): def __init__(self, length): super(Square, self).__init__(length, length) if __name__ == &#39;__main__&#39;: s = Square(4) print(s.area()) Square 继承了 Rectangle，因此拥有了 Rectangle 的所有属性和方法。 Square 可以根据需要覆盖父类的方法，在这里 Square 覆盖了父类的构造函数，参数列表从原来的 2 个变为了 1个。 子类可以通过 super(子类名, self).方法 的方式调用父类的方法。 11 单元测试为每一个模块编写单元测试是非常好的习惯，Python 也内置了一个单元测试库 unittest。 新建一个文件 calc.py，实现 area 和 volume 两个函数： def area(length, width): if length &lt; 0 or width &lt; 0: return 0 return length * width def volume(length, width, height): if length &lt; 0 or width &lt; 0 or height &lt; 0: return 0 return length * width * height 新建文件 calc_test.py 添加测试用例： import unittest import calc class TestCalc(unittest.TestCase): def test_area(self): self.assertEqual(calc.area(10, -1), 0) self.assertEqual(calc.area(10, 8), 80) def test_volume(self): self.assertEqual(calc.volume(2, -1, 4), 0) self.assertEqual(calc.volume(2, 3, 4), 24) if __name__ == &#39;__main__&#39;: unittest.main() 添加测试用例的过程非常简单，定义一个类，继承 unittest.TestCase，然后定义一个或多个 test_ 开头的方法即可。每一个 test_ 开头的方法视为一个用例，这是 unittest 测试框架的约定。 测试用例中，可以使用 assertEqual、assertTrue 等方式检查预期输出。 unittest.main() 将加载该模块中定义的所有用例并执行。 $ python3 calc_test.py .. ---------------------------------------------------------------------- Ran 2 tests in 0.000s OK 使用如下方式可以指定测试某个模块、某个测试类，甚至是只运行某个测试用例: python -m unittest test_module1 test_module2 python -m unittest test_module.TestClass python -m unittest test_module.TestClass.test_method python3 calc_test.py 等价于 python3 -m unittest calc_test。如果只想执行 test_volume 方法，可以这么调用： python3 -m unittest calc_test.TestCalc.test_volume 11.1 setUp 与 tearDown有时候，每个用例执行前后需要一些相同的准备动作和收尾动作，比如打开文件和关闭文件。如果每个用例里都调用一次，就会异常繁琐。与其他测试框架类似，unittest 提供了 setUp 和 tearDown 功能，用于设置每个用例执行前后的一些指令。unittest 还提供了 setUpClass 和 tearDownClass 两个方法，用于设置某个测试类所有用例执行前后的一些指令。 import unittest class TestCalc(unittest.TestCase): @classmethod def setUpClass(cls): print(&#39;所有用例执行前&#39;) @classmethod def tearDownClass(cls): print(&#39;所有用例执行后&#39;) def setUp(self): print(&#39;单个用例执行前&#39;) def tearDown(self): print(&#39;单个用例执行后&#39;) def test_1(self): pass def test_2(self): pass if __name__ == &#39;__main__&#39;: unittest.main() 执行结果如下： $ python3 -m unittest calc_test 所有用例执行前 单个用例执行前 单个用例执行后 .单个用例执行前 单个用例执行后 .所有用例执行后 ---------------------------------------------------------------------- Ran 2 tests in 0.000s OK 关于单元测试的更多用法，可以参考 unittest - Python 官方文档 附这篇文章托管在 github，如果有错别字或其他修改建议，可以直接提 PR，感谢您的阅读和贡献。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Python3","slug":"后端/Python3","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Python3/"}],"tags":[{"name":"Python3","slug":"Python3","permalink":"https://ysluckly.github.io/tags/Python3/"}]},{"title":"Go sqlx操作mysql教程","slug":"back-end/go-sqlx","date":"2021-11-24T13:59:10.000Z","updated":"2022-02-20T13:31:33.482Z","comments":true,"path":"2021/11/24/go/","link":"","permalink":"https://ysluckly.github.io/2021/11/24/go/","excerpt":"","text":"sqlx是Go数据库操作包，它在database/sql包的基础上增加了更加高效的数据库操作函数，也就是说使用sqlx操作数据库比使用database/sql更加方便。 1.sqlx关键概念介绍sqlx定义了下面几个关键类型: sqlx.DB - 代表一个数据库 sqlx.Tx - 代表一个事务 sqlx.Rows - 代表sql查询结果的多行记录 sqlx.Row - 代表sql查询结果的一条记录 使用sqlx的关键步骤:根据mysql地址和帐号密码，创建sqlx.DB对象 通过sqlx.DB对象的sql查询函数，操作数据库 2.安装包//安装sqlx包 go get github.com/jmoiron/sqlx //安装mysql驱动 go get github.com/go-sql-driver/mysql 3.导入包import ( //导入mysql驱动 _ &quot;github.com/go-sql-driver/mysql&quot; //导入sqlx包 &quot;github.com/jmoiron/sqlx&quot; ) 3.连接数据库//定义数据库对象 var pool *sqlx.DB //定义mysql数据源，配置数据库地址，帐号以及密码， dsn格式下面会解释 dsn := &quot;root:123456@tcp(localhost:3306)/tizi365?charset=utf8&amp;parseTime=True&amp;loc=Local&quot; //根据数据源dsn和mysql驱动, 创建数据库对象 pool, err := sqlx.Open(&quot;mysql&quot;, dsn) if err != nil &#123; panic(err) &#125; MYSQL dsn格式： {username}:{password}@tcp({host}:{port})/{Dbname}?charset=utf8&amp;parseTime=True&amp;loc=Local 参数说明: 参数 说明 &#123;username&#125; 数据库帐号 &#123;password&#125; 数据库密码 &#123;host&#125; 数据库地址 &#123;port&#125; 数据库端口 &#123;Dbname&#125; 数据库名字 说明: charset=utf8 用于设置字符集，parseTime=True表示将数据库时间类型转换成Go时间类型 4.数据库连接池设置sqlx.DB内置了数据库连接池，在你调用sql查询函数的时候，自动从连接池申请连接，可以通过下面方式设置连接池参数: //设置连接池最大连接数 pool.SetMaxOpenConns(100) //设置连接池最大空闲连接数 pool.SetMaxIdleConns(20) 5.sql语句绑定参数绑定参数指的是：在sql语句中通过占位符(?), 定义一些参数，然后在执行sql语句的时候再把参数传递进去。 说明： sql语句绑定参数，除了方便我们拼接sql语句参数之外，还有一个重要的功能就是参数的安全检查和过滤，避免sql注入攻击。 例子: //这里通过占位符（？），定义了两个参数 sql := &quot;select * from tablename where cat=? and uid=?&quot; //执行sql，并且传入两个参数, 函数的第二个参数101对应sql语句的第一个问号，第三个参数5对应第二个问号 db.Queryx(sql, 101, 5) 提示：sqlx.DB提供的查询函数，都支持参数绑定，教程后续会有相应的例子 6.插入数据sqlx为我们定义两个函数用于执行插入，更新以及执行DDL语句（创建表，修改表等等）： Exec MustExec 这两个函数的作用是一样的，区别就是处理错误的机制不一样，MustExec遇到错误的时候直接抛出一个panic错误，程序就退出了；Exec是将错误和执行结果一起返回，由我们自己处理错误。 我们先定义一个mysql表结构并创建表： //定义表结构 schema := `CREATE TABLE place ( id int primary key auto_increment, country varchar(50), city varchar(50) NULL default &#39;&#39;, telcode int);` // 调用Exec函数执行sql语句，创建表 _, err := pool.Exec(schema) //错误处理 if err != nil &#123; panic(err) &#125; 插入数据的例子: //定义sql语句, 通过占位符 问号（ ? ) 定义了三个参数 countryCitySql := `INSERT INTO place (country, city, telcode) VALUES (?, ?, ?)` //通过Exec插入数据, 这里传入了三个参数，对应sql语句定义的三个问号所在的位置 result1,err := db.Exec(countryCitySql, &quot;中国&quot;, &quot;香港&quot;, 852) //错误处理 if err != nil &#123; fmt.Println(&quot;插入失败!&quot;) &#125; //插入成功后，获取insert id id, _ := result.LastInsertId() //通过MustExec插入数据, 如果sql语句出错，则直接抛出panic错误 result2 := db.MustExec(countryCitySql, &quot;South Africa&quot;, &quot;Johannesburg&quot;, 27) //插入成功后，获取插入id id2, _ := result2.LastInsertId() 提示: mysql表如果存在自增id，则可以通过Exec返回的结果对象的LastInsertId，查询新插入数据的ID 7.更新数据//定义sql语句，通过问号定义了三个参数 sql := &quot;update place set telcode=?, city=? where id=?&quot; //通过Exec更新数据, 这里传入了三个参数，对应sql语句定义的三个问号所在的位置 result1,err := db.Exec(sql, 100, &quot;香港&quot;, 1) //错误处理 if err != nil &#123; fmt.Println(&quot;更新失败!&quot;) &#125; //查询更新影响行数 rowsAffected, _ := result1.RowsAffected() 8.查询数据8.1.通过Get和Select函数查询数据Get函数主要用于查询一条记录，Select用于查询多条记录。 例子: //定义保存查询结果的struct变量 p := Place&#123;&#125; // 查询一条记录, 并且往sql语句传入参数 1，替换sql语句中的问号，最后将查询结果保存到struct对象中 err = pool.Get(&amp;p, &quot;SELECT * FROM place LIMIT ?&quot;, 1) var total int //统计表的总记录数，并将查询结果保存到一个变量中 err = pool.Get(&amp;total, &quot;SELECT count(*) FROM place&quot;) //定义一个保存多条记录的struct数组变量 pp := []Place&#123;&#125; // 通过Select查询多条记录，并且将结果保存至pp变量中 // 这里相当于将一条记录的字段值都映射到struct字段中 err = pool.Select(&amp;pp, &quot;SELECT * FROM place WHERE telcode &gt; ?&quot;, 50) var names []string // 通过Select查询多条记录，并且将结果保存至names变量中 // 这里仅查询一个字段 err = pool.Select(&amp;names, &quot;SELECT name FROM place LIMIT 10&quot;) 8.2.通过Queryx和QueryRowx查询数据相对于Get和Select函数，Queryx和QueryRowx函数要繁琐一些。Queryx可以用于查询多条记录，QueryRowx函数用于查询一条记录。 Queryx例子1 // 查询所有的数据，这里返回的是sqlx.Rows对象 rows, err := pool.Queryx(&quot;SELECT country, city, telcode FROM place&quot;) //错误检测 if err !=nil &#123; panic(err) &#125; // 循环遍历每一行记录，rows.Next()函数用于判断是否还有下一行数据 for rows.Next() &#123; //这里定义三个变量用于接收每一行数据 var country string var city string var telcode int //调用Scan函数，将当记录的数据保存到变量中，这里参数的顺序跟上面sql语句中select后面的字段顺序一致。 err = rows.Scan(&amp;country, &amp;city, &amp;telcode) &#125; Queryx例子2, 将每一行记录保存到struct/map/数组变量中Rows对象支持将每一行的数据保存到struct、map或者数组中。 //定义保存数据的结构体， 默认struct字段名（小写）跟表的字段名一致。 type Place struct &#123; Country string //因为city字段允许null，所以这里可以使用sql.NullString类型 City sql.NullString //如果struct字段名跟表的字段名不一样，可以通过db标签设置数据库字段名 TelephoneCode int `db:&quot;telcode&quot;` &#125; //查询数据 rows, err := pool.Queryx(&quot;SELECT * FROM place&quot;) //遍历数据 for rows.Next() &#123; //下面演示如何将数据保存到struct、map和数组中 //定义struct对象 var p Place //定义map类型 m := make(map[string]interface&#123;&#125;) //定义slice类型 s := make([]interface&#123;&#125;, 0) //使用StructScan函数将当前记录的数据保存到struct对象中 err = rows.StructScan(&amp;p) //保存到map err = rows.MapScan(&amp;m) //保存到数组 err = rows.SliceScan(&amp;s) &#125; QueryRowx例子 QueryRowx操作跟Queryx类似，区别就是返回一行数据 //查询数据 row, err := pool.QueryRowx(&quot;SELECT country, city, telcode FROM place where id = ?&quot;, 1) //定义保存数据的结构体， 默认struct字段名（小写）跟表的字段名一致。 type Place struct &#123; Country string City sql.NullString Telcode int &#125; var p Place //使用StructScan函数将当前记录的数据保存到struct对象中 err = row.StructScan(&amp;p) 提示: sqlx.Row跟sqlx.Rows对象获取数据的方式一样，支持将数据保存到map,slice,struct中，可以参考上面Queryx的例子。 9.删除数据 //定义sql语句，通过问号定义了一个参数 sql := &quot;delete from place where id=?&quot; //通过Exec删除数据, 这里传入了一个参数，对应sql语句定义的问号所在的位置 result1,err := pool.Exec(sql, 1) //获取删除影响行数 rowsAffected, _ := result1.RowsAffected() //错误处理 if err != nil &#123; fmt.Println(&quot;更新失败!&quot;) &#125; 10.事务处理 sqlx使用mysql事务的格式: //开始一个事务，返回一个事务对象tx tx, err := pool.Beginx() //使用事务对象tx, 执行事务 err = tx.Queryx(...) err = tx.Exec(...) err = tx.Exec(...) if err != nil &#123; //回滚事务 tx.Rollback() &#125; //提交事务 err = tx.Commit() 提示：注意上面的事务格式，使用的是事务对象tx执行sql，而不是数据库对象，数据库对象执行sql每次都会申请一个新的数据库连接，会导致事务无效。 mysql事务例子: //开始一个事务，返回一个事务对象tx tx, err := pool.Beginx() //执行事务 err1 = tx.Exec(&quot;delete from place where id=?&quot;, 1) err2 = tx.Exec(&quot;delete from place where id=?&quot;, 2) if err1 != nil || err2 != nil &#123; //回滚事务 tx.Rollback() &#125; //提交事务 tx.Commit() 参考golang使用mysql实例和第三方库GendryGo操作sqlxGO语言Gin框架数据库操作（原生、xorm、gorm）","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"}],"tags":[{"name":"sqlx","slug":"sqlx","permalink":"https://ysluckly.github.io/tags/sqlx/"},{"name":"Go数据库","slug":"Go数据库","permalink":"https://ysluckly.github.io/tags/Go%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"VMware Pro 14 安装 Ubuntu 18.04 详细教程","slug":"linux/A06-install-ubuntu18.04","date":"2021-10-24T02:10:45.000Z","updated":"2022-02-20T13:20:27.093Z","comments":true,"path":"2021/10/24/linux/","link":"","permalink":"https://ysluckly.github.io/2021/10/24/linux/","excerpt":"","text":"1.下载安装 VMware Workstation Pro 14 进入 VMware 官网或者在软件商店下载最新版VMware虚拟机并安装 2.下载 Ubuntu 18.04 系统 进入 Ubuntu 官网，下载最新版 Ubuntu 系统镜像 3.在 VMware 中创建虚拟机打开安装好的 VMware Workstation Pro 14，选择创建新的虚拟机 在新建虚拟机向导中选择自定义（高级） 默认直接下一步，直到出现下图，再选择稍后安装操作系统 选择客户机操作系统为 Linux ，如果你电脑是32位就选择 Ubuntu 版本，64位就选择 Ubuntu 64 位版本 更改虚拟机名称及存放位置 为虚拟机指定处理器数量，默认即可 为虚拟机分配内存，太大了可能会导致卡顿，太小了也不好，推荐内存大小即可 以下均选择默认即可 选择创建新虚拟磁盘 选择将虚拟磁盘储存为单个文件 默认下一步 点击完成 此时我们就可以在虚拟机左侧“我的计算机”下面看到刚刚创建的虚拟机 Ubuntu 64 位，单击 Ubuntu 64 位，选择“编辑虚拟机设置”， 再选择“CD/DVD(SATA)”，选择“使用ISO映像文件”，点击“浏览”，找到先前我们下载好的 Ubuntu 64 位镜像文件，点击“确定” 4.在虚拟机上安装 Ubuntu 系统单击 Ubuntu 64 位，选择“开启此虚拟机” 来到欢迎界面，选择好语言，点击“安装 Ubuntu” 选择键盘布局为“汉语” 更新和其他软件默认选择即可 安装类型选择“清除整个磁盘并安装 Ubuntu”，PS: 因为我们是新安装的系统，且在虚拟机中，所以可以选择清除整个磁盘，这个操作不会清除你原来电脑里面的东西 地区随便，在中国就行，默认即可 之后设置计算机名，密码 点击继续稍等一会就安装完成啦 安装过程中可能会出现的一些问题 1.在虚拟机上安装 Ubuntu 系统的过程中卡死不动 解决方法：关闭网络，重新安装即可 2.Ubuntu 不能全屏显示解决方法：方法①：安装 open-vm-tools： sudo apt-get install open-vm-tools 然后执行： sudo apt-get install open-vm* 重启即可全屏显示 方法②：在终端输入xrandr，并回车，我们就可以看到很多可以修改的分辨率，选择好分辨率后，比如我们要修改分辨率为 1920x1440 ，则在终端输入 xrandr -s 1920x1440，回车即可，注意 1920x1440 中间是小写字母 x，本人亲测此方法并不是很完美，不能完全适应屏幕 方法③：安装 VMware Tools：1、进入 Ubuntu 系统后，点击虚拟机上的【虚拟机】—＞【安装 VMware Tools】，回到桌面即可看到一个 VMware Tools 的 图标2、复制 VMwareTools-10.0.10-4301679.tar.gz（版本根据自己的实际情况而定）到 home 目录下， 用命令 tar -xzvf VMwareTools-10.0.10-4301679.tar.gz 进行解压3、解压后 cd vmware_tools_distrib，打开终端4、输入“sudo ./vmware-install.pl”，输入用户密码后开始安装5、接下来会有很多地方需要你按 Enter或者 Yes6、当你看到出现 —the vmware team 的字样后就可以关闭窗口了，此时窗口就会自动全屏了，如果没有全屏，重启过后就可以了7、若还没有全屏显示，则将虚拟机的【查看】—&gt;【自动调整大小】—&gt;【自适应客户机】，都选上，即可实现全屏","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"},{"name":"linux","slug":"运维/linux","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/linux/"}],"tags":[{"name":"VMware","slug":"VMware","permalink":"https://ysluckly.github.io/tags/VMware/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ysluckly.github.io/tags/Ubuntu/"}]},{"title":"主流 Markdown 编辑器推荐","slug":"tools/A05-markdown-editor","date":"2021-10-24T02:10:45.000Z","updated":"2022-02-20T13:20:18.333Z","comments":true,"path":"2021/10/24/tools/","link":"","permalink":"https://ysluckly.github.io/2021/10/24/tools/","excerpt":"","text":"Markdown ，2004年由 John Gruberis 设计和开发，是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式，以下将介绍目前比较流行的一些 Markdown 编辑器（排名不分先后） - MarkdownPad 目前分为 MarkdownPad2 和 MarkdownPad Pro 版本，后者收费，我们使用前者足矣，用户可以通过键盘快捷键和工具栏按钮来使用或者移除 Markdown 各种语法格式，支持自定义配色方案、字体、大小和布局 、即时HTML预览、HTML和PDF导出，被很多人称赞为 Windows 平台最好用的 Markdown 编辑器，实用性强，仅支持 Windows 系统，个人觉得在 Windows 10 系统上界面并不是很好看，有时候添加音乐什么的，资源多了，实时预览会显示资源加载失败，点击此处访问 MarkdownPad 官网 - BookPad 无意间在 Microsoft Store 上发现的，完美搭配 Win10 系统，界面非常简洁漂亮，2017年9月份发布，大小30.82 MB，官方网站：https://sosfos.wordpress.com/ ，收费13人民币，可免费使用7天，各种功能应有尽有，和其他编辑器不相上下，本来想着百度百度看看有没有破解版，结果全网看不见 BookPad 的影子，估计是新出来的还不为人所知吧，可以直接在 Microsoft Store 搜索下载，或者点击链接获取：https://www.microsoft.com/store/apps/9N6P5ZH2SJSX - 小书匠 分为免费版和收费版，收费版¥20/年，其实免费版的功能已经足够强大了，多种编辑模式、多种主题选择、多种编辑器实现、丰富的语法支持、第三方同步、强大的文件管理功能，让人使用一次就爱上了它，支持 Windows 和 Web，推荐使用，点击此处访问小书匠官网 - TyporaTypora 同样支持 Windows、OS X 和 Linux，Typora 支持即时渲染技术，这也是与其他 Markdown 编辑器最显著的区别，支持数学编辑，可与 Word 直接格式转换，在 Pandoc 的支持下进行多种文档格式转换，Typora 适合那些对码字手速和排版顺畅度有要求的人群，譬如码农、网站小编等，点击此处访问 Typora 官网 - Visual Studio CodeVisual Studio Code 是众所周知的神器，是微软推出一款轻量级的文本编辑工具，类似于 Sublime，它已经默认集成 Markdown 文档编辑插件，原生就支持高亮 Markdown 的语法，但想要实时预览还需要选择 Markdown: Open Preview to the Side 命令实现，相关教程请点击此处，点击此处 访问 Visual Studio Code 官网 - MarxicoMarxico 中文名马克飞象，提供桌面客户端以及离线 Chrome App，支持移动端 Web，可以直接把文本存到印象笔记，点击此处访问 Marxico，点击此处访问 马克飞象 - Sublime Text 3Sublime Text 3 是基于 Vim 开发的跨平台代码编辑器，收费80美元，好像可以免费试用，支持 OS X、Windows、Ubuntu 等 UNIX 及 Linux 操作系统，由于其功能的多样性而广受好评，界面简约大方，定位专业，原生支持的编程语言就多达十几种，通过第三方插件，还能实现更多语法的支持，其中就包括 Markdown ，但也有个缺点，就是不能实时预览，但是用户可以通过 Markdown Preview 的插件实现对 Markdown 的预览，具体教程请点击此处查看，点击此处访问 Sublime Text 官网 - Mou Mou 是一款由国人独立开发者罗晨开发的实时预览型 Markdown 编辑器，仅支持 OS X操作系统，是目前同类应用中对汉字兼容性最好的作品，也是目前最好用的免费 Markdown 编辑器，提供语法高亮、在线预览、同步滚动、全屏模式，支持自定保存、自动匹配，允许自定义主题，支持 CSS，HTML 和 PDF 导出等功能，点击此处访问 Mou 官网 - AtomAtom 是 Github 专门为程序员推出的一个跨平台文本编辑器，具有简洁和直观的图形用户界面，并有很多有趣的特点：支持CSS，HTML，JavaScript等网页编程语言，当然也支持 Markdown ，支持宏，自动完成分屏功能，集成了文件管理器，点击此处访问 Atom 官网 - Smark国人编写的开源软件，Windows / Linux 等主流系统跨平台支持，完美支持 LaTex 数学公式、脚注、尾注等，支持使用本地 MathJax 调用，不需要在线访问 MathJax CDN，用户可配置的 Markdown 语法高亮显示，美观整洁，多种格式文件导出支持，简洁友好的界面布局，完备的各类快捷键，能极大地提高工作效率，点击此处访问 Smark 官网 - HaroopadHaroopad 覆盖三大主流桌面系统，支持 Windows、OS X 和 Linux，多种主题样式供你选择，语法标亮支持 54 种编程语言，该工具重点推荐 Ubuntu/Linux 用户使用，点击此处访问 Haroopad 官网 - CuteMarkEdCuteMarkEd 是一个基于qt5的跨平台的 Markdown 编辑器，开源的， 提供实时 HTML 预览、数学表达式、源码高亮和PDF导出，点击此处 访问 CuteMarkEd 官网 - MarkPadMarkPad 是款开源的 Markdown 编辑器，与 Window 8 风格和谐友好的界面，可以直接在你的博客或者 GitHub 中打开、保存文档，直接将图片粘贴到 Markdown 文档中，点击此处访问 MarkPad 官网 - Cmd Markdown作业部落出品，是一款不错的工具和博客平台兼顾的产品，同时支持 Linux、Mac 和 Windows 操作系统，此外还提供 Web 在线创作，社交化批注、智能云同步，最简单的方法，满足多种写作需要，点击此处访问 Cmd Markdown 官网 - FarBox同样是一款不错的 Markdown 编辑器和博客平台兼顾的产品，让用户通过Dropbox（现在默认是自己的同步服务器）直接建立个人网站。FarBox编辑器免费，同时支持 Linux、Mac 和 Windows 操作系统，Farbox服务可以免费试用，在本地编辑器内写作自动同步发布在个人博客，对于希望有个人博客但却不愿折腾的小白来说，是个不错的选择，点击此处访问 FarBox 官网 - MiuMiu 是一款 Windows 下的 Markdown 编辑器，支持 Markdown 高亮、代码高亮、即时预览，以及可以快速发布到 Github Gist，小众软件，界面美观，已经找不到官网了，小众软件网有提供百度云下载，Miu 下载地址 - MacDownMacDown 引用了许多 Mou 的设计方式，仅支持 Mac ，开源免费，点击此处访问 MacDown 官网 - Ulysses一款由国外开发商 The Soulmen 制作的 Markdown 编辑器。与其它同类应用相比，Ulysses 最大的不同在于，它能根据内置的文件管理器，以及与 iCloud 云服务器的实时同步方案，达到最快捷的文章整理效率，支持OS X , iPad，26人民币每月，14天免费试用，点击此处访问 Ulysses 官网 - Byword一款轻量级的 Markdown 编辑器，支持Mac，iPhone和iPad，界面极简，功能强大，貌似要付费使用，点击此处 访问 Byword 官网 - MaHua一个在线编辑 Markdown 文档的编辑器，小众软件，VIM 快捷键支持，完美兼容 Github 的 Markdown 语法，界面稍许简陋，点击此处访问 MaHua - Dillinger来自国外的 Markdown 编辑器，漂亮强大，支持md、 html、pdf 文件导出，支持Dropbox、Github、Google Drive、Onedrive 一键保存，点击此处访问 Dillinger - CSDN中国专业IT社区CSDN (Chinese Software Developer Network) 创立于1999年，致力于为中国软件开发者提供知识传播、在线学习、职业发展等全生命周期服务。CSDN的在线编辑器功能强大，支持导出为HTML和md文件，注册账号后即可开始创作，点击此处访问CSDN官网 - 简书简书是一个优质的创作社区，你可以在线创作并发表到社区，是国内优质原创内容输出平台，简书从一开始就已经支持 Markdown 和富文本编辑，是一个为专门为作者打造的平台，点击此处访问简书官网 在写博客的时候，我们不希望都是千篇一律的没有色彩，多了解一些 Markdown 语法技巧有利于丰富我们的博客，看起来更有 feel ！ – 插入图片 如果你使用 MarkdownPad 的话就比较方便，可以直接选择插入本地图片或者是网络图片，实质是通过以下代码实现的，小括号里面就是你的图片地址，中括号里面是图片的替代文字，比如上面的图片代码如下： ![车](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A03/01.jpg) – 插入音乐 打开网页版网易云音乐，选择你准备插入的音乐，点击生成外链播放器，前提是要有版权，不然是无法生成外链播放器的，选择好尺寸后，复制底下的HTML代码 然后将此HTML代码粘贴到你想要放的地方，可自行调节播放器的大小，其中 auto=1 表示打开网页自动播放音乐，auto=0 表示关闭自动播放音乐，比如See You Again (中英文版) - 罗艺恒这首歌曲代码如下： &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=32405683&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt; – 插入视频 高考毕业了我们为下一届的学弟学妹们录制高考加油视频，我担任后期制作，在这里就以该视频为例٩(๑❛ᴗ❛๑)۶，在腾讯视频播放页面找到分享按钮，复制该视频的通用代码（其他视频播放平台也一样）,粘贴到文章中对应位置即可，可根据情况调整视频播放器的大小 &lt;iframe frameborder=&quot;0&quot; width=&quot;840&quot; height=&quot;500&quot; src=&quot;https://v.qq.com/txp/iframe/player.html?vid=x0643zvgtf7&quot; allowFullScreen=&quot;true&quot;&gt;&lt;/iframe&gt; 未完待续…… 要细数 Markdown 编辑器的话，可能永远也数不尽，而且每个人的看法也不同，正所谓萝卜白菜各有所爱，什么编辑器不是最重要的，重要的是我们能写出优质的文章，不断学习进步！不断提升自我！ 参考资料：《好用的Markdown编辑器一览》（By：月光）《10款流行的Markdown编辑器，总有一款适合你》（By：xiaoxiao_engineer）《解决作者们的焦虑：7 款优秀 Markdown 编辑工具推荐》（By：JailJT）《markdown基本语法》","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"markdown","slug":"工具/markdown","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://ysluckly.github.io/tags/Markdown/"},{"name":"编辑器","slug":"编辑器","permalink":"https://ysluckly.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"}]},{"title":"免费CDN：jsDelivr + Github","slug":"tools/A18-free-cdn","date":"2021-10-24T02:10:45.000Z","updated":"2022-02-20T13:20:04.982Z","comments":true,"path":"2021/10/24/hexo/","link":"","permalink":"https://ysluckly.github.io/2021/10/24/hexo/","excerpt":"","text":"CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科 放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。 1、新建Github仓库 2、克隆Github仓库到本地 点击 Clone or download，一键复制仓库地址 在本地目录右键 Git Bash Here，执行以下命令： git clone 一键复制的仓库地址 3、上传资源 复制需要上传的资源到本地git仓库（注：jsDelivr不支持加载超过20M的资源），在本地git仓库目录下右键 Git Bash Here，执行以下命令： git status //查看状态 git add . //添加所有文件到暂存区 git commit -m &#39;第一次提交&#39; //把文件提交到仓库 git push //推送至远程仓库 4、发布仓库 点击release发布 自定义发布版本号 5、通过jsDelivr引用资源 使用方法：https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径例如：https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/ys-thx.png&nbsp;&nbsp;&nbsp;&nbsp;https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.1/css/style.css&nbsp;&nbsp;&nbsp;&nbsp;https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4 注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下： // 加载任何Github发布、提交或分支https://cdn.jsdelivr.net/gh/user/repo@version/file // 加载 jQuery v3.2.1https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js // 使用版本范围而不是特定版本https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.jshttps://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js // 完全省略该版本以获取最新版本https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js // 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js // 在末尾添加 / 以获取资源目录列表https://cdn.jsdelivr.net/gh/jquery/jquery/","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"jsDelivr","slug":"jsDelivr","permalink":"https://ysluckly.github.io/tags/jsDelivr/"},{"name":"CDN","slug":"CDN","permalink":"https://ysluckly.github.io/tags/CDN/"}]},{"title":"利用Cloudflare为基于GitHub Pages的Hexo博客添加HTTPS支持","slug":"tools/A26-hexo-add-https","date":"2021-10-24T02:10:45.000Z","updated":"2022-02-20T13:20:10.317Z","comments":true,"path":"2021/10/24/hexo/","link":"","permalink":"https://ysluckly.github.io/2021/10/24/hexo/","excerpt":"","text":"HTTP（超文本传输协议），是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议，所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。 HTTPS（超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。 – 前言GitHub Pages 自带的域名（xxx.github.io）支持开启 https 服务，可以在仓库的【Settings】- 【GitHub Pages】下勾选【Enforce HTTPS】即可，但是如果你设置了自定义域名的话，就比较复杂了，因为 hexo 博客是托管在 GitHub 上的，没有自己的服务器，因此也不支持上传 SSL 证书，从2018年5月1日起，GitHub官方也支持自定义域名开启https了，实现方法可参考我的文章：《利用官方支持为基于GitHub Pages的Hexo博客启用HTTPS》，另外一种方法就是利用 Cloudflare 的 CDN 中转来启用 HTTPS，这种方法的弊端就是国内访问速度可能会变慢，本文主要讲述这种方法 Cloudflare 是一家美国的跨国科技企业，以向客户提供网站安全管理、性能优化及相关的技术支持为主要业务，它提供了免费的 https 服务，注意不是应用SSL证书，实现原理：用户到CDN服务器的连接为 https 方式，而CDN服务器到 GithubPages 服务器的连接为 http 方式，在CDN服务器那里加上反向代理 – 注册 Cloudflare到 Cloudflare官网 注册账号 – 添加站点添加你的站点，一直下一步即可如果你已经在域名服务商那里解析过域名的话，之后就会出现你域名的解析列表，如果还没有解析过，可以参考《为hexo博客配置个性域名》 –修改DNS点击下一步 Cloudflare 会提供给你两个 DNS 地址到域名服务商那里修改DNS，以阿里云为例，依次选择【控制台】-【域名】，选择你的域名，点击【管理】-【修改DNS】，将上面 Cloudflare 提供的两个 DNS 地址填进去，会过几分钟才生效 –开启 HTTPS在 Cloudflare 管理页面，点击【Crypto】选项，选择 SSL 的模式为【full】，注意：在CloudFlare 上激活站点后，可能需要24小时才能颁发新证书，耐心等待即可 关于三种模式 Flexible、Full、Full (Strict) 的区别： Flexible：访客与 Cloudflare 之间是加密的，Cloudflare 到站点服务器是不加密的 Full：访客到 Cloudflare、Cloudflare 到站点服务器都是加密的，它不会验证你服务器上的证书是否合法，因此你可以在你服务器上安装任何证书，包括自签名证书 Full (strict)：访客到 Cloudflare、Cloudflare 到站点服务器都是加密的，它会验证你服务器上的证书是否合法，你必须在你的服务器上安装有可信赖的CA证书，并且这个证书必须是未过期，包含有域名等信息的 至此，我们的域名就支持 https 访问了，但是当用户输入 http://xxxxxx 访问时，浏览器依旧会以 http 协议来访问，并不会跳转到 https，这时候就需要利用重定向来解决了 –重定向强制 HTTPSCloudflare 提供了一个名叫 Page Rules 的页面规则的功能，我们可以利用此功能对 URL 做一些处理，当用户访问是 HTTP 的时候重定向到 HTTPS，点击【Page Rules】选项，点击【Create Page Rules】，新建如下规则并保存即可 ![06.jpg](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A26/06.jpg) 现在我们的 Hexo 博客就实现了全站 HTTPS！ 参考教程Hexo建站系列教程hexo建站教程最全","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"Cloudflare","slug":"Cloudflare","permalink":"https://ysluckly.github.io/tags/Cloudflare/"}]},{"title":"Github+jsDelivr+PicGo 打造稳定快速、高效免费图床","slug":"tools/A27-image-hosting","date":"2021-10-24T02:10:45.000Z","updated":"2022-02-20T13:19:52.818Z","comments":true,"path":"2021/10/24/hexo/","link":"","permalink":"https://ysluckly.github.io/2021/10/24/hexo/","excerpt":"","text":"– 前言图床是个啥东西就不用过多介绍了，先来对比一下各路图床： 微博图床：以前用的人比较多，从2019年4月开始开启了防盗链，凉凉 SM.MS：运营四年多了，也变得越来越慢了，到了晚上直接打不开图片，速度堪忧 其他小众图床：随时有挂掉的风险 Imgur等国外图床：国内访问速度太慢，随时有被墙的风险 大厂储存服务：例如七牛云、又拍云、腾讯云COS、阿里云OSS等，容量限制，操作繁琐，又是实名认证又是域名备案的，麻烦，而且还要花钱（有钱又不怕麻烦的当我没说） 因此，GitHub 图床是个不错的选择，利用 jsDelivr CDN 加速访问（jsDelivr 是一个免费开源的 CDN 解决方案），PicGo 工具一键上传，操作简单高效，GitHub 和 jsDelivr 都是大厂，不用担心跑路问题，不用担心速度和容量问题，而且完全免费，可以说是目前免费图床的最佳解决方案！ – 新建GitHub仓库登录/注册GitHub，新建一个仓库，填写好仓库名，仓库描述，根据需求选择是否为仓库初始化一个README.md描述文件 ![01](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/01.jpg) ![02](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/02.jpg) – 生成一个Token在主页依次选择【Settings】-【Developer settings】-【Personal access tokens】-【Generate new token】，填写好描述，勾选【repo】，然后点击【Generate token】生成一个Token，注意这个Token只会显示一次，自己先保存下来，或者等后面配置好PicGo后再关闭此网页 ![03](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/03.jpg) ![04](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/04.jpg) ![05](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/05.jpg) ![06](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/06.jpg) ![07](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/07.jpg) – 配置PicGo前往下载PicGo，安装好后开始配置图床 ![08](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/08.jpg) 设定仓库名：按照【用户名/图床仓库名】的格式填写 设定分支名：【master】 设定Token：粘贴之前生成的【Token】 指定存储路径：填写想要储存的路径，如【ITRHX-PIC/】，这样就会在仓库下创建一个名为 ITRHX-PIC 的文件夹，图片将会储存在此文件夹中 设定自定义域名：它的作用是，在图片上传后，PicGo 会按照【自定义域名+储存路径+上传的图片名】的方式生成访问链接，并放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为【https://cdn.jsdelivr.net/gh/用户名/图床仓库名 】，上传完毕后，我们就可以通过【https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径 】加速访问我们的图片了，比如上图的图片链接为：https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/08.jpg 关于 jsDelivr 具体是如何引用资源的可以参考我的另一篇博客：《免费CDN：jsDelivr+Github》 – 进行高效创作配置好PicGo后，我们就可以进行高效创作了，将图片拖拽到上传区，将会自动上传并复制访问链接，将链接粘贴到博文中就行了，访问速度杠杠的，此外PicGo还有相册功能，可以对已上传的图片进行删除，修改链接等快捷操作，PicGo还可以生成不同格式的链接、支持批量上传、快捷键上传、自定义链接格式、上传前重命名等，更多功能自己去探索吧！ 参考教程Hexo建站系列教程hexo建站教程最全","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"jsDelivr","slug":"jsDelivr","permalink":"https://ysluckly.github.io/tags/jsDelivr/"},{"name":"CDN","slug":"CDN","permalink":"https://ysluckly.github.io/tags/CDN/"},{"name":"图床","slug":"图床","permalink":"https://ysluckly.github.io/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"PicGo","slug":"PicGo","permalink":"https://ysluckly.github.io/tags/PicGo/"}]},{"title":"Hexo 博客提交百度、谷歌搜索引擎收录","slug":"tools/A48-submit-search-engine-inclusion","date":"2021-10-24T02:10:45.000Z","updated":"2022-02-20T13:21:06.369Z","comments":true,"path":"2021/10/24/hexo/","link":"","permalink":"https://ysluckly.github.io/2021/10/24/hexo/","excerpt":"","text":"● 写在前面（必看）网站在没有提交搜索引擎收录之前，直接搜索你网站的内容是搜不到的，只有提交搜索引擎之后，搜索引擎才能收录你的站点，通过爬虫抓取你网站的东西，对于 hexo 博客来说，如果你是部署在 GitHub Pages，那么你是无法被百度收录的，因为 GitHub 禁止了百度爬虫，最常见的解决办法是双线部署到 Coding Pages 和 GitHub Pages，因为百度爬虫可以爬取到 Coding 上的内容，从而实现百度收录，如果你的 hexo 博客还没有实现双线部署，请参考：《Hexo 双线部署到 Coding Pages 和 GitHub Pages 并实现全站 HPPTS》，另外百度收录的所需的时间较长，大约半个月左右才会看到效果！ ● 查看网站是否被收录首先我们可以输入 site:域名 来查看域名是否被搜索引擎收录，如下图所示，表示没有收录： ![01](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/01.png) ● 百度资源平台添加网站访问百度搜索资源平台官网，注册或者登陆百度账号，依次选择【用户中心】-【站点管理】，添加你的网站，在添加站点时会让你选择协议头（http 或者 https），如果选择 https，它会验证你的站点，大约能在一天之内完成，我的网站已经实现了全站 https，因此选择了 https 协议，但是不知道为什么始终验证失败，实在是无解，只能选择 http 协议了，如果你的站点也实现了全站 https，也可以尝试一下 ![02](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/02.png) 之后会让你验证网站所有权，提供三种验证方式： 文件验证：下载给定的文件，将其放到本地主题目录 source 文件夹，然后部署上去完成验证 HTML 标签验证：一般是给一个 meta 标签，放到首页 &lt;head&gt; 与 &lt;/head&gt; 标签之间即可完成验证 CNAME 验证：个人觉得这种方法最简单，去域名 DNS 添加一个 CNAME 记录即可完成验证 ![03](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/03.png) ![04](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/04.png) ● 提交百度搜索百度提供了自动提交和手动提交两种方式，其中自动提交又分为主动推送、自动推送和 sitemap 三种方式，以下是官方给出的解释： 主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录 自动推送：是轻量级链接提交组件，将自动推送的 JS 代码放置在站点每一个页面源代码中，当页面被访问时，页面链接会自动推送给百度，有利于新页面更快被百度发现 sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送 手动提交：如果您不想通过程序提交，那么可以采用此种方式，手动将链接提交给百度 四种提交方式对比： 方式 主动推送 自动推送 Sitemap 手动提交 速度 最快 —— —— —— 开发成本 高 低 中 不需开发 可提交量 低 高 高 低 是否建议提交历史连接 否 是 是 是 和其他提交方法是否有冲突 无 无 无 无 个人推荐同时使用主动推送和 sitemap 方式，下面将逐一介绍这四种提交方式的具体实现方法 ● 主动推送在博客根目录安装插件 npm install hexo-baidu-url-submit --save，然后在根目录 _config.yml 文件里写入以下配置： baidu_url_submit: count: 1 # 提交最新的多少个链接 host: www.itrhx.com # 在百度站长平台中添加的域名 token: your_token # 秘钥 path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里 其中的 token 可以在【链接提交】-【自动提交】-【主动推送】下面看到，接口调用地址最后面 token=xxxxx 即为你的 token ![05](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/05.png) 同样是在根目录的 _config.yml 文件，大约第 17 行处，url 要改为在百度站长平台添加的域名，也就是你网站的首页地址： # URL url: https://www.itrhx.com root: / permalink: :year/:month/:day/:title/ 最后，加入新的 deployer： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: - type: git repository: github: git@github.com:TRHX/TRHX.github.io.git # 这是原来的 github 配置 coding: git@git.dev.tencent.com:TRHX/TRHX.git # 这是原来的 coding 配置 branch: master - type: baidu_url_submitter # 这是新加的主动推送 最后执行 hexo g -d 部署一遍即可实现主动推送，推送成功的标志是：在执行部署命令最后会显示类似如下代码： &#123;&quot;remain&quot;:4999953,&quot;success&quot;:47&#125; INFO Deploy done: baidu_url_submitter 这表示有 47 个页面已经主动推送成功，remain 的意思是当天剩余的可推送 url 条数 主动推送相关原理介绍： 新链接的产生：hexo generate 会产生一个文本文件，里面包含最新的链接 新链接的提交：hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎 该插件的 GitHub 地址：https://github.com/huiwang/hexo-baidu-url-submit ● 自动推送关于自动推送百度官网给出的解释是：自动推送是百度搜索资源平台为提高站点新增网页发现速度推出的工具，安装自动推送JS代码的网页，在页面被访问时，页面URL将立即被推送给百度 ![06](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/06.png) 此时要注意，有些 hexo 主题集成了这项功能，比如 next 主题，在 themes\\next\\layout_scripts\\ 下有个 baidu_push.swig 文件，我们只需要把如下代码粘贴到该文件，然后在主题配置文件设置 baidu_push: true 即可 &#123;% if theme.baidu_push %&#125; (function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') &#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else &#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); &#125;)(); &#123;% endif %&#125; 然而大部分主题是没有集成这项功能的，对于大部分主题来说，我们可以把以下代码粘贴到 head.ejs 文件的 &lt;head&gt; 与 &lt;/head&gt; 标签之间即可，从而实现自动推送（比如我使用的是 Material X 主题，那么只需要把代码粘贴到 \\themes\\material-x\\layout\\_partial\\head.ejs 中即可） &lt;script&gt; (function()&#123; var bp = document.createElement(&#39;script&#39;); var curProtocol = window.location.protocol.split(&#39;:&#39;)[0]; if (curProtocol === &#39;https&#39;) &#123; bp.src = &#39;https://zz.bdstatic.com/linksubmit/push.js&#39;; &#125; else &#123; bp.src = &#39;http://push.zhanzhang.baidu.com/push.js&#39;; &#125; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s); &#125;)(); &lt;/script&gt; ● sitemap首先我们要使用以下命令生成一个网站地图： npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save 这里也注意一下，将根目录的 _config.yml 文件，大约第 17 行处，url 改为在百度站长平台添加的域名，也就是你网站的首页地址： # URL url: https://www.itrhx.com root: / permalink: :year/:month/:day/:title/ 然后使用命令 hexo g -d 将网站部署上去，然后访问 你的首页/sitemap.xml 或者 你的首页/baidusitemap.xml 就可以看到网站地图了 比如我的是：https://www.itrhx.com/baidusitemap.xml 或者 https://www.itrhx.com/sitemap.xml 其中 sitemap.xml 文件是搜索引擎通用的 sitemap 文件，baidusitemap.xml 是百度专用的 sitemap 文件 然后来到百度站长平台的 sitemap 提交页面，将你的 sitemap 地址提交即可，如果成功的话状态会显示为正常，初次提交要等几分钟，sitemap.xml 相比 baidusitemap.xml 来说等待时间也会更长，如果以后你博客有新的文章或其他页面，可以点击手动更新文件，更新一下新的 sitemap ![07](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/07.png) ● 手动提交手动提交不需要其他额外操作，直接把需要收录的页面的 url 提交即可，这种方法效率较低，更新较慢，不推荐使用 ![08](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/08.png) ● 提交谷歌搜索提交谷歌搜索引擎比较简单，在提交之前，我们依然可以使用 site:域名 查看网站是否被收录，我的网站搭建了有差不多一年了，之前也没提交过收录，不过谷歌爬虫的确是强大，即使没有提交过，现在也能看到有一百多条结果了： ![09](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/09.png) 接下来我们将网站提交谷歌搜索引擎搜索，进入谷歌站长平台，登录你的谷歌账号之后会让你验证网站所有权： ![10](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/10.png) 有两种验证方式，分别是网域和网址前缀，两种资源类型区别如下： 网址前缀资源 网域资源 说明 仅包含具有指定前缀（包括协议 http/https）的网址。如果希望资源匹配任何协议或子网域（http/https/www./m. 等），建议改为添加网域资源。 包括所有子网域（m、www 等）和多种协议（http、https、ftp）的网域级资源。 验证 多种类型 仅 DNS 记录验证 示例 资源 http://example.com/✔ http://example.com/dresses/1234X https://example.com/dresses/1234X http://www.example.com/dresses/1234 资源 example.com✔ http://example.com/dresses/1234✔ https://example.com/dresses/1234✔ http://www.example.com/dresses/1234✔ http://support.m.example.com/dresses/1234 由对比可知选择网域资源验证方式比较好，只需要一个域名就可以匹配到多种格式的 URL，之后会给你一个 TXT 的记录值，复制它到你域名 DNS 增加一个 TXT 记录，点击验证即可 ![11](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/11.png) 提交谷歌收录比较简单，选择站点地图，将我们之前生成的 sitemap 提交就行了，过几分钟刷新一下看到成功字样表示提交成功！ ![12](https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A48/12.png)","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"搜索引擎","slug":"搜索引擎","permalink":"https://ysluckly.github.io/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"},{"name":"SEO","slug":"SEO","permalink":"https://ysluckly.github.io/tags/SEO/"}]},{"title":"Hexo博客向百度提交链接","slug":"tools/1645801126982","date":"2021-10-08T02:44:30.000Z","updated":"2022-02-25T15:58:26.960Z","comments":true,"path":"2021/10/08/hexo-add-baidu/","link":"","permalink":"https://ysluckly.github.io/2021/10/08/hexo-add-baidu/","excerpt":"","text":"前言 博客弄好后，怎么才能让其他小伙伴搜索到呢，首先重要的是让百度收录你的站点，在百度搜索site:&lt;域名&gt;，就可以产看网站有没有被百度收录。百度提供了主动提交的三种方法来提交链接。 从效率上来排序三种分别是：主动推送 &gt; 自动推送 &gt; sitemap 主动推送 下面介绍两种方法，第一种作者没有试验，网上不少人用，应该是可以的。第二种是作者自己琢磨出来（主要是当时没看到网上介绍的第一种）。 发布的时候推送 安装插件npm install hexo-baidu-url-submit –save 然后再根目录的配置文件中新增字段 baidu_url_submit: count: 100 # 提交最新的一个链接 host: wudong.tech # 在百度站长平台中注册的域名 token: 23GYpxowKnhgVsUM # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里 在加入新的deploye deploy: - type:baidu_url_submitter 新链接的产生， hexo generate 会产生一个文本文件，里面包含最新的链接新链接的提交， hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎 定时推送（需要服务器） 首先作者直接有一台便宜的VPS服务器，因此可配置脚本，然后通过定时任务向百度推送网站地址。作者自己写了一个简单generator生成urls.txt。 安装插件npm install hexo-generator-urls –save 每次只需hexo g的时候，会自动生成urls.txt在public目录下，可以直接通过url访问，例如：https://wudong.tech/urls.txt。 其次在VPS编写脚本 #!/bin/bash cd /usr/local/src/sitepush var=`date +%Y%m%d%H%M` echo $var | tee -a log.txt curl -o urls.txt https://wudong.tech/urls.txt curl -H &#39;Content-Type:text/plain&#39; --data-binary @urls.txt &quot;http://data.zz.baidu.com/urls?site=https://wudong.tech&amp;token=23GYpxowKnhgVsUM&quot; | tee -a log.txt echo -e &quot;\\n&quot; | tee -a log.txt 大概是，先输出执行时间到日志，然后curl调用https://wudong.tech/urls.txt,并将结果写入urls.txt文本，最后curl推送urls.txt的地址。 最后在VPS中配置定时任务，启动当前脚本 编辑定时任务 crontab -e 追加定时任务，每条8点20点执行 0 8,20 * * * /usr/local/src/sitepush/sitepush.sh ps:如果有需求的小伙伴，我可以在自己的vps帮忙配置一个，但是不能确保能运行多久。 自动推送 如果是next主题，在主题配置文件中修改，将baidu_push设置为true： # Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO baidu_push: true 如果没有的话，需要自己修改，在主题生成模板中加入以下脚本： &lt;script&gt; (function()&#123; var bp = document.createElement(&#39;script&#39;); var curProtocol = window.location.protocol.split(&#39;:&#39;)[0]; if (curProtocol === &#39;https&#39;) &#123; bp.src = &#39;https://zz.bdstatic.com/linksubmit/push.js&#39;; &#125; else &#123; bp.src = &#39;http://push.zhanzhang.baidu.com/push.js&#39;; &#125; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s); &#125;)(); &lt;/script&gt; sitemap安装sitemap插件 npm install hexo-generator-sitemap –save #这个生成sitemap文件是可以给百度以外搜索引擎使用，例如谷歌npm install hexo-generator-baidu-sitemap –save #生成百度可用的sitemap文件 修改博客配置文件 # URL ## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39; url: https://wudong.tech root: / permalink: :year/:month/:day/:title/ permalink_defaults: hexo generate 会产生两个文件baidusitemap.xml和sitemap.xml在public的根目录下。可以通过https://wudong.tech/baidusitemap.xml,查看该文件是否生成。然后我们就可以将我们生成的sitemap文件提交给百度 说明 作者以上三种都在使用，但是截至到现在（大概一周左右），百度任然只收录了博客的首页，sitemap提交后的状态任然是等待中。百度收录的效率是非常低的，尤其是对于我这种个人博客，只能在耐心等待。倒是谷歌第一天提交，第二天就收录了所有的网址。 作者正在研究怎么做SEO优化，例如锚文本，熊掌号等，有兴趣的小伙伴也可以试试。","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"},{"name":"3-hexo","slug":"3-hexo","permalink":"https://ysluckly.github.io/tags/3-hexo/"}]},{"title":"SpringCloud系列之接入SkyWalking进行链路追踪和日志收集","slug":"back-end/k8s-springcloud-skywalking","date":"2021-09-26T10:08:00.000Z","updated":"2022-02-20T13:01:01.382Z","comments":true,"path":"2021/09/26/spring-cloud-skywalking/","link":"","permalink":"https://ysluckly.github.io/2021/09/26/spring-cloud-skywalking/","excerpt":"","text":"前言前一段时间一直在研究升级公司项目的架构，在不断学习和试错后，最终确定了一套基于 k8s 的高可用架构体系，未来几期会将这套架构体系的架设过程和注意事项以系列文章的形式分享出来，敬请期待！ 由于集群和分布式规模的扩大，对微服务链路的监控和日志收集，越来越有必要性，所以在筛选了了一些方案后，发现 SkyWalking 完美符合我们的预期，对链路追踪和日志收集都有不错的实现。 SkyWalking 简介SkyWalking 是一款 APM（应用程序监控）系统，转为微服务、云原生、基于容器的架构而设计。主要包含了一下核心功能 对服务、运行实例、API进行指标分析 链路检测，检查缓慢的服务和API 对基础设施（VM、网络、磁盘、数据库）进行监控 对超出阈值的情况进行警报 等等 开源地址：apache/skywalking 官网：Apache SkyWalking SpringCloud 整合 SkyWalking1. 搭建 SkyWalking 服务在使用 SkyWalking 进行链路追踪和日志收集之前，需要先搭建起一套 SkyWalking 的服务，然后才能通过 agent 将 SpringCloud 的运行状态和日志发送给 SkyWalking 进行解析和展示。 SkyWalking 的搭建方式有很多中，我这里介绍两种 docker-compose（非高可用，快速启动，方便测试、学习） 和 k8s（高可用、生产级别） docker-compose 的方式docker 和 docker-compose 的安装不是本文的重点，所以有需要可以自行查询。 以下操作会启动三个容器 elasticsearch 作为 skywalking 的存储，保存链路和日志数据等 oap 数据接收和分析 Observability Analysis Platform ui web端的数据展示 # 创建配置文件保存的目录 mkdir -p /data/docker/admin/skywalking # 切换到刚创建的目录 cd /data/docker/admin/skywalking # 将下面的 docker-compose.yml 文件保存到这个目录 vi docker-compose.yml # 拉去镜像并启动 docker-compose up -d # 查看日志 docker-compose logs -f docker-compose.yml version: &#39;3.8&#39; services: elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:7.14.1 container_name: elasticsearch restart: always ports: - 9200:9200 healthcheck: test: [&quot;CMD-SHELL&quot;, &quot;curl --silent --fail localhost:9200/_cluster/health || exit 1&quot;] interval: 30s timeout: 10s retries: 3 start_period: 40s environment: - discovery.type=single-node - bootstrap.memory_lock=true - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; - TZ=Asia/Shanghai ulimits: memlock: soft: -1 hard: -1 oap: image: apache/skywalking-oap-server:8.7.0-es7 container_name: oap depends_on: - elasticsearch links: - elasticsearch restart: always ports: - 11800:11800 - 12800:12800 healthcheck: test: [&quot;CMD-SHELL&quot;, &quot;/skywalking/bin/swctl&quot;] interval: 30s timeout: 10s retries: 3 start_period: 40s environment: TZ: Asia/Shanghai SW_STORAGE: elasticsearch7 SW_STORAGE_ES_CLUSTER_NODES: elasticsearch:9200 ui: image: apache/skywalking-ui:8.7.0 container_name: ui depends_on: - oap links: - oap restart: always ports: - 8088:8080 environment: TZ: Asia/Shanghai SW_OAP_ADDRESS: http://oap:12800 启动之后浏览器访问 服务ip:8080 即可 k8s等待更新。。 2. 下载 agent 代理包点击链接进行下载，skywalking-apm-8.7 其他版本可以看 apache 归档站，找到对应版本的 .tar.gz 后缀的包，进行下载 通过命令或者软件进行解压 tar -zxvf apache-skywalking-apm-8.7.0.tar.gz 3. java 命令使用代码启动 jar 包springcloud/springboot 一般是通过 java -jar xxx.jar 进行启动。我们只需要在其中加上 -javaagent 参数即可，如下 其中 自定义服务名 可以改为应用名 如 lemes-auth，服务ip 为第一步搭建的 SkyWalking 服务的ip，端口11800 为启动的 oap 这个容器的端口 java -javaagent:上一步解压目录/agent/skywalking-agent.jar=agent.service_name=自定义服务名,collector.backend_service=服务ip:11800 -jar xx.jar 执行命令启动后，访问以下接口，就可以在第一步 服务ip:8080 中看到访问的链接和调用链路。 4. 开启日志收集本文主要以 log4j2 来介绍，其他的大同小异，可以网上找教程。SpringCloud 集成 log4j2 不是本文重点，所以请自行 Google。 引入依赖要开启日志收集，必须要添加依赖，如下 &lt;dependency&gt; &lt;groupId&gt;org.apache.skywalking&lt;/groupId&gt; &lt;artifactId&gt;apm-toolkit-log4j-2.x&lt;/artifactId&gt; &lt;version&gt;8.7.0&lt;/version&gt; &lt;/dependency&gt; 修改 log4j2.xml需要修改 log4j2.xml 主要添加下面两个关键点 添加 %traceId 来打印 traceid 声明 GRPCLogClientAppender 完整内容如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt; &lt;!-- Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时， 你会看到log4j2内部各种详细输出。可以设置成OFF(关闭) 或 Error(只输出错误信息)。 --&gt; &lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt; &lt;configuration status=&quot;WARN&quot; monitorInterval=&quot;30&quot;&gt; &lt;Properties&gt; &lt;Property name=&quot;log.path&quot;&gt;logs/lemes-auth&lt;/Property&gt; &lt;Property name=&quot;logging.lemes.pattern&quot;&gt; %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level] [%traceId] [%logger&#123;50&#125;.%M:%L] - %msg%n &lt;/Property&gt; &lt;/Properties&gt; &lt;Appenders&gt; &lt;!-- 输出控制台日志的配置 --&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt; &lt;ThresholdFilter level=&quot;debug&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;!-- 输出日志的格式 --&gt; &lt;PatternLayout pattern=&quot;$&#123;logging.lemes.pattern&#125;&quot;/&gt; &lt;/Console&gt; &lt;RollingRandomAccessFile name=&quot;debugRollingFile&quot; fileName=&quot;$&#123;log.path&#125;/debug.log&quot; filePattern=&quot;$&#123;log.path&#125;/debug/$$&#123;date:yyyy-MM&#125;/debug.%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;&gt; &lt;ThresholdFilter level=&quot;debug&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;PatternLayout charset=&quot;UTF-8&quot; pattern=&quot;$&#123;logging.lemes.pattern&#125;&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt; &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt; &lt;/Policies&gt; &lt;DefaultRolloverStrategy max=&quot;30&quot;/&gt; &lt;/RollingRandomAccessFile&gt; &lt;GRPCLogClientAppender name=&quot;grpc-log&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;logging.lemes.pattern&#125;&quot;/&gt; &lt;/GRPCLogClientAppender&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;!-- ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF --&gt; &lt;Logger name=&quot;com.lenovo.lemes&quot; level=&quot;debug&quot;/&gt; &lt;Logger name=&quot;org.apache.kafka&quot; level=&quot;warn&quot;/&gt; &lt;Root level=&quot;info&quot;&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;debugRollingFile&quot;/&gt; &lt;AppenderRef ref=&quot;grpc-log&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt; &lt;/configuration&gt; 启动命令中声明上报日志在上一步的 agent 中添加上报日志的参数 plugin.toolkit.log.grpc.reporter.server_host=服务ip,plugin.toolkit.log.grpc.reporter.server_port=11800 完整如下 java -javaagent:上一步解压目录/agent/skywalking-agent.jar=agent.service_name=自定义服务名,collector.backend_service=服务ip:11800,plugin.toolkit.log.grpc.reporter.server_host=服务ip,plugin.toolkit.log.grpc.reporter.server_port=11800 -jar xx.jar 日志收集效果这样启动日志中就会打印 traceid , N/A 代表的是非请求的日志，有 traceid 的为 api 请求日志 在 skywalking 中就能看到我们上报的日志 重点：SkyWalking 可以在链路追踪中查看当前请求的所有日志（不同实例/模块） 5. 兼容 spring-cloud-gateway经过上面的步骤之后，链路已经搭建完成，查看发现了一个问题，gateway 模块的 traceId 和 业务模块的 traceId 不统一。 这是由于 SkyWalking 对于 spring-cloud-gateway 的支持不是默认的，所以需要将 agent/optional-plugins/apm-spring-cloud-gateway-2.1.x-plugin-8.7.0.jar 复制到 agent/plugins 下，然后重启即可。 最后SkyWalking 上面这两个功能就已经非常强大，能够有效帮助我们优化我们的程序，监控系统的问题，并及时报警。日志收集也解决的在大规模分布式集群下日志查询难的问题。 SkyWalking 还支持 VM、浏览器、k8s等监控，后续如果有实践，将会逐步更新。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ysluckly.github.io/tags/java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://ysluckly.github.io/tags/SpringCloud/"},{"name":"SkyWalking","slug":"SkyWalking","permalink":"https://ysluckly.github.io/tags/SkyWalking/"}]},{"title":"逆序字符串问题","slug":"back-end/201861","date":"2021-06-01T14:02:30.000Z","updated":"2022-02-26T05:22:01.286Z","comments":true,"path":"2021/06/01/undefined/","link":"","permalink":"https://ysluckly.github.io/2021/06/01/undefined/","excerpt":"题目 有一个字符数组的内容为: student a am i ,请将数组的内容改为 i am a student","text":"题目 有一个字符数组的内容为: student a am i ,请将数组的内容改为 i am a student 要求： 不能使用库函数。只能开辟有限个空间（空间个数和字符串的长度无关）。 算法分析 先将整个字符串整体逆置，再以每个单词为对象局部逆置（这时判断条件复杂一些）；这里逆置时，需要一个逆置函数，需要两个参数，首指针和尾指针，由这两个指针锁定一个区域，将里面的字符从头至尾逆置 注意： 最后一次跳出while循环时，相当于*pcur==’\\0’,所以最后这个单词没有逆置，需要再次调用逆置函数 if(表达式){语句1}语句2；这样的结构，无论if表达式成立与否，语句2都会执行的效果展示 参考代码#include &lt;stdio.h&gt; #include &lt;assert.h&gt; int my_strlen(const char *str) &#123; int count = 0; assert(str); while(*str++) &#123; count++; &#125; return count; &#125; void reverse_str(char *left,char *right) &#123; assert(left); assert(right); while(left &lt; right) &#123; char temp = *left; *left = *right; *right = temp; left++; right--; &#125; &#125; void reverse(char *str) &#123; assert(str); char *left = str; char *right = str + my_strlen(str) - 1; reverse_str(left,right); &#125; int main() &#123; char arr[] = &quot;student a am i&quot;; printf(&quot;请逆转每个单词:%s\\n\\n&quot;,arr); char *pcur = arr; //逆序字符串 reverse(arr); //逆序单词 while(*pcur) &#123; char *start = pcur; while(*pcur != &#39; &#39;&amp;&amp;*pcur != &#39;\\0&#39;) &#123; pcur++; &#125; reverse_str(start,pcur-1); if(*pcur == &#39; &#39;) pcur++; &#125; printf(&quot;逆转后的结果：\\n&quot;); puts(arr); return 0; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C语言","slug":"后端/C语言","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"逆序字符串","slug":"逆序字符串","permalink":"https://ysluckly.github.io/tags/%E9%80%86%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"自定义类型：结构体，枚举，联合","slug":"back-end/201862","date":"2021-05-31T14:02:36.000Z","updated":"2022-02-26T05:22:22.164Z","comments":true,"path":"2021/05/31/undefined/","link":"","permalink":"https://ysluckly.github.io/2021/05/31/undefined/","excerpt":"前言 对于C语言的学习，我们知道有基本数据类型，指针类型，自定义类型等。今天一起来探讨一下自定义类型。","text":"前言 对于C语言的学习，我们知道有基本数据类型，指针类型，自定义类型等。今天一起来探讨一下自定义类型。 结构体结构体的声明结构的基础知识 结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。 结构的声明struct tag &#123; member_list; //成员列表 &#125;variable_list; //变量列表也称类型名，属于全局变量 注意：程序应尽可能少定义全局变量，在程序中到处引用全局变量，会导致程序难以控制，容易出错。且声明不占用内存 例如描述一个学生 struct Stu &#123; char name[20];//名字 int age;//年龄 char sex[5];//姓名 char telp[11];//电话号 char id[20];//学号 &#125;;//分号不能丢 特殊的声明 特殊声明就是不完全声明又叫匿名结构体类型声明 //匿名结构体类型声明 struct &#123; int a; char b; float c; &#125;x; struct &#123; int a; char b; float c; &#125;a[20],*p; 对于上面声明，均省略了结构体标签，而对于匿名结构体类型声明，编译器会把上面两个声明当成完全不同的 两个类型，所以对于p = &amp;x是非法的 结构的成员 结构的成员可以是标量，数组，指针，甚至是其他结构体。 结构体成员的访问 结构体变量访问成员： 结构变量成员通过点操作符（.）访问，点操作符接收两个操作数。 结构体访问指向变量的成员： 有时候我们得到不是一个结构体变量，而是一个指向结构体的指针，就应该用（-&gt;）操作符。 struct Stu &#123; char name[20];//名字 int age;//年龄 &#125;s; void print(struct Stu* pc) &#123; printf(&quot;%s,%d\\n&quot;,(*pc).name,(*pc).age); printf(&quot;%s,%d\\n&quot;, pc-&gt;name, pc-&gt;age); &#125; 结构自引用 简而言之就是在结构中包含一个类型为结构本身的成员 typedef struct Node &#123; int data; struct Node* next; &#125;Node; 结构的不完整声明struct B; struct A &#123; int a; struct B* pb; &#125;; struct B &#123; int b; struct A* pa; &#125;; 结构体变量定义及初始化 有了结构体类型，定义及初始化就很简单了 struct Stu &#123; int x; int y; &#125;p1; //声明类型同时定义变量p1 struct Stu p2;//定义结构体变量p2 struct Stu P3 = &#123; x, y &#125;;//定义变量同时初始化 struct Po &#123; char name[20]; int age; &#125;; struct Po s = &#123; &quot;zhangsan&quot;, 20 &#125;;//定义变量同时初始化 结构体内存对齐 目前，我们已经掌握了结构体的基本使用了，现在来开始讨论一个问题：计算结构的大小。当然也是一个热门考点：结构体内存对齐 如何计算？ 结构体内存对齐规则： 第一个成员在与结构体变量偏移量为0的地址处； 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。对齐数=编译器默认对齐数 与该成员自身大小中的最小值。VS默认值为8，linux中gcc默认值为4. 结构体总大小为最大对齐数的整数倍； 如果嵌套了结构体的情况，嵌套的结构体对齐到自己最大对齐数的整数倍处，结构体的大小就是所有对齐数中最大对齐数的整数倍。 注意： #pragma pack（n） //n表示系统默认最大对齐数 ... #pragma pack（） //使用完应立即取消自定义设置 为什么存在内存对齐？ 平台原因(移植原因): 不是所有硬件平台都能访问任意地址上的数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则肯呢个抛出硬件异常。 性能原因： 数据结构（尤其是栈）应该尽可能的在自然边界上对齐，原因在于：访问未对齐的内存，处理器需要两次访问，而访问对齐内存，处理器只需访问一次。 总的来说：结构体内存对齐就是用空间换取时间的做法，而我们在设计的时候既要满足内存对齐，还要满足节省空间，那么唯一做法：让占用空间小的成员尽可能集中在一起。 //练习一 struct S1 &#123; double d; //0-7 char c; //8 int i; //11-15 &#125;; printf(&quot;%d\\n&quot;,sizeof(struct S1)); //16 //练习二 struct S2 &#123; char a; //0 struct S1 S; //8-23 double f; //24-31 &#125;; printf(&quot;%d\\n&quot;,sizeof(struct S2)); //32 附加： //宏，表示结构体成员变量在内存中偏移量包含于头文件#include &lt;stddef.h&gt; offsetof(struct S, A); 宏实现：（size_t）&amp;(((S*)0)-&gt;m) 结构体传参 讲解函数栈桢的时候，我们知道函数传参是需要参数压栈的，如果传递的是一个结构体对象，而结构体过大，参数压栈的系统开销就会很大，所以导致系统性能下降。 结论 结构体传参的时候要传结构体指针。 位段什么是位段？位段声明与结构体类型相似，有两个不同： 位段成员必须int 、unsigned int 或 signed int。 位段成员名后面有一个冒号和一个数字。 位段内存分配 位段成员可以是int 、unsigned int、signed int、或者char(整形家族)类型。 位段的空间上按四个字节（int）或者一个字节（char）方式开辟 位段涉及很多不确定因素，位段是不跨平台的，注重可移植性程序因避免使用位段。 eg： struct A &#123; int a:2; int b:5; int c:10; int d:30; &#125;; printf(&quot;%d&quot;,sizeof(struct A)); //8 位段跨平台问题 int位段当成有符号还是无符号是不确定的 位段中最大位数目不确定的 位段中成员是从左到右还是从右到左是不确定的 当一个结构体包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的还是利用，是不确定的总结 跟结构相比，位段可以达到同样的效果，还节省空间，但是因为存在跨平台问题，所以运用的就不是很多了。 枚举 枚举顾名思义就是一一列举。比如：星期、颜色、性别等； 枚举类型定义enum Color &#123; RED, GRENE, BLUE &#125;; 以上定义的enum Color 就是枚举类型，{}中内容就是可能取值，也叫枚举常量，默认从零开始一次递增1，当然有时候也可以自定义赋值： enum Color &#123; RED = 1, GREEN = 4, BLUE = 8 &#125;; 枚举优点 增加代码可读性与可维护性 与#define相比有类型检查，更加严谨 防止命名污染 便于调试 使用方便，一次可定义多个常量 联合（共用体）联合定义 联合也是一种特殊自定义类型，该类型定义变量也包含一系列成员，特征是这些成员公用一块空间。 eg //联合类型声明 union Un &#123; char c; int i; &#125;; //联合变量的定义 union Un un; //计算变量大小 printf(&quot;%d&quot;,sizeof(un)); //4 联合特点 联合成员公用一块内存空间，这样一个联合变量大小，至少是最大成员大小。 经典应用 判断当前计算机大小端存储： int CheckSystem（） &#123; union Un &#123; int a; char i; &#125;un; un.a = 1; //返回为1,小端存储 //返回为0，大端存储 return nu.i; &#125; 联合大小的计算 联合大小至少是最大成员大小 当最大成员大小不是最大对齐数整数倍时，就要对齐到最大对齐数的整数倍 eg union UN1 &#123; char arr[5]; int i; &#125;; union UN2 &#123; short c[7]; int i; &#125;; printf(&quot;%d&quot;,sizeof(union UN1)); //8 printf(&quot;%d&quot;,sizeof(union UN2)); //16 结构体与联合巧妙使用：//将long类型ip地址，转换为电分十进制形式 union ip_addr &#123; unsigned long addr; struct &#123; unsigned char c1; unsigned char c2; unsigned char c3; unsigned char c4; &#125;ip; union ip_addr my_ip; my_ip.addr = 176238749; printf(&quot;%d.%d.%d.%d&quot;,my_ip.ip.c4,my_ip.ip.c3,my_ip.ip.c2,my_ip.ip.c1,); &#125; 结语 通过自定义类型学习，掌握了内存对齐等相关运用，以及如何检验大小端问题。好好学习，天天编程","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C语言","slug":"后端/C语言","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"结构体","slug":"结构体","permalink":"https://ysluckly.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"}]},{"title":"【C语言】静态(动态)顺序表-通讯录","slug":"back-end/2018529","date":"2021-05-29T13:54:55.000Z","updated":"2022-02-26T05:23:57.944Z","comments":true,"path":"2021/05/29/undefined/","link":"","permalink":"https://ysluckly.github.io/2021/05/29/undefined/","excerpt":"前言 近期学习了自定义类型结构体以及顺序表，所以就试着利用顺序表模拟实现了一个通讯录。","text":"前言 近期学习了自定义类型结构体以及顺序表，所以就试着利用顺序表模拟实现了一个通讯录。 简要功能如下： 初始化通讯录 添加联系人 查找联系人 删除联系人 修改联系人 按姓名排序 清空联系人 联系人列表 退出 项目效果展示： 静态顺序表参考代码：Contact.h/*********************************************************** * 程序名称：通讯录（静态顺序表） * * 编译环境：VS2013 * * 编制日期：2018.5.28 * * -----by Hunter * ***********************************************************/ #ifndef __CONTACT_H__ #define __CONTACT_H__ #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; #include &lt;assert.h&gt; #include &lt;string.h&gt; enum OPPTION &#123; EXIT, ADD, SEARCH, DEIETE, MODIFY, SORT, SHOW, EMPTY &#125;; typedef char datatype; #define MAX_NAME 10 #define MAX_SEX 5 #define MAX_TEL 11 #define MAX_ADDR 30 #define MAX_SIZE 1000 typedef struct PeoInfo &#123; datatype Name[MAX_NAME]; datatype Sex[MAX_SEX]; int age; datatype Tel[MAX_TEL]; datatype Addr[MAX_ADDR]; &#125;PeoInfo, *pPeoInfo; typedef struct Contact &#123; PeoInfo data[MAX_SIZE]; int size; &#125;Contact,*pContact; //初始化通讯录 void InitContact(pContact pc); //添加联系人 void AddContact(pContact pc); //查找联系人 int SearchContact(pContact pc); //删除联系人 void DeleteContact(pContact pc); //修改联系人 void ModifyContact(pContact pc); //按姓排序 void SortContact(pContact pc); //列表联系人 void ShowContact(pContact pc); //清空联系人 void EmptyContact(pContact pc); #endif //__CONTACT_H__ Contact.c#define _CRT_SECURE_NO_WARNINGS 1 #include &quot;contact.h&quot; //初始化通讯录 void InitContact(pContact pc) &#123; assert(pc); pc-&gt;size = 0; memset(pc-&gt;data, 0, sizeof(pc-&gt;data)); &#125; //添加联系人 void AddContact(pContact pc) &#123; assert(pc); if (pc-&gt;size == MAX_SIZE) &#123; printf(&quot;\\t\\t\\t空间不足&quot;); return; &#125; printf(&quot;\\t\\t\\t请输入姓名:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].Name); printf(&quot;\\t\\t\\t请输入性别:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].Sex); printf(&quot;\\t\\t\\t请输入年龄:&gt;&quot;); scanf(&quot;%d&quot;, &amp;pc-&gt;data[pc-&gt;size].age); printf(&quot;\\t\\t\\t请输入电话号:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].Tel); printf(&quot;\\t\\t\\t请输入地址:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].Addr); pc-&gt;size++; printf(&quot;\\t\\t\\t添加成功\\n&quot;); &#125; //查找联系人 int SearchContact(pContact pc) &#123; char name[MAX_NAME]; int i = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf(&quot;\\t\\t\\t无此联系人\\n&quot;); return -1; &#125; scanf(&quot;%s&quot;, name); printf(&quot;\\t\\t\\tName\\tSex\\tAge\\tTel\\t\\tAddr\\n&quot;); for (i = 0; i &lt; pc-&gt;size; i++) &#123; if (0 == strcmp(pc-&gt;data[i].Name, name)) &#123; printf(&quot;\\t\\t\\t%-5s\\t%-5s\\t%-5d\\t%-12s\\t%-15s\\n&quot;, pc-&gt;data[i].Name, pc-&gt;data[i].Sex, pc-&gt;data[i].age, pc-&gt;data[i].Tel, pc-&gt;data[i].Addr); return i; &#125; &#125; printf(&quot;\\t\\t\\t无此联系人\\n&quot;); return -1; &#125; //删除联系人 void DeleteContact(pContact pc) &#123; int i = 0; int num = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf(&quot;\\t\\t\\t无联系人\\n&quot;); return; &#125; num = SearchContact(pc); if (num != -1) &#123; int n = 0; printf(&quot;\\t\\t\\t确定删除？ 1.yes, 2.no:&gt;&quot;); scanf(&quot;%d&quot;, &amp;n); if (1 == n) &#123; for (i = num; i &lt; (pc-&gt;size) - 1; i++) &#123; pc-&gt;data[i] = pc-&gt;data[i + 1]; &#125; pc-&gt;size--; printf(&quot;\\t\\t\\t删除成功\\n&quot;); &#125; else &#123; return; &#125; &#125; &#125; //交换 void Swap(pPeoInfo *a, pPeoInfo *b) &#123; pPeoInfo *Tmp; Tmp = *a; *a = *b; *b = Tmp; &#125; //修改联系人 void ModifyContact(pContact pc) &#123; int modify = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf(&quot;\\t\\t\\t无联系人\\n&quot;); return; &#125; modify = SearchContact(pc); if (modify != -1) &#123; int n = 0; printf(&quot;\\t\\t\\t确认修改？1.yes 2.no:&gt;&quot;); scanf(&quot;%d&quot;, &amp;n); if (1 == n) &#123; printf(&quot;\\t\\t\\t请输入姓名:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[modify].Name); printf(&quot;\\t\\t\\t请输入性别:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[modify].Sex); printf(&quot;\\t\\t\\t请输入年龄:&gt;&quot;); scanf(&quot;%d&quot;, &amp;pc-&gt;data[modify].age); printf(&quot;\\t\\t\\t请输入电话号:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[modify].Tel); printf(&quot;\\t\\t\\t请输入地址:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[modify].Addr); printf(&quot;\\t\\t\\t修改成功\\n&quot;); &#125; else &#123; return; &#125; &#125; &#125; //按姓排序 void SortContact(pContact pc) &#123; int i = 0; int j = 0; int flag = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf(&quot;\\t\\t\\t无联系人\\n&quot;); return; &#125; // 冒泡次数 for (i = 0; i &lt; pc-&gt;size - 1; i++) &#123; //冒泡排序 for (j = 0; j &lt; pc-&gt;size - i - 1; j++) &#123; if (strcmp(pc-&gt;data[j].Name,pc-&gt;data[j + 1].Name)&gt;0) &#123; Swap(&amp;pc-&gt;data[j], &amp;pc-&gt;data[j + 1]); flag = 1; &#125; &#125; if (0 == flag) &#123; break; &#125; &#125; printf(&quot;排序成功\\n&quot;); &#125; //列表联系人 void ShowContact(pContact pc) &#123; int i = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf(&quot;\\t\\t\\t无联系人\\n&quot;); return; &#125; printf(&quot;\\t\\t\\tName\\tSex\\tAge\\tTel\\t\\tAddr\\n&quot;); for (i = 0; i &lt; pc-&gt;size; i++) &#123; printf(&quot;\\t\\t\\t%-5s\\t%-5s\\t%-5d\\t%-12s\\t%-15s\\n&quot;, pc-&gt;data[i].Name, pc-&gt;data[i].Sex, pc-&gt;data[i].age, pc-&gt;data[i].Tel, pc-&gt;data[i].Addr); &#125; &#125; //清空联系人 void EmptyContact(pContact pc) &#123; assert(pc); pc-&gt;size = 0; printf(&quot;清空成功&quot;); &#125; test.c #define _CRT_SECURE_NO_WARNINGS 1 #include &quot;contact.h&quot; void meau() &#123; printf(&quot;\\t\\t\\t****** 《通讯录》 ********\\n&quot;); printf(&quot;\\t\\t\\t****************************************\\n&quot;); printf(&quot;\\t\\t\\t****** 1.添加信息 2.查找信息******\\n&quot;); printf(&quot;\\t\\t\\t****** 3.删除信息 4.修改信息******\\n&quot;); printf(&quot;\\t\\t\\t****** 5.按姓排序 6.信息列表******\\n&quot;); printf(&quot;\\t\\t\\t****** 7.清空信息 0.退出 ******\\n&quot;); printf(&quot;\\t\\t\\t****************************************\\n&quot;); &#125; void test() &#123; int input = 0; Contact pc; InitContact(&amp;pc); do &#123; meau(); printf(&quot;\\t\\t\\t请选择:&gt;&quot;); scanf(&quot;%d&quot;, &amp;input); switch (input) &#123; case ADD: AddContact(&amp;pc); break; case SEARCH: SearchContact(&amp;pc); break; case DEIETE: DeleteContact(&amp;pc); break; case MODIFY: ModifyContact(&amp;pc); break; case SORT: SortContact(&amp;pc); break; case SHOW: ShowContact(&amp;pc); break; case EMPTY: EmptyContact(&amp;pc); break; case EXIT: exit(0); break; default: printf(&quot;\\t\\t\\t输入有误，请重新输入:&gt;&quot;); break; &#125; &#125; while (input); &#125; int main() &#123; test(); system(&quot;pause&quot;); return 0; &#125; 动态顺序表参考代码Contact.h/*********************************************************** * 程序名称：通讯录（静态顺序表） * * 编译环境：VS2013 * * 编制日期：2018.5.28 * * -----by Hunter * ***********************************************************/ #ifndef __CONTACT_H__ #define __CONTACT_H__ #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; #include &lt;assert.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; enum OPPTION &#123; EXIT, ADD, SEARCH, DEIETE, MODIFY, SORT, SHOW, EMPTY &#125;; typedef char datatype; #define MAX_NAME 10 #define MAX_SEX 5 #define MAX_TEL 11 #define MAX_ADDR 30 #define MAX_SIZE 1000 typedef struct PeoInfo &#123; datatype Name[MAX_NAME]; datatype Sex[MAX_SEX]; int age; datatype Tel[MAX_TEL]; datatype Addr[MAX_ADDR]; &#125;PeoInfo, *pPeoInfo; typedef struct Contact &#123; pPeoInfo data; int size; int capacity; &#125;Contact, *pContact; //初始化通讯录 void InitContact(pContact pc); //添加联系人 void AddContact(pContact pc); //删除联系人 void DeleteContact(pContact pc); //查找联系人 int SearchContact(pContact pc); //修改联系人 void ModifyContact(pContact pc); //按姓排序 void SortContact(pContact pc); //列表联系人 void ShowContact(pContact pc); //清空联系人 void EmptyContact(pContact pc); //销毁 void DestoryContact(pContact pc); #endif //__CONTACT_H__ Contact.c#define _CRT_SECURE_NO_WARNINGS 1 #include &quot;contact.h&quot; //初始化通讯录 void InitContact(pContact pc) &#123; assert(pc); pc-&gt;size = 0; pc-&gt;capacity = 3; pc-&gt;data = (pPeoInfo)malloc((pc-&gt;capacity)*sizeof(PeoInfo)); if (pc-&gt;data == NULL) &#123; printf(&quot;\\t\\t\\t内存分配失败&quot;); exit(EXIT_FAILURE); &#125; memset(pc-&gt;data,0,sizeof(pc-&gt;data)); &#125; //检查扩容 void CheckCapacity(pContact pc) &#123; assert(pc); pPeoInfo *p = NULL; if (pc-&gt;size == pc-&gt;capacity) &#123; p = (pPeoInfo)realloc(pc-&gt;data, (pc-&gt;capacity + 2)*sizeof(PeoInfo)); if (p != NULL) &#123; pc-&gt;data = p; &#125; else &#123; printf(&quot;\\t\\t\\t增容失败&quot;); exit(EXIT_FAILURE); &#125; pc-&gt;capacity += 2; printf(&quot;\\t\\t\\t增容成功\\n&quot;); &#125; &#125; //添加联系人 void AddContact(pContact pc) &#123; assert(pc); if (pc-&gt;size == MAX_SIZE) &#123; printf(&quot;\\t\\t\\t空间不足&quot;); return; &#125; CheckCapacity(pc); printf(&quot;\\t\\t\\t请输入姓名:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].Name); printf(&quot;\\t\\t\\t请输入性别:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].Sex); printf(&quot;\\t\\t\\t请输入年龄:&gt;&quot;); scanf(&quot;%d&quot;, &amp;pc-&gt;data[pc-&gt;size].age); printf(&quot;\\t\\t\\t请输入电话号:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].Tel); printf(&quot;\\t\\t\\t请输入地址:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[pc-&gt;size].Addr); pc-&gt;size++; printf(&quot;\\t\\t\\t添加成功\\n&quot;); &#125; //查找联系人 int SearchContact(pContact pc) &#123; char name[MAX_NAME]; int i = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf(&quot;\\t\\t\\t无此联系人\\n&quot;); return -1; &#125; printf(&quot;\\t\\t\\t&quot;); scanf(&quot;%s&quot;, name); printf(&quot;\\t\\t\\tName\\tSex\\tAge\\tTel\\t\\tAddr\\n&quot;); for (i = 0; i &lt; pc-&gt;size; i++) &#123; if (0 == strcmp(pc-&gt;data[i].Name, name)) &#123; printf(&quot;\\t\\t\\t%-5s\\t%-5s\\t%-5d\\t%-12s\\t%-15s\\n&quot;, pc-&gt;data[i].Name, pc-&gt;data[i].Sex, pc-&gt;data[i].age, pc-&gt;data[i].Tel, pc-&gt;data[i].Addr); return i; &#125; &#125; printf(&quot;\\t\\t\\t无此联系人\\n&quot;); return -1; &#125; //删除联系人 void DeleteContact(pContact pc) &#123; int i = 0; int num = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf(&quot;\\t\\t\\t无联系人\\n&quot;); return; &#125; num = SearchContact(pc); if (num != -1) &#123; int n = 0; printf(&quot;\\t\\t\\t确定删除？ 1.yes, 2.no:&gt;&quot;); printf(&quot;\\t\\t\\t&quot;); scanf(&quot;%d&quot;, &amp;n); if (1 == n) &#123; for (i = num; i &lt; (pc-&gt;size) - 1; i++) &#123; pc-&gt;data[i] = pc-&gt;data[i + 1]; &#125; pc-&gt;size--; printf(&quot;\\t\\t\\t删除成功\\n&quot;); &#125; else &#123; return; &#125; &#125; &#125; //交换 void Swap(pPeoInfo *a, pPeoInfo *b) &#123; pPeoInfo *Tmp; Tmp = *a; *a = *b; *b = Tmp; &#125; //修改联系人 void ModifyContact(pContact pc) &#123; int modify = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf(&quot;\\t\\t\\t无联系人\\n&quot;); return; &#125; modify = SearchContact(pc); if (modify != -1) &#123; int n = 0; printf(&quot;\\t\\t\\t确认修改？1.yes 2.no:&gt;&quot;); printf(&quot;\\t\\t\\t&quot;); scanf(&quot;%d&quot;, &amp;n); if (1 == n) &#123; printf(&quot;\\t\\t\\t请输入姓名:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[modify].Name); printf(&quot;\\t\\t\\t请输入性别:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[modify].Sex); printf(&quot;\\t\\t\\t请输入年龄:&gt;&quot;); scanf(&quot;%d&quot;, &amp;pc-&gt;data[modify].age); printf(&quot;\\t\\t\\t请输入电话号:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[modify].Tel); printf(&quot;\\t\\t\\t请输入地址:&gt;&quot;); scanf(&quot;%s&quot;, pc-&gt;data[modify].Addr); printf(&quot;\\t\\t\\t修改成功\\n&quot;); &#125; else &#123; return; &#125; &#125; &#125; //按姓排序 void SortContact(pContact pc) &#123; int i = 0; int j = 0; int flag = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf(&quot;\\t\\t\\t无联系人\\n&quot;); return; &#125; // 冒泡次数 for (i = 0; i &lt; pc-&gt;size - 1; i++) &#123; //冒泡排序 for (j = 0; j &lt; pc-&gt;size - i - 1; j++) &#123; if (strcmp(pc-&gt;data[j].Name, pc-&gt;data[j + 1].Name)&gt;0) &#123; Swap(&amp;pc-&gt;data[j], &amp;pc-&gt;data[j + 1]); flag = 1; &#125; &#125; if (0 == flag) &#123; break; &#125; &#125; printf(&quot;排序成功\\n&quot;); &#125; //列表联系人 void ShowContact(pContact pc) &#123; int i = 0; assert(pc); if (0 == pc-&gt;size) &#123; printf(&quot;\\t\\t\\t无联系人\\n&quot;); return; &#125; printf(&quot;\\t\\t\\tName\\tSex\\tAge\\tTel\\t\\tAddr\\n&quot;); for (i = 0; i &lt; pc-&gt;size; i++) &#123; printf(&quot;\\t\\t\\t%-5s\\t%-5s\\t%-5d\\t%-12s\\t%-15s\\n&quot;, pc-&gt;data[i].Name, pc-&gt;data[i].Sex, pc-&gt;data[i].age, pc-&gt;data[i].Tel, pc-&gt;data[i].Addr); &#125; &#125; //清空联系人 void EmptyContact(pContact pc) &#123; assert(pc); pc-&gt;size = 0; printf(&quot;\\t\\t\\t清空成功&quot;); &#125; //销毁通讯录 void DestoryContact(pContact pc) &#123; assert(pc); free(pc-&gt;data); pc-&gt;data = NULL; pc-&gt;capacity = 0; pc-&gt;size = 0; printf(&quot;\\t\\t\\t销毁成功&quot;); &#125; test.c #define _CRT_SECURE_NO_WARNINGS 1 #include &quot;contact.h&quot; void meau() &#123; printf(&quot;\\t\\t\\t****** 《通讯录》 ********\\n&quot;); printf(&quot;\\t\\t\\t****************************************\\n&quot;); printf(&quot;\\t\\t\\t****** 1.添加信息 2.查找信息******\\n&quot;); printf(&quot;\\t\\t\\t****** 3.删除信息 4.修改信息******\\n&quot;); printf(&quot;\\t\\t\\t****** 5.按姓排序 6.信息列表******\\n&quot;); printf(&quot;\\t\\t\\t****** 7.清空信息 0.退出 ******\\n&quot;); printf(&quot;\\t\\t\\t****************************************\\n&quot;); &#125; void test() &#123; int input = 0; Contact pc; InitContact(&amp;pc); do &#123; meau(); printf(&quot;\\t\\t\\t请选择:&gt;&quot;); scanf(&quot;%d&quot;, &amp;input); switch (input) &#123; case ADD: AddContact(&amp;pc); break; case SEARCH: SearchContact(&amp;pc); break; case DEIETE: DeleteContact(&amp;pc); break; case MODIFY: ModifyContact(&amp;pc); break; case SORT: SortContact(&amp;pc); break; case SHOW: ShowContact(&amp;pc); break; case EMPTY: EmptyContact(&amp;pc); break; case EXIT: exit(1); break; default: printf(&quot;\\t\\t\\t输入有误，请重新输入:&gt;&quot;); break; &#125; &#125; while (input); &#125; int main() &#123; Contact pc; test(); //销毁通讯录 DestoryContact(&amp;pc); system(&quot;pause&quot;); return 0; &#125; 结语 今天简单实现了基于静态（动态）顺序表的通讯录，需再努力继续实现链表通讯录。 不忘初心，方得始终！","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C语言","slug":"后端/C语言","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"通讯录","slug":"通讯录","permalink":"https://ysluckly.github.io/tags/%E9%80%9A%E8%AE%AF%E5%BD%95/"}]},{"title":"二分查找，你真的掌握了吗？","slug":"back-end/2018528","date":"2021-05-27T13:54:50.000Z","updated":"2022-02-26T05:24:32.669Z","comments":true,"path":"2021/05/27/undefined/","link":"","permalink":"https://ysluckly.github.io/2021/05/27/undefined/","excerpt":"前言 二分查找，最基本的算法之一，也是面试中常被考察的重点，因为基本的算法最能反映出一个人的基础是否扎实。本文对二分查找相关题目做一个总结。","text":"前言 二分查找，最基本的算法之一，也是面试中常被考察的重点，因为基本的算法最能反映出一个人的基础是否扎实。本文对二分查找相关题目做一个总结。 二分查找函数实现：int bin_search(int arr[], int n, int key) &#123; int mid = 0; int low = 0, high = n-1; while (low &lt;= high) &#123; mid = low + (high - low) &gt;&gt; 1; if (arr[mid] == key) &#123; return mid;//找到返回下标 &#125; else if (arr[mid] &lt; key) &#123; low = mid + 1; &#125; else high = mid - 1; &#125; return -1;//找不到返回-1 &#125; 题目一 给定一个有序（非降序）数组A，求任意一个i使得A[i]等于key，不存在则返回-1 这个是最原始的二分查找题目，利用数组的有序特性，拆半查找，使得查找时间复杂度为O(logN)。请参考实现代码与注释。 int search(int arr[], int n, int key) &#123; int low = 0, high = n-1; while(low &lt;= high) &#123; // 注意：若使用(low+high)/2求中间位置容易溢出 int mid = low+((high-low)&gt;&gt;1); if(A[mid] == key) return mid; else if(A[mid] &lt; key) low = mid+1; else // A[mid] &gt; key high = mid-1; &#125; return -1; &#125; 题目二 给定一个有序（非降序）数组A，可含有重复元素，求最小的i使得A[i]等于key，不存在则返回-1 此题也就是求key在数组中第一次出现的位置。这里可能会有人想先直接用原始的二分查找，如果不存在直接返回-1，如果存在，然后再顺序找到这个等于key值区间的最左位置，这样的话，最坏情况下的复杂度就是O（n）了，没有完全发挥出二分查找的优势。这里的解法具体过程请参考实现代码与注释。 int searchFirstPos(int arr[], int n, int key) &#123; if(n &lt;= 0) return -1; int low = 0, high = n-1; while(low &lt; high) &#123; int mid = low+((high-low)&gt;&gt;1); if(A[mid] &lt; key) low = mid+1; else // A[mid] &gt;= key high = mid; &#125; /* 循环过程中，当low大于0时，A[low-1]是小于key的，因为A[mid] &lt; key时， low=mid+1；当high小于n-1时，A[high]是大于等于key的，因为A[mid] &gt;= key时， high = mid；循环结束时，low 等于 high，所以，如果A[low](A[high])等于key， 那么low(high)就是key出现的最小位置，否则key在数组中不存在。 */ if(A[low] != key) return -1; else return low; &#125; 题目三 给定一个有序（非降序）数组A，可含有重复元素，求最大的i使得A[i]等于key，不存在则返回-1 此题也就是求key在数组中最后一次出现的位置。与上一题基本一样，但是有个地方要注意，具体请参考实现代码与注释。 int searchLastPos(int arr[], int n, int key) &#123; if(n &lt;= 0) return -1; int low = 0, high = n-1; while(low &lt; high) &#123; /* 这里中间位置的计算就不能用low+((high-low)&gt;&gt;1)了，因为当low+1等于high 且A[low] &lt;= key时，会死循环；所以这里要使用low+((high-low+1)&gt;&gt;1)， 这样能够保证循环会正常结束。 */ int mid = low+((high-low+1)&gt;&gt;1); if(A[mid] &gt; key) high = mid-1; else // A[mid] &lt;= key low = mid; &#125; /* 循环过程中，当high小于n-1时，A[high+1]是大于key的，因为A[mid] &gt; key时， high=mid-1；当low大于0时，A[low]是小于等于key的，因为A[mid] &lt;= key时， low = mid；循环结束时，low 等于 high，所以，如果A[high](A[low])等于key， 那么high(low)就是key出现的最大位置，否则key在数组中不存在。 */ if(A[high] != key) return -1; else return high; &#125; 题目四 给定一个有序（非降序）数组A，可含有重复元素，求最大的i使得A[i]小于key，不存在则返回-1 也就是求小于key的最大元素的位置。请参考实现代码与注释。 int searchLastPosLessThan(int arr[], int n, int key) &#123; if(n &lt;= 0) return -1; int low = 0, high = n-1; while(low &lt; high) &#123; int mid = low+((high-low+1)&gt;&gt;1); // 注意，不要导致死循环 if(A[mid] &lt; key) low = mid; else // A[mid] &gt;= key high = mid-1; &#125; /* 循环过程中，当low大于0时，A[low]是小于key的，因为A[mid] &lt; key时， low=mid；当high小于n-1时，A[high+1]是大于等于key的，因为A[mid] &gt;= key时， high = mid-1；循环结束时，low 等于 high，所以，如果A[low](A[high])小于key， 那么low(high)就是要找的位置，否则不存在这样的位置（A[0] &gt;= key时）。 */ return A[low] &lt; key ? low : -1; &#125; 题目五 给定一个有序（非降序）数组A，可含有重复元素，求最小的i使得A[i]大于key，不存在则返回-1。 也就是求大于key的最小元素的位置。请参考实现代码与注释。 int searchFirstPosGreaterThan(int arr[], int n, int key) &#123; if(n &lt;= 0) return -1; int low = 0, high = n-1; while(low &lt; high) &#123; int mid = low+((high-low)&gt;&gt;1); if(A[mid] &gt; key) high = mid; else // A[mid] &lt;= key low = mid+1; &#125; /* 循环过程中，当low大于0时，A[low-1]是小于等于key的，因为A[mid] &lt;= key时， low=mid+1；当high小于n-1时，A[high]是大于key的，因为A[mid] &gt; key时， high = mid；循环结束时，low 等于 high，所以，如果A[high](A[low])大于key， 那么high(low)就是要找的位置，否则不存在这样的位置（A[n-1] &lt;= key时）。 */ return A[high] &gt; key ? high : -1; &#125; 题目六 给定一个有序（非降序）数组A，可含有重复元素，求key在数组中出现的次数 求出第一次出现位置和最后一次出现位置。由于前面都已实现，这里不多解释。请参考实现代码与注释 int count(int arr[], int n, int key) &#123; int firstPos = searchFirstPos(A, n, key); // 第一次出现位置 if(firstPos == -1) return 0; int lastPos = searchLastPos(A, n, key); // 最后一次出现位置 return lastPos-firstPos+1; // 出现次数 &#125; 题目七 给定一个有序（非降序）数组A，若key在数组中出现，返回位置，若不存在，返回它应该插入的位置 如 [1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0 int searchInsert(int arr[], int n, int key) &#123; // 如果比最大值还大，那插入位置就是位置n if(A[n-1] &lt; key) return n; int low = 0, high = n-1; while(low &lt; high) &#123; int mid = low+((high-low)&gt;&gt;1); if(A[mid] &gt;= key) high = mid; else // A[mid] &lt; key low = mid+1; &#125; /* 循环过程中，当low大于0时，A[low-1]是小于key的，因为A[mid] &lt; key时， low=mid+1；当high小于n-1时，A[high]是大于等于key的，因为A[mid] &gt;= key时， high = mid；循环结束时，low 等于 high，所以，如果A[low](A[high])等于key， 那么low(high)就是key出现的位置，否则low就是key在数组中应该插入的位置。 */ return high; &#125; 题目八 给定一个有序（非降序）数组A，可含有重复元素，求绝对值最小的元素的位置 找第一个大于等于0的位置，然后和前一个元素的绝对值比较，返回绝对值较小的元素的位置。请参考实现代码与注释 int searchMinAbs(int arr[], int n) &#123; int low = 0, high = n-1; while(low &lt; high) &#123; int mid = low+((high-low)&gt;&gt;1); if(A[mid] &lt; 0) low = mid+1; else // A[mid] &gt;= 0 high = mid; &#125; /* 循环结束时，如果low != n-1，A[low] &gt;= 0，如果low&gt;0，A[low-1] &lt; 0 */ if(low &gt; 0 &amp;&amp; abs(A[low-1]) &lt; abs(A[low])) return low-1; else return low; &#125; 题目九 给定一个有序（非降序）数组A和一个有序（非降序）数组B，可含有重复元素，求两个数组合并结果中的第k(k&gt;=0)个数字 这个题目出现了两个数组，有序的，不管怎样我们就应该首先考虑二分查找是否可行。若使用顺序查找，时间复杂度最低为O(k)，就是类似归并排序中的归并过程。使用用二分查找时间复杂度为O(logM+logN)。二分查找的具体实现过程请参考实现代码与注释。 int findKthIn2SortedArrays(int arr[], int m, int B[], int n, int k) &#123; if(m &lt;= 0) // 数组A中没有元素，直接在B中找第k个元素 return B[k]; if(n &lt;= 0) // 数组B中没有元素，直接在A中找第k个元素 return A[k]; int i = (m-1)&gt;&gt;1; // 数组A的中间位置 int j = (n-1)&gt;&gt;1; // 数组B的中间位置 if(A[i] &lt;= B[j]) // 数组A的中间元素小于等于数组B的中间元素 &#123; /* 设x为数组A和数组B中小于B[j]的元素数目，则i+1+j+1小于等于x， 因为A[i+1]到A[m-1]中还可能存在小于等于B[j]的元素； 如果k小于i+1+j+1，那么要查找的第k个元素肯定小于等于B[j]， 因为x大于等于i+1+j+1；既然第k个元素小于等于B[j]，那么只 需要在A[0]~A[m-1]和B[0]~B[j]中查找第k个元素即可，递归调用下去。 */ if(k &lt; i+1+j+1) &#123; if(j &gt; 0) return findKthIn2SortedArrays(A, m, B, j+1, k); else // j == 0时特殊处理，防止死循环 &#123; if(k == 0) return min(A[0], B[0]); if(k == m) return max(A[m-1], B[0]); return A[k] &lt; B[0] ? A[k] : max(A[k-1], B[0]); &#125; &#125; /* 设y为数组A和数组B中小于于等于A[i]的元素数目，则i+1+j+1大于等于y； 如果k大于等于i+1+j+1，那么要查找到第k个元素肯定大于A[i]，因为 i+1+j+1大于等于y；既然第k个元素大于A[i]，那么只需要在A[i+1]~A[m-1] 和B[0]~B[n-1]中查找第k-i-1个元素，递归调用下去。 */ else return findKthIn2SortedArrays(A+i+1, m-i-1, B, n, k-i-1); &#125; // 如果数组A的中间元素大于数组B的中间元素，那么交换数组A和B，重新调用即可 else return findKthIn2SortedArrays(B, n, A, m, k); &#125; 题目十 一个有序（升序）数组，没有重复元素，在某一个位置发生了旋转后，求key在变化后的数组中出现的位置，不存在则返回-1 如 0 1 2 4 5 6 7 可能变成 4 5 6 7 0 1 2.我们先比较中间元素是否是目标值，如果是返回位置。如果不是，我们就应该想办法将搜索区间减少一半。因为存在旋转变化，所以我们要多做一些判断。我们知道因为只有一次旋转变化，所以中间元素两边的子数组肯定有一个是有序的，那么我们可以判断key是不是在这个有序的子数组中，从而决定是搜索这个子数组还是搜索另一个子数组。具体请参考实现代码与注释。 int searchInRotatedArray(int arr[], int n, int key) &#123; int low = 0, high = n-1; while(low &lt;= high) &#123; int mid = low+((high-low)&gt;&gt;1); if(A[mid] == key) return mid; if(A[mid] &gt;= A[low]) &#123; // low ~ mid 是升序的 if(key &gt;= A[low] &amp;&amp; key &lt; A[mid]) high = mid-1; else low = mid+1; &#125; else &#123; // mid ~ high 是升序的 if(key &gt; A[mid] &amp;&amp; key &lt;= A[high]) low = mid+1; else high = mid-1; &#125; &#125; return -1; &#125; **如果这样的数组中存在重复元素，还能使用二分吗？答案是不能。请看几个栗子：[1, 2, 2, 2, 2], [2, 1, 2, 2, 2], [2, 2, 1, 2, 2], [2, 2, 2, 1, 2], [2, 2, 2, 2, 1]这些都是有第一个数组旋转一次变化来的，我们不能通过二分确定是否存在元素1. ** 题目十一 一个有序（升序）数组，没有重复元素，在某一个位置发生了旋转后，求最小值所在位置 如果中间元素小于左端元素，则最小值在左半区间内（包含中间元素）；如果中间元素大于右端元素，则最小值在右半区间内（包含中间元素）。请参考实现代码与注释。 int searchMinInRotatedArray(int arr[], int n) &#123; if(n == 1) return 0; int low = 0, high = n-1; while(low &lt; high-1) // 保证mid != low且mid != high &#123; int mid = low+((high-low)&gt;&gt;1); if(A[mid] &lt; A[low]) // 最小值在low~mid high = mid; else // A[mid] &gt; A[low], // 最小值在mid和high之间 low = mid; &#125; return A[low] &lt; A[low+1] ? low : low+1; &#125; 题目十二 一个有序（升序）数组，没有重复元素，在某一个位置发生了旋转后，求第k(k &gt; 0)小元素的位置 *我们可以利用上一题的解答，求出最小值所在位置后，便可以求出第k小元素。请参考实现代码与注释 * int searchKthInRotatedArray(int arr[], int n, int k) &#123; int posMin = searchMinInRotatedArray(A, n); return (posMin+k-1)%n; &#125; 题目十三 查找数组中第一个比k大的数的下标 当low和high都是非负数时，使用 mid = low + (high - low) / 2;这种形式可以避免溢出。当low和high一个为负另一个为非负时，用mid = (low + high) / 2;这种形式可以避免溢出。 int searrrch_first_larger_k(int arr[], int length, int key) &#123; if (arr == nullptr || length &lt;= 0 || arr[length - 1] &lt;= key) return -1; int res = length - 1,low=0,high=length-1; while (low &lt;= high) &#123; int mid = low + (high - low) / 2; if (arr[mid] &gt; key) &#123; res = mid; high = mid - 1; &#125; else// if (arr[mid] &lt;= key) low = mid + 1; &#125; return res; &#125; 结语 二分查找是个普遍考查点，只要深入了解某几个点就可以对二分查找运用自如。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C语言","slug":"后端/C语言","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"https://ysluckly.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"【C语言】经典小游戏-三子棋","slug":"back-end/2018527","date":"2021-05-26T13:54:45.000Z","updated":"2022-02-26T05:23:44.745Z","comments":true,"path":"2021/05/26/undefined/","link":"","permalink":"https://ysluckly.github.io/2021/05/26/undefined/","excerpt":"前言 要实现三子棋，首先思考三子棋怎么样实现的，如一下几点： 实现三子棋，在一个3*3的二维数组下把二维数组都初始化为 ‘ *’ 电脑随机生成坐标，判断该坐标是否合法，合法赋值为 ‘0’ 玩家输入合法坐标，该坐标赋值为 ‘X’ 判断输赢，每一行，每一列，或者对角线上的值相等，则为赢。如果棋盘满了，还没有赢家，则为平局！返回 ‘Q’","text":"前言 要实现三子棋，首先思考三子棋怎么样实现的，如一下几点： 实现三子棋，在一个3*3的二维数组下把二维数组都初始化为 ‘ *’ 电脑随机生成坐标，判断该坐标是否合法，合法赋值为 ‘0’ 玩家输入合法坐标，该坐标赋值为 ‘X’ 判断输赢，每一行，每一列，或者对角线上的值相等，则为赢。如果棋盘满了，还没有赢家，则为平局！返回 ‘Q’ 项目效果展示： 参考代码：game.h/********************************************************* * 程序名称：三子棋 * * 编译环境：vs2013 * * 编辑日期：2018.5.26 * * ------by Hunter * **********************************************************/ #ifndef __GAME_H__ #define __GAME_H__ #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;time.h&gt; #include&lt;string.h&gt; typedef unsigned int uint; enum APP &#123; EXIT, START &#125;; #define ROW 3 #define COL 3 //初始化棋盘 void InitBoard(char board[ROW][COL], int row, int col); //打印棋盘 void PrintBoard(char board[ROW][COL], int row, int col); //电脑走 void ComputerMove(char board[ROW][COL], int row, int col); //玩家走 void PlayerMove(char board[ROW][COL], int row, int col); //判输赢 char is_win(char board[ROW][COL], int row, int col); #endif //__GAME_H__ game.c #define _CRT_SECURE_NO_WARNINGS 1 #include&quot;game.h&quot; void InitBoard(char board[ROW][COL], int row, int col) &#123; memset(board, &#39; &#39;, sizeof(char)* row*col); &#125;//memset函数用来对一段内存空间全部设置为某个字符 void PrintBoard(char board[ROW][COL], int row, int col) &#123; int i = 0; for (i = 0; i &lt; row; i++) &#123; printf(&quot; %c | %c | %c \\n&quot;, board[i][0], board[i][1], board[i][2]); if (i != 2) &#123; printf(&quot;---|---|---\\n&quot;); &#125; &#125; &#125; void PlayerMove(char board[ROW][COL], int row, int col) &#123; int x = 0; int y = 0; printf(&quot;请输入落子的坐标：\\n&quot;); while (1) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); //保证输入坐标的合法性,玩家输入的坐标是从1开始的 if (((x &gt;= 1) &amp;&amp; (x &lt;= row)) &amp;&amp; ((y &gt;= 1) &amp;&amp; (y &lt;= col))) &#123; if (board[x - 1][y - 1] == &#39; &#39;) &#123; board[x - 1][y - 1] = &#39;X&#39;;//玩家落子 break; &#125; else &#123; printf(&quot;该坐标已被占用，请换一个坐标：\\n&quot;); &#125; &#125; else &#123; printf(&quot;输入坐标不合法，请重新输入：\\n&quot;); &#125; &#125; &#125; void ComputerMove(char board[ROW][COL], int row, int col) &#123; int x = 0; int y = 0; while (1) &#123; x = rand() % row; y = rand() % col;//利用rand函数生成随机坐标 if (board[x][y] == &#39; &#39;) &#123; board[x][y] = &#39;0&#39;; break; &#125; &#125; &#125; static int is_full(char board[ROW][COL], int row, int col) //函数is_full只在is_win中被调用，可以加上static改变其链接属性 &#123; int i = 0; for (i = 0; i &lt; row; i++) &#123; int j = 0; for (j = 0; j &lt; col; j++) &#123; if (board[i][j] == &#39; &#39;) return 0; &#125; &#125; return 1; &#125;//判断棋盘是否下满了 char is_win(char board[ROW][COL], int row, int col) &#123; int i = 0; int j = 0; for (i = 0; i &lt; row; i++) &#123; if ((board[i][0] == board[i][1]) &amp;&amp; (board[i][1] == board[i][2]) &amp;&amp; (board[i][2] != &#39; &#39;)) &#123; return board[i][1]; &#125; &#125; for (j = 0; j &lt; col; j++) &#123; if ((board[0][j] == board[1][j]) &amp;&amp; (board[1][j] == board[2][j]) &amp;&amp; (board[2][j] != &#39; &#39;)) &#123; return board[1][j]; &#125; &#125; if ((board[0][0] == board[1][1]) &amp;&amp; (board[1][1] == board[2][2]) &amp;&amp; (board[2][2] != &#39; &#39;)) &#123; return board[1][1]; &#125; else if ((board[0][2] == board[1][1]) &amp;&amp; (board[1][1] == board[2][0]) &amp;&amp; (board[1][1] != &#39; &#39;)) &#123; return board[1][1]; &#125; else if (is_full(board, ROW, COL) == 1) &#123; return &#39;Q&#39;;//表示棋盘下满了 &#125; else return &#39; &#39;; &#125; test.c #define _CRT_SECURE_NO_WARNINGS 1 #include&quot;game.h&quot; void menu() &#123; printf(&quot;***** 《三子棋游戏》*****\\n&quot;); printf(&quot;****** 1.play *******\\n&quot;); printf(&quot;****** 0.exit *******\\n&quot;); printf(&quot;*************************\\n&quot;); printf(&quot;*************************\\n&quot;); &#125; void game() &#123; char ret; char board[ROW][COL]; InitBoard(board, ROW, COL); PrintBoard(board, ROW, COL); while (1) &#123; printf(&quot;玩家走：\\n&quot;); PlayerMove(board, ROW, COL); PrintBoard(board, ROW, COL); ret = is_win(board, ROW, COL); if (ret != &#39; &#39;) break; printf(&quot;电脑走：\\n&quot;); ComputerMove(board, ROW, COL); PrintBoard(board, ROW, COL); ret = is_win(board, ROW, COL); if (ret != &#39; &#39;) break; &#125; if (ret == &#39;X&#39;) &#123; printf(&quot; 你赢了！\\n&quot;); &#125; else if (ret == &#39;0&#39;) &#123; printf(&quot; 你输了\\n&quot;); &#125; else if (ret == &#39;Q&#39;) &#123; printf(&quot;平局\\n&quot;); &#125; &#125; void test() &#123; int input = 0; srand((uint)time(NULL)); do &#123; menu(); printf(&quot;请选择:&quot;); scanf(&quot;%d&quot;, &amp;input); switch (input) &#123; case START: game(); break; case EXIT: break; default: break; &#125; &#125; while (input); &#125; int main() &#123; test(); system(&quot;pause&quot;); return 0; &#125; 结语 天天编程，天天向上！","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C语言","slug":"后端/C语言","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"三子棋","slug":"三子棋","permalink":"https://ysluckly.github.io/tags/%E4%B8%89%E5%AD%90%E6%A3%8B/"}]},{"title":"函数调用过程（栈桢）","slug":"back-end/2018526","date":"2021-05-25T13:54:40.000Z","updated":"2022-02-26T05:23:11.040Z","comments":true,"path":"2021/05/25/undefined/","link":"","permalink":"https://ysluckly.github.io/2021/05/25/undefined/","excerpt":"前言 栈帧也叫过程活动记录，是编译器用来实现函数调用过程的一种数据结构。C语言中，每个栈帧对应着一个未运行完的函数。从逻辑上讲，栈帧就是一个函数执行的环境：函数调用框架、函数参数、函数的局部变量、函数执行完后返回到哪里等等。栈是从高地址向低地址延伸的。每个函数的每次调用，都有它自己独立的一个栈帧，这个栈帧中维持着所需要的各种信息。寄存器ebp指向当前的栈帧的底部（高地址），寄存器esp指向当前的栈帧的顶部（低地址）。","text":"前言 栈帧也叫过程活动记录，是编译器用来实现函数调用过程的一种数据结构。C语言中，每个栈帧对应着一个未运行完的函数。从逻辑上讲，栈帧就是一个函数执行的环境：函数调用框架、函数参数、函数的局部变量、函数执行完后返回到哪里等等。栈是从高地址向低地址延伸的。每个函数的每次调用，都有它自己独立的一个栈帧，这个栈帧中维持着所需要的各种信息。寄存器ebp指向当前的栈帧的底部（高地址），寄存器esp指向当前的栈帧的顶部（低地址）。 Add()函数调用深度剖析 我们以Add（）函数为例深入的研究一下函数的调用过程。先看一段简单的代码： #include &lt;stdio.h&gt; int Add(int x, int y) &#123; int z = 0; z = x + y; return z; &#125; int main() &#123; int a = 10; int b = 20; int ret = Add(a, b) ; printf(&quot;ret = %d\\n&quot;, ret) ; return 0; &#125; 当开始剖析程序调试的时候， 查看【调用堆栈】（按F10进入调试-&gt;窗口-&gt;调用堆栈，或快捷键ctrl+alt+C），用VS2013调试 如下图： 我们发现其实main函数在 __tmai nCRTStartup 函数中调用的，而 __tmai nCRTStartup 函数是在 mai nCRTStartup 被调用的。我们知道每一次函数调用都是一个过程。这个过程我们通常称之为： 函数的调用过程。这个过程要为函数开辟栈空间（运行时堆栈）， 用于本次函数的调用中临时变量的保存、 现场保护。 这块栈空间我们称之为函数栈帧。所以函数调用过程实际上就是函数栈桢创建与销毁。 而栈帧的维护我们必须了解ebp和esp两个寄存器。 在函数调用的过程中这两个寄存器存放了维护这个栈的栈底和栈顶指针。比如：调用main函数， 我们为main函数分配栈帧空间， 那么栈帧维护如下： ebp存放了指向函数栈帧栈底的地址。esp存放了指向函数栈帧栈顶的地址。 注意：ebp指向当前位于系统栈最上边一个栈帧的底部，而不是系统栈的底部。严格说来，“栈帧底部”和“栈底”是不同的概念;esp所指的栈帧顶部和系统栈的顶部是同一个位置。 1 . main函数开始。 要展开main函数的调用就得为main函数创建栈帧， 那我们先来看main函数栈帧的创建。转到反汇编可以更清晰的看到过程： 过程分析： 首先mainCRTStartup()，__mainCRTStartup()函数的调用，调main()函数； 将ebp压栈处理，保存指向栈底的ebp的地址（方便函数返回之后的现场恢复），此时esp指向新的栈顶位置； 将esp的值赋给ebp，产生新的ebp； 给esp减去一个16进制数0E4H（为main函数预开辟空间）； push ebx、esi、edi； lea指令，加载有效地址； 初始化预开辟的空间为0xcccccccc； 创建变量a与b。 2. 接下来Add函数的调用。 参数传递过程：(从右到左传参) 过程分析： 将b存入寄存器eax,对b进行实例化_b ; 将a存入寄存器ecx,对a进行实例化_a ; call指令的调用，先要压栈call指令下一条指令的地址，然后跳转到Add()函数的地方。 执行call指令的时候按F11 ， 来到了这里。 再按F11 就进入Add函数的执行代码处。Add函数栈帧的创建： 过程分析： 首先将main()函数ebp压栈处理，保存指向main()函数栈帧底部的ebp的地址（方便函数返回之后的现场恢复），此时esp指向新的栈顶位置； 将esp的值赋给ebp，产生新的ebp，即Add()函数栈帧的ebp；给esp减去一个16进制数0E4H（为Add()函数预开辟空间）； push ebx、esi、edi； lea指令，加载有效地址； 初始化预开辟的空间为0xcccccccc； 创建变量z； 获取形参的a和b再相加，将结果存储到z中； 将结果存储到eax寄存器，通过寄存器带回函数的返回值。 *剩下的就是是函数返回部分：** 过程分析： pop 3次，edi、esi、ebx依次出栈,esp 向下移动； 将ebp赋给esp，使esp指向ebp指向的地方; ebp 出栈，将出栈的内容给ebp（即main()函数ebp），回到main()函数的栈帧； ret 指令，出栈一次，并将出栈的内容当做地址，并跳转到该地址处 。 注： 栈帧这部分内容在不同的编译器上实现存在差异， 但是思想都是一致的。 对于函数调用具体过程剖析完了，我们来个小测验： 在VC6.0环境中， 下面代码的结果是什么？ #include &lt;stdio.h&gt; void fun() &#123; int tmp = 10; int *p = (int *)(*(&amp;tmp + 1)); *(p - 1) = 20; &#125; int main() &#123; int a = 0; fun(); printf(&quot;a = %d\\n&quot;, a); return 0; &#125; 事实上在不同平台下这段代码有不同的输出，可自行验证。 此处提供VS编译器答案：20 结语堆和栈的关系 我们平时说的堆栈其实是指栈，而实际上堆和栈是两种不同的内存分配。简单罗列如下各方面的异同点。 堆需要用户在程序中显式申请，栈不用，由系统自动完成。申请/释放堆内存的API，在C中是malloc/free，在C++中是new/delete。申请与释放一定要配对使用，否则会造成内存泄漏(memory leak)，久而久之系统就无内存可用了，出现OOM（Out Of Memory）错误。一般在return/exit或break/continue等语句时容易忘记释放内存，所以检查内存泄漏的代码时要关注这些语句，看它们前面是否有必要的释放语句free/delete。 堆的空间比较大，栈比较小。所以申请大的内存一般在堆中申请；栈上不要有较大的内存使用，比如大的静态数组；而且除非算法必要，否则一般不要使用较深的迭代函数调用，那样栈消耗内存会随着迭代次数的增加飞涨。 关于生命周期。栈较短，随着函数退出或返回，本函数的栈就完成了使用；堆就要看什么时候释放，生命周期就什么时候结束。 关于函数调用即栈桢创建与销毁就浅析到此！","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C语言","slug":"后端/C语言","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"栈桢","slug":"栈桢","permalink":"https://ysluckly.github.io/tags/%E6%A0%88%E6%A1%A2/"}]},{"title":"平均数三种境界","slug":"back-end/2018524","date":"2021-05-24T13:54:20.000Z","updated":"2022-02-26T05:22:44.894Z","comments":true,"path":"2021/05/24/undefined/","link":"","permalink":"https://ysluckly.github.io/2021/05/24/undefined/","excerpt":"前言 平均数:平均数是指在一组数据中所有数据之和再除以数据的个数。平均数是表示一组数据集中趋势的量数，它是反映数据集中趋势的一项指标。今天就简单讲解一下编程界平均数几种简要解法。","text":"前言 平均数:平均数是指在一组数据中所有数据之和再除以数据的个数。平均数是表示一组数据集中趋势的量数，它是反映数据集中趋势的一项指标。今天就简单讲解一下编程界平均数几种简要解法。 解法一： 这种方法最为简单，弊端是如果a和b非常大的话，a+b的值可能超过了整型的储存范围（最大值为2147483647），导致溢出，得到错误的结果。 参考代码 #include &lt;stdio.h&gt; int main() &#123; int a=10; int b=20; int avg=0; avg=(a+b)/2;//平局值 //或者 avg=(a+b)&gt;&gt;1://右移表示除2，左移表示乘2。 //【-1除外】（右移一位为-1，左移一位为-2） printf(&quot;%d\\n&quot;,avg); return 0; &#125; 解法二： 用一个较大值减去另一个较小值得到二者之差，将差除2后加上较小值即得到了二者平均值，可有效防止溢出的情况的出现。 步骤如图： 参考代码 #include &lt;stdio.h&gt; int main() &#123; int a=10; int b=20; int avg=0; avg=b+(a-b)/2;//平均值 //或者 avg=b+(a-b)&gt;&gt;1://右移表示除2，左移表示乘2 //【-1除外】（右移一位为-1，左移一位为-2） printf(&quot;%d\\n&quot;,avg); return 0; &#125; 方法三： 将两个数的二进制位分为相同部分和不同部分，利用按位与求出相同部分的平均数，然后再用按位异或求出不同部分的平均数，加起来就是两个数的平均数。 这里举个栗子： a = 10,b = 12; 10&amp;12可得到 1000 10^12可得到 0110 计算a与b的平均值C语言表达式:* avg = (a&amp;b) + (a^b)&gt;&gt;1 参考代码 #include &lt;stdio.h&gt; int main() &#123; int a=10; int b=20; int avg=0; avg = (a&amp;b) + (a^b)&gt;&gt;1; //或者 avg = (a&amp;b) + (a^b)/2; printf(&quot;%d\\n&quot;,avg); return 0; &#125; 结语 知识在于汇总，方法在于总结。不忘初心，励志前行！","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C语言","slug":"后端/C语言","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"平均数","slug":"平均数","permalink":"https://ysluckly.github.io/tags/%E5%B9%B3%E5%9D%87%E6%95%B0/"}]},{"title":"C/C++代码规范","slug":"back-end/2018525","date":"2021-05-23T13:54:33.000Z","updated":"2022-02-26T05:22:57.702Z","comments":true,"path":"2021/05/23/undefined/","link":"","permalink":"https://ysluckly.github.io/2021/05/23/undefined/","excerpt":"前言 本文摘录自谷歌开源项目开源指南。 详见 —&gt;谷歌开源项目开源指南","text":"前言 本文摘录自谷歌开源项目开源指南。 详见 —&gt;谷歌开源项目开源指南 头文件 每通常一个 .c/.cpp文件都有一个对应的 .h 文件。也有一些常见例外，如单元测试代码和只包含 main() 函数的 .c/.cpp文件。正确使用头文件可令代码在可读性，文件大小和性能上大为改观。 下面的规则将引导你规避使用头文件时的各种陷阱。 自包含的头文件 头文件应该能够自给自足（自包含的，也就是可以作为第一个头文件被引入），以 .h 结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以以应 .inc 结尾不允许。出分离 -inl.h 头文件的做法。所有头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。详言之，一个头文件要有 1.2。#define保护，统计包含它所需要的其它头文件，也不要求定义任何特别的符号。 不过有一个例外，即一个文件并不是自足的，而是作为文本插入到代码某处。或者，文件内容实际上是其它头文件的特定平台（特定于平台）扩展部分，这些文件就要用 .inc 文件扩展名。 如果 .h 文件声明了一个模板或内联函数，同时也在该文件加以定义。有用凡是到这些的 .cpp 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。不要把这些定义放到分离的 -inl.h 文件里（译者注：过去该规范曾提倡把定义放到-inl.h里过）。 有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，它就那么定义只能在实例化该模板的 .cpp 文件里。 #define保护 所有头文件都应该使用 #define 来防止头文件被多重包含，命名格式当是： H 。为保证唯一性，头文件的命名应该基于所有项目源代码树的全路径。例如，项目 foo 中的头文件 foo/src/bar/baz.h 可按如下方式保护： #ifndef FOO_BAR_BAZ_H_#define FOO_BAR_BAZ_H_ …#endif // FOO_BAR_BAZ_H_ 前置声明 尽可能地避免使用前置声明。使用 #include 所有游戏需要的头文件即可。定义：所谓「前置声明」（forward declaration）是类，函数和模板的纯粹声明，没伴随着其定义。 优点： 前置声明能够节省编译时间，的多余 #include 会迫使compile-器展开更多的文件，处理更多的输入。前置声明能够节省不必要的重新编译的时间。 #include 使代码因为头文件中无关的改动而被重新编译多次。 缺点： 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其API。例如扩大形参类型，加个自带默认参数的模板形参等等。前置声明来自命名空间 std:: 的符号时，其行为未定义。很难判断什么时候该用前置声明，时候什么用该 #include 极端情况下，用前置声明代替。 includes 甚至都会暗暗地改变代码的含义： // bh：struct B {};struct D ： B {} // good_user.cpp：＃包括 “BH”void f （B * ）;void f （void * ）;void test （D * x ） { f （x ）; } //调用f（B ）如果 #include 被 B 状语从句： D 的前置声明替代， test() 就会调用 f(void) 。前置声明了include 不少来自头文件的符号时，就会比单单一行的 冗长。仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂。 结论： 尽量避免前置声明那些定义在其他项目中的实体。 函数：总是使用 #include。 类模板：优先使用 #include。 至于什么时候包含头文件，参见 **1.5。#include的路径及顺序 **。 内联函数 只有当函数只有10行甚至更少时才将其定义为内联函数。定义：当函数被声明为内联函数之后，编译器会将其内联展开，而不是按通常的函数调用机制进行调用。 优点： 只要内联的函数体小小，内联该函数可以令目标代码更加高效。对于存取函数以及其它函数体比较短，性​​能关键的函数，鼓励使用内联。 缺点： 滥用内联将导致程序变得更慢。内联可能使目标代码量或增或减，这取决于内联函数的大小。内联非常短小的存取函数通常会减少代码大小，但内联一个相当大的函数将戏剧性的增加代码大小。现代处理器由于更好的利用了指令缓存，小巧的代码往往执行更快。 结论： 一个较为合理的经验准则是，不要内联超过10行的函数。谨谨对待析构函数，析构函数往往比其表面看起来要更长，因为有隐含的成员和基类析构函数被调用！ 另一个实用的经验准则：内联那些包含循环或 switch 语句的函数常常是得不偿失（除非在大多数情况下，这些循环或 switch 语句从不被执行）。 有些函数即使声明为内联的也不一定会被编译器内联，这点很重要; 比如虚函数和递归函数就不会被正常内联。通常，递归函数不应该声明成内联函数。（YuleFox注：递归调用堆栈的展开并不像循环那么简单，比如递进层数在编译时可能是未知的，大多数编译器都不支持内联递归函数）。虚函数内联的主要原因是想把它的函数体放在类定义内，为了图个方便，抑或是当作文件描述其行为，比如精短的存取函数。 #include 的路径及顺序 使用标准的头文件包含顺序可增强可读性，避免隐藏依赖：相关头文件，C库，C ++库，其他库的 .h，本项目内的 .h。项目内部文件应按照项目源代码目录树结构排列，避免使用UNIX特殊的快捷目录 .（当前目录）或 .. （上级目录）。 例如， google-awesome-project/src/base/logging.h 应该按如下方式包含：#include “base / logging.h”又如， dir/foo.cpp 或 dir/foo_test.cpp 的主要作用英文的英文实现或测试 dir2/foo2.h 的功能， foo.cpp 中包含头文件的次序如下：dir2/foo2.h （优先位置，详情如下）C系统文件C ++系统文件库其他的 .h 文件项目本。内 .h 文件优先这种顺序的排序保证当 dir2/foo2.h 遗漏某些必要的库时， dir/foo.cpp 或 dir/foo_test.cpp 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。 dir/foo.cpp 和 dir2/foo2.h 通常位于同一目录下(如base/basictypes_unittest.cpp 和 base/basictypes.h），但也可放在不同目录下。按字母顺序分别对每种类型的头文件进行二次排序是不错的主意。注意较老的代码可不符合这条规则，要在方便的时候改正它们。 您所依赖的符号（符号）被哪些头文件所定义，您就应该包含（包括）哪些头文件，前置声明 （向前声明）情况除外。您比如要用到 bar.h 中的某个符号，哪怕您所包含的 foo.h 已经包含了 bar.h，也照样得包含 bar.h，除非foo.h 有明确 说明它会自动向您提供 bar.h 中符号。不过，凡是cc文件所对应的「相关头文件」已经包含的，就不用再重复包含进其cc文件里面了，就像 foo.cpp 只包含 foo.h就够了，不用再管后者所包含的其它内容。 函数参数顺序 总述:函数的参数顺序为：输入参数在先，后跟输出参数。 说明 C / C ++中的函数参数或者是函数的输入，或者是函数的输出，或兼而有之。输入参数通常是值参或 const 引用，输出参数或输入/输出参数则一般为非 const 指针。在排列参数顺序时，将所有的输入参数置于输出参数之前。特别要注意，在加入新参数时不要因为它们是新参数就置于参数列表最后，而是仍然要按照前述的规则，即将新的输入参数也置于输出参数之前。 这并非一个硬性规定。输入/输出参数（通常是类或结构体）让这个问题变得复杂。并且，有时候为了其他函数保持一致，你可能不得不不所有变通。 编写简短函数 总述:我们倾向于编写简短，凝练的函数。 说明 我们承认长函数有时是合理的，因此并不硬限制函数的长度。如果函数超过40行，可以思索一下能不能在不影响程序结构的前提下对其进行分割。 即使一个长函数现在工作的非常好，一旦有人对其修改，有可能出现新的问题，甚至导致难以发现的错误。使函数尽量简短，以便于他在他人阅读和修改代码。 在处理代码时，你可能会发现复杂的长函数。不要害怕修改现有代码：如果证实这些代码使用/调试起来很困难，或者你只需​​要使用其中的一小段代码，考虑将其分割为更加简短并易于管理的若干函数。 引用参数 总述:所有按引用传递的参数必须加上 const。 说明 》在C语言中，如果函数需要修改变量的值，参数必须为指针，如 。在C ++中，函数还可以声明为引用参数： 。int foo(int *pval)int foo(int &amp;val) 优点 引用定义参数可以防止出现 (*pval)++ 这样丑陋的代码。引用参数对于拷贝构造函数这样的应用也是必需的。同时也更明确地不接受空指针。 缺点 容易引起误解，因为引用在语法上是值变量却拥有指针的语义。 结论 函数参数列表中，所有引用参数都必须是 const：void Foo （const string ＆in ， string * out ）;事实上这在Google Code是一个硬性约定：输入参数是值参或 const 引用，输出参数为指针。输入参数可以是 const 指针，但决不能是非 const 引用参数，除非特殊要求，比如 swap()。有时候，在输入形参中用针指更明智。 比如：const Tconst T&amp;可能会传递空指针。函数要把指针或对地址的引用赋值给输入形参。总而言之，大多时候输入形参往往是 。用若 则说明输入侧另有处理。所以若要使用 ，则应给出相应的理由，否则会使读者感到迷惑。const T&amp;const Tconst T* 函数重载总述 》若要使用函数重载，则必须能让读者一看调用点就胸有成竹，而不用花心思猜测调用的重载函数到底是哪一种。这一规则也适用于构造函数。 定义 你可以编写一个参数类型的函数，然后用另一个参数类型函数对其进行重载： const string&amp;const char* class MyClass &#123; public ： void Analyze （const string ＆text ）; void 分析（const char * text ， size_t textlen ）; &#125;; 优点 通过重载参数不同的同名函数，可以令代码更直观。模板化代码需要重载，这同时也能为使用者带来便利。 缺点 如果函数单靠不同的参数类型而重载（acgtyrant注：这意味着参数数量不变），读者就得十分熟悉C ++五花八门的匹配规则，以了解匹配过程具体到底如何。另外，如果派生类只重载了某个函数的部分变体，继承语义就容易令人困惑。 结论 如果打算重载一个函数，可以试试改在函数名里加参数信息。例如，用 AppendString()和 AppendInt() 等，而不是一口气重载多个 Append()。如果重载函数的目的是为了支持不同数量的同一类型参数，则优先考虑使用 std::vector 以便使用者可以用 列表初始化指定参数。 缺省参数总述 只允许在非虚函数中使用缺省参数，且必须保证缺省参数的值始终一致。参数缺省与 函数重载 遵循同样的规则。一般情况下建议使用函数重载，尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下。 优点 有些函数一般情况下使用默认参数，但有时需要又使用非默认的参数。缺省参数为这样的情形提供了便利，使程序员不需要为了极少的例外情况编写大量的函数。和函数重载相比，缺省参数的语法更简洁明了，减少了大量的样板代码，也更好地区别了“必要参数”和“可选参数”。 缺点 缺省参数实际上是函数重载语义的另一种实现方式，因此所有 不应当使用函数重载的理由 也都适用于缺省参数。 虚函数调用的缺省参数取决于目标对象的静态类型，此时无法保证给定函数的所有重载声明的都是同样的缺省参数。 缺省参数是在每个调用点都要进行重新求值的，这会造成生成的代码迅速膨胀。作为读者，一般来说也更希望缺省的参数在声明时就已经被固定了，而不是在每次调用时都可能会有不同的取值。 缺省参数会干扰函数指针，导致函数签名与调用点的签名不一致。而函数重载不会导致这样的问题。 结论 对于虚函数，不允许使用缺省参数，因为在虚函数中缺省参数不一定能正常工作。如果在每个调用点缺省参数的值都有可能不同，在这种情况下缺省函数也不允许使用。（例如，不要写像 这样的代码。）void f(int n = counter++); 在其他情况下，如果缺省参数对可读性的提升远远超过了以上提及的缺点的话，可以使用缺省参数。如果仍有疑惑，就使用函数重载。 函数返回类型后置语法总述 只有在常规写法（返回类型前置）不便于书写或不便于阅读时使用返回类型后置语法。 定义 C ++现在允许两种不同的函数声明方式。以往的写法是将返回类型置于函数名之前。例如： int foo （int x ）; C ++ 11引入了这一新的形式。现在可以在函数名前使用 auto 关键字，在参数列表之后后置返回类型。例如： auto foo （int x ） - &gt; int ; 后置返回类型为函数作用域。对于像 int 这样简单的类型，两种写法没有区别。但对于复杂的情况，例如类域中的类型声明或者以函数参数的形式书写的类型，写法的不同会造成区别。 优点 后置返回类型是显式地指定 Lambda表达式 的返回值的唯一方式。某些情况下，编译器可以自动推导出Lambda表达式的返回类型，但并不是在所有的情况下都能实现。即使编译器能够自动推导，显式地指定返回类型也能让读者更明了。 有时在已经出现了的函数参数列表之后指定返回类型，能够让书写更简单，也更易读，尤其是在返回类型依赖于模板参数时。例如： template &lt; class T ， class U &gt; auto add （T t ， U u ） - &gt; decltype （t + u ）; 对比下面的例子： template &lt; class T ， class U &gt; decltype （declval &lt; T ＆&gt; （） + declval &lt; U ＆gt ;） add （T t ， U u ）; 缺点 后置返回类型相对来说是非常新的语法，而且在C和Java中都没有相似的写法，因此可能对读者来说比较陌生。在已有的代码中有大量的函数声明，你不可能把它们都用新的语法重写一遍。因此实际的做法只能是使用旧的语法或者新旧混用。在这种情况下，只使用一种版本是相对来说更规整的形式。 结论 在大部分情况下，应当继续使用以往的函数声明写法，即将返回类型置于函数名前。只有在必要的时候（如Lambda表达式）或者使用后置语法能够简化书写并且提高易读性的时候才使用新的返回类型后置语法。但是后一种情况一般来说是很少见的，大部分时候都出现在相当复杂的模板代码中，而多数情况下不鼓励写这样 复杂的模板代码。 命名约定 最重要的一致性规则是命名管理。命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义：类型，变量，函数，常量，宏，等等，甚至。我们大脑中的模式匹配引擎非常依赖这些命名规则。 命名规则具有一定随意性，但相比按个人喜好命名，一致性更重要，所以无论你认为它们是否重要，规则总归是规则。 通用命名规则总述 函数命名，变量命名，文件命名要有描述性; 少用缩写。 说明 尽可能使用描述性的命名，别心疼空间，毕竟相比之下让代码易于新读者理解更重要。不要用只有项目开发者能理解的缩写，也不要通过砍掉几个字母来缩写单词。 int price_count_reader ; //无缩写 int num_errors ; //“num”是一个常见的写法 int num_dns_connections ; //人人都知道“DNS”是什么 int n ; //毫无意义。 int nerr ; //含糊不清的缩写。 int n_comp_conns ; //含糊不清的缩写。 int wgc_connections ; //只有贵团队知道是什么意思 int pc_reader ; //“pc”有太多可能的解释了。 int cstmr_id ; //删减了若干字母。 注意，一些特定的广为人知的缩写是允许的，例如用 i 表示迭代变量和用 T 表示模板参数。 模板参数的命名应当遵循对应的分类：类型模板参数应当遵循 类型命名 的规则，而非类型模板应当 遵循变量命名 的规则。 文件命名总述 文件名要全部小写，可以包含下划线（_）或连-字符（），依照项目的约定。如果没有约定，那么“ _” 更好。 说明 可接受的文件命名示例： my_useful_class.cpp my-useful-class.cpp myusefulclass.cpp myusefulclass_test.cpp // _unittest 状语从句： _regtest 已弃用。 C ++文件要以 .cpp结尾，头文件以 .h 结尾。专门插入文本的文件则以 .inc 结尾，参见 头文件自足。 不要使用已经存在于 /usr/include 下的文件名（Yang.Y注：即编译器搜索系统头文件的路径），如 db.h。 通常应尽量让文件名更加明确。 http_server_logs.h 就比 logs.h 要好。定义类时文件名一般成对出现，如 foo_bar.h 和 foo_bar.cpp，对应于类 FooBar。 联内必须函数放在 .h 文件中。如果内联函数比较短，就直接放在 .h 中。 类型命名总述 类型名称的每个单词首字母均大写，不包含下划线： MyExcitingClass， MyExcitingEnum。 说明 所有类型命名 - 类，结构体，类型定义（typedef），枚举，类型模板参数 - 均使用相同约定，即以大写字母开始，每个单词首字母均大写，不包含下划线。例如： //类和结构体 类 UrlTable &#123; ... class UrlTableTester &#123; ... struct UrlTableProperties &#123; ... //类型定义 typedef hash_map &lt; UrlTableProperties * ， string &gt; PropertiesMap ; //使用别名 使用 PropertiesMap = hash_map &lt; UrlTableProperties * ， string &gt; ; //枚举 enum UrlTableErrors &#123; ... 变量命名总述 变量（包括函数参数）和数据成员名一律小写，单词之间用下划线连接。类的成员变量以下划线结尾，但结构体的就不用，如： a_local_variable， a_struct_data_member， a_class_data_member_。 说明 普通变量命名 举例： 字符串 table_name ; //好 - 用下划线。字符串 表名; //好 - 全小写。字符串 tableName ; //差 - 混合大小写类数据成员 不管是静态的还是非静态的，类数据成员都可以和普通变量一样，但要接下划线。 类 TableInfo &#123; ... private ： string table_name_ ; //好 - 后加下划线。 字符串 tablename_ ; //好。 静态 池&lt; TableInfo &gt; * pool_ ; //好。 &#125;; 结构体变量 不管是静态的还是非静态的，结构体数据成员都可以和普通变量一样，不用像类那样接下划线： struct UrlTableProperties &#123; string name ; int num_entries ; 静态 池&lt; UrlTableProperties &gt; * 池; &#125;; 结构体与类的使用讨论，参考 结构体与类。 常量命名总述 声明为 constexpr 或 const 的变量，或在程序运行期间其值始始保持不变的，命名时以“k”开头，大小写混合。例如： const int kDaysInAWeek = 7 ; 说明 所有具有静态存储类型的变量（例如静态变量或全局变量，参见 存储类型）都应当以此方式命名。对于其他存储类型的变量，如自动变量等，这条规则是可选的。如果不采用这条规则，就按照一般的变量命名规则。 命名空间命名总述 命名空间以小写字母命名。最高级命名空间的名字取决于项目名称。要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突。 顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字。命名空间中的代码，应当存放于和命名空间的名字匹配的文件夹或其子文件夹中。 注意 不使用缩写作为名称 的规则同样适用于命名空间。命名空间中的代码极少需要涉及命名空间的名称，因此没有必要在命名空间中使用缩写。 要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突。由于名称查找规则的存在，命名空间之间的冲突完全有可能导致编译失败。尤其是，不要创建嵌套的 std 命名空间。建议使用更独特的项目标识符（websearch::index， websearch::index_util）而非常见的极易发生冲突的名称（比如 websearch::util）。 对于 internal 命名空间，要当心加入到同一 internal 命名空间的代码之间发生冲突（由于内部维护人员通常来自同一团队，因此常有可能导致冲突）。在这种情况下，请使用文件名以使内部名称独一无二（例如对于 frobber.h，使用 websearch::index::frobber_internal）。 枚举命名总述 枚举命名应当状语从句： 常量 或 宏 harmony和谐： kEnumName 或是 ENUM_NAME。 说明 单独枚举值应该优先采用 常量 的命名方式。但 宏 方式的命名也可以接受。枚举名 UrlTableErrors （以及 AlternateUrlTableErrors）是类型，所以要用大小写混合的方式。 enum UrlTableErrors &#123; kOK = 0 ， kErrorOutOfMemory ， kErrorMalformedInput ， &#125;; 枚举 AlternateUrlTableErrors &#123; OK = 0 ， OUT_OF_MEMORY = 1 ， MALFORMED_INPUT = 2 ， &#125;; 宏命名总述 你并不打算 使用宏，对吧？如果你一定要用，像这样命名： MY_MACRO_THAT_SCARES_SMALL_CHILDREN。 说明 参考 预处理宏 ; 通常 不应该 使用宏。如果不得不使用，其命名像枚举命名一样全部大写，使用下划线： #define ROUND（x）... #define PI_ROUNDED 3.0 命名规则的特例总述 如果你命名的实体与已有C / C ++实体相似，可参考现有命名策略。 bigopen()：函数名，参照 open() 的形式 uint： typedef bigpos： struct 或 class，参照 pos 的形式 sparse_hash_map：STL型实体; 参照STL命名约定 LONGLONG_MAX：常量，如同 INT_MAX 注意 注释虽然写起来很痛苦，但对保证代码可读性至关重要。下面的规则描述了如何注释以及在哪儿注释。当然也要记住：注释固然很重要，但最好的代码应当本身就是文档。有意义的类型名和变量名，要远胜过要用注释解释的含糊不清的名字。 你写的注释是给代码读者看的，也就是下一个需要理解你的代码的人。所以慷慨些吧，下一个读者可能就是你！ 注释风格总述 使用 // 或 /** * */ 统一就好。 说明 // 或 /** * */ 都可以; 但 //更 常用。要在如何注释及注释风格上确保统一。 文件注释总述 在每一个文件开头加入版权公告。 文件注释描述了该文件的内容。如果一个文件只声明，或实现或测试了一个对象，并且这个对象已经在它的声明处进行了详细的注释，那么就没有必要再加上文件注释。除此之外的其他文件都需要文件注释。 说明 法律公告和作者信息 每个文件都应该包含许可证引用。为项目选择合适的许可证版本（比如，Apache 2.0，BSD，LGPL，GPL） 如果你对原始作者的文件做了重大修改，请考虑删除原作者信息。 文件内容 如果一个 .h 文件声明了多个概念，则文件注释应当对文件的内容做一个大致的说明，同时说明各个概念之间的联系。一个一到两行的文件注释就足够了，对于每个概念的详细文档应当放在各个概念中，而不是文件注释中。 不要在 .h 和 .cpp 之间复制注释，这样的注释偏离了注释的实际意义。 类注释总述 每个类的定义都要附带一份注释，描述类的功能和用法，除非它的功能相当明显。 //遍历GargantuanTable的内容。 //示例： // GargantuanTableIterator * iter = table-&gt; NewIterator（）; // it for（iter-&gt; Seek（“foo”）;！iter-&gt; done（）; iter-&gt; Next（））&#123; // process（iter-&gt; key（），iter-&gt; value（））; //&#125; //删除它; 类 GargantuanTableIterator &#123; ... &#125;; 说明 类注释应当为读者理解如何使用与何时使用类提供足够的信息，同时应当提醒读者在正确使用此类时应当考虑的因素。如果类有任何同步前提，请用文档说明。如果该类的实例可被多线程访问，要特别注意文档说明多线程环境下相关的规则和常量使用。 如果你想用一小段代码演示这个类的基本用法或通常用法，放在类注释里也非常合适。 如果类的声明和定义分开了（例如分别放在了 .h 和 .cpp 文件中），此时，描述类用法的注释应当和接口定义放在一起，描述类的操作和实现的注释应当和实现放在一起。 函数注释总述 函数声明处的注释描述函数功能; 定义处的注释描述函数实现。 说明 函数声明:基本上每个函数声明处前都应当加上注释，描述函数的功能和用途。只有在函数的功能简单而明显时才能省略这些注释（例如，简单的取值和设值函数）。注释使用叙述式（“打开文件”）而非指令式（“打开文件”）; 注释只是为了描述函数，而不是命令函数做什么。通常，注释不会描述函数如何工作。那是函数定义部分的事情。 函数声明处注释的内容： 函数的输入输出。对类成员函数而言：函数调用期间对象是否需要保持引用参数，是否会释放这些参数。函数是否分配了必须由调用者释放的空间。参数是否可以为空指针。是否存在函数使用上的性能隐患。如果函数是可重入的，其同步提提是什么？举例如下： //返回此表的迭代器。当迭代器完成时，它是客户端的责任//并且一旦创建迭代器的GargantuanTable对象被删除，它就不能使用迭代器。////迭代器最初位于表的开始位置。////此方法等同于：// Iterator * iter = table-&gt; NewIterator（）;// iter-&gt; Seek（“”）;//返回iter;//如果您要立即寻找到返回的迭代器中的其他位置，则使用NewIterator（）会更快，并避免额外的查找。Iterator * GetIterator （） const;但也要避免罗罗嗦嗦，或者对显着易见的内容进行说明。下面的注释就没有必要加上“否则返回false”，因为已经暗含其中了：//如果表不能包含更多条目，则返回true。bool IsTableFull （）;注释函数重载时，注释的重点应该是函数中被重载的部分，而不是简单的重复被重载的函数的注释。多数情况下，函数重载不需要额外的文档，因此也没有必要加上注释。 注释构造/析构函数，切记读代码的人知道构造/析构函数的所有功能，所以“销毁这一对象”这样的注释是没有意义的。你应该注意的是注意构造函数对参数做了什么（例如，是否取得指针所有权）以及析构函数清理了什么。如果都是些无关紧要的内容，直接省掉注释。析构函数前没有注释是很正常的。 函数定义 如果函数的实现过程中用到了很巧妙的方式，那么在函数定义处应当加上解释性的注释。例如，你所使用的编程技巧，实现的大致步骤，或解释如此实现的理由。举个例子，你可以说明为什么函数的前半部分要加锁而后半部分不需要。 不要 从 .h 文件或其他地方的函数声明处直接复制注释。简要重述函数功能是可以的，但注释重点要放在如何实现上。 变量注释总述 通常变量名本身足以很好说明变量用途。某些情况下，也需要额外的注释说明。 说明 类数据成员:每个类数据成员（也叫实例变量或成员变量）都应该用注释说明用途。如果有非变量的参数（例如特殊值，数据成员之间的关系，生命周期等）不能够使用类型与变量名明确表达，则应当加上注释。然而，如果变量类型与变量名已经足够描述一个变量，那么就不需要加上注释。 特别地，如果变量可以接受 NULL 或 -1 等警戒值，须加以说明。比如： private ： //用于限制检查表访问。-1意味着 //我们还不知道表中有多少个条目。 int num_total_entries_ ; 全局变量 和数据成员一样，所有全局变量也要注释说明含义及用途，以及作为全局变量的原因。比如： //在此回归测试中我们经历的测试用例的总数。 const int kNumTestCases = 6 ; 实现注释总述 对于代码中巧妙的，晦涩的，有趣的，重要的地方加以注释。 说明 代码前注释:巧妙或复杂的代码段前要加注释。比如： //将结果除以2，考虑到x //包含来自add的进位。 for （int i = 0 ; i &lt; result - &gt; size （）; i ++ ） &#123; x = （x &lt;&lt; 8 ） + （* result ）[ i ]; （* 结果）[ i ] = x &gt;&gt; 1 ; x ＆= 1 ; &#125; 行注释 比较隐晦的地方要在行尾加入注释。在行尾空两格进行注释。比如： //如果我们有足够的内存，也可以对数据部分进行mmap。 mmap_budget = max &lt; int64 &gt; （0 ， mmap_budget - index_ - &gt; length （））; if （mmap_budget &gt; = data_size_ &amp;&amp; ！MmapData （mmap_chunk_bytes ， mlock ）） return ; //错误已经记录。 注意，这里用了两段注释分别描述这段代码的作用，并提示函数返回错误已经被记入日志。 如果你需要连续进行多行注释，可以使之对齐获得更好的可读性： DoSomething （）; //在这里发表评论，以便评论排成一行。 DoSomethingElseThatIsLonger （）; //代码和注释之间有两个空格。 &#123; //允许打开一个新的作用域时，在注释之前的一个空格 // //因此注释与下面的注释和代码一起排列。 DoSomethingElse （）; //通常在行注释之前有两个空格。 &#125; std :: vector &lt; string &gt; list &#123; //支撑列表中的注释描述下一个元素... “First item” ， // ..并且应该适当地对齐。 &#125;; 函数参数注释 如果函数参数的意义不明显，考虑用下面的方式进行弥补： 如果参数是一个字面常量，并且这一常量在多处函数调用中被使用，用以推断它们一致，你应该用一个常量名让这个约定变得更明显，并且保证这一约定不会被打破。考虑更改函数的签名，让某个 bool 类型的参数变为 enum 类型，这样可以让这个参数的值表达其意义。如果某个函数有多个配置选项，你可以考虑定义一个类或结构体以保存所有的选项，并传入类或结构体的实例。这样的方法有许多优点，例如这样的选项可以在调用处用变量名引用，这样就能清晰地表明其意义。同时也减少了函数参数的数量，使得函数调用更易读也易写。除此之外，以这样的方式，如果你使用其他的选项，就无需对调用点进行更改。用具名变量代替大段而复杂的嵌套表达式。万不得已时，才考虑在调用点用注释阐明参数的意义。 不允许的行为 不要描述显而易见的现象， 永远不要 用自然语言翻译代码作为注释，除非即使对深入理解C ++的读者来说代码的行为都是不明显的。要假设读代码的人C ++水平比你高，即便他/她可能不知道你的用意. 你所提供的注释应当解释代码 为什么 要这么做和代码的目的，或者最好是让代码自文档化. 标点，拼写和语法总述 注意标点，拼写和语法; 写的好的注释比差的要易读的多。 说明 注释的通常写法是包含正确大小写和结尾句号的完整叙述性语句。大多数情况下，完整的句子比句子片段可读性更高。短一点的注释，比如代码行尾注释，可以随意点，但依然要注意风格的一致性。 虽然被别人指出该用分号时却用了逗号多少有些尴尬，但清晰易读的代码还是很重要的。正确的标点，拼写和语法对此会有很大帮助。 行长度总述 每一行代码字符数不超过80。 我们也认识到这条规则是有争议的，但很多已有代码都遵照这一规则，因此我们感觉一致性更重要。 优点 提倡该原则的人认为强迫他们调整编辑器窗口大小是很野蛮的行为。很多人同时并排开几个代码窗口，根本没有多余的空间拉伸窗口。大家都把窗口最大尺寸加以限定，并且80列宽是传统标准。那么为什么要改变呢？ 缺点 反对该原则的人则认为更宽的代码行更易阅读。80列的限制是上个世纪60年代的大型机的古板缺陷;现代设备具有更宽的显示屏，可以很轻松地显示更多代码。 结论 80个字符是最大值。 如果无法在不伤害易读性的条件下进行断行，那么注释行可以超过80个字符，这样可以方便复制粘贴。例如，带有命令示例或URL的行可以超过80个字符。长所有游戏的路径 #include 语句可以超出80列。 文件头保护 可以无视该原则。 函数调用总述 要么一行写完函数调用，要么在圆括号里对参数分行，要么参数另起一行且缩进四格。如果没有其它顾虑的话，尽可能精简行数，比如把多个参数适当地放在同一行里。 说明 函数调用遵循如下形式： bool retval = DoSomething （argument1 ， argument2 ， argument3 ）; 如果同一行放不下，可断为多行，后面每一行都和第一个实参对齐，左圆括号后和右圆括号前不要留空格： bool retval = DoSomething （averyveryveryverylongargument1 ， argument2 ， argument3 ）; 参数也可以放在次行，缩进四格： 如果 （...） &#123; ... ... if （...） &#123; DoSomething （ argument1 ， argument2 ， // 4空格缩进 argument3 ， argument4 ）; &#125; 把多个参数放在同一行以减少函数调用所需的行数，除非影响到可读性。有人认为把每个参数都独立成行，不仅更好读，而且方便编辑参数。 循环和开关选择语句总述 switch 语句可以使用大括号分段，以表明cases之间不是连在一起的。在单语句循环里，括号可用可不用。循环空应行业释义体育使用 {} 或 continue。 说明 switch 语句中的 case 块可以使用大括号也可以不用，取决于你的个人喜好。如果用的话，要按照下文所述的方法。 如果有不满足 case 条件的枚举值， switch 应该default 总是包含一个 匹配（如果有输入值没有case去处理，编译器将给出警告）。如果 default 应该永远执行不到，简单的加条 assert： switch （var ） &#123; case 0 ： &#123; // 2空格缩进 ... // 4空格缩进 break ; &#125; 案例 1 ： &#123; ... break ; &#125; default ： &#123; assert （false ）; &#125; &#125; 在单语句循环里，括号可用可不用： for （int i = 0 ; i &lt; kSomeNumber ; ++ i ） printf （“我爱你\\ n ” ）; for （int i = 0 ; i &lt; kSomeNumber ; ++ i ） &#123; printf （“我拿回来\\ n ” ）; &#125; 空循环体应使用 &#123;&#125; 或 continue，而不是一个简单的分号。 while （condition ） &#123; //反复循环直到条件失效。 &#125; for （int i = 0 ; i &lt; kSomeNumber ; ++ i ） &#123;&#125; //可 - 空循环体。 同时 （条件） 继续; //可 - contunue表明没有逻辑。 while （condition ）; //差 - 看起来仅仅只是while / loop的部分之一。 构造函数初始值列表*总述** 构造函数初始化列表放在同一行或按四格缩进并排多行。 说明 下面两种初始值列表方式都可以接受： //如果所有变量能放在同一行： MyClass :: MyClass （int var ） ： some_var_ （var ） &#123; DoSomething （）; &#125; //如果不能放在同一行， //必须置于冒号后，并缩进4个空格 MyClass :: MyClass （int var ） ： some_var_ （var ）， some_other_var_ （var + 1 ） &#123; DoSomething （）; &#125; //如果初始化列表需要置于多行，将每个成员放在单独的一行 //并逐行对齐 MyClass :: MyClass （int var ） ： some_var_ （var ）， // 4空格缩进 some_other_var_ （var + 1 ） &#123; //列队 DoSomething （）; &#125; //右大括号&#125;可以和左大括号&#123;放在同一行 //如果这样做合适的话 MyClass :: MyClass （int var ） ： some_var_ （var ） &#123;&#125; 结语 代码规范是项目开发非常重要的一点，作为一名合格的程序猿应该将代码规范熟记于心。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C语言","slug":"后端/C语言","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"c/c++代码规范","slug":"c-c-代码规范","permalink":"https://ysluckly.github.io/tags/c-c-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}]},{"title":"【C语言】经典小游戏-扫雷","slug":"back-end/201855223","date":"2021-05-22T05:27:47.000Z","updated":"2022-02-26T05:25:38.265Z","comments":true,"path":"2021/05/22/undefined/","link":"","permalink":"https://ysluckly.github.io/2021/05/22/undefined/","excerpt":"前言 扫雷，是一个Windows平台下一个经典的小游戏，今有兴趣玩了几把后，就利用所学二维数组的相关知识模拟实现了一个“扫雷游戏”。由于学识浅薄，界面有点简陋，尽请谅解！","text":"前言 扫雷，是一个Windows平台下一个经典的小游戏，今有兴趣玩了几把后，就利用所学二维数组的相关知识模拟实现了一个“扫雷游戏”。由于学识浅薄，界面有点简陋，尽请谅解！ 项目思路: 首先想一想扫雷游戏在Windows平台下是如何实现的。 其次通过观察游戏，我们可以想到需要用两个二维数组来实现扫雷的功能。 游戏刚开始，需要需要显示棋盘，用“*”遮盖雷的坐标，所以要有一个填充棋盘的函数。 通过rand()函数，随机生成雷的坐标，埋雷的函数。 每次扫过后，都要显示新的棋盘，显示棋盘的函数。 如果要想第一次踩不到雷的，需要把该坐标下得雷移动到其他不是雷的坐标，并且点击不是雷，还要满足一点击一片的效果。 最后需要一个函数判断是否扫雷成功。 项目展示： 是不是很有意思？当然重中之重的是： 要注意需要用二维数组来打印两个棋盘，假如我们要打印10X10的棋盘，那我们的二维数组元素也要为10X10个吗？，不能，因为我们在设计算法时需要统计坐标周围8个方位雷的个数，假如要统计边界坐标周围雷的个数，那么就会有数组越界的问题，那我们就要在10X10的边界多上一圈元素，也就要定义12X12的数组元素，这些元素我们不要打印出来，心里有数就行。 项目源码：game.h:/********************************************************************************************* * 项目名称：扫雷游戏 * * 编译环境：Vs 2013 * * 创建日期：2018.4.18 * * 项目编辑：Mr.Yao * ***********************************************************************************************/ //知识点： //1.数组 //2.函数 //3.循环 //4.扩展内容： 递归 (内存换取时间) #ifndef __GAME_H_ #define __GAME_H_ #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; #include &lt;time.h&gt; #include &lt;string.h&gt; enum opp &#123; EXIT, PLAY &#125;; #define EASY 10 #define HARD 30 #define ROW 10 #define COL 10 #define ROWS (ROW+2) #define COLS (COL+2) void InitMap(char arr[ROWS][COLS], int row,int col, char set); //创建初始化棋盘 void PrintMap(char arr[ROWS][COLS], int row, int col); //打印棋盘 void SetMy(char arr[ROWS][COLS], int row, int col, int count); //布雷 void SweepMap(char my_map[ROWS][COLS], char player_map[ROWS][COLS], int row, int cow, int sum); //扫雷 void MoveLei(char my_map[ROWS][COLS], int x, int y); //若第一次扫到雷，则移动雷的位置 void GetCount(char my_map[ROWS][COLS], char player_map[ROWS][COLS], int x, int y);//统计雷数 #endif game.c:#define _CRT_SECURE_NO_WARNINGS 1 #include &quot;game.h&quot; //初始化棋盘 void InitMap(char arr[ROWS][COLS], int row, int col, char set) &#123; memset(arr, set, col*row*sizeof(arr[0][0])); &#125; //打印棋盘 void PrintMap(char arr[ROWS][COLS], int row, int col) &#123; int i = 0; int j = 0; printf(&quot; &quot;); for (i = 1; i&lt;=row ; i++) &#123; printf(&quot;%3d&quot;, i); &#125; printf(&quot;\\n&quot;); for (i = 0; i&lt;=row; i++) &#123; printf(&quot;---&quot;); &#125; printf(&quot;\\n&quot;); for (i = 1; i &lt;= row; i++) &#123; printf(&quot;%2d|&quot;, i); for (j = 1; j &lt;= col ; j++) &#123; printf(&quot;%3c&quot;, arr[i][j]); &#125; printf(&quot;\\n&quot;); &#125; &#125; //布雷 void SetMy(char arr[ROWS][COLS], int row, int col, int sum) &#123; int count = sum; int x = 0; int y = 0; while (count) &#123; x = rand() % row + 1; y = rand() % col + 1; if (arr[x][y] == &#39;0&#39;) &#123; arr[x][y] = &#39;1&#39;; count--; &#125; &#125; &#125; //扫雷 void SweepMap(char my_map[ROWS][COLS],char player_map[ROWS][COLS], int row, int col, int sum) &#123; int x = 0; int y = 0; int count = 0; int temp = 0; int win = 0; while (win &lt; (row * col - sum)) &#123; printf(&quot;请输入你扫雷坐标:&gt;&quot;); scanf(&quot;%d%d&quot;, &amp;x, &amp;y); temp++; if (x &gt;= 1 &amp;&amp; x &lt;= row&amp;&amp;y &gt;= 1 &amp;&amp; y &lt;= col) &#123; while ((my_map[x][y] == &#39;1&#39;) &amp;&amp; (temp == 1)) &#123; //保证玩家第一次不死 MoveLei(my_map, x, y); //对周围的雷数进行遍历 GetCount(my_map, player_map, x, y); &#125; if (my_map[x][y] == &#39;1&#39;) &#123; printf(&quot;\\n恭喜你，壮烈牺牲\\n&quot;); PrintMap(my_map, ROW, COL); break; &#125; else &#123; GetCount(my_map, player_map, x, y); printf(&quot;\\n&quot;); win++; &#125; PrintMap(player_map, ROW, COL); &#125; else &#123; printf(&quot;坐标输入有误\\n&quot;); &#125; &#125; if(win == (row * col - sum)) &#123; printf(&quot;恭喜你，排完了\\n&quot;); &#125; &#125; //若输入的坐标无雷，则要遍历周围，统计雷数 //若周围无雷，则递归遍历，统计周围雷数 void GetCount(char my_map[ROWS][COLS], char player_map[ROWS][COLS], int x, int y) &#123; if ((my_map[x][y] == &#39;0&#39;)) &#123; int count = 0; if (my_map[x - 1][y - 1] == &#39;1&#39;) count++; if (my_map[x - 1][y] == &#39;1&#39;) count++; if (my_map[x - 1][y + 1] == &#39;1&#39;) count++; if (my_map[x][y - 1] == &#39;1&#39;) count++; if (my_map[x][y + 1] == &#39;1&#39;) count++; if (my_map[x + 1][y - 1] == &#39;1&#39;) count++; if (my_map[x + 1][y] == &#39;1&#39;) count++; if (my_map[x + 1][y + 1] == &#39;1&#39;) count++; player_map[x][y] = (count + &#39;0&#39;); &#125; if (player_map[x][y] == &#39;0&#39;) &#123; if (player_map[x - 1][y - 1] == &#39;*&#39;) GetCount(my_map, player_map, x - 1, y - 1); if (player_map[x - 1][y] == &#39;*&#39;) GetCount(my_map, player_map, x - 1, y); if (player_map[x - 1][y + 1] == &#39;*&#39;) GetCount(my_map, player_map, x - 1, y + 1); if (player_map[x][y - 1] == &#39;*&#39;) GetCount(my_map, player_map, x, y - 1); if (player_map[x][y + 1] == &#39;*&#39;) GetCount(my_map, player_map, x, y + 1); if (player_map[x + 1][y - 1] == &#39;*&#39;) GetCount(my_map, player_map, x + 1, y - 1); if (player_map[x + 1][y] == &#39;*&#39;) GetCount(my_map, player_map, x + 1, y); if (player_map[x + 1][y + 1] == &#39;*&#39;) GetCount(my_map, player_map, x + 1, y + 1); &#125; &#125; //为提高游戏体验，设置玩家第一次无论如何都不会被炸死 void MoveLei(char my_map[ROWS][COLS], int x, int y) &#123; int ret = 1; do &#123; my_map[x][y] = &#39;0&#39;; while (ret) &#123; x = rand() % ROW + 1; y = rand() % COL + 1; if (my_map[x][y] == &#39;0&#39;) &#123; my_map[x][y] = &#39;1&#39;; &#125; ret--; &#125; &#125; while (ret); &#125; test.c#define _CRT_SECURE_NO_WARNINGS 1 #include &quot;game.h&quot; void GotoXY(int x, int y) //设定输出位置 &#123; COORD c; c.X = x - 1; c.Y = y - 1; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), c); &#125; void meau() &#123; GotoXY(10, 5); printf(&quot;开始游戏\\n Let&#39;s Go!&quot;); Sleep(1500); system(&quot;cls&quot;); printf(&quot;**** 《扫雷》 ****\\n&quot;); printf(&quot;************************\\n&quot;); printf(&quot;******* 1.play *******\\n&quot;); printf(&quot;******* 0.exit *******\\n&quot;); printf(&quot;************************\\n&quot;); &#125; void game() &#123; int input = 0; int sum = 0; char my_map[ROWS][COLS]; char player_map[ROWS][COLS]; InitMap(my_map,ROWS,COLS,&#39;0&#39;); InitMap(player_map, ROWS, COLS, &#39;*&#39;); printf(&quot;**** 1.Easy 0.Hard *****\\n&quot;); scanf(&quot;%d&quot;, &amp;input); switch (input) &#123; case PLAY: sum = EASY; break; case EXIT: sum = HARD; break; default: printf(&quot;输入有误\\n&quot;); break; &#125; printf(&quot;\\n这个棋盘有%d个雷。\\n&quot;, sum); SetMy(my_map,ROW,COL,sum); PrintMap(player_map, ROW, COL); //PrintMap(my_map, ROW, COL); SweepMap(my_map,player_map ,ROW, COL, sum); system(&quot;pause&quot;); &#125; void test() &#123; int input = 0; do &#123; meau(); printf(&quot;请选择:&gt;&quot;); scanf(&quot;%d&quot;, &amp;input); switch (input) &#123; case PLAY: game(); break; case EXIT: break; default: printf(&quot;输出有误\\n&quot;); &#125; &#125; while (input); &#125; int main() &#123; srand((unsigned)time(NULL)); test(); system(&quot;pause&quot;); return 0; &#125; 结语 简单利用C语言做了一个小游戏，如有不正之处，欢迎双击评论！","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C语言","slug":"后端/C语言","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"扫雷","slug":"扫雷","permalink":"https://ysluckly.github.io/tags/%E6%89%AB%E9%9B%B7/"}]},{"title":"字符串左右旋转问题","slug":"back-end/20180520","date":"2021-05-20T05:27:47.000Z","updated":"2022-02-26T05:24:59.230Z","comments":true,"path":"2021/05/20/undefined/","link":"","permalink":"https://ysluckly.github.io/2021/05/20/undefined/","excerpt":"题目 实现一个函数，可以左旋字符串中的k个字符。 AABCD左旋一个字符得到ABCDA AABCD左旋两个字符得到BCDAA","text":"题目 实现一个函数，可以左旋字符串中的k个字符。 AABCD左旋一个字符得到ABCDA AABCD左旋两个字符得到BCDAA 方法一：【暴力移位法】算法思想：用移的步数作为while循环条件(每移1位完了减1)，1位1位的移动，即只需要一个空的变量来存移出去的字符，而这时变量i已经到了数组最后的空位置，此时把先前移出去的字符再补回来即可 #define _CRT_SECURE_NO_WARNINGS 1 #include &lt;stdio.h&gt; #include &lt;assert.h&gt; #include &lt;string.h&gt; void left_move(char *str, int k) &#123; assert(str); char temp = 0; int len = strlen(str); k = k%len; while (k--) &#123; char *cur = str; temp = *cur; while (*(cur + 1) != &#39;\\0&#39;) &#123; *cur = *(cur + 1); cur++; &#125; *cur = temp; &#125; &#125; int main() &#123; char arr[] = &quot;abcdef&quot;; int k = 0; scanf(&quot;%d&quot;, &amp;k); left_move(arr, k); printf(&quot;%s&quot;, arr); return 0; &#125; 方法二：【三步翻转法】算法思想：以移动的步数为界限，左边字符串整体逆置，右边字符串整体逆置，再整个字符串整体逆置，即需要调用3次整体逆置字符串函数，要注意各个逆置区间的定义 #define _CRT_SECURE_NO_WARNINGS 1 #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;assert.h&gt; void reverse(char *left, char*right)//逆序 &#123; assert(left&amp;&amp;right); while (left &lt; right) &#123; char tmp; tmp = *left; *left = *right; *right = tmp; left++, right--; &#125; &#125; void reverse_left(char *str, int k) &#123; int len = 0; assert(str); len = strlen(str); k = k%len; reverse(str, (str + k - 1));//要旋转的k个字符逆序 reverse((str + k), (str + len - 1));//之后的字符逆序 reverse(str, (str + len - 1));//所有的字符逆序 &#125; int main() &#123; int k = 0; char str[] = &quot;abcdefgh&quot;; scanf(&quot;%d&quot;, &amp;k); reverse_left(str, k); printf(&quot;%s&quot;, str); return 0; &#125; 方法三：【穷举法】算法思想：(相当于穷举法)申请一个是原来2倍+1(算上\\0)的数组空间，将原来的字符串复制一遍存在这个空间里，然后从原来的首元素加上移动的步数开始输出len个长度的字符串，完成左旋效果(先后用到strcpy strcat strncpy函数) 注意：(1)变量定义一定要放在表达式前面，否则乱报错；(2)用malloc函数申请完空间记得释放，头文件&lt;stdlib.h&gt; #define _CRT_SECURE_NO_WARNINGS 1 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; void reverse_string(char *str, int k) &#123; int len = strlen(str); char *tmp = (char*)malloc(2 * len + 1); //申请2倍的原数组空间 assert(str); strcpy(tmp, str); //把原来的字符串拷贝到这个大空间里 strcat(tmp, str); //把原来的字符串再拼接到后面(复制2遍) strncpy(str, tmp + k, len); //从要移动的位数后一位起，获取原来长度的字符串，达到左旋效果 free(tmp); &#125; int main() &#123; char arr[] = &quot;abcdef&quot;; int k = 0; scanf(&quot;%d&quot;, &amp;k); reverse_string(arr, k); printf(&quot;%s&quot;, arr); return 0; &#125; 结语考查字符串和字符数组的相关操作，注意在没有明确指定是否允许使用库函数的时候，就默认允许使用库函数，在不允许的情况下需要自定义实现这些函数（本题中只需要自定义实现strlen()、strstr()、strcat()这些函数），这样就很OK了！","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C语言","slug":"后端/C语言","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"字符串旋转","slug":"字符串旋转","permalink":"https://ysluckly.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%8B%E8%BD%AC/"}]},{"title":"浅析（命令行参数 ）&（main函数参数）","slug":"back-end/201852222-2","date":"2021-05-20T05:27:47.000Z","updated":"2022-02-26T05:25:27.570Z","comments":true,"path":"2021/05/20/undefined/","link":"","permalink":"https://ysluckly.github.io/2021/05/20/undefined/","excerpt":"前言命令行参数: ● 命令行参数是控制命令执行的一种方式。 ● 命令行参数类似于函数的参数，只是命令行参数是传送给命令的。命令执行时，内核已经将命令行参数放入命令的栈中，命令执行时则可以获取命令行参数，解析，执行。 ● 命令行参数使命令可以执行不同任务。","text":"前言命令行参数: ● 命令行参数是控制命令执行的一种方式。 ● 命令行参数类似于函数的参数，只是命令行参数是传送给命令的。命令执行时，内核已经将命令行参数放入命令的栈中，命令执行时则可以获取命令行参数，解析，执行。 ● 命令行参数使命令可以执行不同任务。 linux系统下的实现:#include &lt;stdio.h&gt; int main(int argc, char *argv[]) &#123; printf(&quot;%d\\n&quot;,argc); printf(&quot;%s\\n&quot;,argv[0]); printf(&quot;%s\\n&quot;,argv[1]); printf(&quot;%s\\n&quot;,argv[2]); &#125; 在这个例子中，我们给main函数传递两个参数：argc，argv： ● argc是int类型的，它表示的是命令行参数的个数。不许要用户传递，它会根据用户从命令行输入的参数个数，自动确定。 ● argv是char* argv[]类型的，即是指针数组类型，它的作用是存储用户从命令行传递进来的参数。它的第一个成员是程序执行的.exe文件。 ● main函数还有一个参数是envp，是一个 指针数组类型，每个元素存储指向一个环境变量的字符指针。这里不予赘述。 对于上面的例子，我们将其保存为test.c，用gcc编译生成目标文件为a.out 编译结果如下： 执行结果如下： 这里第一个输出的是argc，因为我们只输入了./a.out，所以argc为1，即只有一个命令行参数。后面输出的第一个命令行参数也是./a.out。接着程序就出错了，因为程序要说输出第二、第三参数，而后面已经没有第二个和第三个参数了，在写实际的应用时，应注意对这一部分进行容错处理。所谓容错处理就是指软件运行时，能对由非正常因素引起的运行错误给出适当的处理或信息提示，使软件运行正常结束。而这个错误也就是程序员很容易犯得段错误。 当在命令行输入./a.out、linux、nihao三个参数时，执行结果如图： 命令行参数个数为3，第一个参数./a.out、第二个参数linux、第三个参数nihao。 当输入./a.out、”linux nihao”、hehe、”hi apple”四个参数时，执行结果如图： 当输入四个参数，命令行参数个数就为4，但需要注意的是就是如果一个参数之间有空格，需要用双引号引起来，以免产生不必要的错误。 当然对于具体情况请看下图： 结语 对于main函数第二个参数argv，其数据类型可以写成三种形式：char *argv[]、char **argv、char argv[][]，当然第三个函数参数envp同理。","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C语言","slug":"后端/C语言","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"命令行参数 main函数","slug":"命令行参数-main函数","permalink":"https://ysluckly.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0-main%E5%87%BD%E6%95%B0/"}]},{"title":"Linux 基础教程","slug":"linux/quick-linux","date":"2021-05-17T14:00:42.000Z","updated":"2022-02-20T13:40:50.228Z","comments":true,"path":"2021/05/17/linux/","link":"","permalink":"https://ysluckly.github.io/2021/05/17/linux/","excerpt":"","text":"Linux介绍 Linux入门——个人感想 Google怎么用linux初入Linux Windows XP硬盘安装Ubuntu 12.04双系统图文详解 实例讲解虚拟机3种网络模式(桥接、nat、Host-only) 在线求助 man page文件,目录,权限 所有者,群组,其他人 文件的属性 Linux目录规范和含义 改变文件属性与权限 常用的文件和目录操作命令 ”十六“进制查看器 文件与目录的默认权限与隐藏权限 文件的搜寻 权限与命令间的关系帐户 Linux 的账号与群组 Linux 账号管理 账户切换磁盘和文件系统 EXT2 文件系统 磁盘的分区、格式化、挂载 磁盘检验 磁盘参数修订 另一个分区工具:GNU 的 parted&nbsp; 磁盘与目录的容量 硬链接与软链接 启动挂载 内存置换空间(swap)之建置 释放 Linux 系统预留的硬盘空间 Linux磁盘空间被未知资源耗尽 恢复Ext3下被删除的文件 使用grep恢复被删文件内容程序管理 shell下的作业管理 常用的程序管理命令 程序的运行顺序 查询进程打开的文件启动流程,grub,模块管理,系统服务 Linux 内核启动流程 Centos启动流程 内核模块管理 Boot loader: Grub入门 Boot loader: Grub进阶&nbsp; Linux 查看系统信息(实例详解)文字处理 linux grep命令详解 linux sed命令详解 linux sort,uniq,cut,wc命令详解 linux awk命令详解例行性工作 crontab实用手册rsync&nbsp; &nbsp; &nbsp;&nbsp;rysnc命令详解ftp&nbsp; &nbsp; &nbsp;&nbsp;vsftpd详解(ubuntu)ssh ssh服务器启动和客户端常用操作 scp和sftp ssh服务器公钥记录文件 ssh服务器配置 ssh客户端配置 ssh证书登录(实例详解) ssh密钥转发(Linux和Windows) SSH登录很慢问题的解决&nbsp; SecureCRT实用配置防火墙 Linxu iptables防火墙实用模板 linux平台下防火墙iptables原理 iptables用法简介 网络 ubuntu12.04 双网卡绑定 解决netstat中TIME_WAIT过多的问题svn svn在linux下的使用 免费的SVN空间vnc Linux VNC黑屏shell bash 的环境配置文件 shell 的变量 shell的重定向和管线 bash的通配符与特殊符号 shell script 入门 shell条件判断式 shell循环语法 shell function shell script 的追踪与 debug&nbsp; Linux使用Shell脚本实现ftp的自动上传下载 shell下root用户切换其他用户运行程序&nbsp;&nbsp;&nbsp;vim linux vi(vim)常用命令汇总 VIM实用配置 VIM编码设置 VIM高效率操作 vim 代码提示功能，让vim可以媲美IDE其他 Linux大文件传输 &nbsp;性能分析 Linux CPU实时监控mpstat命令详解 Linux进程内存分析pmap命令 Linux&nbsp;vmstat命令实战详解 FreeBSD vmstat详解&nbsp; linux的top命令参数详解 Linux 运行进程实时监控pidstat命令详解&nbsp; Linux free命令详解 Buffer和Cache的区别&nbsp; Linux IO实时监控iostat命令详解 Linux进程实时IO监控iotop命令详解 linux lsof命令详解&nbsp; Linux网络流量实时监控ifstat iftop命令详解 Linux netstat命令详解 Linux tcpdump命令详解 Linux流量测试工具Iperf&nbsp; 16 个 Linux 服务器监控命令&nbsp; Linux strace命令 latencytop深度了解你的Linux系统的延迟 blktrace 深度了解linux系统的IO运作 Perf系统性能调优工具介绍 调查服务器响应时间的利器 tcprstat Oprofile 系统层面的性能微调工具 SystemTap–Linux下的万能观测工具 性能调优攻略&nbsp; &nbsp;开发环境 GCC常用命令 GDB详解 GDB多进程调试 学会用core dump调试程序错误 实用make最佳实践 编程 Linux系统调用列表 Linux创建进程达到65535 Linux IO协议栈框图&nbsp; Linux IO调度器相关算法介绍&nbsp; PROC系列之---/proc/pid/stat","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"},{"name":"linux","slug":"运维/linux","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ysluckly.github.io/tags/linux/"}]},{"title":"五险一金&个税小常识","slug":"reading/wuxian","date":"2021-05-02T09:46:16.000Z","updated":"2022-02-25T15:11:59.578Z","comments":true,"path":"2021/05/02/undefined/","link":"","permalink":"https://ysluckly.github.io/2021/05/02/undefined/","excerpt":"","text":"一、“五险一金”是什么？ 身在职场的亲们，对五险一金应该并不陌生。这项重要的权益保障生活的方方面面，值得每个身在职场的劳动者关注。但你真的了解五险一金吗？ “五险”指的是养老保险、医疗保险、失业保险、工伤保险和生育保险；“一金”指的是住房公积金。 目前，我国阶段性降低养老保险单位缴费费率和失业保险费率。 1、养老保险 养老保险一般多指基本养老保险。养老保险一般要缴满15年，到退休的时候才能终生享受基本养老金。所以想拿养老金的人必须在自己退休前缴满15年。这就意味着：养老保险有工作要缴，没工作自己也应该缴。 2、医疗保险 城镇职工医疗保险由企业为员工统一办理。其中，个人账户支付门诊、急诊的医疗费用，到定点零售药店购药的费用等。现在，刷社保卡可以看病就医和购药，住院可以报销医疗费用，目前大多数地方住院出院时可以直接报销，未在医院结算的，可到社保经办机构申请报销。 3、失业保险 失业保险由单位为职工统一办理，对因失业而暂时中断生活来源的劳动者提供物质帮助，必须在街道登记才能申请使用。 4、工伤保险 工伤保险的全部费用由用人单位负担。用人单位的缴纳数额应为本单位职工工资总额乘以单位缴费费率之积。工伤职工已经评定伤残等级并经劳动能力鉴定委员会确认需要生活护理的，从工伤保险基金按月支付生活护理费。 5、生育保险 参加生育保险的女职工生育或流产后，其生育津贴和生育医疗费由生育保险基金支付，按照本企业上年度职工月平均工资计发。但如果你是男员工，你老婆没工作或者工作单位没交保险，而她生孩子的时候你交生育保险也已经超过了1年，那么你也可以报销生育保险。 6、住房公积金 住房公积金是指国家机关、国有企业、城镇集体企业、外商投资企业、城镇私营企业及其他城镇企业、事业单位、民办非企业单位、社会团体(以下统称单位)及其在职职工缴存的长期住房储金。例如：您每月公积金缴纳300元，那么公司每月也需往你的账户打300元。住房公积金不仅可以买房，还可以支付租房房租，建造、翻建、大修住房，治疗重大疾病……当然，住房公积金的具体使用问题还需咨询当地相关部门。 二、何谓“个税”？ 个人所得税（personal income tax）是调整征税机关与自然人（居民、非居民人）之间在个人所得税的征纳与管理过程中所发生的社会关系的法律规范的总称。 英国是开征个人所得税最早的国家，1799年英国开始试行差别税率征收个人所得税，到了1874年才成为英国一个固定的税种。 个人所得税的纳税义务人，既包括居民纳税义务人，也包括非居民纳税义务人。居民纳税义务人负有完全纳税的义务，必须就其来源于中国境内、境外的全部所得缴纳个人所得税；而非居民纳税义务人仅就其来源于中国境内的所得，缴纳个人所得税。 个人所得税是国家对本国公民、居住在本国境内的个人的所得和境外个人来源于本国的所得征收的一种所得税。在有些国家，个人所得税是主体税种，在财政收入中占较大比重，对经济亦有较大影响。 计算个税可以点击：个税计算器 个税专项扣除：详情 工业、交通运输业、商业 应税所得率下调！ 刚刚，北京发布调整个人独资企业和合伙企业个人所得税应税所得率的通知： 划重点： 1 应税所得率下调了吗？ 是的，京财税〔2020〕2645号，实行核定应税所得率征收方式的工业、交通运输业、商业个人独资企业和合伙企业， 应税所得率按5%标准执行。较京财税〔2010〕18号文件下调了2个百分点。 2 核定应税所得率征收的企业，如何计算应纳税所得额和应纳税额？ 3 其他已调整地区政策汇总 特别提醒！老板和会计们，2020年度经营所得个人所得税汇算清缴时间到了！还未完成申报的个体户及企业要抓紧啦！ 最新的经营所得汇算清缴大全来了！ 一、哪些人需要按照取得取得经营所得办理汇算清缴？ 二、什么时间办理？ 纳税人取得经营所得按年计算个人所得税，应在取得所得的次年3月31日前，向经营管理所在地主管税务机关办理汇算清缴。 三、应纳税额如何计算？ 1、算整体 计算个体工商户、个人独资企业、合伙企业以及个人从事其他生产经营活动的应纳税所得额。 2、算个人： 计算个人来源于个体工商户、个人独资企业、合伙企业以及个人从事其他生产经营活动的经营所得 （1）个体工商户业主、个人独资企业的投资者或个人从事其他生产经营活动的，以第一步计算的全部应纳税所得额为经营所得。不重复算！ （2）合伙企业的投资者，有约从约；没约定的平均。 3、算综合： 4、查找适用税率 5、计算应纳税额 应纳税额=应纳税所得额×适用税率-速算扣除数 四、费用扣除标准是什么？ 五、如何纳税申报？ 个体户、个独企业、合伙企业个税 十大热点问题 01 个体户要补交个税了吗？ 是的，2020年个体户缓缴经营所得个税需要在1月或第一季度申报时一并缴纳。否则滞纳金+罚款哦！ （1） 按月申报的个体工商户税款所属期在2020年4月至2020年11月的经营所得个人所得税，只申报不缴税的，税款在2021年1月申报期内与2020年12月税款一并划缴。 （2） 按季申报的个体工商户税款所属期在2020年二季度和三季度的经营所得个人所得税，只申报不缴税的，税款在2021年1月申报期内与2020年四季度税款一并划缴。 02 个体户可以不记账报税？ 税局出了新规定，2020年10月1日起，所有个体工商户自行申报纳税！个体工商户还想不记账不报？注意了，罚款可能交的比税多！ 10月1日起，定期定额征收的个体工商户也要自行申报了 在此之前，只有查账征收、定率征收的个体工商户自行申报，一些刚成立、规模小的个体工商户定期定额征收，采用简易申报，由税务机关扣缴税款来代替申报。 但是现在，定期定额征收的个体工商户也要自行申报了。 1、月销售额超过10万元（季度超过30万元）， 必须自行申报。 2、月销售额不超过10万元（季度不超过30万元），可暂不进行增值税及附加税费申报，但并不免除其申报纳税义务。（意思是，目前的管理规定暂不申报，但依然负有纳税义务，后期根据管理规定决定是否申报） 3、若定期定额个体工商户自开或代开增值税专用发票的，无论销售额是否超过以上标准，都应该自行申报纳税。 查账征收、定率征收的个体工商户仍按现行征收方式自行申报。 03 经营所得检查中的涉税风险有哪些？ 04 税局检查重点是什么？ 05 工资薪金、劳务报酬、经营所得如何区分？ 06 特许权使用费和稿酬所得如何区分？ 07 创投企业的个人合伙人分得的红利和股权转让收入，应如何缴纳个税？ 08 购买房产如何计征个税？ 09 承包承租经营如何计征个税？ 10 个体户、个独企业、合伙企业税收优惠有哪些？","categories":[{"name":"读书","slug":"读书","permalink":"https://ysluckly.github.io/categories/%E8%AF%BB%E4%B9%A6/"}],"tags":[{"name":"五险一金","slug":"五险一金","permalink":"https://ysluckly.github.io/tags/%E4%BA%94%E9%99%A9%E4%B8%80%E9%87%91/"},{"name":"个税","slug":"个税","permalink":"https://ysluckly.github.io/tags/%E4%B8%AA%E7%A8%8E/"}]},{"title":"Python3 基础学习笔记 C09","slug":"back-end/A15-Python3-basic-C09","date":"2021-01-24T15:59:10.000Z","updated":"2022-02-20T13:25:05.421Z","comments":true,"path":"2021/01/24/python3/","link":"","permalink":"https://ysluckly.github.io/2021/01/24/python3/","excerpt":"","text":"- 9.1 从文件中读取数据 - 9.1.1 读取整个文件 有一个文件，包含精确到小数点后30位的圆周率值，且在小数点后每10位处都换行： Circumference rate.txt ---------- 3.1415926535 8979323846 2643383279 以下两个程序将打开并读取这个文件，再将其内容显示到屏幕上： #file_reader.py with open(&#39;Circumference rate.txt&#39;) as file_object: contents = file_object.read() print(contents) #file_reader2.py contents = open (&#39;Circumference rate.txt&#39;) print(contents.read()) contents.close() 函数open()接受一个参数：要打开的文件的名称，Python在当前执行的文件所在的目录中查找指定的文件；关键字with在不再需要访问文件后将其关闭；也可以调用open()和close()来打开和关闭文件，如果使用这种方法，当程序存在bug时，close()语句未执行，文件将不会被关闭；方法read()将读取这个文件的全部内容，并将其作为一个长长的字符串储存在变量contents中，通过打印contents的值，就可以将这个文本文件的全部内容打印出来： 3.1415926535 8979323846 2643383279 输出结果末尾有一空行，这是因为read()到达末尾时返回一个空字符串，而将这个空字符串显示出来就是一个空行，如果要删除末尾的空行，可在print语句中使用rstrip(): #file_reader.py with open(&#39;Circumference rate.txt&#39;) as file_object: contents = file_object.read() print(contents.rstrip()) 输出结果如下： 3.1415926535 8979323846 2643383279 - 9.1.2 文件路径 相对文件路径：假定程序文件位于python_work文件夹中，程序文件操作的文本文件位于python_work文件夹的子文件夹text_files中，此时可以使用相对文件路径来打开该文本文件，相对文件路径让Python到指定的位置去查找，而该位置是相对于当前运行的程序所在目录的 在Linux和OS X中，相对路径类似于如下： with open(&#39;text_files/filename.txt&#39;) as file_object: 在Windows系统中，文件路径中使用反斜杠（\\）而不是斜杠（/）: with open(&#39;text_files\\filename.txt&#39;) as file_object: 绝对文件路径：不用关心当前运行的程序储存在什么地方，直接将文件在计算机中的准确位置告诉Python，这称为绝对文件路径，绝对路径通常比相对路径更长，因此将其储存在一个变量中，再将变量传递给open()会有所帮助 在Linux和OS X中，绝对路径类似于如下： file_path = &#39;/home/ehmatthes/other_files/text_files/filename.txt&#39; with open(file_path) as file_object: 在Windows系统中，绝对路径类似于如下： file_path = &#39;C:\\Users\\ehmatthes\\other_files\\text_files\\filename.txt&#39; with open(file_path) as file_object: - 9.1.3 逐行读取 要以每次一行的方式检查文件，可对文件对象使用for循环： #file_reader.py filename = &#39;Circumference rate.txt&#39; with open(filename) as file_object: for line in file_object: print(line) 在文件中每行的末尾都有一个看不见的换行符，而print语句也会加上一个换行符，因此每行末尾都有两个换行符：一个来自文件，一个来自print语句，输出结果如下： 3.1415926535 8979323846 2643383279 要消除这些多余的空白行，可以使用rstrip(): #file_reader.py filename = &#39;Circumference rate.txt&#39; with open(filename) as file_object: for line in file_object: print(line.rstrip()) 输出结果如下： 3.1415926535 8979323846 2643383279 - 9.1.4 创建一个包含文件各行内容的列表 使用关键字with时，open()返回的文件对象只在with代码块内可用，如果要在with代码块外访问文件的内容，可在with代码块内将文件的各行储存在一个列表当中，并在with代码块外使用该列表： #file_reader.py filename = &#39;Circumference rate.txt&#39; with open(filename) as file_object: lines = file_object.readlines() for line in lines: print(line.rstrip()) 输出结果与文件内容完全一致 - 9.1.5 使用文件的内容 创建一个字符串，它包含文件中储存的所有数字，且没有任何空格： #pi_string.py filename = &#39;Circumference rate.txt&#39; with open(filename) as file_object: lines = file_object.readlines() pi_string = &#39;&#39; for line in lines: pi_string += line.rstrip() print(pi_string) print(len(pi_string)) 打印该字符串以及其长度： 3.1415926535 8979323846 2643383279 36 由于原文件每行左边都有空格，我们可以使用strip()而不是rstrip()来删除它： #pi_string.py filename = &#39;Circumference rate.txt&#39; with open(filename) as file_object: lines = file_object.readlines() pi_string = &#39;&#39; for line in lines: pi_string += line.strip() print(pi_string) print(len(pi_string)) 输出结果如下： 3.141592653589793238462643383279 32 Python中有三个去除头尾字符、空白符的函数，它们依次为:strip：用来去除头尾字符、空白符(包括\\n、\\r、\\t、’ ‘，即：换行、回车、制表符、空格)lstrip：用来去除开头字符、空白符(包括\\n、\\r、\\t、’ ‘，即：换行、回车、制表符、空格)rstrip：用来去除结尾字符、空白符(包括\\n、\\r、\\t、’ ‘，即：换行、回车、制表符、空格)注意：这些函数都只会删除头和尾的字符，中间的不会删除。用法分别为：string.strip([chars])string.lstrip([chars])string.rstrip([chars])参数chars是可选的，当chars为空，默认删除string头尾的空白符(包括\\n、\\r、\\t、’ ‘)当chars不为空时，函数会被chars解成一个个的字符，然后将这些字符去掉它返回的是去除头尾字符(或空白符)的string副本，string本身不会发生改变 - 9.2 写入文件 将一条简单的消息储存到文件中： #write_message.py filename = &#39;programming.txt&#39; with open(filename,&#39;w&#39;) as file_object: file_object.write(&quot;I love programming!&quot;) 调用open()时提供了两个实参，第一个实参也是要打开文件的名称，第二个实参（’w’）告诉Python，我们要以写入模式打开这个文件，打开文件时，可指定读取模式（’r’）、写入模式（’w’）、附加模式（’a’）或者让我们能够读取和写入文件的模式（’r+’），如果省略模式实参，则默认以只读模式打开文件 附表：Python读写文件各种模式区别 模式 可做操作 若文件不存在 是否覆盖 r 打开一个文件用于只读 报错 - rb 以二进制格式打开一个文件用于只读 报错 - r+ 打开一个文件用于读和写 报错 是 rb+ 以二进制格式打开一个文件用于读和写 报错 是 w 打开一个文件用于只写 创建 是 wb 以二进制格式打开一个文件只用于只写 创建 是 w+ 打开一个文件用于读和写 创建 是 wb+ 以二进制格式打开一个文件用于读和写 创建 是 a 打开一个文件用于追加 创建 否，追加写 ab 以二进制格式打开一个文件用于追加 创建 否，追加写 a+ 打开一个文件用于读和写 创建 否，追加写 ab+ 以二进制格式打开一个文件用于追加 创建 否，追加写 - 9.3 使用 try-except 代码块处理异常 当我们尝试将一个数字除以0时，会发生ZeroDivisionError异常： &gt;&gt;&gt; print(5/0) Traceback (most recent call last): File &quot;&lt;pyshell#0&gt;&quot;, line 1, in &lt;module&gt; print(5/0) ZeroDivisionError: division by zero 此时我们可以编写一个try-except代码块来处理该异常： try: print(5/0) except ZeroDivisionError: print(&quot;You can&#39;t divide by zero!&quot;) 当我们运行该程序时，会出现提示： You can&#39;t divide by zero! 在try-except代码块中加入else，编写一个只执行除法运算的简单计算器： print(&quot;Give me two numbers,and I&#39;ll divide them.&quot;) print(&quot;Enter &#39;q&#39; to quit.&quot;) while True: first_number = input(&quot;\\nFirst number:&quot;) if first_number == &#39;q&#39;: break second_number = input(&quot;\\nSecond number:&quot;) if second_number == &#39;q&#39;: break try: answer = int(first_number)/int(second_number) except ZeroDivisionError: print(&quot;You can&#39;t divide by 0!&quot;) else: print(answer) 运行程序： Give me two numbers,and I&#39;ll divide them. Enter &#39;q&#39; to quit. First number:45 Second number:0 You can&#39;t divide by 0! First number:36 Second number:8 4.5 First number:q 若不加入try-except代码块，我们在输入0时，程序就会出现异常而崩溃，而try-except代码块很好的解决了这种问题，而且还起到了提示的作用，同样的，try-except代码块也可以处理其他异常，如FileNotFoundError等 - 9.4 储存数据 - 9.4.1 使用 json.dump() 和 json.load() 模块json能够将简单的Python数据结构转储到文件中，并在程序再次运行时加载该文件中的数据；编写一个储存一组数字的简短程序，再编写一个将这些数字读取到内存中的程序，第一个程序将使用 json.dump()来储存这组数据，而第二个程序将使用 json.load()。函数 json.dump()接受两个实参：要储存的数据以及可用于储存数据的文件对象： #number_writer.py import json numbers = [2,3,5,7,11,13] filename = &#39;numbers.json&#39; with open(filename,&#39;w&#39;) as f_obj: json.dump(numbers,f_obj) 先导入模块json，再创建一个数字列表， 通常用文件扩展名.json来指出文件储存的数据为JSON格式，然后以写入模式打开该文件，使用函数json.dump()将数字列表储存到文件numbers.json中，打开该文件，数据的储存格式与Python一样： [2, 3, 5, 7, 11, 13] 再编写一个程序，使用json.load()将这个列表读取到内存中： #number_reader.py import json filename = &#39;numbers.json&#39; with open(filename) as f_obj: numbers = json.load(f_obj) print(numbers) 输出结果与number_writer.py中创建的数字列表相同： [2, 3, 5, 7, 11, 13] 进阶：在同一个程序中使用 json.dump() 和 json.load()：创建文件username.json储存用户名，从该文件中获取用户名，如果这个文件不存在，就在except代码块中提示用户输入用户名，并将其储存在username.json中： #remember_me.py import json #如果以前储存了用户名，就加载它 #否则就提示用户输入用户名并储存它 filename = &#39;numbers.json&#39; try: with open(filename) as f_obj: username = json.load(f_obj) except FileNotFoundError: username = input(&quot;What&#39;s your name?&quot;) with open(filename,&#39;w&#39;) as f_obj: json.dump(username,f_obj) print(&quot;We&#39;ll remember you when you come back, &quot; + username + &quot;!&quot;) else: print(&quot;Welcome back, &quot; + username + &quot;!&quot;) 以前没有储存用户名，第一次运行程序： What&#39;s your name?TRHX We&#39;ll remember you when you come back, TRHX! 再次运行程序： Welcome back, TRHX! - 9.4.2 重构 代码能够正确运行，但可以做进一步的改进——将代码划分为一系列完成具体工作的函数，这样的过程称为重构，重构让代码更清晰、更易于理解、更容易扩展重构remember_me.py，将大部分逻辑放到一个或者多个函数中： #remember_me.py import json def greet_user(): #问候用户，并指出其名字 filename = &#39;numbers.json&#39; try: with open(filename) as f_obj: username = json.load(f_obj) except FileNotFoundError: username = input(&quot;What&#39;s your name?&quot;) with open(filename,&#39;w&#39;) as f_obj: json.dump(username,f_obj) print(&quot;We&#39;ll remember you when you come back, &quot; + username + &quot;!&quot;) else: print(&quot;Welcome back, &quot; + username + &quot;!&quot;) greet_user() 重构greet_user()，让它不执行这么多任务——将获取储存的用户名的代码移到另一个函数中： #remember_me.py import json def get_stored_username(): #如果储存了用户名，就获取它 filename = &#39;numbers.json&#39; try: with open(filename) as f_obj: username = json.load(f_obj) except FileNotFoundError: return None else: return username def greet_user(): #问候用户，并指出其名字 username = get_stored_username() if username: print(&quot;Welcome back, &quot; + username + &quot;!&quot;) else: username = input(&quot;What&#39;s your name?&quot;) filename = &#39;username.json&#39; with open(filename,&#39;w&#39;) as f_obj: json.dump(username,f_obj) print(&quot;We&#39;ll remember you when you come back, &quot; + username + &quot;!&quot;) greet_user() 将greet_user()中的另一个代码块提取出来：将没有储存用户名时提示用户输入的代码放在一个独立的函数中： #remember_me.py import json def get_stored_username(): #如果储存了用户名，就获取它 filename = &#39;numbers.json&#39; try: with open(filename) as f_obj: username = json.load(f_obj) except FileNotFoundError: return None else: return username def get_new_username(): #提示输入用户名 username = input(&quot;What&#39;s your name?&quot;) filename = &#39;username.json&#39; with open(filename,&#39;w&#39;) as f_obj: json.dump(username,f_obj) return username def greet_user(): #问候用户，并指出其名字 username = get_stored_username() if username: print(&quot;Welcome back, &quot; + username + &quot;!&quot;) else: username = get_new_username() print(&quot;We&#39;ll remember you when you come back, &quot; + username + &quot;!&quot;) greet_user() 最终版本实现了每个函数只负责单一而清晰的任务，我们在编写程序时也要像这样，要写出清晰而易于维护和扩展的代码","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Python3","slug":"后端/Python3","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Python3/"}],"tags":[{"name":"Python3","slug":"Python3","permalink":"https://ysluckly.github.io/tags/Python3/"}]},{"title":"Python3 基础学习笔记 C08","slug":"back-end/A14-Python3-basic-C08","date":"2021-01-23T15:59:10.000Z","updated":"2022-02-20T13:24:58.841Z","comments":true,"path":"2021/01/23/python3/","link":"","permalink":"https://ysluckly.github.io/2021/01/23/python3/","excerpt":"","text":"- 8.1 创建类和使用类 创建一个表示小狗的简单类Dog，根据Dog类创建的每个实例都将储存名字和年龄，赋予每条小狗蹲下（sit()）和打滚（roll_over()）的能力： class Dog(): def __init__(self,name,age): #初始化属性name和age self.name = name self.age = age def sit(self): #模拟小狗被命令时蹲下 print(self.name.title() + &quot; is now sitting.&quot;) def roll_over(self): #模拟小狗被命令时打滚 print(self.name.title() + &quot; rolled over!&quot;) 方法init()：类中的函数称为方法，本例中方法init()是一个特殊的方法，每当我们根据Dog类创建新实例时，Python都会自动运行它，在方法的名称中，开头和结尾各有两个下划线，这是一种约定，避免Python默认方法与普通方法发生名称冲突，例子中将方法init()定义成了包含三个形参：self、name和age，在这个方法的定义中，形参self必不可少，还必须位于其他形参的前面，Python调用方法init()来创建Dog实例时，将自动传入实参self，每个与类相关联的方法调用都自动传递实参self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法，我们创建Dog实例时，Python将调用Dog类的方法init()，我们将通过实参向Dog()传递名字和年龄；self会自动传递，因此我们不需要传递它，每当我们根据Dog类创建实例时，都只需要给最后两个形参（name和age）提供值；定义的两个变量都有前缀self，以self为前缀的变量都可以供类中的所有方法使用，还可以通过类的任何实例来访问这些变量。self.name = name 获取储存在形参name中的值，并将其储存到变量name中，然后该变量被关联到当前创建的实例。self.age = age 的作用与此类似，像这样可通过实例访问的变量称为属性；Dog还定义了另外两种方法：sit() 和 roll_over() ，由于这些方法不需要额外的信息，如名字和年龄，因此它们只有一个形参self 在Python 2.7中创建类时，需要在括号内包含单词object： class ClassName(object): ---snip--- - 8.2 根据类创建实例访问属性：创建一个表示特定小狗的实例： class Dog(): def __init__(self,name,age): #初始化属性name和age self.name = name self.age = age def sit(self): #模拟小狗被命令时蹲下 print(self.name.title() + &quot; is now sitting.&quot;) def roll_over(self): #模拟小狗被命令时打滚 print(self.name.title() + &quot; rolled over!&quot;) my_dog = Dog(&#39;willie&#39;,6) print(&quot;My dog&#39;s name is &quot; + my_dog.name.title() + &quot;.&quot;) print(&quot;My dog is &quot; + str(my_dog.age) + &quot; years old.&quot;) 让Python创建一条名字为’willie’，年龄为6的小狗，Python使用实参’willie’和6调用Dog类中的方法init()。方法init()创建一个表示特定小狗的示例，并使用我们提供的值来设置属性name和age；在访问实例的属性时，可使用句点表示法，比如该例子中的 my_dog.name；最终程序输出结果如下： My dog&#39;s name is Willie. My dog is 6 years old. 调用方法：根据Dog类创建实例后，就可以使用句点表示法来调用Dog类中定义的任何方法： class Dog(): def __init__(self,name,age): #初始化属性name和age self.name = name self.age = age def sit(self): #模拟小狗被命令时蹲下 print(self.name.title() + &quot; is now sitting.&quot;) def roll_over(self): #模拟小狗被命令时打滚 print(self.name.title() + &quot; rolled over!&quot;) my_dog = Dog(&#39;willie&#39;,6) my_dog.sit() my_dog.roll_over() 输出结果如下： Willie is now sitting. Willie rolled over! 创建多个实例：可按需求根据类创建任意数量的实例： class Dog(): def __init__(self,name,age): #初始化属性name和age self.name = name self.age = age def sit(self): #模拟小狗被命令时蹲下 print(self.name.title() + &quot; is now sitting.&quot;) def roll_over(self): #模拟小狗被命令时打滚 print(self.name.title() + &quot; rolled over!&quot;) my_dog = Dog(&#39;willie&#39;,6) your_dog = Dog(&#39;lucy&#39;,8) print(&quot;My dog&#39;s name is &quot; + my_dog.name.title() + &quot;.&quot;) print(&quot;My dog is &quot; + str(my_dog.age) + &quot; years old.&quot;) my_dog.sit() print(&quot;\\nYour dog&#39;s name is &quot; + your_dog.name.title() + &quot;.&quot;) print(&quot;Your dog is &quot; + str(your_dog.age) + &quot; years old.&quot;) your_dog.roll_over() 输出结果如下： My dog&#39;s name is Willie. My dog is 6 years old. Willie is now sitting. Your dog&#39;s name is Lucy. Your dog is 8 years old. Lucy rolled over! - 8.3 使用类和实例 创建一个表示汽车的类，其中储存了有关汽车的信息，还有一个汇总这些信息的方法： class Car(): def __init__(self,make,model,year): self.make = make self.model = model self.year = year def get_descriptive_name(self): long_name = str(self.year) + &#39; &#39; + self.make + &#39; &#39; +self.model return long_name.title() my_new_car = Car(&#39;audi&#39;,&#39;a9&#39;,&#39;2018&#39;) print(my_new_car.get_descriptive_name()) 输出结果如下： 2018 Audi A9 - 8.3.1 给属性指定默认值 类中的每个属性都必须有初始值，如果我们设置了默认值，就无需包含为它提供初始值的形参，下面为8.3的例子添加一个 odometer_reading 的属性，其初值是0，添加一个 odometer_reading() 方法，用于读取汽车的里程表： class Car(): def __init__(self,make,model,year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): long_name = str(self.year) + &#39; &#39; + self.make + &#39; &#39; +self.model return long_name.title() def read_odomter(self): print(&quot;This car has &quot; + str(self.odometer_reading) + &quot; miles on it.&quot;) my_new_car = Car(&#39;audi&#39;,&#39;a9&#39;,&#39;2018&#39;) print(my_new_car.get_descriptive_name()) my_new_car.read_odomter() 输出结果如下： 2018 Audi A9 This car has 0 miles on it. - 8.3.2 修改属性的值 可以以三种不同的方式修改属性的值：直接通过实例进行修改；通过方法进行设置；通过方法进行递增（增加特定的值） 直接修改属性的值：要修改属性的值，最简单的方法就是通过实例直接访问它，将8.3.1中的例子第7行代码 self.odometer_reading = 0 改为 self.odometer_reading = 66，输出结果如下： 2018 Audi A9 This car has 66 miles on it. 通过方法修改属性的值： class Car(): def __init__(self,make,model,year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): long_name = str(self.year) + &#39; &#39; + self.make + &#39; &#39; +self.model return long_name.title() def read_odomter(self): print(&quot;This car has &quot; + str(self.odometer_reading) + &quot; miles on it.&quot;) def update_odometer(self,mileage): self.odometer_reading = mileage my_new_car = Car(&#39;audi&#39;,&#39;a9&#39;,&#39;2018&#39;) print(my_new_car.get_descriptive_name()) my_new_car.update_odometer(66) my_new_car.read_odomter() 对Car类所做的唯一修改就是在第17、18行添加了方法 update_odometer()，这个方法接受一个里程值，并将其储存到 self.odometer_reading 中，在倒数第二行，调用了 update_odometer()，并向它提供了一个实参（该实参对应于方法定义中的形参mileage），它将里程数设置为66，而方法 read_odomter() 打印该读数： 2018 Audi A9 This car has 66 miles on it. 可对方法 update_odometer() 进行扩展，使其能够在修改里程表读数时做一些额外的工作，添加一些逻辑，禁止任何人将里程表读数往回调： class Car(): def __init__(self,make,model,year): self.make = make self.model = model self.year = year self.odometer_reading = 50 def get_descriptive_name(self): long_name = str(self.year) + &#39; &#39; + self.make + &#39; &#39; +self.model return long_name.title() def read_odomter(self): print(&quot;This car has &quot; + str(self.odometer_reading) + &quot; miles on it.&quot;) def update_odometer(self,mileage): if mileage &gt;= self.odometer_reading: self.odometer_reading = mileage else: print(&quot;You can&#39;t roll back an odometer!&quot;) my_new_car = Car(&#39;audi&#39;,&#39;a9&#39;,&#39;2018&#39;) print(my_new_car.get_descriptive_name()) my_new_car.update_odometer(33) my_new_car.read_odomter() 修改 self.odometer_reading 的默认值为50，当我们再次尝试修改其值为33时，由于小于原来的里程，因此无法修改： 2018 Audi A9 You can&#39;t roll back an odometer! This car has 50 miles on it. 通过方法对属性的值进行递增：有时候需要将属性值递增到特定的量，而不是将其设置为全新的值，假设我们购买了一辆二手车，从购买到登记期间增加了100英里的里程，下面的方法让我们能够传递这个增量，并相应地增加里程表读数： class Car(): def __init__(self,make,model,year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): long_name = str(self.year) + &#39; &#39; + self.make + &#39; &#39; +self.model return long_name.title() def read_odomter(self): print(&quot;This car has &quot; + str(self.odometer_reading) + &quot; miles on it.&quot;) def update_odometer(self,mileage): if mileage &gt;= self.odometer_reading: self.odometer_reading = mileage else: print(&quot;You can&#39;t roll back an odometer!&quot;) def increment_odometer(self,miles): #将里程表读数增加指定的量 self.odometer_reading += miles my_new_car = Car(&#39;audi&#39;,&#39;a9&#39;,&#39;2018&#39;) print(my_new_car.get_descriptive_name()) my_new_car.update_odometer(6600) my_new_car.read_odomter() my_new_car.increment_odometer(100) my_new_car.read_odomter() 输出结果如下： 2018 Audi A9 This car has 6600 miles on it. This car has 6700 miles on it. - 8.4 继承 编写类时，并非总是要从空白开始，如果要编写的类是另一个现成类的特殊版本，可使用继承，一个类继承另一个类时，它自动获得另一个类的所有属性和方法；原有的类称为父类，而新类称为子类，子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法；继承的通用语法大致如下： class ClassName1(object): def __init__(self,name1,name2,name3): --snip-- class ClassName2(ClassName1): def __init__(self,name1,name2,name3): super().__init__(name1,name2,name3) --snip-- - 8.4.1 子类的方法init() class Car(): def __init__(self,make,model,year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): long_name = str(self.year) + &#39; &#39; + self.make + &#39; &#39; +self.model return long_name.title() class ElectricCar(Car): #电动车的独特之处 def __init__(self,make,model,year): #初始化父类的属性 super().__init__(make,model,year) my_new_car = ElectricCar(&#39;tesla&#39;,&#39;model s&#39;,&#39;2016&#39;) print(my_new_car.get_descriptive_name()) 创建子类时，父类必须包含在当前文件中，且位于子类前面，定义了子类 ElectricCar，定义子类时，必须在括号内指定父类名称，方法 __init__()接受创建Car实例所需信息，super() 是一个特殊的函数，帮助Python将父类和子类关联起来，让Python调用 ElectricCar 的父类的方法 __init__()，让 ElectricCar 实例包含父类的所有属性，父类也称为超类（superclass），程序输出结果如下： 2016 Tesla Model S - 8.4.2 Python 2.7 中的继承 在Python 2.7中，ElectricCar类的定义类似于下面这样： class Car(object): def __init__(self,make,model,year): --snip-- class ElectricCar(Car): def __init__(self,make,model,year): super(ElectricCar,self).__init__(make,model,year) --snip-- - 8.4.3 给子类定义属性和方法 让一个类继承另一个类后，可添加区分子类和父类所需的新属性和方法，下面添加一个电动车特有的属性（battery），以及一个描述该属性的方法： class Car(): def __init__(self,make,model,year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): long_name = str(self.year) + &#39; &#39; + self.make + &#39; &#39; +self.model return long_name.title() class ElectricCar(Car): def __init__(self,make,model,year): super().__init__(make,model,year) self.battery_size = 80 def describe_battery(self): print(&quot;This car has a &quot; + str(self.battery_size) + &quot;-KWh battery.&quot;) my_new_car = ElectricCar(&#39;tesla&#39;,&#39;model s&#39;,&#39;2016&#39;) print(my_new_car.get_descriptive_name()) my_new_car.describe_battery() 输出结果如下： 2016 Tesla Model S This car has a 80-KWh battery. - 8.4.4 重写父类的方法 要重写父类的方法，只需要在子类中定义一个与要重写的父类方法同名的方法即可，这样，Python将不会考虑这个父类的方法，而只关心在子类中定义的相应方法，假设Car类有一个名为 fill_gas_tank() 的方法，对于电动车来说毫无意义，因此可以重写它： class ElectricCar(Car): --snip-- def fill_gas_tank(self): print(&quot;This car doesn&#39;t need a gas tank!&quot;) - 8.4.5 将实例用作属性 class Car(): def __init__(self,make,model,year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): long_name = str(self.year) + &#39; &#39; + self.make + &#39; &#39; +self.model return long_name.title() class Battery(): #一次模拟电动车电瓶的简单尝试 def __init__(self,battery_size=70): #初始化电瓶的属性 self.battery_size = battery_size def describe_battery(self): #打印一条描述电瓶容量的消息 print(&quot;This car has a &quot; + str(self.battery_size) + &quot;-KWh battery.&quot;) class ElectricCar(Car): def __init__(self,make,model,year): super().__init__(make,model,year) self.battery = Battery() my_new_car = ElectricCar(&#39;tesla&#39;,&#39;model s&#39;,&#39;2016&#39;) print(my_new_car.get_descriptive_name()) my_new_car.battery.describe_battery() 输出结果如下： 2016 Tesla Model S This car has a 70-KWh battery. 看起来似乎做了多余的工作，但现在我们可以对电瓶添加更多的描述，而且不会导致 ElectricCar 类混乱不堪，下面再给Battery添加一个方法，使其能够根据电瓶容量报告汽车的续航里程： class Car(): def __init__(self,make,model,year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): long_name = str(self.year) + &#39; &#39; + self.make + &#39; &#39; +self.model return long_name.title() class Battery(): #一次模拟电动车电瓶的简单尝试 def __init__(self,battery_size=70): #初始化电瓶的属性 self.battery_size = battery_size def describe_battery(self): #打印一条描述电瓶容量的消息 print(&quot;This car has a &quot; + str(self.battery_size) + &quot;-KWh battery.&quot;) def get_range(self): #打印一条消息，指出电瓶的续航里程 if self.battery_size == 70: range = 240 elif self.battery_size == 90: range = 280 message = &quot;This car can go approximately &quot; + str(range) message += &quot; miles on a full charge.&quot; print(message) class ElectricCar(Car): def __init__(self,make,model,year): super().__init__(make,model,year) self.battery = Battery() my_new_car = ElectricCar(&#39;tesla&#39;,&#39;model s&#39;,&#39;2016&#39;) print(my_new_car.get_descriptive_name()) my_new_car.battery.describe_battery() my_new_car.battery.get_range() 输出结果如下： 2016 Tesla Model S This car has a 70-KWh battery. This car can go approximately 240 miles on a full charge. - 8.5 导入类 Python允许将类储存在模块中，然后在主程序中导入所需的模块 - 8.5.1 导入单个类 #car.py #一个用于表示汽车的类 class Car(): def __init__(self,make,model,year): #初始化描述汽车的属性 self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): #返回整洁的描述性名称 long_name = str(self.year) + &#39; &#39; + self.make + &#39; &#39; +self.model return long_name.title() def read_odomter(self): #打印一条消息，指出汽车的里程 print(&quot;This car has &quot; + str(self.odometer_reading) + &quot; miles on it.&quot;) def update_odometer(self): #将里程表读数设置为指定的值，拒绝将里程表往回拨 if mileage &gt;= self.odometer_reading: self.odometer_reading = mileage else: print(&quot;You can&#39;t roll back an odometer!&quot;) def increment_odometer(self,miles): #将里程表读数增加指定的量 self.odometer_reading += miles 创建另一个文件——my_car.py，在其中导入Car类并创建其实例： #my_car.py from car import Car my_new_car = Car(&#39;audi&#39;,&#39;a9&#39;,&#39;2018&#39;) print(my_new_car.get_descriptive_name()) my_new_car.odometer_reading = 23 my_new_car.read_odometer() import语句让Python打开模块car，并导入其中的Car类，输出结果如下： 2018 Audi A9 This car has 23 miles on it. - 8.5.2 在一个模块中储存多个类 将类Battery和ElectricCar都加入到模块car.py中： #car.py #一组用于表示燃油汽车和电动汽车的类 class Car(): def __init__(self,make,model,year): #初始化描述汽车的属性 self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): #返回整洁的描述性名称 long_name = str(self.year) + &#39; &#39; + self.make + &#39; &#39; +self.model return long_name.title() def read_odometer(self): #打印一条消息，指出汽车的里程 print(&quot;This car has &quot; + str(self.odometer_reading) + &quot; miles on it.&quot;) def update_odometer(self): #将里程表读数设置为指定的值，拒绝将里程表往回拨 if mileage &gt;= self.odometer_reading: self.odometer_reading = mileage else: print(&quot;You can&#39;t roll back an odometer!&quot;) def increment_odometer(self,miles): #将里程表读数增加指定的量 self.odometer_reading += miles class Battery(): #一次模拟电动车电瓶的简单尝试 def __init__(self,battery_size=70): #初始化电瓶的属性 self.battery_size = battery_size def describe_battery(self): #打印一条描述电瓶容量的消息 print(&quot;This car has a &quot; + str(self.battery_size) + &quot;-KWh battery.&quot;) def get_range(self): #打印一条消息，指出电瓶的续航里程 if self.battery_size == 70: range = 240 elif self.battery_size == 90: range = 280 message = &quot;This car can go approximately &quot; + str(range) message += &quot; miles on a full charge.&quot; print(message) class ElectricCar(Car): #模拟电动车的独特之处 def __init__(self,make,model,year): #初始化父类的属性，再初始化电动车特有的属性 super().__init__(make,model,year) self.battery = Battery() 新建一个my_electric_car.py的文件，导入ElectricCar类，并创建一辆电动车： #my_electric_car.py from car import ElectricCar my_tesla = ElectricCar(&#39;tesla&#39;,&#39;model s&#39;,&#39;2016&#39;) print(my_tesla.get_descriptive_name()) my_tesla.battery.describe_battery() my_tesla.battery.get_range() 输出结果如下： 2016 Tesla Model S This car has a 70-KWh battery. This car can go approximately 240 miles on a full charge. - 8.5.3 从一个模块中导入多个类 可根据需要在程序文件中导入任意数量的类，假如我们要在同一个程序中创建普通汽车和电动汽车，就需要将类Car和ElectricCar类都导入，多个类之间用逗号进行分隔： #my_car.py from car import Car,ElectricCar my_audi = Car(&#39;audi&#39;,&#39;a9&#39;,&#39;2018&#39;) print(my_audi.get_descriptive_name()) my_tesla = ElectricCar(&#39;tesla&#39;,&#39;model s&#39;,&#39;2016&#39;) print(my_tesla.get_descriptive_name()) 输出结果如下： 2018 Audi A9 2016 Tesla Model S - 8.5.4 导入整个模块 导入整个模块后，需要使用句点表示法访问需要的类： #my_car.py import car my_audi = car.Car(&#39;audi&#39;,&#39;a9&#39;,&#39;2018&#39;) print(my_audi.get_descriptive_name()) my_tesla = car.ElectricCar(&#39;tesla&#39;,&#39;model s&#39;,&#39;2016&#39;) print(my_tesla.get_descriptive_name()) 我们导入了整个car模块，需要使用语法 module_name.class_name 访问需要的类，程序输出结果与8.5.3一致： 2018 Audi A9 2016 Tesla Model S - 8.5.5 导入模块中的所有类 要导入模块中的所有类，可使用以下语法： from module_name import * 这种导入方法是不推荐的，没有明确指出你使用了模块中的哪些类，还可能引发名称方面的困惑，需要从一个模块中导入很多类时，最好导入整个模块，并使用 module_name.class_name 语法来访问类 - 8.5.6 在一个模块中导入另一个模块 有时候需要将类分散到多个模块当中，以免模块太大，或者在同一个模块中储存不相关的类，将类储存在多个模块中时，一个模块中的类可能会依赖于另一个模块中的类，这种情况下，我们可以在前一个模块中导入必要的类，以下例子中，将Car类储存在一个模块当中，并将ElectricCar和Battery类储存在另一个模块当中，将第二个模块命名为electric_car.py，并将ElectricCar和Battery类复制到这个模块中： #electric_car.py #一组可用于表示电动汽车的类 from car import Car class Battery(): #一次模拟电动车电瓶的简单尝试 def __init__(self,battery_size=70): #初始化电瓶的属性 self.battery_size = battery_size def describe_battery(self): #打印一条描述电瓶容量的消息 print(&quot;This car has a &quot; + str(self.battery_size) + &quot;-KWh battery.&quot;) def get_range(self): #打印一条消息，指出电瓶的续航里程 if self.battery_size == 70: range = 240 elif self.battery_size == 90: range = 280 message = &quot;This car can go approximately &quot; + str(range) message += &quot; miles on a full charge.&quot; print(message) class ElectricCar(Car): #模拟电动车的独特之处 def __init__(self,make,model,year): #初始化父类的属性，再初始化电动车特有的属性 super().__init__(make,model,year) self.battery = Battery() #car.py #一个可用于表示汽车的类 class Car(): def __init__(self,make,model,year): #初始化描述汽车的属性 self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): #返回整洁的描述性名称 long_name = str(self.year) + &#39; &#39; + self.make + &#39; &#39; +self.model return long_name.title() def read_odometer(self): #打印一条消息，指出汽车的里程 print(&quot;This car has &quot; + str(self.odometer_reading) + &quot; miles on it.&quot;) def update_odometer(self): #将里程表读数设置为指定的值，拒绝将里程表往回拨 if mileage &gt;= self.odometer_reading: self.odometer_reading = mileage else: print(&quot;You can&#39;t roll back an odometer!&quot;) def increment_odometer(self,miles): #将里程表读数增加指定的量 self.odometer_reading += miles 现在可以分别从每个模块中导入类： #my_car.py from car import Car from electric_car import ElectricCar my_audi = Car(&#39;audi&#39;,&#39;a9&#39;,&#39;2018&#39;) print(my_audi.get_descriptive_name()) my_tesla = ElectricCar(&#39;tesla&#39;,&#39;model s&#39;,&#39;2016&#39;) print(my_tesla.get_descriptive_name()) 输出结果如下： 2018 Audi A9 2016 Tesla Model S - 8.6 Python标准库 Python标准库是一组模块，安装的Python都包含它，我们可以使用标准库中的任何函数和类，只需要在程序的开头包含一条简单的import语句，下面以模块collections中的一个类——OrderedDict（创建字典并记录其中的键-值对的添加顺序）为例： #favorite_languages.py from collections import OrderedDict favorite_languages = OrderedDict() favorite_languages [&#39;jen&#39;] = &#39;python&#39; favorite_languages [&#39;sarah&#39;] = &#39;c&#39; favorite_languages [&#39;edward&#39;] = &#39;java&#39; favorite_languages [&#39;anly&#39;] = &#39;python&#39; for name,language in favorite_languages.items(): print(name.title() + &quot;&#39;s favorite languages is &quot; + language.title() + &quot;.&quot;) 输出结果如下： Jen&#39;s favorite languages is Python. Sarah&#39;s favorite languages is C. Edward&#39;s favorite languages is Java. Anly&#39;s favorite languages is Python.","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Python3","slug":"后端/Python3","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Python3/"}],"tags":[{"name":"Python3","slug":"Python3","permalink":"https://ysluckly.github.io/tags/Python3/"}]},{"title":"Python3 基础学习笔记 C07","slug":"back-end/A13-Python3-basic-C07","date":"2021-01-22T15:59:10.000Z","updated":"2022-02-20T13:24:53.229Z","comments":true,"path":"2021/01/22/python3/","link":"","permalink":"https://ysluckly.github.io/2021/01/22/python3/","excerpt":"","text":"- 7.1 定义函数 一个简单的函数，命名为 example()，其中，关键字 def 来告诉Python我们要定义一个函数，这就是函数定义 def example(): print(&quot;Hello world!&quot;) example() 输出结果如下： Hello world! - 7.1.1 向函数传递信息 在函数定义 def example() 的括号中添加 username，可以让函数接受我们给 username 指定的任何值，在调用函数时给 username 指定一个值，调用 example() 时，可将一个名字传递给它： def example(username): print(&quot;Hello , &quot; + username + &#39;!&#39;) example(&#39;TRHX&#39;) 输出结果如下： Hello , TRHX! - 7.1.2 实参和形参 在 7.1.1 的例子中，函数 example() 的定义中，变量 username 是一个形参——函数完成其工作所需的一项信息，在代码 example(‘TRHX’) 中，值’TRHX’是一个实参，实参是调用函数时传递给函数的信息，调用函数时，将要让函数使用的信息放在括号内。在 example(‘TRHX’) 中，将实参 ‘TRHX’ 传递给了函数 example，这个值被储存在形参 username 中 - 7.2 传递实参 鉴于函数定义中可能包含多个形参，因此函数调用中也可能包含多个实参。向函数传递实参的方式很多，可使用位置实参，这要求实参的顺序与形参的顺序相同；也可以使用关键字实参，其中每个实参都由变量和值组成；还可以使用列表和字典 - 7.2.1 位置实参 调用函数时，Python必须将函数调用中的每个实参都关联到函数定义中的一个形参。为此，最简单的方法是基于实参的顺序，这种关联方式被称为位置实参 def describe_pet(animal_type , pet_name): print(&quot;I have a &quot; + animal_type + &quot;.&quot;) print(&quot;My &quot; + animal_type + &quot;&#39;s name is &quot; + pet_name.title() + &quot;.&quot;) describe_pet(&#39;hamster&#39; , &#39;harry&#39;) 输出结果如下： I have a hamster. My hamster&#39;s name is Harry. 调用函数多次：我们可以根据需要调用函数任意次，要再描述一个宠物，只需要再次调用 describe_pet() 即可 def describe_pet(animal_type , pet_name): print(&quot;I have a &quot; + animal_type + &quot;.&quot;) print(&quot;My &quot; + animal_type + &quot;&#39;s name is &quot; + pet_name.title() + &quot;.&quot;) describe_pet(&#39;hamster&#39; , &#39;harry&#39;) describe_pet(&#39;dog&#39; , &#39;willi&#39;) 输出结果如下： I have a hamster. Myhamster&#39;s name is Harry. I have a dog. My dog&#39;s name is Willi. - 7.2.2 关键字实参 关键字实参是传递给函数的名称-值对。直接在实参中将名称和值关联起来，不用考虑函数调用中的实参顺序 def describe_pet(animal_type , pet_name): print(&quot;I have a &quot; + animal_type + &quot;.&quot;) print(&quot;My &quot; + animal_type + &quot;&#39;s name is &quot; + pet_name.title() + &quot;.&quot;) describe_pet(animal_type = &#39;hamster&#39; , pet_name = &#39;harry&#39;) describe_pet(pet_name = &#39;willi&#39; , animal_type = &#39;dog&#39; ) 输出结果如下： I have a hamster. Myhamster&#39;s name is Harry. I have a dog. My dog&#39;s name is Willi. - 7.2.3 默认值 编写函数时，可给每个形参指定默认值，在调用函数中给形参提供了实参时，Python将使用指定的实参值，否则将使用形参的默认值 def describe_pet(pet_name , animal_type = &#39;dog&#39;): print(&quot;I have a &quot; + animal_type + &quot;.&quot;) print(&quot;My &quot; + animal_type + &quot;&#39;s name is &quot; + pet_name.title() + &quot;.&quot;) describe_pet(pet_name = &#39;willi&#39;) 输出结果如下： I have a dog. My dog&#39;s name is Willi. 在这个函数定义中，修改了形参的排列顺序，由于给 animal_type 指定了默认值，无需通过实参来指定动物类型，因此在函数调用中只包含一个实参——宠物的名字，然而Python依然将这个实参视为位置实参，因此如果函数调用中只包含宠物的名字，这个实参将关联到函数定义中的第一个形参，这就是需要将 pet_name 放在形参列表开头的原因所在注意：使用默认值时，在形参列表中必须先列出没有默认值的形参，再列出有默认值的形参，这让Python依然能够准确地解读位置实参 - 7.3 返回值 函数并非总是直接显示输出，相反，它可以处理一些数据，并返回一个或一组值，函数返回的值被称为返回值，在函数中，可使用 return 语句将值返回到函数调用的代码行 - 7.3.1 返回简单值 def name(first_name , last_name): full_name = first_name + &#39; &#39; + last_name return full_name.title() student = name(&#39;jimi&#39; , &#39;hendrix&#39;) print(student) 输出结果如下： Jimi Hendrix - 7.3.2 让实参变成可选的 对 7.3.1 的例子进行改进，扩展函数 name，使其还能够处理中间名： def name(first_name , middle_name , last_name): full_name = first_name + &#39; &#39; + middle_name + &#39; &#39; + last_name return full_name.title() student = name(&#39;jimi&#39; , &#39;lee&#39; , &#39;hendrix&#39;) print(student) 输出结果如下： Jimi Lee Hendrix 然而，如果一个人没有中间名，那么在调用这个函数时就会出错，为了让中间名变成可选的，可以给实参 middle_name 指定一个默认值——空字符串，并在用户没有提供中间名时不使用这个实参，注意需要将 middle_name 移到形参列表的末尾： def name(first_name , last_name , middle_name = &#39; &#39;): if middle_name: full_name = first_name + &#39; &#39; + middle_name + &#39; &#39; + last_name else: full_name = first_name + &#39; &#39; + last_name return full_name.title() student = name(&#39;jimi&#39; , &#39;hendrix&#39;) print(student) student = name(&#39;jimi&#39; , &#39;hendrix&#39; , &#39;lee&#39; ) print(student) 输出结果如下： Jimi Hendrix Jimi Lee Hendrix - 7.3.3 返回字典 函数可返回任何类型的值，包括列表和字典等较复杂的数据结构： def name(first_name , last_name): full_name = &#123;&#39;first&#39; : first_name , &#39;last&#39; : last_name&#125; return full_name student = name(&#39;jimi&#39; , &#39;hendrix&#39;) print(student) 输出结果如下： &#123;&#39;first&#39;: &#39;jimi&#39;, &#39;last&#39;: &#39;hendrix&#39;&#125; - 7.3.4 结合使用函数和 while 循环 def name(first_name , last_name): full_name = first_name + &#39; &#39; + last_name return full_name while True: print(&quot;\\nPlease input your name:&quot;) print(&quot;(Enter &#39;exit&#39; to quit)&quot;) f_name = input(&quot;First_name:&quot;) if f_name == &#39;exit&#39;: break l_name = input(&quot;Last_name:&quot;) if l_name == &#39;exit&#39;: break student = name(f_name , l_name) print(student) print(&quot;Hello, &quot; + student.title() + &quot;!&quot;) 运行程序： Please input your name: (Enter &#39;exit&#39; to quit) First_name:jimi Last_name:hendrix jimi hendrix Hello, Jimi Hendrix! Please input your name: (Enter &#39;exit&#39; to quit) First_name:exit - 7.4 传递列表 def users(names): for name in names: message = &quot;Hello, &quot; + name.title() + &quot;!&quot; print(message) usernames = [&#39;hannah&#39; , &#39;tony&#39; , &#39;margot&#39;] users(usernames) 输出结果如下： Hello, Hannah! Hello, Tony! Hello, Margot! - 7.4.1 在函数中修改列表 将列表传递给函数后，函数就可以对其进行修改，在函数中对这个列表所做的任何修改都是永久性的#首先创造一个列表，其中包含一些要打印的设计 unprinted_designs = [&#39;iphone case&#39; , &#39;robot pendannt&#39; , &#39;dodecahedron&#39;] completed_models = [] #模拟打印每个设计，直到没有未打印的设计为止 #打印每个设计后，都将其移到列表completed_models中 while unprinted_designs: current_design = unprinted_designs.pop() #模拟根据设计制作3D打印模型的过程 print(&quot;Printing model: &quot; + current_design) completed_models.append(current_design) #显示打印好的所有模型 print(&quot;\\nThe following models have been printed: &quot;) for completed_model in completed_models: print(completed_model) 输出结果如下： Printing model: dodecahedron Printing model: robot pendannt Printing model: iphone case The following models have been printed: dodecahedron robot pendannt iphone case 编写两个函数重新组织这些代码，每一个函数都做一件具体的工作，输出结果与原程序相同： def print_models(unprinted_designs , completed_models): #模拟打印每个设计，直到没有未打印的设计为止 #打印每个设计后，都将其移到列表completed_models中 while unprinted_designs: current_design = unprinted_designs.pop() #模拟根据设计制作3D打印模型的过程 print(&quot;Printing model: &quot; + current_design) completed_models.append(current_design) def show_completed_models(completed_models): #显示打印好的所有模型 print(&quot;\\nThe following models have been printed: &quot;) for completed_model in completed_models: print(completed_model) unprinted_designs = [&#39;iphone case&#39; , &#39;robot pendannt&#39; , &#39;dodecahedron&#39;] completed_models = [] print_models(unprinted_designs , completed_models) show_completed_models(completed_models) - 7.4.2 禁止函数修改列表 有时候需要禁止函数修改列表，拿 7.4.1 的例子来说，我们打印了所有设计后，也要保留原来的未打印的设计列表，以供备案，但由于我们将所有的设计都移出了 unprinted_designs，这个列表变成了空的，原来的列表没有了，为了解决这个问题，可向函数传递列表的副本而不是原件；这样函数所做的任何修改都只影响副本，而丝毫不影响原件，要将列表的副本传递给函数，可以像下面这样做： function_name(list_name[:]) 切片表示法 [:] 创建列表的副本，在 7.4.1 的例子中如果不想清空未打印的设计列表，可像下面这样调用 print_models()： print_models(unprinted_designs[:] , completed_models) - 7.5 传递任意数量的实参 Python允许函数从调用语句中收集任意数量的实参 def make_pizza(*toppings): print(toppings) make_pizza(&#39;pepperoni&#39;) make_pizza(&#39;mushrooms&#39; , &#39;green peppers&#39; , &#39;extra cheese&#39;) 形参名 *toppings 中的星号让Python创建一个名为 toppings 的空元组，并将收到的所有值都封装到这个元组中，函数体内的print语句通过生成输出来证明Python能够处理使用一个值调用函数的情形，也能处理使用三个值来调用函数的情形，输出结果如下： (&#39;pepperoni&#39;,) (&#39;mushrooms&#39;, &#39;green peppers&#39;, &#39;extra cheese&#39;) 使用循环语句： def make_pizza(*toppings): print(&quot;\\nMaking a pizza with the followiing toppings: &quot;) for topping in toppings: print(&quot;- &quot; + topping) make_pizza(&#39;pepperoni&#39;) make_pizza(&#39;mushrooms&#39; , &#39;green peppers&#39; , &#39;extra cheese&#39;) 输出结果如下： Making a pizza with the followiing toppings: - pepperoni Making a pizza with the followiing toppings: - mushrooms - green peppers - extra cheese - 7.5.1 结合使用位置实参和任意数量实参 如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中： def make_pizza(size , *toppings): print(&quot;\\nMaking a &quot; + str(size) + &quot;-inch pizza with the followiing toppings: &quot;) for topping in toppings: print(&quot;- &quot; + topping) make_pizza(16 , &#39;pepperoni&#39;) make_pizza(18 , &#39;mushrooms&#39; , &#39;green peppers&#39; , &#39;extra cheese&#39;) 输出结果如下： Making a 16-inch pizza with the followiing toppings: - pepperoni Making a 18-inch pizza with the followiing toppings: - mushrooms - green peppers - extra cheese - 7.5.2 使用任意数量的关键字实参 有时候，需要接受任何数量的实参，但预先我们不知道传递给函数的会是什么样的信息，在这种情况下，可以将函数编写成能够接受任意数量的键-值对——调用语句提供了多少就接受多少： def build_profile(first , last , **user_info): #创建一个字典，其中包括我们知道的有关用户的一切 profile = &#123;&#125; profile[&#39;first_name&#39;] = first profile[&#39;last_name&#39;] = last for key , value in user_info.items(): profile[key] = value return profile user_profile = build_profile(&#39;albert&#39; , &#39;einstein&#39; , location = &#39;princeton&#39; , field = &#39;physics&#39;) print(user_profile) 形参 **user_info 中的两个星号让Python创建一个名为 user_info 的空字典，并将收到的所有名称-值对都封装到这个字典中，在这个函数中，可以像访问其他字典那样访问 user_info 中的名字-值对，程序运行结果如下： &#123;&#39;first_name&#39;: &#39;albert&#39;, &#39;last_name&#39;: &#39;einstein&#39;, &#39;location&#39;: &#39;princeton&#39;, &#39;field&#39;: &#39;physics&#39;&#125; - 7.6 将函数储存在模块中 更进一步，我们可以把函数储存在被称为模块的独立文件中，再将模块导入到主程序中，import 语句运行在当前运行的程序文件中使用模块中的代码 - 7.6.1 导入整个模块 要让函数是可导入的，得先创建模块，模块是扩展名为.py的文件，包含要导入到程序中的代码，下面将创建一个包含函数 make_pizza() 的模块 #pizza.py def make_pizza(size , *toppings): #概述要制作的比萨 print(&quot;\\nMaking a &quot; + str(size) + &quot;-inch pizza with the followiing toppings: &quot;) for topping in toppings: print(&quot;- &quot; + topping) 接下来，我们在 pizza.py 所在的目录中创建另一个名为 making_pizzas.py 的文件，在这个文件中导入刚刚创建的模块，在调用 make_pizza() 两次： #making_pizzas.py import pizza pizza.make_pizza(16 , &#39;pepperoni&#39;) pizza.make_pizza(18 , &#39;mushrooms&#39; , &#39;green peppers&#39; , &#39;extra cheese&#39;) Python在读取这个文件时，代码行 import pizza 让Python打开文件 pizza.py，并在幕后将其中所有函数都复制到这个程序中，在 making_pizzas.py 中，可以使用 pizza.py 中定义的所有函数，要调用被导入的模块中的函数，可指定导入的模块的名称 pizza 和函数名 make_pizza()，并使用句点分隔它们，最终运行结果与原程序相同： Making a 16-inch pizza with the followiing toppings: - pepperoni Making a 18-inch pizza with the followiing toppings: - mushrooms - green peppers - extra cheese - 7.6.2 导入特定的函数 导入模块中特定的函数，可以使用以下语法： from module_name import function_name 通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数： from module_name import function_0 , function_1 , function_2 以前面的 making_pizzas.py 为例，如果只想导入要使用的函数，代码类似于下面这样： from pizza import make_pizza make_pizza(16 , &#39;pepperoni&#39;) make_pizza(18 , &#39;mushrooms&#39; , &#39;green peppers&#39; , &#39;extra cheese&#39;) - 7.6.3 使用 as 给函数指定别名 如果要导入的函数名称可能与程序中现有的名称冲突，或者函数的名称太长，可指定简短而独一无二的别名，要给函数指定别名，需要在导入它的时候这样做，通用语法为： from module_name import function_name as fn 同样以前面的 making_pizzas.py 为例： from pizza import make_pizza as mp mp(16 , &#39;pepperoni&#39;) mp(18 , &#39;mushrooms&#39; , &#39;green peppers&#39; , &#39;extra cheese&#39;) - 7.6.4 使用 as 给模块指定别名 我们还可以给模块指定别名，通用语法为： import module_name as mn 同样以前面的 making_pizzas.py 为例： import pizza as p p.make_pizza(16 , &#39;pepperoni&#39;) p.make_pizza(18 , &#39;mushrooms&#39; , &#39;green peppers&#39; , &#39;extra cheese&#39;) - 7.6.5 导入模块中的所有函数 导入模块中所有函数的通用语法为： from module_name import * 同样以前面的 making_pizzas.py 为例： from pizza import * make_pizza(16 , &#39;pepperoni&#39;) make_pizza(18 , &#39;mushrooms&#39; , &#39;green peppers&#39; , &#39;extra cheese&#39;) import 语句中的星号让Python将模块 pizza 中的每个函数都复制到这个程序中，由于导入了每个函数，可通过名称来调用每个函数，而不需要用句点表示法，然而，如果模块中有函数的名称与项目中的名称相同，就有可能导致意想不到的结果，最佳的做法是，要么只导入我们需要使用的函数，要么导入整个模块并使用句点表示法","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Python3","slug":"后端/Python3","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Python3/"}],"tags":[{"name":"Python3","slug":"Python3","permalink":"https://ysluckly.github.io/tags/Python3/"}]},{"title":"Python3 基础学习笔记 C05","slug":"back-end/A11-Python3-basic-C05","date":"2021-01-20T15:59:10.000Z","updated":"2022-02-20T13:24:42.530Z","comments":true,"path":"2021/01/20/python3/","link":"","permalink":"https://ysluckly.github.io/2021/01/20/python3/","excerpt":"","text":"- 5.1 一个简单的字典 fruits = &#123;&#39;apple&#39; : &#39;red&#39; , &#39;number&#39; : 5&#125; print(fruits[&#39;apple&#39;]) print(fruits[&#39;number&#39;]) 输出结果如下： red 5 在Python中，字典是一系列键-值对。每个键都与一个值相关联，你可以使用键来访问与之相关联的值。与键相关联的值可以是数字、字符串、列表乃至字典。事实上，可以将任何Python对象用作字典中的值。键-值对是两个相关联的值。在指定键时，Python将返回与之相关联的值。键和值之间用冒号分隔，而键-值对之间用逗号分隔。在字典中，想储存多少个键-值对都可以 - 5.1.1 访问字典中的值 要获取与键相关联的值，可依次指定字典名和放在方括号内的键： fruits = &#123;&#39;apple&#39; : &#39;red&#39; , &#39;number&#39; : 5&#125; number_fruits = fruits[&#39;number&#39;] print(&quot;The number of apple is &quot; + str(number_fruits) + &quot;!&quot;) 输出结果如下： The number of apple is 5! - 5.1.2 添加键-值对 字典是一种动态结构，可随时在其中添加键-值对。要添加键-值对，可依次指定字典名、用方括号括起来的键和相关联的值 fruits = &#123;&#39;apple&#39; : &#39;red&#39; , &#39;number1&#39; : 5&#125; print(fruits) fruits[&#39;banana&#39;] = &#39;yellow&#39; fruits[&#39;number2&#39;] = 13 print(fruits) 输出结果如下： &#123;&#39;apple&#39;: &#39;red&#39;, &#39;number1&#39;: 5&#125; &#123;&#39;apple&#39;: &#39;red&#39;, &#39;number1&#39;: 5, &#39;banana&#39;: &#39;yellow&#39;, &#39;number2&#39;: 13&#125; 注意：键-值对的排列顺序与添加顺序不同。Python不关心键-值对的添加顺序，而只关心键和值之间的关联关系 有时候为了方便也可以先使用一对空的花括号定义一个字典，再分行添加各个键-值对： fruits = &#123;&#125; fruits[&#39;banana&#39;] = &#39;yellow&#39; fruits[&#39;number2&#39;] = 13 print(fruits) 输出结果如下： &#123;&#39;banana&#39;: &#39;yellow&#39;, &#39;number2&#39;: 13&#125; - 5.1.3 修改字典中的值 要修改字典中的值，可依次指定字典名、用方括号括起来的键以及与该键相关联的新值 fruits = &#123;&#39;color&#39; : &#39;red&#39;&#125; print(&quot;The color of the fruits is &quot; + fruits[&#39;color&#39;] + &quot;!&quot;) fruits[&#39;color&#39;] = &#39;yellow&#39; print(&quot;The color of the fruits is &quot; + fruits[&#39;color&#39;] + &quot; now!&quot;) 输出结果如下： The color of the fruits is red! The color of the fruits is yellow now! 进阶：对一个能够以不同速度移动的外星人的位置进行跟踪，为此，我们将储存该外星人的当前速度，并据此确定该外星人将向右移动多远： alien = &#123;&#39;x_position&#39;: 0, &#39;y_position&#39;: 25, &#39;speed&#39;: &#39;medium&#39;&#125; print(&quot;Original x-position: &quot; + str(alien[&#39;x_position&#39;])) #向右移动外星人，据外星人当前速度决定将其移动多远 if alien[&#39;speed&#39;] == &#39;slow&#39;: x_increment = 1 elif alien[&#39;speed&#39;] == &#39;medium&#39;: x_increment = 2 else: x_increment = 3 #新位置等于老位置加上增量 alien[&#39;x_position&#39;] = alien[&#39;x_position&#39;] + x_increment print(&quot;New x_position: &quot; + str(alien[&#39;x_position&#39;])) 输出结果如下： Original x-position: 0 New x_position: 2 - 5.1.4 删除键-值对 对于字典中不再需要的信息，可使用del语句将相应的键-值对彻底删除。使用del语句时，必须指定字典名和要删除的键 fruits = &#123;&#39;apple&#39; : &#39;red&#39; , &#39;number&#39; : 5&#125; print(fruits) del fruits[&#39;number&#39;] print(fruits) 输出结果如下： &#123;&#39;apple&#39;: &#39;red&#39;, &#39;number&#39;: 5&#125; &#123;&#39;apple&#39;: &#39;red&#39;&#125; - 5.1.5 由类似对象组成的字典 字典储存的可以是一个对象的多种信息，也可以储存众多对象的同一种信息，例如要调查很多人最喜欢的编程语言： favorite_languages = &#123; &#39;jen&#39; : &#39;python&#39; , &#39;sarah&#39; : &#39;c&#39; , &#39;edward&#39; : &#39;ruby&#39; , &#39;phil&#39; : &#39;java&#39; , &#125; print(&quot;Sarah&#39;s favorite languages is &quot; + favorite_languages[&#39;sarah&#39;].title() + &quot;!&quot;) 输出结果如下： Sarah&#39;s favorite languages is C! - 5.2 遍历字典 - 5.2.1 方法 items() 遍历所有的键-值对 使用for循环来遍历字典： name = &#123; &#39;username&#39; : &#39;efermi&#39; , &#39;first&#39; : &#39;enrico&#39; , &#39;last&#39; : &#39;fermi&#39; , &#125; for key , value in name.items(): print(&quot;\\nKey: &quot; + key) print(&quot;Value: &quot; + value) 输出结果如下： Key: username Value: efermi Key: first Value: enrico Key: last Value: fermi for语句的第二部分包含字典和方法items()，它返回一个键-值对列表。接下来，for循环依次将每个键-值对储存到指定的两个变量中 favorite_languages = &#123; &#39;jen&#39; : &#39;python&#39; , &#39;sarah&#39; : &#39;c&#39; , &#39;edward&#39; : &#39;ruby&#39; , &#39;phil&#39; : &#39;java&#39; , &#125; for name, language in favorite_languages.items(): print(name.title() + &quot;&#39;s favorite language is &quot; + language.title() + &quot;.&quot;) 输出结果如下： Jen&#39;s favorite language is Python. Sarah&#39;s favorite language is C. Edward&#39;s favorite language is Ruby. Phil&#39;s favorite language is Java. - 5.2.2 方法 keys() 遍历字典中所有的键 在不需要使用字典中的值时，方法key()很有用，下面来遍历字典favorite_languages，并将每个被调查者的名字都打印出来： favorite_languages = &#123; &#39;jen&#39; : &#39;python&#39; , &#39;sarah&#39; : &#39;c&#39; , &#39;edward&#39; : &#39;ruby&#39; , &#39;phil&#39; : &#39;java&#39; , &#125; for name in favorite_languages.keys(): print(name.title()) 输出结果如下： Jen Sarah Edward Phil 遍历字典时，会默认遍历所有的键，因此，如果将上述代码中的for name in favorite_languages.keys():替换为for name in favorite_languages:输出结果将不变进阶： favorite_languages = &#123; &#39;jen&#39; : &#39;python&#39; , &#39;sarah&#39; : &#39;c&#39; , &#39;edward&#39; : &#39;ruby&#39; , &#39;phil&#39; : &#39;java&#39; , &#125; friends = [&#39;phil&#39;, &#39;sarah&#39;] for name in favorite_languages.keys(): print(name.title()) if name in friends: print(&quot;Hi &quot; + name + &quot;, I see your favorite languages is &quot; + favorite_languages[name].title() + &quot;!&quot;) 输出结果如下： Jen Sarah Hi sarah, I see your favorite languages is C! Edward Phil Hi phil, I see your favorite languages is Java! - 5.2.3 函数 sorted() 按顺序遍历字典中的所有键 字典总是明确地记录键和值之间的关联关系，但获取字典的元素时，获取顺序是不可预测的，要以特定的顺序返回元素，一种办法是在for循环中对返回的键进行排序，为此，可以使用函数sorted()来获得按特定顺序排列的键列表的副本： favorite_languages = &#123; &#39;jen&#39; : &#39;python&#39; , &#39;sarah&#39; : &#39;c&#39; , &#39;edward&#39; : &#39;ruby&#39; , &#39;phil&#39; : &#39;java&#39; , &#125; for name in sorted(favorite_languages.keys()): print(name.title()) 输出结果如下： Edward Jen Phil Sarah - 5.2.4 方法 values() 遍历字典中的所有值 favorite_languages = &#123; &#39;jen&#39; : &#39;python&#39; , &#39;sarah&#39; : &#39;c&#39; , &#39;edward&#39; : &#39;ruby&#39; , &#39;phil&#39; : &#39;java&#39; , &#125; for languages in favorite_languages.values(): print(languages.title()) 输出结果如下： Python C Ruby Java 这种做法提取字典中所有的值，而没有考虑是否重复，为剔除重复项，可使用集合(set)，集合类似于列表，但每个元素都必须是独一无二的： favorite_languages = &#123; &#39;jen&#39; : &#39;python&#39; , &#39;sarah&#39; : &#39;c&#39; , &#39;edward&#39; : &#39;ruby&#39; , &#39;phil&#39; : &#39;python&#39; , &#125; for languages in set(favorite_languages.values()): print(languages.title()) 输出结果如下： C Python Ruby - 5.3 嵌套 有时候，需要将一系列字典储存在列表中，或将列表作为值储存在字典中，这称为嵌套。可以在列表中嵌套字典、在字典中嵌套列表甚至在字典中嵌套字典 - 5.3.1 字典列表 下面代码创建三个字典，每个字典都表示一个个学生，将这三个字典都放到一个名为students的列表当中，遍历列表将每个学生都打印出来： student_0 = &#123;&#39;name&#39; : &#39;anily&#39; , &#39;class&#39; : 2&#125; student_1 = &#123;&#39;name&#39; : &#39;nikey&#39; , &#39;class&#39; : 5&#125; student_2 = &#123;&#39;name&#39; : &#39;heyk&#39; , &#39;class&#39; : 3&#125; students = [student_0 , student_1 , student_2] for student in students: print(student) 输出结果如下： &#123;&#39;name&#39;: &#39;anily&#39;, &#39;class&#39;: 2&#125; &#123;&#39;name&#39;: &#39;nikey&#39;, &#39;class&#39;: 5&#125; &#123;&#39;name&#39;: &#39;heyk&#39;, &#39;class&#39;: 3&#125; 进阶：使用 range() 自动生成三十个外星人： #创建一个用于存储外星人的空列表 aliens = [] #创建三十个绿色的外星人 for alien_number in range(30): new_alien = &#123;&#39;color&#39; : &#39;green&#39; , &#39;points&#39; : 5 , &#39;speed&#39; : &#39;slow&#39;&#125; aliens.append(new_alien) #显示前五个外星人 for alien in aliens[:5]: print(alien) print(&quot;......&quot;) #显示创建了多少外星人 print(&quot;Total number of aliens: &quot; + str(len(aliens))) 输出结果如下： &#123;&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5, &#39;speed&#39;: &#39;slow&#39;&#125; &#123;&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5, &#39;speed&#39;: &#39;slow&#39;&#125; &#123;&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5, &#39;speed&#39;: &#39;slow&#39;&#125; &#123;&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5, &#39;speed&#39;: &#39;slow&#39;&#125; &#123;&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5, &#39;speed&#39;: &#39;slow&#39;&#125; ...... Total number of aliens: 30 在上述例子中，虽然每个外星人都具有相同特征，但在Python看来，每个外星人都是独立的，我们可以独立地修改每个外星人： aliens = [] for alien_number in range(30): new_alien = &#123;&#39;color&#39; : &#39;green&#39; , &#39;points&#39; : 5 , &#39;speed&#39; : &#39;slow&#39;&#125; aliens.append(new_alien) for alien in aliens[0:3]: if alien[&#39;color&#39;] == &#39;green&#39;: alien[&#39;color&#39;] = &#39;yellow&#39; alien[&#39;points&#39;] = 10 alien[&#39;speed&#39;] = &#39;medium&#39; for alien in aliens[:5]: print(alien) print(&quot;......&quot;) print(&quot;Total number of aliens: &quot; + str(len(aliens))) 输出结果如下： &#123;&#39;color&#39;: &#39;yellow&#39;, &#39;points&#39;: 10, &#39;speed&#39;: &#39;medium&#39;&#125; &#123;&#39;color&#39;: &#39;yellow&#39;, &#39;points&#39;: 10, &#39;speed&#39;: &#39;medium&#39;&#125; &#123;&#39;color&#39;: &#39;yellow&#39;, &#39;points&#39;: 10, &#39;speed&#39;: &#39;medium&#39;&#125; &#123;&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5, &#39;speed&#39;: &#39;slow&#39;&#125; &#123;&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5, &#39;speed&#39;: &#39;slow&#39;&#125; ...... Total number of aliens: 30 - 5.3.2 在字典中存储列表 有时候需要将列表储存在字典中，而不是将字典储存在列表中：例一： #储存所点比萨的信息 pizza = &#123; &#39;crust&#39; : &#39;thick&#39; , &#39;toppings&#39; : [&#39;mushrooms&#39; , &#39;extra chees&#39;] , &#125; #概述所点的比萨 print(&quot;You ordered a &quot; + pizza[&#39;crust&#39;] + &quot;-crust pizza&quot; + &quot;with the following toppings :&quot; ) for topping in pizza[&#39;toppings&#39;]: print(&quot;\\t&quot; + topping) 输出结果如下： You ordered a thick-crust pizzawith the following toppings : mushrooms extra chees 例二： favorite_languages = &#123; &#39;jen&#39; : [&#39;python&#39; , &#39;ruby&#39;] , &#39;sarah&#39; : [&#39;c&#39;] , &#39;edward&#39; : [&#39;go&#39; , &#39;ruby&#39;] , &#39;phil&#39; : [&#39;python&#39; , &#39;java&#39;] , &#125; for name , languages in favorite_languages.items(): print(&quot;\\n&quot; + name.title() + &quot;&#39;s favorite languages are:&quot;) for language in languages: print(&quot;\\t&quot; + language.title()) 输出结果如下： Jen&#39;s favorite languages are: Python Ruby Sarah&#39;s favorite languages are: C Edward&#39;s favorite languages are: Go Ruby Phil&#39;s favorite languages are: Python Java - 5.3.3 在字典中存储字典 users = &#123; &#39;aeinstein&#39; : &#123; &#39;first&#39; : &#39;albert&#39; , &#39;last&#39; : &#39;einstein&#39; , &#39;location&#39; : &#39;princeton&#39; , &#125; , &#39;mcurie&#39; : &#123; &#39;first&#39; : &#39;marie&#39; , &#39;last&#39; : &#39;curie&#39; , &#39;location&#39; : &#39;paris&#39; , &#125; , &#125; for username , user_info in users.items(): print(&quot;\\nUsername : &quot; + username) full_name = user_info[&#39;first&#39;] + &quot; &quot; + user_info[&#39;last&#39;] location = user_info[&#39;location&#39;] print(&quot;\\tFull name : &quot; + full_name.title()) print(&quot;\\tlocation : &quot; + location .title()) 输出结果如下： Username : aeinstein Full name : Albert Einstein location : Princeton Username : mcurie Full name : Marie Curie location : Paris","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Python3","slug":"后端/Python3","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Python3/"}],"tags":[{"name":"Python3","slug":"Python3","permalink":"https://ysluckly.github.io/tags/Python3/"}]},{"title":"Python3 基础学习笔记 C06","slug":"back-end/A12-Python3-basic-C06","date":"2021-01-20T15:59:10.000Z","updated":"2022-02-20T13:24:48.352Z","comments":true,"path":"2021/01/20/python3/","link":"","permalink":"https://ysluckly.github.io/2021/01/20/python3/","excerpt":"","text":"- 6.1 函数 input() 的工作原理 函数 input() 让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其储存在一个变量当中，以方便你使用；函数 input() 返回为 string 类型 message = input(&quot;Please tell me your name:&quot;) print(&quot;Hello , &quot; + message + &quot;!&quot;) 输出结果如下： Please tell me your name:anliy Hello , anliy! 进阶： message = &quot;Please tell me your name so that we can personalize the messages you see.&quot; message += &quot;\\nWhat&#39;s your first name?&quot; name = input(message) print(&quot;\\nHello , &quot; + name + &quot;!&quot;) 输出结果如下： Please tell me your name so that we can personalize the messages you see. What&#39;s your first name?trhx Hello , trhx! - 6.1.1 使用 int() 来获取数值输入 使用函数 input() 时，Python会将用户输入解读为字符串： &gt;&gt;&gt; age = input(&quot;How old are you?&quot;) How old are you?19 &gt;&gt;&gt; age &#39;19&#39; 为了解决这个问题，可以使用函数 int() ，它让Python将输入视为数值： &gt;&gt;&gt; age = input(&quot;How old are you?&quot;) How old are you?19 &gt;&gt;&gt; age = int(age) &gt;&gt;&gt; age 19 实例： age = input(&quot;Please tell me your age:&quot;) age = int(age) if age &gt;= 18: print(&quot;You are old enough to go to the Internet bar!&quot;) else: print(&quot;You are not old enough to go to Internet bar!&quot;) 输出结果如下： Please tell me your age:17 You are not old enough to go to Internet bar! - 6.1.2 求模运算符 处理数值信息时，求模运算符（%）是一个很有用的工具，它将两个数相除并返回余数： &gt;&gt;&gt; 4 % 3 1 &gt;&gt;&gt; 5 % 3 2 &gt;&gt;&gt; 8 % 2 0 &gt;&gt;&gt; 7 % 3 1 - 6.1.3 在 Python 2.7 中获取输入 如果使用 Python 2.7，应该使用函数 raw_input() 来提示用户输入，这个函数与 Python 3 中的 input() 一样，也将输入解读为字符串；Python 2.7 也包含函数 input()，但它将用户输入解读为Python代码，并尝试运行它们 - 6.2 while 循环 for 循环用于针对集合中的每一个元素的一个代码块，而 while 循环不断地运行，直到指定的条件不满足为止 - 6.2.1 使用 while 循环 一个简单的 while 循环： num = 1 while num &lt; 5: print(num) num += 1 输出结果如下： 1 2 3 4 - 6.2.2 让用户选择退出循环 prompt = &quot;\\nTell me something, and I will repeat it back to you:&quot; prompt += &quot;\\nEnter &#39;quit&#39; to end the program.&quot; message = &quot; &quot; while message != &#39;quit&#39;: message = input(prompt) print(message) 运行程序： Tell me something, and I will repeat it back to you: Enter &#39;quit&#39; to end the program.Hello everyone! Hello everyone! Tell me something, and I will repeat it back to you: Enter &#39;quit&#39; to end the program.Hello again! Hello again! Tell me something, and I will repeat it back to you: Enter &#39;quit&#39; to end the program.quit quit - 6.2.3 使用标志 在要求很多条件都满足才继续运行的程序中，可以定义一个变量，用于判断整个程序是否处于活动状态，这个变量称为标志 prompt = &quot;\\nTell me something, and I will repeat it back to you:&quot; prompt += &quot;\\nEnter &#39;quit&#39; to end the program.&quot; active = True while active: message = input(prompt) if message == &#39;quit&#39;: active = False else: print(message) 运行结果与6.2.2一致 - 6.2.4 使用 break 退出循环 要立即退出 while 循环，不再运行循环中余下的代码，也不管条件测试的结果如何，可使用 break 语句，break 语句用于控制程序流程，可使用它来控制哪些代码将执行，哪些代码不执行 prompt = &quot;\\nPlease enter the name of a city you have visited:&quot; prompt += &quot;\\nEnter &#39;quit&#39; when you are finished.&quot; active = True while active: city = input(prompt) if city == &#39;quit&#39;: break else: print(&quot;I&#39;d love to go to &quot; + city.title() + &quot;!&quot;) 运行程序： Please enter the name of a city you have visited: Enter &#39;quit&#39; when you are finished.Shanghai I&#39;d love to go to Shanghai! Please enter the name of a city you have visited: Enter &#39;quit&#39; when you are finished.Beijing I&#39;d love to go to Beijing! Please enter the name of a city you have visited: Enter &#39;quit&#39; when you are finished.quit 在任何Python循环中都可以使用break语句，例如，可以使用break语句来退出遍历列表或字典 - 6.2.5 在循环中使用 continue 要返回到循环开头，并根据条件测试结果决定是否继续执行循环，可使用 continue 语句，它不像 break 语句那样不再执行余下的代码并退出整个循环，例如，从1到10只打印其中奇数： number =0 while number &lt; 10: number += 1 if number % 2 == 0: continue print(number) 输出结果如下： 1 3 5 7 9 - 6.3 使用 while 循环来处理列表和字典 for循环是一种遍历列表的有效方式，但在for循环中不应修改列表，否则将导致Python难以跟踪其中的元素，要在遍历列表的同时对其进行修改，可使用while循环 - 6.3.1 在列表之间移动元素 unconfirmed_users = [&#39;alice&#39; , &#39;brian&#39; , &#39;candace&#39;] confirmed_users = [] while unconfirmed_users: current_user = unconfirmed_users.pop() print(&quot;Verifying user: &quot; + current_user.title()) confirmed_users.append(current_user) print(&quot;\\nThe following users have been confirmed:&quot;) for confirmed_user in confirmed_users: print(confirmed_user.title()) 首先创建一个未验证用户列表，其中包含用户Alice、Brian和Candace，还创建了一个空列表，用于存储已验证的用户，程序中的 while 循环将不断地运行，直到列表 unconfirmed_users 变成空的。在这个循环中，函数pop() 以每次一个的方式从列表 unconfirmed_users 末尾删除未验证的用户。由于Candace位于列表 unconfirmed_users 的末尾，因此其名字将首先被删除、存储到变量 current_user 中并加入到列表 confirmed_users 中。接下来是Brian，然后是Alice 为模拟用户验证过程，我们打印一条验证消息并将用户加入到已验证用户列表中。未验证用户列表越来越短，而已验证用户列表越来越长。未验证用户列表为空后结束循环，再打印已验证用户列表： Verifying user: Candace Verifying user: Brian Verifying user: Alice The following users have been confirmed: Candace Brian Alice - 6.3.2 删除包含特定值的所有列表元素 可以使用方法 remove() 来删除列表中特定的值，但如果要删除的值在列表中出现了多次，方法 remove() 就不管用了，如果要删除列表中所有包含特定值的元素则可以使用 while 循环： names = [&#39;alice&#39; , &#39;candace&#39; , &#39;alice&#39; , &#39;brian&#39; , &#39;alix&#39; , &#39;candace&#39; , &#39;heliy&#39;] print(names) while &#39;candace&#39; in names: names.remove(&#39;candace&#39;) print(names) 输出结果如下： [&#39;alice&#39;, &#39;candace&#39;, &#39;alice&#39;, &#39;brian&#39;, &#39;alix&#39;, &#39;candace&#39;, &#39;heliy&#39;] [&#39;alice&#39;, &#39;alice&#39;, &#39;brian&#39;, &#39;alix&#39;, &#39;heliy&#39;] 使用方法 remove() 做对比： names = [&#39;alice&#39; , &#39;candace&#39; , &#39;alice&#39; , &#39;brian&#39; , &#39;alix&#39; , &#39;candace&#39; , &#39;heliy&#39;] print(names) names.remove(&#39;candace&#39;) print(names) 输出结果如下： [&#39;alice&#39;, &#39;candace&#39;, &#39;alice&#39;, &#39;brian&#39;, &#39;alix&#39;, &#39;candace&#39;, &#39;heliy&#39;] [&#39;alice&#39;, &#39;alice&#39;, &#39;brian&#39;, &#39;alix&#39;, &#39;candace&#39;, &#39;heliy&#39;] - 6.3.3 使用用户输入来填充字典 responses = &#123;&#125; #设置一个标志，指出调查是否继续 polling_active = True while polling_active: #提示输入被调查者的姓名和回答 name = input(&quot;\\nWhat&#39;s your name?&quot;) response = input(&quot;What kind of fruit do you like?&quot;) #将答卷储存在字典中 responses[name] = response #询问是否还有其他人要参与回答 repeat = input(&quot;Would you like to let another person respond?(Yes/No)&quot;) if repeat == &#39;No&#39;: polling_active = False #调查结束，显示结果 print(&quot;\\n------ Poll Results ------&quot;) for name , response in responses.items(): print(name + &quot; like &quot; + response + &quot;.&quot;) 运行程序： What&#39;s your name?TRHX What kind of fruit do you like?apple Would you like to let another person respond?(Yes/No)Yes What&#39;s your name?TRHXCC What kind of fruit do you like?banana Would you like to let another person respond?(Yes/No)No ------ Poll Results ------ TRHX like apple. TRHXCC like banana.","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Python3","slug":"后端/Python3","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Python3/"}],"tags":[{"name":"Python3","slug":"Python3","permalink":"https://ysluckly.github.io/tags/Python3/"}]},{"title":"Python3 基础学习笔记 C04","slug":"back-end/A10-Python3-basic-C04","date":"2021-01-19T15:59:10.000Z","updated":"2022-02-20T13:24:37.443Z","comments":true,"path":"2021/01/19/python3/","link":"","permalink":"https://ysluckly.github.io/2021/01/19/python3/","excerpt":"","text":"- 4.1 一个简单的数列 给定一个汽车列表，将其中每一辆汽车的名称打印出来，要求打印 ‘bmw’ 时所有字母都要大写，其余名称只需要首字母大写： cars = [&#39;audi&#39; , &#39;bmw&#39; , &#39;subaru&#39; , &#39;toyota&#39;] for car in cars: if car == &#39;bmw&#39;: print(car.upper()) else: print(car.title()) 输出结果如下： Audi BMW Subaru Toyota - 4.1.1 检查特定值是否包含在列表当中 要判断特定的值是否已包含在列表当中，可使用关键字 in user_names = [&#39;andia&#39; , &#39;david&#39; , &#39;liwa&#39;] user = &#39;andia&#39; if user in user_names: print(user.title() + &quot;is in user_name.&quot;) 输出结果如下： Andiais in user_name. 要判断特定的值是否不包含在列表当中，可使用关键字 not in user_names = [&#39;andia&#39; , &#39;david&#39; , &#39;liwa&#39;] user = &#39;kivle&#39; if user not in user_names: print(user.title() + &quot;is not in user_name.&quot;) 输出结果如下： Kivleis not in user_name. - 4.2 if-else 语句 age = input(&quot;请输入你的年龄查看是否可以去网吧：&quot;) if int(age) &gt;= 18: print(&quot;You are old enough to go to the net bar!&quot;) print(&quot;You should go to net bar less,study more!&quot;) else: print(&quot;You are too young to go to the net bar!&quot;) print(&quot;Wait until you are 18 to go to the net bar!&quot;) 分别输入19和15，输出结果如下： 请输入你的年龄查看是否可以去网吧：19 You are old enough to go to the net bar! You should go to net bar less,study more! 请输入你的年龄查看是否可以去网吧：15 You are too young to go to the net bar! Wait until you are 18 to go to the net bar! - 4.3 if-elif-else 结构 age = 12 if age &lt; 4: price = 0 elif age &lt; 18: price = 5 else: price = 10 print(&quot;Your admission cost is $&quot; + str(price) + &quot;.&quot;) 输出结果如下： Your admission cost is $5. - 4.3.1 使用多个 elif 代码块 age = 20 if age &lt; 4: price = 0 elif age &lt; 18: price = 5 elif age &lt; 65: price = 15 else: price = 10 print(&quot;Your admission cost is $&quot; + str(price) + &quot;.&quot;) 输出结果如下： Your admission cost is $15. - 4.3.2 省略 else 代码块 Python并不要求 if-elif 结构后面必须有 else 代码块： age = 20 if age &lt; 4: price = 0 elif age &lt; 18: price = 5 elif age &lt; 65: price = 15 elif age &gt;= 65: price = 10 print(&quot;Your admission cost is $&quot; + str(price) + &quot;.&quot;) 输出结果仍与3.3.1一样 - 4.4 测试多个条件 if-elif-else结构功能强大，但仅适用于只有一个条件满足的情况：遇到通过了的测试后，Python就会跳过余下的测试： names = [&#39;Zhangshan&#39; , &#39;Wanger&#39;] if &#39;Zhangshan&#39; in names: print(&quot;Zhangshan is here!&quot;) if &#39;Wanger&#39; in names: print(&quot;Wanger is here!&quot;) if &#39;Xiaoming&#39; in names: print(&quot;Xiaoming is here!&quot;) print(&quot;All the students are here!&quot;) 输出结果如下： Zhangshan is here! Wanger is here! All the students are here! 相同的程序，如果使用 if-elif-else 结构，代码将不能正确运行： names = [&#39;Zhangshan&#39; , &#39;Wanger&#39;] if &#39;Zhangshan&#39; in names: print(&quot;Zhangshan is here!&quot;) elif &#39;Wanger&#39; in names: print(&quot;Wanger is here!&quot;) elif &#39;Xiaoming&#39; in names: print(&quot;Xiaoming is here!&quot;) print(&quot;All the students are here!&quot;) 输出结果如下： Zhangshan is here! All the students are here! 总之，如果我们只想执行一个代码块，就使用 if-elif-else 结构；如果要运行多个代码块，就必须使用一系列独立的 if 语句！ - 4.5 使用 if 语句处理列表 - 4.5.1 检查特殊元素对3.4例子改版，加入姓名 ‘Xiaoming’，当检索到Xiaoming时告诉他，他妈妈叫他回家吃饭 names = [&#39;Zhangshan&#39; , &#39;Wanger&#39; , &#39;Xiaoming&#39;] for name in names: if name == &#39;Xiaoming&#39;: print(&quot;Xiaoming,Your mother told you to go home for dinner!&quot;) else: print(name +&quot;is here!&quot;) print(&quot;All the students are here!&quot;) 输出结果如下： Zhangshanis here! Wangeris here! Xiaoming,Your mother told you to go home for dinner! All the students are here! - 4.5.2 确定列表不是空的 在检索姓名前检查姓名是否为空，不为空则打印出所有姓名，为空则提示没有姓名： names = [] if names: for name in names: print(name +&quot; is here!&quot;) print(&quot;All the students are here!&quot;) else: print(&quot;There is no students!&quot;) 输出结果如下： There is no students! 在if语句中将列表名用在条件表达式中时，Python将在列表至少包含一个元素时返回Ture，并在列表为空时返回False - 4.5.3 使用多个列表 两个列表names_1和names_2，要求输出既在names_2中又在names_1中的元素： names_1 = [&#39;Zhangshan&#39; , &#39;Liyang&#39; , &#39;Wanger&#39; , &#39;Tangyang&#39; , &#39;Xiaoming&#39;] names_2 = [&#39;Liyang&#39; , &#39;Zhangwei&#39; , &#39;Tangyang&#39;] for names in names_2: if names in names_1: print(names +&quot; is here!&quot;) print(&quot;All the students are here!&quot;) 输出结果如下： Liyang is here! Tangyang is here! All the students are here!","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Python3","slug":"后端/Python3","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Python3/"}],"tags":[{"name":"Python3","slug":"Python3","permalink":"https://ysluckly.github.io/tags/Python3/"}]},{"title":"Python3 基础学习笔记 C03","slug":"back-end/A09-Python3-basic-C03","date":"2021-01-18T15:59:10.000Z","updated":"2022-02-20T13:24:28.955Z","comments":true,"path":"2021/01/18/python3/","link":"","permalink":"https://ysluckly.github.io/2021/01/18/python3/","excerpt":"","text":"- 3.1遍历整个列表 使用 for 循环来遍历整个列表： names = [&#39;alice&#39; , &#39;david&#39; , &#39;liwei&#39;] for name in names: print(name) 输出结果如下： alice david liwei for循环让Python从列表names中取出一个名字，并将其储存在变量name中，最后 让Python打印前面储存到变量name中的名字，对于列表中的每个名字，Python都将 重复执行后两行代码，将列表names中的每个名字都打印出来 - 3.1.1在for循环中执行更多的操作 在for循环中，可对每个元素执行任何操作，下面对前面的示例进行扩展： 例一： names = [&#39;alice&#39; , &#39;david&#39; , &#39;liwei&#39;] for name in names: print(name.title() + &quot;, that was a good man!&quot;) 输出结果如下： Alice, that was a good man! David, that was a good man! Liwei, that was a good man! 例二： names = [&#39;alice&#39; , &#39;david&#39; , &#39;liwei&#39;] for name in names: print(name.title() + &quot;, that was a good man!&quot;) print(&quot;I can&#39;t wait to see you again,&quot; + name.title() + &quot;.\\n&quot;) print(&quot;Nice to meet you!&quot;) 输出结果如下： Alice, that was a good man! I can&#39;t wait to see you again,Alice. David, that was a good man! I can&#39;t wait to see you again,David. Liwei, that was a good man! I can&#39;t wait to see you again,Liwei. Nice to meet you! - 3.2 range()函数 Python使用range()函数能够轻松地生成一系列的数字 Python3 range() 函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表； Python3 list() 函数是对象迭代器，可以把range()返回的可迭代对象转为一个列表，返回的变量类型为列表； Python2 range() 函数返回的是列表 例一： for i in range(1,5): print(i) 输出结果如下： 1 2 3 4 例二： for i in range(5): print(i) 输出结果如下： 0 1 2 3 4 例三： &gt;&gt;&gt; list(range(5)) [0, 1, 2, 3, 4] &gt;&gt;&gt; list(range(0)) [] &gt;&gt;&gt;list(range(0, 30, 5)) [0, 5, 10, 15, 20, 25] &gt;&gt;&gt; list(range(0, 10, 2)) [0, 2, 4, 6, 8] &gt;&gt;&gt; list(range(0, -10, -1)) [0, -1, -2, -3, -4, -5, -6, -7, -8, -9] &gt;&gt;&gt; list(range(1, 0)) [] 例四： squares = [] for value in range(1,11): square = value ** 2 squares.append(square) print(squares) 输出结果如下： [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] - 3.2.1 对数字列表执行简单的统计计算 &gt;&gt;&gt; digits = [1, 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0] &gt;&gt;&gt; min(digits) 0 &gt;&gt;&gt;max(digits) 9 &gt;&gt;&gt;sum(digits) 45 - 3.2.2 列表解析 列表解析能够让比如3.2中的例四更加简化，只需要一行代码就能生成这样的列表，列表解析将for循环和创建新元素的代码合并成一行，并自动附加新元素： squares = [value ** 2 for value in range(1,11)] print(squares) 在这个示例中，for循环为for value in range(1,11)，它将值1~10提供给表达式value ** 2输出结果如下： [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] - 3.3 使用列表的一部分 处理列表的部分元素——Python称之为切片 - 3.3.1 切片 list = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;] print(list[:]) #省略全部，代表截取全部内容，可以用来将一个列表拷给另一个列表 print(list[:3]) #省略起始位置的索引，默认起始位置从头开始，结束位置索引为2 print(list[3:]) #省略结束位置的索引，默认结束位置为最后一个，开始位置索引为3 print(list[1:4]) #开始位置索引为1，结束位置索引为3，顾头不顾尾 print(list[4:1]) #从左到右索引，因此为空值 print(list[-1:-3]) #从左到右索引，因此为空值 print(list[-3:-1]) #开始位置索引为倒数第三个，结束位置索引为倒数第二个 print(list[1:5:2]) #开始位置索引为1，结束位置索引为4，间隔2 print(list[5:1:-1]) #反向取值，开始位置索引为5，结束位置索引为2 print(list[::-1]) #反向取值，反向输出列表 - 3.3.2 遍历列表 players = [&#39;charles&#39; , &#39;martina&#39; , &#39;michael&#39; , &#39;florence&#39; , &#39;eli&#39;] print(&quot;Here are the first three players on my team:&quot;) for player in players[:3]: print(player.title()) 输出结果如下： Here are the first three players on my team: Charles Martina Michael - 3.3.3 复制列表 要复制列表，可以创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引（[:]），这让Python创建一个始于第一个元素，终止于最后一个元素的切片，即复制整个列表： my_foods = [&#39;pizza&#39; , &#39;falafel&#39; , &#39;carrot cake&#39;] friend_foods = my_foods[:] print(&quot;My favorite foods are:&quot;) print(my_foods) print(&quot;\\nMy friend&#39;s favorite foods are:&quot;) print(friend_foods) 输出结果如下： My favorite foods are: [&#39;pizza&#39;, &#39;falafel&#39;, &#39;carrot cake&#39;] My friend&#39;s favorite foods are: [&#39;pizza&#39;, &#39;falafel&#39;, &#39;carrot cake&#39;] 为核实我们的确有两个列表，下面在每个列表中都添加一种食品，并核实每个列表都记录了相应人员喜欢的食品： my_foods = [&#39;pizza&#39; , &#39;falafel&#39; , &#39;carrot cake&#39;] friend_foods = my_foods[:] my_foods.append(&#39;cannoli&#39;) friend_foods.append(&#39;ice cream&#39;) print(&quot;My favorite foods are:&quot;) print(my_foods) print(&quot;\\nMy friend&#39;s favorite foods are:&quot;) print(friend_foods) 输出结果如下： My favorite foods are: [&#39;pizza&#39;, &#39;falafel&#39;, &#39;carrot cake&#39;, &#39;cannoli&#39;] My friend&#39;s favorite foods are: [&#39;pizza&#39;, &#39;falafel&#39;, &#39;carrot cake&#39;, &#39;ice cream&#39;] 输出结果表明，’cannoli’包含在我喜欢的食品列表中，而’ice cream’没有；’ice cream’包含在我朋友喜欢的食品中，而’cannoli’没有，假如我们只是简单的将my_foods赋给friend_foods，就不能得到两个列表。下面是错误示例： my_foods = [&#39;pizza&#39; , &#39;falafel&#39; , &#39;carrot cake&#39;] friend_foods = my_foods #错误写法 my_foods.append(&#39;cannoli&#39;) friend_foods.append(&#39;ice cream&#39;) print(&quot;My favorite foods are:&quot;) print(my_foods) print(&quot;\\nMy friend&#39;s favorite foods are:&quot;) print(friend_foods) 错误示例输出结果如下： My favorite foods are: [&#39;pizza&#39;, &#39;falafel&#39;, &#39;carrot cake&#39;, &#39;cannoli&#39;, &#39;ice cream&#39;] My friend&#39;s favorite foods are: [&#39;pizza&#39;, &#39;falafel&#39;, &#39;carrot cake&#39;, &#39;cannoli&#39;, &#39;ice cream&#39;] - 3.4 元组 Python将不能修改的值称为不可变的，而不可变的列表被称为元组 - 3.4.1 定义元组 元组看起来就像是列表，但元组使用圆括号而不是方括号来标识，定义元组后，就可以使用索引来访问其元素，就像访问列表元素一样： dimensions = (200,50) print(dimensions[0]) print(dimensions[1]) 输出结果如下： 200 50 如果尝试修改元组中元素的值，将会导致Python返回类型错误消息，由于试图修改元组的操作是被禁止的，因此Python指出不能给元组的元素赋值： dimensions = (200,50) dimensions[0] = 300 将会报错： Traceback (most recent call last): File &quot;dimensions.py&quot;, line 2, in &lt;module&gt; dimensions[0] = 300 TypeError: &#39;tuple&#39; object does not support item assignment - 3.4.2 遍历元组中所有的值 像列表一样，元组也可以使用for循环来遍历元组中的所有值： 例一： dimensions = (200,100,50,6) for dimension in dimensions: print(dimension) 输出结果如下： 200 100 50 6 例二： dimensions = (200,100,50,6) for dimension in dimensions[:3]: print(dimension) 输出结果如下： 200 100 50 - 3.4.3 修改元组变量 虽然不能修改元组元素，但是可以给储存元组的变量赋值： dimensions = (200,50) print(&quot;Original dimensions:&quot;) for dimension in dimensions: print(dimension) dimensions = (400,100) print(&quot;\\nModified dimensions:&quot;) for dimension in dimensions: print(dimension) 输出结果如下： Original dimensions: 200 50 Modified dimensions: 400 100 我们首先定义了一个元组，并将其储存的尺寸打印了出来；然后将一个新元组储存到变量dimensions中，打印新的尺寸；相比于列表，元组是更简单的数据结构。如果需要储存的一组值在程序的整个生命周期内都不变，可使用元组","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Python3","slug":"后端/Python3","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Python3/"}],"tags":[{"name":"Python3","slug":"Python3","permalink":"https://ysluckly.github.io/tags/Python3/"}]},{"title":"Python3 基础学习笔记 C02","slug":"back-end/A08-Python3-basic-C02","date":"2021-01-16T15:59:10.000Z","updated":"2022-02-20T13:24:23.973Z","comments":true,"path":"2021/01/16/python3/","link":"","permalink":"https://ysluckly.github.io/2021/01/16/python3/","excerpt":"","text":"- 2.1列表是什么 列表由一系列按特定顺序的元素组成，在 Python 中用方括号（ [ ] ）来表示列表，并用逗号来分隔其中的元素，例： list1 = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;] list2 = [&#39;abc&#39;, &#39;xyz&#39;, 2018, 2020] list3 = [1, 2, 3, 4, 5 ,6] list4 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] print(list1, list2, list3 ,list4) 输出结果如下： [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] [&#39;abc&#39;, &#39;xyz&#39;, 2018, 2020] [1, 2, 3, 4, 5, 6] [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] - 2.1.1访问列表元素 列表是有序集合，因此要访问列表的元素，只需要将该元素的位置或索引告诉Python即可，注意：在Python中的第一个列表元素的索引为0，而不是1 list = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;] print(list[0]) print(list[3]) print(list[-1]) #Python为访问最后一个列表元素提供了一种特殊语法，通过将索引指定为-1，可以让Python返回最后一个列表元素 print(list[-3]) 输出结果如下： a d f d - 2.1.2列表切片 list = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;] print(list[:]) #省略全部，代表截取全部内容，可以用来将一个列表拷给另一个列表 print(list[:3]) #省略起始位置的索引，默认起始位置从头开始，结束位置索引为2 print(list[3:]) #省略结束位置的索引，默认结束位置为最后一个，开始位置索引为3 print(list[1:4]) #开始位置索引为1，结束位置索引为3，顾头不顾尾 print(list[4:1]) #从左到右索引，因此为空值 print(list[-1:-3]) #从左到右索引，因此为空值 print(list[-3:-1]) #开始位置索引为倒数第三个，结束位置索引为倒数第二个 print(list[1:5:2]) #开始位置索引为1，结束位置索引为4，间隔2 print(list[5:1:-1]) #反向取值，开始位置索引为5，结束位置索引为2 print(list[::-1]) #反向取值，反向输出列表 输出结果如下： [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;] [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;] [] [] [&#39;d&#39;, &#39;e&#39;] [&#39;b&#39;, &#39;d&#39;] [&#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;] [&#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;] - 2.1.3使用列表中的各个值 可像使用其他变量一样使用列表中的各个值，例如，我们可以使用拼接根据列表中的值来创建消息： list = [&#39;python&#39;, &#39;c&#39;, &#39;c++&#39;, &#39;java&#39;, &#39;php&#39;] message = &quot;My favorite language is &quot; + list[0].title() + &quot;!&quot; print(message) 输出结果如下： My favorite language is Python! - 2.1.4修改元素 修改列表元素的语法与访问列表元素的语法类似，要修改列表元素，可指定列表名和要修改的元素的索引，再次指定该元素的新值： names = [&#39;zhangsan&#39;, &#39;lishi&#39;, &#39;wanger&#39;, &#39;liming&#39;, &#39;xiaowang&#39;] print(names) names[1] = &#39;lifang&#39; print(names) 输出结果如下： [&#39;zhangsan&#39;, &#39;lishi&#39;, &#39;wanger&#39;, &#39;liming&#39;, &#39;xiaowang&#39;] [&#39;zhangsan&#39;, &#39;lifang&#39;, &#39;wanger&#39;, &#39;liming&#39;, &#39;xiaowang&#39;] - 2.1.5添加元素 - 使用方法 append() 在列表末尾添加元素 list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] print(list) list.append(&#39;g&#39;) print(list) 输出结果如下： [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;] - 使用方法 insert() 在列表指定位置添加元素 list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] print(list) list.insert(2,&quot;h&quot;) #其中括号里的数字表示要插入的位置，此后面的元素将右移一个位置 print(list) 输出结果如下： [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] [&#39;a&#39;, &#39;b&#39;, &#39;h&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;] - 2.1.6删除元素 - 使用 del 语句删除元素 list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] print(list) del list[3] print(list) 输出结果如下： list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;e&#39;, &#39;f&#39;] - 使用方法 pop() 删除最后一个元素方法 pop() 可以删除列表末尾的元素，并让你能够接着使用它。术语弹出（pop）源自这样的类比：列表就像是一个栈，而删除列表末尾的元素就相当于弹出栈顶元素： list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] print(list) new_list = list.pop() print(list) print(new_list) 输出结果如下： [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;] f - 使用方法 pop() 删除任意位置元素可以使用 pop() 来删除列表中任何位置的元素，只需要在括号中指定要删除的元素的索引即可： list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] print(list) new_list = list.pop(1) print(list) print(new_list) 输出结果如下： [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] [&#39;a&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] b - 使用方法 remove() 删除未知位置元素当我们不知道元素的位置，只知道元素的值的时候，就可以使用方法 remove() list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] print(list) list.remove(&#39;d&#39;) print(list) 输出结果如下： [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;e&#39;, &#39;f&#39;] - 2.1.7使用方法 index() 查找指定元素位置 list = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;a&quot;] print(list.index(&#39;c&#39;)) 输出结果如下： 2 - 2.1.8使用方法 count() 统计指定元素数量 list = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;a&quot;] print(list.count(&#39;a&#39;)) 输出结果如下： 2 - 2.1.9清空列表 list = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;a&quot;] list.clear() print(list) 输出结果如下： [] - 2.2组织列表 在创建的列表中，元素的排列顺序常常是无法预测的，因为我们并非总能控制用户提供数据的顺序。有时候，我们希望保留列表元素最初的排列顺序，而有时候又需要调整排列顺序。Python提供了很多组织列表的方式，可根据具体情况选用 - 2.2.1使用方法 sort() 对列表进行永久排序 使用方法 sort() 可以对列表按照特殊符号，数字，大写字母，小写字母顺序进行永久排序： cars = [&#39;bmw&#39;, &#39;audi&#39;, &#39;toyota&#39;, &#39;subaru&#39;] cars.sort() print(cars) 输出结果如下： [&#39;audi&#39;, &#39;bmw&#39;, &#39;subaru&#39;, &#39;toyota&#39;] 还可以按与字母顺序相反的顺序排列列表元素，只需要向 sort() 方法传递参数 reverse = True 就可以了： cars = [&#39;bmw&#39;, &#39;audi&#39;, &#39;toyota&#39;, &#39;subaru&#39;] cars.sort(reverse = True) print(cars) 输出结果如下： [&#39;toyota&#39;, &#39;subaru&#39;, &#39;bmw&#39;, &#39;audi&#39;] - 2.2.2使用函数 sorted() 对列表进行临时排序 要保留列表元素原来的排列顺序，同时以特定的顺序呈现它们，可使用函数sorted()。函数sorted()让你能够按特定顺序显示列表元素，同时不影响它们在列表中的原始排列顺序： cars = [&#39;bmw&#39;, &#39;audi&#39;, &#39;toyota&#39;, &#39;subaru&#39;] print(&quot;Here is the original list:&quot;) print(cars) print(&quot;\\nHere is the sorted list:&quot;) print(sorted(cars)) print(&quot;\\nHere is the sorted reverse list:&quot;) print(sorted(cars, reverse=True)) print(&quot;\\nHere is the original list again:&quot;) print(cars) 输出结果如下： Here is the original list: [&#39;bmw&#39;, &#39;audi&#39;, &#39;toyota&#39;, &#39;subaru&#39;] Here is the sorted list: [&#39;audi&#39;, &#39;bmw&#39;, &#39;subaru&#39;, &#39;toyota&#39;] Here is the sorted reverse list: [&#39;toyota&#39;, &#39;subaru&#39;, &#39;bmw&#39;, &#39;audi&#39;] Here is the original list again: [&#39;bmw&#39;, &#39;audi&#39;, &#39;toyota&#39;, &#39;subaru&#39;] - 2.2.3使用方法 reverse() 对列表进行反向排序 要反转列表元素的排列顺序，可使用方法 reverse() cars = [&#39;bmw&#39;, &#39;audi&#39;, &#39;toyota&#39;, &#39;subaru&#39;] cars.reverse() print(cars) 输出结果如下： [&#39;subaru&#39;, &#39;toyota&#39;, &#39;audi&#39;, &#39;bmw&#39;] - 2.2.4确定列表的长度 使用函数 len() 可以快速获悉列表的长度： &gt;&gt;&gt;cars = [&#39;bmw&#39;, &#39;audi&#39;, &#39;toyota&#39;, &#39;subaru&#39;] &gt;&gt;&gt;len(cars) 4 - 2.2.5合并列表 - 使用方法 extend() 合并列表 list1 = [1, 2, 3, 4] list2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] list1.extend(list2) #将列表list2添加到list1当中去 print(list1) print(list2) 输出结果如下： [1, 2, 3, 4, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] - 使用 “+” 号合并列表 list1 = [1, 2, 3, 4] list2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] print(list1 + list2) print(list2 + list1) 输出结果如下： [1, 2, 3, 4, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, 1, 2, 3, 4] - 使用切片合并列表 list1 = [1, 2, 3, 4] list2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] list1[len(list1) : len(list1)] = list2 #len(list1)代表要将list2插入list1中的位置 print(list1) list1 = [1, 2, 3, 4] list2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] list1[0 :0] = list2 print(list1) list1 = [1, 2, 3, 4] list2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] list1[1:1] = list2 print(list1) 输出结果如下： [1, 2, 3, 4, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, 1, 2, 3, 4] [1, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, 2, 3, 4]","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Python3","slug":"后端/Python3","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Python3/"}],"tags":[{"name":"Python3","slug":"Python3","permalink":"https://ysluckly.github.io/tags/Python3/"}]},{"title":"Python3 基础学习笔记 C01","slug":"back-end/A07-Python3-basic-C01","date":"2021-01-15T15:59:10.000Z","updated":"2022-02-20T13:24:19.090Z","comments":true,"path":"2021/01/15/python3/","link":"","permalink":"https://ysluckly.github.io/2021/01/15/python3/","excerpt":"","text":"- 1.1变量的命名和使用 变量名只能包含字母、数字和下划线。变量名可以字母或者下划线打头，但不能以数字开头，例如，可以将变量命名为message_1，但不能将其命名为1_message 变量名不能包含空格，但可使用下划线来分割其中的单词，例如，变量名greeting_message可行，但变量名greeting message会引发错误 不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词，如print 变量名应既简短又具有描述性，例如，name比n好，student_name比s_n好，name_length比length_of_persons_name好 慎用小写字母l和大写字母O，因为它们可能被人看错成数字1和0 - 1.2字符串 字符串就是一系列字符，在Python中，用引号括起来的都是字符串，其中的引号可以是单引号也可以双引号： &quot;This is a string.&quot; &#39;This is also a string.&#39; 这种灵活性让我们能够在字符串中包含引号和撇号： &#39;I told my friend,&quot;Python is my favorite language!&quot;&#39; &quot;The language &#39;Python&#39; is named er Monty Python,not the snake.&quot; &quot;One of Python&#39;s strengths is i diverse and supportive community.&quot; - 1.2.1使用方法修改字符串的大小写三种处理方法如下： title() #将字符串每个单词的首字母都改为大写 upper() #将字符串的每个字母都改为大写 lower() #将字符串的每个字母都改为小写 例如： message = &quot;I love you!&quot; print(name.title()) print(name.upper()) print(name.lower()) 输出结果如下： I Love You! I LOVE YOU! i love you! - 1.2.2合并（拼接）字符串Python使用加号（+）来合并字符串，举例说明： first_name = &quot;I&quot; second_name = &quot;love&quot; third_name = &quot;python&quot; full_name = first_name + &quot; &quot; + second_name + &quot; &quot; + third_time print(full_name.title() + &quot;!&quot;) 输出结果如下： I Love Python! - 1.2.3使用制表符或换行符来添加空白添加横向制表符： &gt;&gt;&gt;print(&quot;\\tPython&quot;) Python 添加换行符： &gt;&gt;&gt;print(&quot;C\\nC++\\nPython\\nJavaScript&quot;) C C++ Python JavaScript 附表：Python转义符 - 1.2.4删除空白在Python中可用 lstrip()、rstrip()、strip() 分别删除字符串开头、结尾、全部的空白，举例说明： &gt;&gt;&gt;message = &#39; python &#39; &gt;&gt;&gt;message &#39; python &#39; &gt;&gt;&gt;message.lstrip() &#39;python &#39; &gt;&gt;&gt;message.rstrip() &#39; python&#39; &gt;&gt;&gt;message.strip() &#39;python&#39; 如果要永久删除字符串中的空白，必须将删除操作的结果存回到变量中： &gt;&gt;&gt;message = &#39; python &#39; &gt;&gt;&gt;message = message.strip() &gt;&gt;&gt;message &#39;python&#39; - 1.3数字在编程中，经常使用数字来记录游戏得分、表示可视化数据、储存Web应用信息等。Python根据数字的用法以不同的方式处理它们 - 1.3.1整数在Python中，可对整数执行加（+）减（-）乘（*）除（/）乘方（**）运算，同时也支持运算次序： &gt;&gt;&gt;3 + 2 5 &gt;&gt;&gt;3 - 2 1 &gt;&gt;&gt;3 * 2 6 &gt;&gt;&gt;3 \\ 2 1.5 &gt;&gt;&gt;3 ** 2 9 &gt;&gt;&gt;3 ** 3 27 &gt;&gt;&gt;2 + 3 * 4 14 &gt;&gt;&gt;(2 + 3) * 4 20 - 1.3.2浮点数Python将带小数点的数字都称为浮点数： &gt;&gt;&gt;0.1 + 0.1 0.2 &gt;&gt;&gt;2 * 0.2 0.4 需要注意的是，结果包含的小数位可能是不确定的，就现在而言，暂时忽略多余的小数位即可： &gt;&gt;&gt;0.2 + 0.1 0.30000000000000004 &gt;&gt;&gt;3 * 0.1 0.30000000000000004 - 1.3.3使用函数 str() 避免错误错误例子： age = 23 message = &quot;Happy &quot; + age + &quot;rd Birthday!&quot; print(message) 运行时会报错： Traceback (most recent call last): File &quot;birthday.py&quot;, line 2, in &lt;module&gt; message = &quot;Happy &quot; + age + &quot;rd Birthday!&quot; TypeError: must be str, not int 这是一个类型错误，意味着Python无法识别我们使用的信息。在这个例子中，Python发现我们使用了一个值为整数（int）的变量，但它不知道该如何解读这个值，这个变量表示的可能是数值23，也可能是字符2和3。像上面这样的字符串中使用整数时，需要显式地指出我们希望Python将这个整数用作字符串。为此，可调用函数 str()，它让Python将非字符串值表示为字符串： age = 23 message = &quot;Happy &quot; + str(age) + &quot;rd Birthday!&quot; print(message) 输出结果如下： Happy 23rd Birthday! - 1.4注释注释让我们能够使用自然语言在程序中添加说明，Python中注释有三种方法： print(&quot;Hello Python!&quot;) #这是单行注释 &#39;&#39;&#39;这是多行注释 这是多行注释&#39;&#39;&#39; &quot;&quot;&quot;这也是多行注释 这也是多行注释&quot;&quot;&quot;","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Python3","slug":"后端/Python3","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Python3/"}],"tags":[{"name":"Python3","slug":"Python3","permalink":"https://ysluckly.github.io/tags/Python3/"}]},{"title":"3-hexo添加自定义图标","slug":"tools/3-hexo-add-icon","date":"2020-12-28T14:00:00.000Z","updated":"2022-02-19T09:27:58.534Z","comments":true,"path":"2020/12/28/3-hexo-add-icon/","link":"","permalink":"https://ysluckly.github.io/2020/12/28/3-hexo-add-icon/","excerpt":"","text":"一、前言鉴于许多人问过如何添加自定义图标，这里就详细说明一下，以备后人乘凉。 这篇文章主要讲解是从 iconfont 添加图标。 二、添加彩色图标2.1 登录并添加图标访问 iconfont，点击如下图位置登录，可以使用 Github 账号登录。 登录成功后，搜索合适的图标，然后点击添加到购物车，如下图所示。 添加了多个后，可以点击右上角的“购物车”，添加到项目，点击加号创建项目，如下图所示。 添加完成后回到项目页面，找到自己刚刚创建的项目。 如果没有到项目页面，可以点击上面菜单进入：资源管理 -&gt; 我的项目 2.2 引入 3-hexo 中点击下载到本地，解压并复制其中的 iconfont.js 到项目 3-hexo/source/js/ 下，并改名 custom-iconfont.js。 在文件 3-hexo/layout/_partial/meta.ejs 最后追加下面一行。 &lt;script src=&quot;&lt;%=theme.blog_path?theme.blog_path.lastIndexOf(&quot;/&quot;) === theme.blog_path.length-1?theme.blog_path.slice(0, theme.blog_path.length-1):theme.blog_path:&#39;&#39; %&gt;/js/custom-iconfont.js?v=&lt;%=theme.version%&gt;&quot; &gt;&lt;/script&gt; 2.3 在配置文件中添加生效修改 3-hexo/_config.yml 如下图所示 完成！ 图标名如上面的 gitee 可以在 网站上修改，如下图所示 三、添加黑白图标link.theme=white 3.1 同 2.13.2 引入 3-hexo 中点击生成代码，如下图所示。 复制生成的代码，修改 font-family 的值为 custom-iconfont，添加到 3-hexo/source/css/_partial/font.styl 最后，并写入图标信息，content 可以移到图标上进行复制，注意前面斜杠转译和去掉后面的分号。 @font-face &#123; font-family: &#39;custom-iconfont&#39;; /* project id 2298064 */ src: url(&#39;//at.alicdn.com/t/font_2298064_34vkk4c9945.eot&#39;); src: url(&#39;//at.alicdn.com/t/font_2298064_34vkk4c9945.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;), url(&#39;//at.alicdn.com/t/font_2298064_34vkk4c9945.woff2&#39;) format(&#39;woff2&#39;), url(&#39;//at.alicdn.com/t/font_2298064_34vkk4c9945.woff&#39;) format(&#39;woff&#39;), url(&#39;//at.alicdn.com/t/font_2298064_34vkk4c9945.ttf&#39;) format(&#39;truetype&#39;), url(&#39;//at.alicdn.com/t/font_2298064_34vkk4c9945.svg#iconfont&#39;) format(&#39;svg&#39;); &#125; .icon-gitee:before &#123; content: &quot;\\e602&quot;; &#125; .icon-youtubeautored:before &#123; content: &quot;\\e649&quot;; &#125; 3.3 在配置文件中添加生效 同2.2结束！","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"},{"name":"3-hexo","slug":"3-hexo","permalink":"https://ysluckly.github.io/tags/3-hexo/"}]},{"title":"一文看懂JavaScript中的Promise","slug":"front-end/一文看懂JavaScript中的Promise","date":"2020-10-20T11:43:44.000Z","updated":"2022-02-19T09:27:58.502Z","comments":true,"path":"2020/10/20/know-javascript-promise/","link":"","permalink":"https://ysluckly.github.io/2020/10/20/know-javascript-promise/","excerpt":"","text":"一、Promise 是什么Promise 是 ES6 提供的原生对象，用来处理异步操作 它有三种状态 pending: 初始状态，不是成功或失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 二、使用2.1 创建 Promise通过 new Promise 来实例化，支持链式调用 new Promise((resolve, reject)=&gt;&#123; // 逻辑 &#125;).then(()=&gt;&#123; //当上面&quot;逻辑&quot;中调用 resolve() 时触发此方法 &#125;).catch(()=&gt;&#123; //当上面&quot;逻辑&quot;中调用 reject() 时触发此方法 &#125;) 2.2 执行顺序Promise一旦创建就立即执行，并且无法中途取消，执行逻辑和顺序可以从下面的示例中获得 如下，可修改 if 条件来改变异步结果，下面打印开始的数字是执行顺序 在线调试此示例 - jsbin console.log(&#39;1.开始创建并执行 Promise&#39;) new Promise(function(resolve, reject) &#123; console.log(&#39;2.由于创建会立即执行，所以会立即执行到本行&#39;) setTimeout(()=&gt;&#123; // 模拟异步请求 console.log(&#39;4. 1s之期已到，开始执行异步操作&#39;) if (true) &#123; // 一般我们符合预期的结果时调用 resolve()，会在 .then 中继续执行 resolve(&#39;成功&#39;) &#125; else &#123; // 不符合预期时调用 reject()，会在 .catch 中继续执行 reject(&#39;不符合预期&#39;) &#125; &#125;, 1000) &#125;).then((res)=&gt;&#123; console.log(&#39;5.调用了then，接收数据：&#39; + res) &#125;).catch((error)=&gt;&#123; console.log(&#39;5.调用了catch，错误信息：&#39; + error) &#125;) console.log(&#39;3.本行为同步操作，所以先于 Promise 内的异步操作（setTimeout）&#39;) 执行结果如下 &quot;1.开始创建并执行 Promise&quot; &quot;2.由于创建会立即执行，所以会立即执行到本行&quot; &quot;3.本行为同步操作，所以先于 Promise 内的异步操作（setTimeout）&quot; &quot;4. 1s之期已到，开始执行异步操作&quot; &quot;5.调用了then，接收数据：成功&quot; 2.3 用函数封装 Promise这是比较常用的方法，如下用 setTimeout 模拟异步请求，封装通用请求函数 在线调试此示例 - jsbin // 这是一个异步方法 function ajax(url)&#123; return new Promise(resolve=&gt;&#123; console.log(&#39;异步方法开始执行&#39;) setTimeout(()=&gt;&#123; console.log(&#39;异步方法执行完成&#39;) resolve(url+&#39;的结果集&#39;) &#125;, 1000) &#125;) &#125; // 调用请求函数，并接受处理返回结果 ajax(&#39;/user/list&#39;).then((res)=&gt;&#123; console.log(res) &#125;) 执行结果 &quot;异步方法开始执行&quot; &quot;异步方法执行完成&quot; &quot;/user/list的结果集&quot; 三、高级用法3.1 同时支持Callback与Promise在线调试此示例 - jsbin function ajax(url, success, fail) &#123; if (typeof success === &#39;function&#39;) &#123; setTimeout(() =&gt; &#123; if (true) &#123; success(&#123;user: &#39;羊&#39;&#125;) &#125; else if (typeof fail === &#39;function&#39;) &#123; console.log(typeof fail) fail(&#39;用户不存在&#39;) &#125; &#125;, 1000) &#125; else &#123; return new Promise((resolve, reject) =&gt; &#123; this.ajax(url, resolve, reject) &#125;) &#125; &#125; // callback 调用方式 ajax(&#39;/user/get&#39;, (res)=&gt;&#123; console.log(&#39;Callback请求成功！返回结果:&#39;, res) &#125;, (error)=&gt;&#123; console.log(&#39;Callback请求失败！错误信息:&#39;, error) &#125;) // Promise 调用方式 ajax(&#39;/user/get&#39;).then((res)=&gt;&#123; console.log(&#39;Pormise请求成功！返回结果：&#39;, res) &#125;).catch((error)=&gt;&#123; console.log(&#39;Promise请求失败！返回结果：&#39;, error) &#125;) 执行结果 Callback请求成功！返回结果: &#123;user: &quot;羊&quot;&#125; Pormise请求成功！返回结果： &#123;user: &quot;羊&quot;&#125; 3.2 链式调用.then 支持返回 Promise 对象进行链式调用 ajax(&#39;/user/info&#39;).then((res)=&gt;&#123; // 用户信息查询成功后，可以根据返回结果查询后续信息 console.log(&#39;用户信息:&#39;, res) return ajax(&#39;/user/score&#39;) &#125;).then((res)=&gt;&#123; console.log(&#39;用户成绩:&#39;, res) return ajax(&#39;/user/friends&#39;) &#125;).then((res)=&gt;&#123; console.log(&#39;用户朋友:&#39;, res) &#125;) 3.3 Promise.allPromise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。在线调试此示例 - jsbin // 生成一个Promise对象的数组 var promises = [2, 3, 5, 7, 11, 13].map(function(id)&#123; return new Promise((resolve, reject)=&gt;&#123; if (id % 3 === 0) &#123; resolve(id) &#125; else &#123; reject(id) &#125; &#125;); &#125;); Promise.all(promises).then(function(post) &#123; console.log(&#39;全部通过&#39;) &#125;).catch(function(reason)&#123; console.log(&#39;未全部通过，有问题id：&#39;+reason) &#125;); 执行结果 未全部通过，有问题id：2 Referencemozilla web docs","categories":[{"name":"大前端","slug":"大前端","permalink":"https://ysluckly.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://ysluckly.github.io/tags/javascript/"}]},{"title":"Docker 技术整理","slug":"linux/Docker-技术整理","date":"2020-09-01T14:11:00.000Z","updated":"2022-02-19T09:27:58.510Z","comments":true,"path":"2020/09/01/Docker-summary/","link":"","permalink":"https://ysluckly.github.io/2020/09/01/Docker-summary/","excerpt":"","text":"一、概述1.1 什么是dockerDocker 诞生于 2013 年初，由 dotCloud 公司（后改名为 Docker Inc）基于 Go 语言实现并开源的项目。此项目后来加入 Linux基金会，遵从了 Apache 2.0 协议 Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。Docker 是在 Linux 容器技术（LXC）的基础上进行了封装，让用户可以快速并可靠的将应用程序从一台运行到另一台上。 使用容器部署应用被称为容器化，容器化技术的几大优势： 灵活：甚至复杂的应用也可以被容器化 轻量：容器利用和共享宿主机内核，从而在利用系统资源比虚拟机更加的有效 可移植：你可以在本地构建，在云端部署并在任何地方运行 松耦合：容器是高度封装和自给自足的，允许你在不破环其他容器的情况下替换或升级任何一个 可扩展：你可以通过数据中心来新增和自动分发容器 安全：容器依赖强约束和独立的进程 1.2 和传统虚拟机的区别容器在Linux上本地运行，并与其他容器共享主机的内核。它运行一个离散进程，不占用任何其他可执行文件更多的内存，从而使其轻巧。 1.3 相关链接官网：https://www.docker.com/ 文档：https://docs.docker.com/ 二、Image镜像2.1 介绍Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 父镜像：每个镜像都可能依赖于有一个或多个下层组成的另一个镜像。下层那个镜像就是上层镜像的父镜像 基础镜像：一个没有任何父镜像的镜像，被称为基础镜像 镜像ID：所有镜像都是通过一个 64 位十六进制字符串（256 bit 的值）来标识的。为了简化使用，前 12 个自负可以组成一个短ID，可以在命令行中使用。短ID还是有一定的碰撞几率，所以服务器总是返回长ID 2.2 从仓库下载镜像可以通过 docker pull 命令从仓库获取所需要的镜像 docker pull [选项] [Docker Registry 地址]&lt;镜像名&gt;:&lt;标签&gt; 选项: –all-tags,-a : 拉去所有 tagged 镜像 –disable-content-trust：忽略镜像的校验，默认 –platform：如果服务器是开启多平台支持的，则需要设置平台 –quiet,-q：静默执行，不打印详细信息 标签： 下载指定标签的镜像，默认 latest 示例 # 从 Docker Hub 下载最新的 debian 镜像 docker pull debian # 从 Docker Hub 下载 jessie 版 debian 镜像 docker pull debian:jessie # 下载指定摘要(sha256)的镜像 docker pull ubuntu@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2 2.3 列出本地镜像# 列出已下载的镜像 image_name: 指定列出某个镜像 docker images [选项] [image_name] 选项 参数 描述 –all, -a 展示所有镜像(包括 intermediate 镜像) –digests 展示摘要 –filter, -f 添加过滤条件 –format 使用 Go 模版更好的展示 –no-trunc 不删减输出 –quiet, -q 静默输出，仅仅展示 IDs 示例 # 展示本地所有下载的镜像 docker images # 在本地查找镜像名是 &quot;java&quot; 标签是 &quot;8&quot; 的 奖项 docker images: java:8 # 查找悬挂镜像 docker images --filter &quot;dangling=true&quot; # 过滤 lable 为 &quot;com.example.version&quot; 的值为 0.1 的镜像 docker images --filter &quot;label=com.example.version=0.1&quot; 2.4 Dockerfile创建镜像为了方便分享和快速部署，我们可以使用 docker build 来创建一个新的镜像，首先创建一个文件 Dockerfile，如下 # This is a comment FROM ubuntu:14.04 MAINTAINER Chris &lt;jaytp@qq.com&gt; RUN apt-get -qq update RUN apt-get -qqy install ruby ruby-dev RUN gem install sinatra 然后在此 Dockerfile 所在目录执行 docker build -t yelog/ubuntu:v1 . 来生成镜像，所属组织/镜像名:标签 2.5 上传镜像用户可以通过 docker push 命令，把自己创建的镜像上传到仓库中来共享。例如，用户在 Docker Hub 上完成注册后，可以推送自己的镜像到仓库中。 docker push yelog/ubuntu 2.6 导出和载入镜像docker 支持将镜像导出为文件，然后可以再从文件导入到本地镜像仓库 # 导出 docker load --input yelog_ubuntu_v1.tar # 载入 docker load &lt; yelog_ubuntu_v1.tar 2.7 移除本地镜像# -f 强制删除 docker rmi [-f] yelog/ubuntu:v1 # 删除悬挂镜像 docker rmi $(docker images -f &quot;dangling=true&quot; -q) # 删除所有未被容器使用的镜像 docker image prune -a 三、容器3.1 介绍容器和镜像，就像面向对象中的 类 和 示例 一样，镜像是静态的定义，容器是镜像运行的实体，容器可以被创建、启动、停止、删除和暂停等 容器的实质是进城，耽于直接的宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 root 文件系统、网络配置和进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。 3.2 创建容器我们可以通过命令 docker run 命令创建容器 如下，启动一个容器，执行命令输出 “Hello word”，之后终止容器 docker run ubuntu:14.04 /bin/echo &#39;Hello world&#39; 下面的命令则是启动一个 bash 终端，允许用户进行交互 docker run -t -i ubuntu:14.04 /bin/bash -t 让 Dcoker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上 -i 责让容器的标准输入保持打开 更多参数可选 -a stdin 指定标准输入输出内容类型 -d 后台运行容器，并返回容器ID -i 以交互模式运行容器，通常与 -t 同时使用 -P 随机端口映射，容器端口内部随即映射到宿主机的端口上 -p 指定端口映射， -p 宿主机端口:容器端口 -t \b为容器重新分配一个伪输入终，通常与 -i 同时使用 –name=”gate” 为容器指定一个名称 –dns 8.8.8.8 指定容器的 DNS 服务器，默认与宿主机一致 –dns-search example.com 指定容器 DNS 搜索域名，默认与宿主机一致 -h “gate” 指定容器的 hostname -e username=’gate’ 设置环境变量 –env-file=[] 从指定文件读入环境变量 –cpuset=”0-2” or –cpuset=”0,1,2” 绑定容器到指定 CPU 运行 -m 设置容器使用内存最大值 –net=”bridge” 指定容器的网络连接类型支持 bridge/host/none/container –link=[] 添加链接到另一个容器 –expose=[] 开放一个端口或一组端口 –volume,-v 绑定一个卷 当利用 docker run 来创建容器时，Dcoker 在后台运行的标准操作包括： 检查本地是否存在指定的镜像，不存在就从公有仓库下载 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像外面挂在一层可读写层 从宿主主机配置的网桥接口中桥接一个虚拟借口到容器中去 从地址池配置一个 ip 地址给容器 执行用户指定的应用程序 执行用户指定的应用程序 执行完毕后容器被终止 3.3 启动容器# 创建一个名为 test 的容器，容器任务是：打印一行 Hello word docker run --name=&#39;test&#39; ubuntu:14.04 /bin/echo &#39;Hello world&#39; # 查看所有可用容器 [-a]包括终止在内的所有容器 docker ps -a # 启动指定 name 的容器 docker start test # 重启指定 name 的容器 docker restart test # 查看日志运行日志（每次启动的日志均被查询出来） $ docker logs test Hello world Hello world 3.4 守护态运行前面创建的容器都是执行任务（打印Hello world）后，容器就终止了。更多的时候，我们需要让 Docker 容器在后台以守护态（Daemonized）形式运行。此时，可以通过添加 -d 参数来实现 注意：docker是否会长久运行，和 docker run 指定的命令有关 # 创建 docker 后台守护进程的容器 docker run --name=&#39;test2&#39; -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot; # 查看容器 $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 237e555d4457 ubuntu:14.04 &quot;/bin/sh -c &#39;while t…&quot; 52 seconds ago Up 51 seconds test2 # 获取容器的输出信息 $ docker logs test2 hello world hello world hello world 3.5 进入容器上一步我们已经实现了容器守护态长久运行，某些时候需要进入容器进行操作，可以使用 attach 、exec 进入容器。 # 不安全的，ctrl+d 退出时容器也会终止 docker attach [容器Name] # 以交互式命令行进入，安全的，推荐使用 docker exec -it [容器Name] /bin/bash 命令优化 使用 docker exec 命令时，好用，但是命令过长，我们可以通过自定义命令来简化使用 创建文件 /user/bin/ctn 命令文件，内容如下 docker exec -it $1 /bin/bash 检查环境变量有没有配置目录 /usr/bin （一般是有配置在环境变量里面的，不过最好再确认一下） $PATH bash: /usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games: No such file or directory 完成上面步骤后，就可以直接通过命令 ctn 来进入容器 注意：如果是使用非 root 账号创建的命令，而 docker 命令是 root 权限，可能存在权限问题，可以通过设置 chmod 777 /usr/bin/ctn 设置权限，使用 sudo ctn [容器Name] 即可进入容器 $ ctn [容器Name] 使用上面命令时，容器Name 需要手动输入，容器出错。我们可以借助 complete 命令来补全 容器Name，在 ~/.bashrc （作用于当前用户，如果想要所要用户上校，可以修改 /etc/bashrc）文件中添加一行，内容如下。保存后执行 source ~/.bashrc 使之生效，之后我们输入 ctn 后，按 tab 就会提示或自动补全容器名了了 # ctn auto complete complete -W &quot;$(docker ps --format&quot;&#123;&#123;.Names&#125;&#125;&quot;)&quot; ctn 注意： 由于提示的 容器Name 是 ~/.bashrc 生效时的列表，所有如果之后 docker 容器列表有变动，需要重新执行 source ~/.bashrc 使之更新提示列表 3.6 终止容器通过 docker stop [容器Name] 来终止一个运行中的容器 # 终止容器名为 test2 的容器 docker stop test2 # 查看正在运行中的容器 docker ps # 查看所有容器（包括终止的） docker ps -a 3.7 将容器保存为镜像我们修改一个容器后，可以经当前容器状态打包成镜像，方便下次直接通过镜像仓库生成当前状态的容器。 # 创建容器 docker run -t -i training/sinatra /bin/bash # 添加两个应用 gem install json # 将修改后的容器打包成新的镜像 docker commit -m &quot;Added json gem&quot; -a &quot;Docker Newbee&quot; 0b2616b0e5a8 ouruser/sinatra:v2 3.8 导出/导入容器容器 -&gt;导出&gt; 容器快照文件 -&gt;导入&gt; 本地镜像仓库 -&gt;新建&gt; 容器 $ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2a8bffa405c8 ubuntu:14.04 &quot;/bin/sh -c &#39;while t…&quot; About an hour ago Up 3 seconds test2 # 导出 $ docker export 2a8bffa405c8 &gt; ubuntu.tar # 导入为镜像 $ docker ubuntu.tar | docker import - test/ubuntu:v1.0 # 从指定 URL 或者某个目录导入 $ docker import http://example.com/exampleimage.tgz example/imagerepo 注意：用户既可以通过 docker load 来导入镜像存储文件到本地镜像仓库，也可以使用 docker import 来导入一个容器快找到本地镜像仓库，两者的区别在于容器快照将丢失所有的历史记录和元数据信息，仅保存容器当时的状态，而镜像存储文件将保存完成的记录，体积要更大。所有容器快照文件导入时需要重新指定标签等元数据信息。 3.9 删除容器可以使用 docker rm [容器Name] 来删除一个终止状态的容器，如果容器还未终止，可以先使用 docker stop [容器Name] 来终止容器，再进行删除操作 docker rm test2 # 删除容器 -f: 强制删除，无视是否运行 $ docker [-f] rm myubuntu # 删除所有已关闭的容器 $ docker rm $(docker ps -a -q) 3.10 查看容器状态docker stats $(docker ps --format=&#123;&#123;.Names&#125;&#125;) 四、数据卷4.1 介绍数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多特性： 数据卷可以在容器之间共享和重用 对数据卷的修改会立马生效 对数据卷的更新，不会影响镜像 卷会一直存在，直到没有容器使用 数据卷类似于 Linux 下对目录或文件进行 mount 4.2 创建数据卷在用 docker run 命令的时候，使用 -v 标记来创建一个数据卷并挂在在容器里，可同时挂在多个。 # 创建一个 web 容器，并加载一个数据卷到容器的 /webapp 目录 docker run -d -P --name web -v /webapp training/webapp python app.py # 挂载一个宿主机目录 /data/webapp 到容器中的 /opt/webapp docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py # 默认是读写权限，也可以指定为只读 docker run -d -P --name web -v /src/webapp:/opt/webapp:ro # 挂载单个文件 docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash 4.3 数据卷容器如果需要多个容器共享数据，最好创建数据卷容器，就是一个正常的容器，撰文用来提供数据卷供其他容器挂载的 # 创建一个数据卷容器 dbdata docker run -d -v /dbdata --name dbdata training/postgres echo Data-only container for postgres # 其他容器挂载 dbdata 容器的数据卷 docker run -d --volumes-from dbdata --name db1 training/postgres docker run -d --volumes-from dbdata --name db2 training/postgres 五、网络5.1 外部访问容器在容器内运行一些服务，需要外部可以访问到这些服务，可以通过 -P 或 -p 参数来指定端口映射。 当使用 -P 标记时，Docker 会随即映射一个 49000～49900 的端口到内部容器开放的网络端口。 使用 docker ps 可以查看端口映射情况 $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7f43807dc042 training/webapp &quot;python app.py&quot; 3 seconds ago Up 2 seconds 0.0.0.0:32770-&gt;5000/tcp amazing_liskov -p 指定端口映射，支持格式 ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort # 不限制ip访问 docker run -d -p 5000:5000 training/webapp python app.py # 只允许宿主机回环地址访问 docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py # 宿主机自动分配绑定端口 docker run -d -p 127.0.0.1::5000 training/webapp python app.py # 指定 udp 端口 docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py # 指定多个端口映射 docker run -d -p 5000:5000 -p 3000:80 training/webapp python app.py # 查看映射端口配置 $ docker port amazing_liskov 5000/tcp -&gt; 0.0.0.0:32770 5.2 容器互联容器除了跟宿主机端口映射外，还有一种容器间交互的方式，可以在源/目标容器之间建立一个隧道，目标容器可以看到源容器指定的信息。 可以通过 --link name:alias 来连接容器，下面就是 “web容器连接db容器” 的例子 # 创建 容器db docker run -d --name db training/postgres # 创建 容器web 并连接到 容器db docker run -d -P --name web --link db:db training/webapp python app.py # 进入 容器web，测试连通性 $ ctn web $ ping db PING db (172.17.0.3) 56(84) bytes of data. 64 bytes from db (172.17.0.3): icmp_seq=1 ttl=64 time=0.254 ms 64 bytes from db (172.17.0.3): icmp_seq=2 ttl=64 time=0.190 ms 64 bytes from db (172.17.0.3): icmp_seq=3 ttl=64 time=0.389 ms 5.3 访问控制容器想要访问外部网络，需要宿主机的转发支持。在 Linux 系统中，通过以下命令检查是否打开 $ sysctl net.ipv4.ip_forward net.ipv4.ip_forward = 1 如果是 0，说明没有开启转发，则需要手动打开。 $ sysctl -w net.ipv4.ip_forward=1 5.4 配置 docker0 桥接Docker 服务默认会创建一个 docker0 网桥，他在内核层连通了其他物理或虚拟网卡，这就将容器和主机都放在同一个物理网络。 Docker 默认制定了 docker0 接口的IP地址和子网掩码，让主机和容器间可以通过网桥相互通信，他还给了 MTU（接口允许接收的最大单元），通常是 1500 Bytes，或宿主机网络路由上支持的默认值。这些都可以在服务启动的时候进行配置。 --bip=CIDR ip地址加子网掩码格式，如 192.168.1.5/24 --mtu=BYTES 覆盖默认的 Docker MTU 配置 可以通过 brctl show 来查看网桥和端口连接信息 5.5 网络配置文件Docker 1.2.0 开始支持在运行中的容器里编辑 /etc/hosts 、/etc/hostsname 和 /etc/resolve.conf 文件，修改都是临时的，重新容器将会丢失修改，通过 docker commit 也不会被提交。 六、Dockerfile6.1 介绍Dockerfile 是由一行行命令组成的命令集合，分为四个部分： 基础镜像信息 维护着信息 镜像操作指令 容器启动时执行指令 如下： # 最前面一般放这个 Dockerfile 的介绍、版本、作者及使用说明等 # This dockerfile uses the ubuntu image # VERSION 2 - EDITION 1 # Author: docker_user # Command format: Instruction [arguments / command] .. # 使用的基础镜像，必须放在非注释第一行 FROM ubuntu # 维护着信息信息： 名字 联系方式 MAINTAINER docker_user docker_user@email.com # 构建镜像的命令：对镜像做的调整都在这里 RUN echo &quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot; &gt;&gt; /etc/apt/sources.list RUN apt-get update &amp;&amp; apt-get install -y nginx RUN echo &quot;\\ndaemon off;&quot; &gt;&gt; /etc/nginx/nginx.conf # 创建/运行 容器时的操作指令 # 可以理解为 docker run 后跟的运行指令 CMD /usr/sbin/nginx 6.2 指令指令一般格式为 INSTRUCTION args，包括 FORM 、 MAINTAINER 、RUN 等 FORM 第一条指令必须是 FORM 指令，并且如果在同一个Dockerfile 中创建多个镜像，可以使用多个 FROM 指令（每个镜像一次） FORM ubuntuFORM ubuntu:14.04 MAINTAINER 维护者信息 MAINTAINER Chris &#x78;&#120;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109; RUN 每条 RUN 指令在当前镜像基础上执行命令，并提交为新的镜像。当命令过长时可以使用 \\ 来换行 在 shell 终端中运行命令RUN apt-get update &amp;&amp; apt-get install -y nginx在 exec 中执行:RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;] CMD 指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。 CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] 使用 exec 执行，推荐方式；CMD command param1 param2 在 /bin/sh 中执行，提供给需要交互的应用；CMD [&quot;param1&quot;,&quot;param2&quot;] 提供给 ENTRYPOINT 的默认参数； EXPOSE 告诉服务端容器暴露的端口号， EXPOSE ENV 指定环境变量 ENV PG_MAJOR 9.3ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH ADD ADD 该命令将复制指定的 到容器中的 。其中 可以是 Dockerfile 所在目录的一个相对路径，也可以是一个URL；还可以是一个 tar文件（自动解压为目录） COPY 格式为 COPY 复制本地主机的 （为 Dockerfile 所在目录的相对路径）到容器中的 。当使用本地目录为源目录时，推荐使用 COPY ENTRYPOINT 配置容器启动执行的命令，并且不可被 docker run 提供的参数覆盖每个Docekrfile 中只能有一个 ENTRYPOINT ，当指定多个时，只有最后一个起效 两种格式ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]``ENTRYPOINT command param1 param2（shell中执行） VOLUME 创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。 VOLUME [“/data”] USER 指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户 USER daemon WORKDIR 为后续的 RUN、CMD、ENTRYPOINT 指令配置工作目录。可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。 格式为 WORKDIR /path/to/workdir。 WORKDIR /aWORKDIR bWORKDIR cRUN pwd最后的路径为 /a/b/c ONBUILD 配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。 格式为 ONBUILD [INSTRUCTION]。 6.3 创建镜像编写完成 Dockerfile 之后，可以通过 docker build 命令来创建镜像 docker build [选项] 路径 该命令江都区指定路径下（包括子目录）的Dockerfile，并将该路径下所有内容发送给 Docker 服务端，有服务端来创建镜像。可以通过 .dockerignore 文件来让 Docker 忽略路径下的目录与文件 # 使用 -t 指定镜像的标签信息 docker build -t myrepo/myimage . 七、Docker Compose7.1 介绍Docker Compose 是 Docker 官方编排项目之一，负责快速在集群中部署分布式应用。维护地址：https://github.com/docker/compose，由 Python 编写，实际调用 Docker提供的API实现。 Dockerfile 可以让用户管理一个单独的应用容器，而 Compose 则允许用户在一个模版（YAML格式）中定义一组相关联的应用容器（被称为一个project/项目），例如一个 web容器再加上数据库、redis等。 7.2 安装# 使用 pip 进行安装 pip install -U docker-compose # 查看用法 docker-ompose -h # 添加 bash 补全命令 curl -L https://raw.githubusercontent.com/docker/compose/1.2.0/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose 7.3 使用术语 服务/service： 一个应用容器，实际上可以运行多个相同镜像的实例 项目/project： 有一组关联的应用容器组成的完成业务单元 示例：创建一个 Haproxy 挂载三个 Web 容器 创建一个 compose-haproxy-web 目录，作为项目工作目录，并在其中分别创建两个子目录： haproxy 和 web 。 compose-haproxy-webcompose-haproxy-web git clone https://github.com/yelog/compose-haproxy-web.git 目录长这样： compose-haproxy-web ├── docker-compose.yml ├── haproxy │ └── haproxy.cfg └── web ├── Dockerfile ├── index.html └── index.py 在该目录执行 docker-compose up 命令，会整合输出所有容器的输出 $ docker-compose up Starting compose-haproxy-web_webb_1 ... done Starting compose-haproxy-web_webc_1 ... done Starting compose-haproxy-web_weba_1 ... done Recreating compose-haproxy-web_haproxy_1 ... done Attaching to compose-haproxy-web_webb_1, compose-haproxy-web_weba_1, compose-haproxy-web_webc_1, compose-haproxy-web_haproxy_1 haproxy_1 | [NOTICE] 244/131022 (1) : haproxy version is 2.2.2 haproxy_1 | [NOTICE] 244/131022 (1) : path to executable is /usr/local/sbin/haproxy haproxy_1 | [ALERT] 244/131022 (1) : parsing [/usr/local/etc/haproxy/haproxy.cfg:14] : &#39;listen&#39; cannot handle unexpected argument &#39;:70&#39;. haproxy_1 | [ALERT] 244/131022 (1) : parsing [/usr/local/etc/haproxy/haproxy.cfg:14] : please use the &#39;bind&#39; keyword for listening addresses. haproxy_1 | [ALERT] 244/131022 (1) : Error(s) found in configuration file : /usr/local/etc/haproxy/haproxy.cfg haproxy_1 | [ALERT] 244/131022 (1) : Fatal errors found in configuration. compose-haproxy-web_haproxy_1 exited with code 1 此时访问本地的 80 端口，会经过 haproxy 自动转发到后端的某个 web 容器上，刷新页面，可以观察到访问的容器地址的变化。 7.4 命令说明大部分命令都可以运行在一个或多个服务上。如果没有特别的说明，命令则应用在项目所有的服务上。 执行 docker-compose [COMMAND] --help 查看具体某个命令的使用说明 使用格式 docker-compose [options] [COMMAND] [ARGS...] build 构建/重建服务服务一旦构建后，将会带上一个标记名，例如 web_db可以随时在项目目录运行 docker-compose build 来重新构建服务 help 获得一个命令的信息 kill 通过发送 SIGKILL 信号来强制停止服务容器，支持通过参数来指定发送信号，例如docker-compose kill -s SIGINT logs 查看服务的输出 port 打印绑定的公共端口 ps 列出所有容器 pull 拉去服务镜像 rm 删除停止的服务容器 run 在一个服务上执行一个命令docker-compose run ubuntu ping docker.com scale 设置同一个服务运行的容器个数通过 service=num 的参数来设置数量docker-compose scale web=2 worker=3 start 启动一个已经存在的服务容器 stop 停止一个已经运行的容器，但不删除。可以通过 docker-compose start 再次启动 up 构建、创建、启动、链接一个服务相关的容器链接服务都将被启动，除非他们已经运行docker-compose up -d 将后台运行并启动docker-compose up 已存在容器将会重新创建docker-compose up --no-recreate 将不会重新创建容器 7.5 环境变量环境变量可以用来配置 Compose 的行为 以 Docker_ 开头的变量用来配置 Docker 命令行客户端使用的一样 COMPOSE_PROJECT_NAME 设置通过 Compose 启动的每一个容器前添加的项目名称，默认是当前工作目录的名字。 COMPOSE_FILE 设置要使用的 docker-compose.yml 的路径。默认路径是当前工作目录。 DOCKER_HOST 设置 Docker daemon 的地址。默认使用 unix:///var/run/docker.sock，与 Docker 客户端采用的默认值一致。 DOCKER_TLS_VERIFY 如果设置不为空，则与 Docker daemon 交互通过 TLS 进行。 DOCKER_CERT_PATH 配置 TLS 通信所需要的验证（ca.pem、cert.pem 和 key.pem）文件的路径，默认是 ~/.docker 。 7.6 docker-compose.yml默认模版文件是 docker-compose.yml ，启动定义了每个服务都必须经过 image 指令指定镜像或 build 指令（需要 Dockerfile) 来自动构建。 其他大部分指令跟 docker run 类似 如果使用 build 指令，在 Dockerfile 中设置的选项（如 CMD 、EXPOSE 等）将会被自动获取，无需在 docker-compose.yml 中再次设置。 **image** 指定镜像名称或镜像ID，如果本地仓库不存在，将尝试从远程仓库拉去此镜像 image: ubuntu image: orchardup/postgresql image: a4bc65fd **build** 指定 Dockerfile 所在文件的路径。Compose 将利用它自动构建这个镜像，然后使用这个镜像。 build: /path/to/build/dir **command** 覆盖容器启动默认执行命令 command: bundle exec thin -p 3000 **links** 链接到其他服务中的容器，使用服务名称或别名 links: - db - db:database - redis 别名会自动在服务器中的 /etc/hosts 里创建。例如： 172.17.2.186 db 172.17.2.186 database 172.17.2.187 redis **external_links** 连接到 docker-compose.yml 外部的容器，甚至并非 Compose 管理的容器。 external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql ports 暴露端口信息 HOST:CONTAINER 格式或者仅仅指定容器的端口（宿主机会随机分配端口） ports: - &quot;3000&quot; - &quot;8000:8000&quot; - &quot;49100:22&quot; - &quot;127.0.0.1:8001:8001&quot; 注：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 你可能会得到错误得结果，因为 YAML 将会解析 xx:yy 这种数字格式为 60 进制。所以建议采用字符串格式。 **expose** 暴露端口，但不映射到宿主机，只被连接的服务访问 expose: - &quot;3000&quot; - &quot;8000&quot; volumes 卷挂载路径设置。可以设置宿主机路径 （HOST:CONTAINER） 或加上访问模式 （HOST:CONTAINER:ro）。 volumes: - /var/lib/mysql - cache/:/tmp/cache - ~/configs:/etc/configs/:ro **** volumes_from 从另一个服务或容器挂载它的所有卷。 volumes_from: - service_name - container_name environment 设置环境变量。你可以使用数组或字典两种格式。 只给定名称的变量会自动获取它在 Compose 主机上的值，可以用来防止泄露不必要的数据。 environment: RACK_ENV: development SESSION_SECRET: environment: - RACK_ENV=development - SESSION_SECRET env_file 从文件中获取环境变量，可以为单独的文件路径或列表。 如果通过 docker-compose -f FILE 指定了模板文件，则 env_file 中路径会基于模板文件路径。 如果有变量名称与 environment 指令冲突，则以后者为准。 env_file: .env env_file: - ./common.env - ./apps/web.env - /opt/secrets.env 环境变量文件中每一行必须符合格式，支持 # 开头的注释行。 # common.env: Set Rails/Rack environment RACK_ENV=development extends 基于已有的服务进行扩展。例如我们已经有了一个 webapp 服务，模板文件为 common.yml。 # common.yml webapp: build: ./webapp environment: - DEBUG=false - SEND_EMAILS=false 编写一个新的 development.yml 文件，使用 common.yml 中的 webapp 服务进行扩展。 # development.yml web: extends: file: common.yml service: webapp ports: - &quot;8000:8000&quot; links: - db environment: - DEBUG=true db: image: postgres 后者会自动继承 common.yml 中的 webapp 服务及相关环节变量。 **** net 设置网络模式。使用和 docker client 的 --net 参数一样的值。 net: &quot;bridge&quot; net: &quot;none&quot; net: &quot;container:[name or id]&quot; net: &quot;host&quot; **** pid 跟主机系统共享进程命名空间。打开该选项的容器可以相互通过进程 ID 来访问和操作。 pid: &quot;host&quot; dns 配置 DNS 服务器。可以是一个值，也可以是一个列表。 dns: 8.8.8.8 dns: - 8.8.8.8 - 9.9.9.9 cap_add, cap_drop 添加或放弃容器的 Linux 能力（Capabiliity）。 cap_add: - ALL cap_drop: - NET_ADMIN - SYS_ADMIN **** dns_search 配置 DNS 搜索域。可以是一个值，也可以是一个列表。 dns_search: example.com dns_search: - domain1.example.com - domain2.example.com **** working_dir, entrypoint, user, hostname, domainname, mem_limit, privileged, restart, stdin_open, tty, cpu_shares 这些都是和 docker run 支持的选项类似。 八、安全8.1 内核命名空间当使用 docker run 启动一个容器时，在后台 Docker 为容器创建一个独立的命名空间和控制集合。命名空间踢空了最基础的也是最直接的隔离，在容器中运行的进程不会被运行在主机上的进程和其他容器发现和作用。 8.2 控制组控制组是 Linux 容器机制的另一个关键组件，负责实现资源的审计和限制。 它提供了很多特性，确保哥哥容器可以公平地分享主机的内存、CPU、磁盘IO等资源；当然，更重要的是，控制组确保了当容器内的资源使用产生压力时不会连累主机系统。 8.3 内核能力机制能力机制是 Linux 内核的一个强大特性，可以提供细粒度的权限访问控制。 可以作用在进程上，也可以作用在文件上。 例如一个服务需要绑定低于 1024 的端口权限，并不需要 root 权限，那么它只需要被授权 net_bind_service 能力即可。 默认情况下， Docker 启动的容器被严格限制只允许使用内核的一部分能力。 使用能力机制加强 Docker 容器的安全有很多好处，可以按需分配给容器权限，这样，即便攻击者在容器中取得了 root 权限，也不能获取宿主机较高权限，能进行的破坏也是有限的。 参考资料https://docs.docker.com/engine/reference/commandline/images/ http://www.dockerinfo.net/","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ysluckly.github.io/tags/docker/"},{"name":"linux","slug":"linux","permalink":"https://ysluckly.github.io/tags/linux/"}]},{"title":"3-hexo评论设置","slug":"tools/3-hexo-comment","date":"2020-05-23T14:26:23.000Z","updated":"2022-02-19T09:27:58.536Z","comments":true,"path":"2020/05/23/3-hexo-comment/","link":"","permalink":"https://ysluckly.github.io/2020/05/23/3-hexo-comment/","excerpt":"","text":"前言目前 3-hexo 已经集成了评论系统有 gitalk 、gitment、 disqus 、来必力、utteranc 一、gitalkgitalk 是一款基于 Github Issue 和 Preact 开发的评论插件 官网: https://gitalk.github.io/ 1. 登录 github ，注册应用点击进行注册 ，如下 注册完后，可得到 Client ID 和 Client Secret 2. 新建存放评论的仓库因为 gitalk 是基于 Github 的 Issue 的，所以需要指定一个仓库，用来承接 gitalk 的评论，我们一般使用 Github Page 来做我们博客的评论，所以，新建仓库名为 xxx.github.io，其中 xxx 为你的 Github 用户名 3. 配置主题在主题下 _config.yml 中找到如下配置，启用评论，并使用 gitalk ##########评论设置############# comment: on: true type: gitalk 在主题下 _config.yml 中找到 gitalk 配置，将 第1步 得到的 Client ID 和 Client Secret 复制到如下位置 gitalk: githubID: # 填你的 github 用户名 repo: xxx.github.io # 承载评论的仓库，一般使用 Github Page 仓库 ClientID: # 第1步获得 Client ID ClientSecret: # 第1步获得 Client Secret adminUser: # Github 用户名 distractionFreeMode: true language: zh-CN perPage: 10 二、来必力1. 创建来必力账号，并选择 City 免费版官网http://livere.com/ ，创建账号，点击上面的安装，选择 City 免费版 复制获取到的代码中的 data-uid 2. 主题选择使用来必力评论在主题下 _config.yml 在找到来必力配置如下，第一步中复制的 data-uid 粘贴到下面 data_uid 处 livere: data_uid: xxxxxx 找到以下代码， 开启并选择 livere (来必力) ##########评论设置############# comment: on: true type: livere 三、utteranc官网地址：https://utteranc.es/ 1. 安装 utterances点我进行安装 2. 配置主题在主题下 _config.yml 中找到 utteranc 的配置 ，修改 repo 为自己的仓库名 utteranc: repo: xxx/xxx.github.io # 承载评论的仓库，填上自己的仓库 issue_term: pathname # Issue 与 博客文章 之间映射关系 label: utteranc # 创建的 Issue 添加的标签 theme: github-light # 主题，可选主题请查看官方文档 https://utteranc.es/#heading-theme # 官方文档 https://utteranc.es/ # 使用说明 https://yelog.org//2020/05/23/3-hexo-comment/ 在主题下 _config.yml 中找到如下配置，启用评论，并使用 utteranc comment: on: true type: utteranc","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"3-hexo","slug":"3-hexo","permalink":"https://ysluckly.github.io/tags/3-hexo/"}]},{"title":"3-hexo支持mermaid图表","slug":"tools/3-hexo-support-mermaid","date":"2019-11-12T01:55:37.000Z","updated":"2022-02-19T09:27:58.545Z","comments":true,"path":"2019/11/12/3-hexo-support-mermaid/","link":"","permalink":"https://ysluckly.github.io/2019/11/12/3-hexo-support-mermaid/","excerpt":"","text":"一、说明开启 安装hexo插件npm install hexo-filter-mermaid-diagrams 修改themes/3-hexo/_config.yml 的 mermaid.on，开启主题支持# Mermaid 支持 mermaid: on: true cdn: //cdn.jsdelivr.net/npm/mermaid@8.4.2/dist/mermaid.min.js #cdn: //cdnjs.cloudflare.com/ajax/libs/mermaid/8.3.1/mermaid.min.js options: # 更多配置信息可以参考 https://mermaidjs.github.io/#/mermaidAPI theme: &#39;default&#39; startOnLoad: true flowchart: useMaxWidth: false htmlLabels: true 在markdown中，像写代码块一样写图表 二、示例以下示例源码可以在这边查看 本文源码更多示例可以查看官网：https://mermaidjs.github.io 1. flowchartgraph TD; A-->B; A-->C; B-->D; C-->D; graph TB c1-->a2 subgraph one a1-->a2 end subgraph two b1-->b2 end subgraph three c1-->c2 end 2.Sequence diagramssequenceDiagram participant Alice participant Bob Alice->>John: Hello John, how are you? loop Healthcheck John->>John: Fight against hypochondria end Note right of John: Rational thoughts prevail! John-->>Alice: Great! John->>Bob: How about you? Bob-->>John: Jolly good! 3.Class diagramsclassDiagram Animal NumLockOn : EvNumLockPressed NumLockOn --> NumLockOff : EvNumLockPressed -- [*] --> CapsLockOff CapsLockOff --> CapsLockOn : EvCapsLockPressed CapsLockOn --> CapsLockOff : EvCapsLockPressed -- [*] --> ScrollLockOff ScrollLockOff --> ScrollLockOn : EvCapsLockPressed ScrollLockOn --> ScrollLockOff : EvCapsLockPressed } 5.Gantt diagramsgantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h 6.Pie chart diagramspie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"},{"name":"3-hexo","slug":"3-hexo","permalink":"https://ysluckly.github.io/tags/3-hexo/"}]},{"title":"3-hexo 添加音乐插件","slug":"tools/3-hexo-add-music","date":"2019-10-08T02:44:30.000Z","updated":"2022-02-19T09:27:58.535Z","comments":true,"path":"2019/10/08/3-hexo-add-music/","link":"","permalink":"https://ysluckly.github.io/2019/10/08/3-hexo-add-music/","excerpt":"","text":"网易云音乐1. 复制网易云音乐插件代码前往网易云音乐官网，搜索一个作为背景音乐的歌曲，并进入播放页面，点击 生成外链播放器 设置好想要显示的样式后，复制 html 代码 最好外层在加一个 div，如下，可直接将上一步复制的 iframe 替换下方里面的 iframe &lt;div id=&quot;musicMouseDrag&quot; style=&quot;position:fixed; z-index: 9999; bottom: 0; right: 0;&quot;&gt; &lt;div id=&quot;musicDragArea&quot; style=&quot;position: absolute; top: 0; left: 0; width: 100%;height: 10px;cursor: move; z-index: 10;&quot;&gt;&lt;/div&gt; &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=38592976&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; 2. 将插件引入到主题中将上一步加过 div 的代码粘贴到主题下 layout/_partial/footer.ejs 的最后面 3. 调整位置默认给的样式是显示在右下角，可以通过调整上一步粘贴的 div 的 style 中 bottom 和 right 来调整位置。 4. 自由拖动如果需要自由拖动，在刚才添加的代码后面，再添加下面代码即可，鼠标就可以在音乐控件的 上边沿 点击拖动 &lt;!--以下代码是为了支持随时拖动音乐控件的位置，如没有需求，可去掉下面代码--&gt; &lt;script&gt; var $DOC = $(document) $(&#39;#musicMouseDrag&#39;).on(&#39;mousedown&#39;, function (e) &#123; // 阻止文本选中 $DOC.bind(&quot;selectstart&quot;, function () &#123; return false; &#125;); $(&#39;#musicDragArea&#39;).css(&#39;height&#39;, &#39;100%&#39;); var $moveTarget = $(&#39;#musicMouseDrag&#39;); $moveTarget.css(&#39;border&#39;, &#39;1px dashed grey&#39;) var div_x = e.pageX - $moveTarget.offset().left; var div_y = e.pageY - $moveTarget.offset().top; $DOC.on(&#39;mousemove&#39;, function (e) &#123; var targetX = e.pageX - div_x; var targetY = e.pageY - div_y; targetX = targetX &lt; 0 ? 0 : (targetX + $moveTarget.outerWidth() &gt;= window.innerWidth) ? window.innerWidth - $moveTarget.outerWidth() : targetX; targetY = targetY &lt; 0 ? 0 : (targetY + $moveTarget.outerHeight() &gt;= window.innerHeight) ? window.innerHeight - $moveTarget.outerHeight() : targetY; $moveTarget.css(&#123;&#39;left&#39;: targetX + &#39;px&#39;, &#39;top&#39;: targetY + &#39;px&#39;, &#39;bottom&#39;: &#39;inherit&#39;, &#39;right&#39;: &#39;inherit&#39;&#125;) &#125;).on(&#39;mouseup&#39;, function () &#123; $DOC.unbind(&quot;selectstart&quot;); $DOC.off(&#39;mousemove&#39;) $DOC.off(&#39;mouseup&#39;) $moveTarget.css(&#39;border&#39;, &#39;none&#39;) $(&#39;#musicDragArea&#39;).css(&#39;height&#39;, &#39;10px&#39;); &#125;) &#125;) &lt;/script&gt;","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"},{"name":"3-hexo","slug":"3-hexo","permalink":"https://ysluckly.github.io/tags/3-hexo/"}]},{"title":"3-hexo支持jsfiddle渲染","slug":"tools/3-hexo-jsfiddle","date":"2019-09-24T01:59:37.000Z","updated":"2022-02-19T09:27:58.540Z","comments":true,"path":"2019/09/24/3-hexo-jsfiddle/","link":"","permalink":"https://ysluckly.github.io/2019/09/24/3-hexo-jsfiddle/","excerpt":"","text":"1. canvas 粒子效果 2. 复选框动画","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"},{"name":"3-hexo","slug":"3-hexo","permalink":"https://ysluckly.github.io/tags/3-hexo/"}]},{"title":"3-hexo文章内toc生成","slug":"tools/3-hexo-toc","date":"2019-09-24T01:48:20.000Z","updated":"2022-02-19T09:27:58.545Z","comments":true,"path":"2019/09/24/3-hexo-toc/","link":"","permalink":"https://ysluckly.github.io/2019/09/24/3-hexo-toc/","excerpt":"","text":"[toc] 1. 如何使用1.1 关键字只要在在文章中使用如下关键字，不区分大小写，便可以在相应位置显示目录导航，效果文章开头 1.2 小标题2jlksjdflksdjflksjdflksjdflkaj;sdfjka;lskdjfla;skjdf;lajsdflkjal;sdjkf;laskjdf占位占位 1.3 小标题占位占位占位 2. 标题二占位占位占位 2.1 小标题占位占位 2.2 小标题2占位占位占位占位占位 文末占位占位占位占位占位","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"},{"name":"3-hexo","slug":"3-hexo","permalink":"https://ysluckly.github.io/tags/3-hexo/"}]},{"title":"[记]《知识分子的不幸》-王小波","slug":"reading/misfortune-intellectual","date":"2019-06-09T13:31:09.000Z","updated":"2022-02-19T09:27:58.530Z","comments":true,"path":"2019/06/09/misfortune-intellectual/","link":"","permalink":"https://ysluckly.github.io/2019/06/09/misfortune-intellectual/","excerpt":"","text":"前言这篇文章发表于1996年第二期《东方》杂志，同样收录于《沉默的大多数》一书中。 所想文章一开头就抛出了一个问题：什么是知识分子最害怕的事？想起了高晓松在晓说中提到过这个问题，晓松肯定是看过这篇文章的。 王小波说：“知识分子最怕活在不理智的年代。”所谓不理智的年代，就是伽利略低头认罪，承认地球不转的年代，也是拉瓦斯上断头台的年代；是茨威格服毒自杀的年代，也是老舍跳太平湖的年代。“ 王小波和他的美国老师谈论了一个问题：”有信仰比无信仰要好。“，由于王小波是经历过文革的，所以王小波一开始是抵触这种思想的，尤其是 课间祷告 **让王小波想起了文革中的 **早请示。但老师最终说服了他，“不管是信神，还是自珍自重，人活在世界上总得有点信念才成。就我个人而言，虽是无神论者，我也有个人操守，从不逾越。” 国内的学者，只搞学术研究，不搞意识形态，这由不了自己。有朝一日它成了意识形态，你的话就是罪状。言论不自由，不理智，民族狂热，这不就是知识分子最怕的事情吗？ 王小波崇拜墨子：其一，他思维缜密，其二，他敢赤裸裸地谈利害。（有了他，我也敢说自己是中华民族的赤诚分子，不怕国学家说我是全盘西化了。） 营造意识形态则是灭绝思想额丰饶。中国的人文知识分子，有种以天下为己任的使命感，总觉得自己该搞出些老百姓当信仰的东西。 国学，这种东西实在厉害。最可怕之处就在于那个“国”字。顶着这个字，谁敢有不同意见？抢到了这个制高点，就可以压制一切不同意见；所以很容易落入思想流氓的手中变成一种凶器。 目前正值 “中美贸易战”，各种自媒体为了点击量、关注度。煽动民族狂热情绪，导致民众根本容不得半点不同意见，不讲道理，“盲目爱国“。 认真思索，真诚的明辨是非，有这种态度大概就可算是善良了吧。 人活在世上，自会形成信念，一种学问、一本书，假如不对我的价值观发生变化，就不值得一学，不值得一看。","categories":[{"name":"读书","slug":"读书","permalink":"https://ysluckly.github.io/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"阅读笔记","slug":"读书/阅读笔记","permalink":"https://ysluckly.github.io/categories/%E8%AF%BB%E4%B9%A6/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"reading","slug":"reading","permalink":"https://ysluckly.github.io/tags/reading/"}]},{"title":"人们在一本叫《活着》的书中纷纷死去","slug":"reading/to-live","date":"2019-05-02T09:46:16.000Z","updated":"2022-02-19T09:27:58.532Z","comments":true,"path":"2019/05/02/to-live/","link":"","permalink":"https://ysluckly.github.io/2019/05/02/to-live/","excerpt":"","text":"有那么一个年代，离我们很近，它腥风血雨，连活着都是一件奢侈的事。 在富贵的一生中，每次出现看似被上天眷顾的福气后（如有庆长跑第一、凤霞嫁了人并怀了孩子），读者还在替富贵开心的时候，他们却以各种方式迅速死去，最终富贵亲手埋葬了他所有的亲人。 一本 12w 左右的小说，但是在没有华丽词藻的情况下，在顺畅流利的写作手法、跌宕起伏的剧情、第一人称的代入感下一口气读完了。期间多次痛哭流涕（一点儿没夸张），不得不放下书本，洗过脸后才能继续阅读。所以已经多年没写书评的我，还是忍不住为她写下书评。 人是为了活着本身而活着，而不是为了活着之外的任何事物所活着。 这是作者在中文序言中的一句话，在当今生活着的我，初读序言中的这句话，并无任何共鸣，甚至还行吐槽两句。随着富贵将他的”一生”娓娓道来，你就会明白在那样的时代背景下，活着已经是一件不容易的事。 所以作者在日文版序言中说到： 在旁人眼中富贵的一生是苦熬的一生；可是对于富贵自己，我相信他更多地感受到了幸福。 因为他相信自己的妻子是世上最好的妻子，他相信自己的子女也是世上最好的子女，还有他的女婿他的外孙，还有他的那头也叫富贵的牛，还有一起上火锅的朋友们，还有生活的点点滴滴…… 富贵的真是一路跌下去的一生，从”富家少爷”赌光了家产、气死了爹爹。由于母亲生病，为母亲求医路上被国民党抓壮丁，被俘虏后，放回家中。却发现母亲已死，女儿也由于生病变成了聋哑人。本想着大难之后必有后福，却只是悲惨一生的开端。儿子有庆由于和县长夫人血型匹配，遭抽血而亡、女儿凤霞产子大出血而亡、妻子家珍失去儿女后，失去了最后与病魔争斗的信念，也走了、女婿二喜在工地被水泥板拍死、外孙苦根难得吃到豆子，却被豆子撑死。最后只剩下自己和一个也叫作富贵的老牛。 春生想自杀前，找到富贵告别，在被家珍原谅，并答应不会自杀，在这种情况下坚持了一个月，最终还是自杀了。那种时代背景下的无奈，那种窒息感。。。 富贵的一生跨越了地主、解放战争、人民公社运动、大炼钢铁、自然灾害和文化大革命，从一个人的视角看到每个时代下的一个小小的缩影，但却比任何其他的描述更让人深刻了解到这些时代背景下人们的生活状态。 在那时，活着不仅是幸运，也更需要勇气。","categories":[{"name":"读书","slug":"读书","permalink":"https://ysluckly.github.io/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"阅读笔记","slug":"读书/阅读笔记","permalink":"https://ysluckly.github.io/categories/%E8%AF%BB%E4%B9%A6/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"reading","slug":"reading","permalink":"https://ysluckly.github.io/tags/reading/"},{"name":"活着","slug":"活着","permalink":"https://ysluckly.github.io/tags/%E6%B4%BB%E7%9D%80/"}]},{"title":"shell速查表","slug":"linux/shell速查表","date":"2018-09-08T03:48:24.000Z","updated":"2022-02-19T09:27:58.522Z","comments":true,"path":"2018/09/08/shell-command/","link":"","permalink":"https://ysluckly.github.io/2018/09/08/shell-command/","excerpt":"","text":"1. 变量#!/bin/bash msg=&quot;hello world&quot; echo $msg 变量名的命名须遵循如下规则： 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。 2. 传参#!/bin/bash echo &quot;执行的文件名：$0&quot;; echo &quot;第一个参数为：$1&quot;; echo &quot;第二个参数为：$2&quot;; echo &quot;第三个参数为：$3&quot;; 脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……另外，还有几个特殊字符用来处理参数： 参数 说明 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数。如&quot;$*&quot;用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。 $- 显示Shell使用的当前选项，与set命令功能相同。 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 3. 数组```bash#!/bin/bashmy_array=(A B “C” D)echo “第一个元素为: ${my_array[0]}”echo “第二个元素为: ${my_array[1]}”echo “第三个元素为: ${my_array[2]}”echo “第四个元素为: ${my_array[3]}” echo “数组的元素为: ${my_array[*]}”echo “数组的元素为: ${my_array[@]}” echo “数组元素个数为: $","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ysluckly.github.io/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://ysluckly.github.io/tags/shell/"}]},{"title":"nginx配置记录","slug":"linux/nginx配置记录","date":"2018-02-08T01:19:09.000Z","updated":"2022-02-19T09:27:58.521Z","comments":true,"path":"2018/02/08/nginx-config/","link":"","permalink":"https://ysluckly.github.io/2018/02/08/nginx-config/","excerpt":"","text":"启用https1.购买免费证书登录阿里云 -&gt; 控制台 -&gt; 安全（云盾） -&gt; CA证书服务 -&gt; 购买证书 2.补全证书信息点击补全，绑定域名 3.下载并配置选择下载 证书for nginx 上面这个页面有相关的配置信息，下面简单介绍： ① 将下载文件中的 *.pem、*.key, 拷贝到 nginx 目录下 的 cert , 当然也可以是其他目录② 修改 nginx.conf server &#123; listen 443 ssl; server_name xiangzhangshugongyi.com; ssl_certificate cert/214487958220243.pem; ssl_certificate_key cert/214487958220243.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-Proto https; proxy_redirect off; proxy_connect_timeout 240; proxy_send_timeout 240; proxy_read_timeout 240; # note, there is not SSL here! plain HTTP is used proxy_pass http://127.0.0.1:8080; &#125; &#125; ③ 重启 nginx，通过 证书绑定域名进行 https 访问到 服务器跑在 8080 的服务","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://ysluckly.github.io/tags/nginx/"}]},{"title":"My First Blog","slug":"reading/My-First-Blog","date":"2018-01-20T05:27:47.000Z","updated":"2022-02-26T06:06:03.166Z","comments":true,"path":"2018/01/20/undefined/","link":"","permalink":"https://ysluckly.github.io/2018/01/20/undefined/","excerpt":"前言 人生，走着走着便懂了，对于未来，不再迷茫彷徨，而是以更坚定的步伐迈向预定的目标；人生，走着走着便懂了，对于爱情，不再痴迷悲伤，而是以更理智的心态去接受爱情细水长流的平淡；人生，走着走着便懂了，对于生活，不再困惑感伤，而是以积极乐观的心态去迎接每一个黎明的到来。","text":"前言 人生，走着走着便懂了，对于未来，不再迷茫彷徨，而是以更坚定的步伐迈向预定的目标；人生，走着走着便懂了，对于爱情，不再痴迷悲伤，而是以更理智的心态去接受爱情细水长流的平淡；人生，走着走着便懂了，对于生活，不再困惑感伤，而是以积极乐观的心态去迎接每一个黎明的到来。 白驹过隙，转眼间，我已是大学生，虽然已经在大学生活了两年，却依然对未来很迷茫，这种迷茫也带来了一系列的恐惧：能否找到称心如意的工作、能否有能力赡养自己的父母，买不起房怎么办、程序员真的是青春饭吗……我是某院某专业的一名普通的不能再普通的学生。说实话，上大学以来，我并没有为了某些事情真正地努力过，即使是一些很简单的事情 。 曾听人说大学有四个阶段：不知道自己不知道-&gt;知道自己不知道-&gt;不知道自己知道-&gt;知道自己知道。就目前情况来看我应该处于第二阶段，我认识到自己缺乏太多的专业知识以及社交原则，我也会经常阅读搞IT的成功人士的案例来寻求安慰与激励，但这只是短暂的麻痹罢了。 曾经很“牛逼”地对好朋友说过：“我不想过一辈子穷苦生活！”现在想起当时的自己真的是既无知又可笑，我特么拿什么去过理想中的生活呢？殊不知：开水不响，响水不开。被打的人才会大吼几声来搏回一点颜面，而真正有实力的人都是深藏不露的。 小时候家里还种地的时候，我也像其他孩子一样要去田里除草。烈日炎炎下，站在田地里往前一看，我的妈，还有这么多的草要拔呀！还没干活便没了一半的力气。而如果一步一步的做好眼前的这一块，便在不知不觉中就到了地头。我现在何尝又不是当年那个拔草的少年呢，我还有海量的东西要学，我为何不能脚踏实地的学好现在的东西呢？ 现于公元二零一八年，特写此篇 ，抒己所感。我并不是为自己起初愚笨忏悔，而是把压在心里的东西排出来轻松一下，并且要警示自己从现在起，静下心来，虚心学习，因为仅剩的大学时光不多了。说实话，像我这样无实力的人连现在的生活都掌控不好，有何权利去畅想未来？关键是要把自己变强大，才能在困难面前有获胜的筹码。曾听过一句自认为非常好的话，毅然当作了自己的座右铭：人生在勤，不索何获！ 作此篇亦献给正处于迷茫中的你，希望能够共勉，一起进步!","categories":[{"name":"读书","slug":"读书","permalink":"https://ysluckly.github.io/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"程序人生","slug":"读书/程序人生","permalink":"https://ysluckly.github.io/categories/%E8%AF%BB%E4%B9%A6/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"}],"tags":[{"name":"人生在勤，不索何获","slug":"人生在勤，不索何获","permalink":"https://ysluckly.github.io/tags/%E4%BA%BA%E7%94%9F%E5%9C%A8%E5%8B%A4%EF%BC%8C%E4%B8%8D%E7%B4%A2%E4%BD%95%E8%8E%B7/"}]},{"title":"Mac神器-BTT(BetterTouchTool)不完全教程","slug":"tools/Mac-BetterTouchTool","date":"2017-12-13T09:04:25.000Z","updated":"2022-02-19T09:27:58.548Z","comments":true,"path":"2017/12/13/Mac-BetterTouchTool/","link":"","permalink":"https://ysluckly.github.io/2017/12/13/Mac-BetterTouchTool/","excerpt":"","text":"介绍BetterTouchTool 是一款专为Mac用户开发的 窗口管理/Trackpad(触控板)/Magic Mouse(苹果鼠标)/Keyboard(键盘)/TouchBar 功能增强制作的软件。 这款软件不但可以设置全局的 手势/快捷键/TouchBar ，还可以给不同的应用定义不同的姿势，再配合上 Alfred 的 workflow，简直各种高难度姿势都能玩的出来。 本文主要介绍以下功能： 窗口管理 帮 Trackpad 定义各种姿势 帮 Magic Mouse 定义各种姿势 帮 Keyboard 定义各种姿势 帮任何应用自定义 TouchBar 本文以 macbook pro 2017 touchbar 版为例 1. 窗口管理这个功能无需过多配置，默认配置即可很好使用（和windows的理念相似） 将窗口移到左右边缘，最大化至半屏 将窗口移到上边缘，最大化至全屏 如果对默认配置不满意，也可以在如下图所示的位置来调整窗口展示： 2. 帮 Trackpad 定义各种姿势姿势选择在界面选择 Trackpad（触摸板） -&gt; Add New Gesture（添加一个新姿势） 左边可以选择生效的范围：全局或者某个应用 如上图所示，姿势包括但不限于如： 单指：左下角单击、单指轻拍右上角、单指轻拍上边中点 双指：两个手指捏、张开两指以两指中心为圆轴逆时针、中指拍住中央食指轻拍面板、双指从上边缘下滑 三指：三指轻拍、三指拍顶端、三指点击并向上滑、两指轻拍住，拍左、右二指固定拍住，左一下滑 四指：四指双轻拍、中指无名小拍住，食单击、食中指无名拍住，小单击 五指：五手指轻拍、五手指上滑 上面只是列一些典型，更多姿势可以在上图中浏览。 绑定功能 选择过姿势之后，也可以选择在按住某个功能键的时候才能使用（左下角）。 右边是绑定功能：快捷键或动作。 绑定快捷键举例：比如 给chrome 设置 姿势（两指从触控板下边缘滑入），弹出开发者模式（快捷键绑定：command+option+i），如下图： 绑定动作举例：设置 在任何应用内，五指下滑 锁屏，如下图 3. 帮 Magic Mouse 定义各种姿势这个功能设置和 Trackpad 设置 大同小异，所以这边就不多讲，直接图示几个功能。 我快捷键设置了 option+E 鼠标取词翻译（欧陆词典），然后绑定到双指轻拍鼠标，即可触发翻译。 4. 帮 Keyboard 定义各种姿势这个功能比较简单，设置一些 键盘快捷键或录制案件序列 来触发 一些动作或者其他快捷键功能。 5. 帮任何应用自定义 TouchBar这个重磅功能，可以帮助不支持touchbar的软件定制 TouchBar，是不是有点厉害。 下面就以我给 IntelliJ IDEA 定制 TouchBar 为例 (没有F1 ~ F12 功能键，debug真的很痛苦，这个软件真的是雪中送炭)，展示一下使用效果 如上图所示，我给 IntelliJ IDEA 添加了 四个功能 step over/step into/resume/evaluate 添加完之后，切到 IntelliJ IDEA 软件中时，TouchBar 就显示我们添加的四个功能键， 如下图所示 最后BTT还有其他很方便的功能，这盘就介绍到这里，等之后更新了 Alfred 的 workflow 开发指南之后，再一起更新一篇有意思的 BTT+Alfred 效率流。","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"软件记录","slug":"工具/软件记录","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://ysluckly.github.io/tags/mac/"},{"name":"efficiency","slug":"efficiency","permalink":"https://ysluckly.github.io/tags/efficiency/"}]},{"title":"[转]谈谈Java中的语法糖","slug":"back-end/转-谈谈Java中的语法糖","date":"2017-11-27T14:51:45.000Z","updated":"2022-02-20T13:02:04.005Z","comments":true,"path":"2017/11/27/java-grammatical-sugar/","link":"","permalink":"https://ysluckly.github.io/2017/11/27/java-grammatical-sugar/","excerpt":"","text":"语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言本身功能来说没有什么影响，只是为了方便程序员的开发，提高开发效率。说白了，语法糖就是对现有语法的一个封装。 Java作为一种与平台无关的高级语言，当然也含有语法糖，这些语法糖并不被虚拟机所支持，在编译成字节码阶段就自动转换成简单常用语法。一般来说Java中的语法糖主要有以下几种： 泛型与类型擦除 自动装箱与拆箱，变长参数、 增强for循环 内部类与枚举类 泛型与类型擦除Java语言并不是一开始就支持泛型的。在早期的JDK中，只能通过Object类是所有类型的父类和强制类型转换来实现泛型的功能。强制类型转换的缺点就是把编译期间的问题延迟到运行时，JVM并不能为我们提供编译期间的检查。 在JDK1.5中，Java语言引入了泛型机制。但是这种泛型机制是通过类型擦除来实现的，即Java中的泛型只在程序源代码中有效（源代码阶段提供类型检查），在编译后的字节码中自动用强制类型转换进行替代。也就是说，Java语言中的泛型机制其实就是一颗语法糖，相较与C++、C#相比，其泛型实现实在是不那么优雅。 /** * 在源代码中存在泛型 */ public static void main(String[] args) &#123; Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); map.put(&quot;hello&quot;,&quot;你好&quot;); String hello = map.get(&quot;hello&quot;); System.out.println(hello); &#125; 当上述源代码被编译为class文件后，泛型被擦除且引入强制类型转换 public static void main(String[] args) &#123; HashMap map = new HashMap(); //类型擦除 map.put(&quot;hello&quot;, &quot;你好&quot;); String hello = (String)map.get(&quot;hello&quot;);//强制转换 System.out.println(hello); &#125; 自动装箱与拆箱 Java中的自动装箱与拆箱指的是基本数据类型与他们的包装类型之间的相互转换。 我们知道Java是一门面向对象的语言，在Java世界中有一句话是这么说的：“万物皆对象”。但是Java中的基本数据类型却不是对象，他们不需要进行new操作，也不能调用任何方法，这在使用的时候有诸多不便。因此Java为这些基本类型提供了包装类，并且为了使用方便，提供了自动装箱与拆箱功能。自动装箱与拆箱在使用的过程中，其实是一个语法糖，内部还是调用了相应的函数进行转换。 下面代码演示了自动装箱和拆箱功能 public static void main(String[] args) &#123; Integer a = 1; int b = 2; int c = a + b; System.out.println(c); &#125; 经过编译后，代码如下 public static void main(String[] args) &#123; Integer a = Integer.valueOf(1); // 自动装箱 byte b = 2; int c = a.intValue() + b;//自动拆箱 System.out.println(c); &#125; 变长参数 所谓变长参数，就是方法可以接受长度不定确定的参数 变长参数特性是在JDK1.5中引入的，使用变长参数有两个条件，一是变长的那一部分参数具有相同的类型，二是变长参数必须位于方法参数列表的最后面。变长参数同样是Java中的语法糖，其内部实现是Java数组。 public class Varargs &#123; public static void print(String... args) &#123; for(String str : args)&#123; System.out.println(str); &#125; &#125; public static void main(String[] args) &#123; print(&quot;hello&quot;, &quot;world&quot;); &#125; &#125; 编译为class文件后如下，从中可以很明显的看出变长参数内部是通过数组实现的 public class Varargs &#123; public Varargs() &#123; &#125; public static void print(String... args) &#123; String[] var1 = args; int var2 = args.length; //增强for循环的数组实现方式 for(int var3 = 0; var3 &lt; var2; ++var3) &#123; String str = var1[var3]; System.out.println(str); &#125; &#125; public static void main(String[] args) &#123; //变长参数转换为数组 print(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;); &#125; &#125; 增强for循环 增强for循环与普通for循环相比，功能更强并且代码更简洁 增强for循环的对象要么是一个数组，要么实现了Iterable接口。这个语法糖主要用来对数组或者集合进行遍历，其在循环过程中不能改变集合的大小。 public static void main(String[] args) &#123; String[] params = new String[]&#123;&quot;hello&quot;,&quot;world&quot;&#125;; //增强for循环对象为数组 for(String str : params)&#123; System.out.println(str); &#125; List&lt;String&gt; lists = Arrays.asList(&quot;hello&quot;,&quot;world&quot;); //增强for循环对象实现Iterable接口 for(String str : lists)&#123; System.out.println(str); &#125; &#125; 编译后的class文件为 public static void main(String[] args) &#123; String[] params = new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;; String[] lists = params; int var3 = params.length; //数组形式的增强for退化为普通for for(int str = 0; str &lt; var3; ++str) &#123; String str1 = lists[str]; System.out.println(str1); &#125; List var6 = Arrays.asList(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;); Iterator var7 = var6.iterator(); //实现Iterable接口的增强for使用iterator接口进行遍历 while(var7.hasNext()) &#123; String var8 = (String)var7.next(); System.out.println(var8); &#125; &#125; 内部类 内部类就是定义在一个类内部的类 Java语言中之所以引入内部类，是因为有些时候一个类只在另一个类中有用，我们不想让其在另外一个地方被使用。内部类之所以是语法糖，是因为其只是一个编译时的概念，一旦编译完成，编译器就会为内部类生成一个单独的class文件，名为outer$innter.class。 public class Outer &#123; class Inner&#123; &#125; &#125; 使用javac编译后，生成两个class文件Outer.class和Outer$Inner.class，其中Outer$Inner.class的内容如下： class Outer$Inner &#123; Outer$Inner(Outer var1) &#123; this.this$0 = var1; &#125; &#125; 内部类分为四种：成员内部类、局部内部类、匿名内部类、静态内部类，每一种都有其用法，这里就不介绍了 枚举类型 枚举类型就是一些具有相同特性的类常量 java中类的定义使用class，枚举类的定义使用enum。在Java的字节码结构中，其实并没有枚举类型，枚举类型只是一个语法糖，在编译完成后被编译成一个普通的类。这个类继承java.lang.Enum，并被final关键字修饰。 public enum Fruit &#123; APPLE,ORINGE &#125; 使用jad对编译后的class文件进行反编译后得到 //继承java.lang.Enum并声明为final public final class Fruit extends Enum &#123; public static Fruit[] values() &#123; return (Fruit[])$VALUES.clone(); &#125; public static Fruit valueOf(String s) &#123; return (Fruit)Enum.valueOf(Fruit, s); &#125; private Fruit(String s, int i) &#123; super(s, i); &#125; //枚举类型常量 public static final Fruit APPLE; public static final Fruit ORANGE; private static final Fruit $VALUES[];//使用数组进行维护 static &#123; APPLE = new Fruit(&quot;APPLE&quot;, 0); ORANGE = new Fruit(&quot;ORANGE&quot;, 1); $VALUES = (new Fruit[] &#123; APPLE, ORANGE &#125;); &#125; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ysluckly.github.io/tags/java/"}]},{"title":"PostgreSQL事务及隔离级别","slug":"database/PostgreSQL事务及隔离级别","date":"2017-11-08T16:07:33.000Z","updated":"2022-02-20T13:03:40.977Z","comments":true,"path":"2017/11/09/PostgreSQL事物及隔离级别/","link":"","permalink":"https://ysluckly.github.io/2017/11/09/PostgreSQL%E4%BA%8B%E7%89%A9%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/","excerpt":"","text":"介绍PostgreSQL中提供了多种数据完整性的保证机制。如：约束、触发器、事务和锁管理等。 事务主要是为了保证一组相关数据库的操作能全部执行成功，从而保证数据的完整性。锁机制主要是控制多个用户对同一数据进行操作，使用锁机制可以解决并发问题。 事务事务是用户对一个数据库操作的一个序列，这些操作要么全做，要么全不做，是一个不可分割的单位。 事务管理的常用语句如下： BEGIN; SQL语句1; SQL语句2; ... COMMIT; 事务块是指包围在BEGIN和COMMIT之间的语句。在PostgreSQL9中，常用的事务块管理语句含义如下： START TRANSACTION：此命令表示开始一个新的事务块.BEGIN：初始化一个事务块。在BEGIN命令后的语句都将在一个事务里面执行，知道遇见COMMIT或ROLLBACK。它和START TRANSACTION是一样的。COMMIT：提交事务。ROLLBACK：事务失败时执行回滚操作。SET TRANSACTION：设置当前事务的特性。对后面的事务没有影响。 事务隔离及并发控制PostgreSQL是一个支持多用户的数据库，当多个用户操作同一数据库时，并发控制要保证所有用户可以高效的访问的同时不破坏数据的完整性。 数据库中数据的并发操作经常发生，而对数据的并发操作会带来下面的一些问题： 脏读一个事务读取了另一个未提交事务写入的数据。 不可重复读一个事务重新读取前面读取过的数据，发现该数据已经被另一个已经提交的事务修改。 幻读一个事务重新执行一个查询，返回符合查询条件的行的集合，发现满足查询条件的行的集合因为其它最近提交的事务而发生了改变。 SQL标准定义了四个级别的事务隔离。 | 隔离级别 | 脏读 | 幻读 | 不可重复性读取 || :- | :- ||读未提交 |可能 |可能 |可能||读已提交 |不可能| 可能 |可能||可重复读 |不可能 |可能 |不可能||可串行读 |不可能 |不可能 |不可能| 在PostgreSQL中，可以请求4种隔离级别中的任意一种。但是在内部，实际上只有两种独立的隔离级别，分别对应已提交和可串行化。如果选择了读未提交的级别，实际上使用的是读已提交，在选择可重复读级别的时候，实际上用的是可串行化，所以实际的隔离级别可能比选择的更严格。这是SQL标准允许的：4种隔离级别只定义了哪种现象不能发生，但是没有定义哪种现象一定发生。 PostgreSQL只提供两种隔离级别的原因是，这是把标准的隔离级别与多版本并发控制架构映射相关的唯一合理方法。 读已提交这是PostgreSQL中默认的隔离级别，当一个事务运行在这个隔离级别时，一个SELECT查询只能看到查询开始前已提交的数据，而无法看到未提交的数据或者在查询期间其他的事务已提交的数据。 可串行化可串行化提供最严格的事务隔离。这个级别模拟串行的事务执行，就好像事务是一个接着一个串行的执行。不过，这个级别的应用必须准备在串行化失败的时候重新启动事务。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"PostgreSQL","slug":"数据库/PostgreSQL","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://ysluckly.github.io/tags/PostgreSQL/"}]},{"title":"linux下修改按键ESC<=>CAPSLOCK和Control=>ALT_R","slug":"linux/linux下修改按键ESC-CAPSLOCK和Control-ALT-R","date":"2017-10-20T09:38:49.000Z","updated":"2022-02-25T15:10:38.669Z","comments":true,"path":"2017/10/20/undefined/","link":"","permalink":"https://ysluckly.github.io/2017/10/20/undefined/","excerpt":"","text":"使用 vim 过程中发现 esc 和 ctrl 按键很难按，小拇指没有那么长啊～～，而 caps_lock 和 alt_r(右alt) 很少用。 本教程将 esc 和 caps_lock 两个按键交换， alt_r(右alt) 改为 ctrl。 一、 esc 与 caps_lock 按键交换①. 创建 .xmodmaprc 文件。②. 加入以下内容： remove Lock = Caps_Lock add Lock = Escape keysym Caps_Lock = Escape keysym Escape = Caps_Lock ③. 执行 xmodmap .xmodmaprc 使之生效。 二、 将 右alt 改为 ctrl①. 查看需要修改键位的 keysym通过 xev | grep keycode 获取右 alt 的 keysym 为 Alt_R。如下图所示： ②. 查看 Alt_R 是哪个 modifier 使用的通过 xmodmap -pm 查看，发现 Alt_R 是作为 modifier mod1 使用的。如下图所示： ③. 修改 modifier xmodmap -e &#39;remove mod1 = Alt_R&#39; # 解除原来绑定 xmodmap -e &#39;add control = Alt_R&#39; # 作为 control 使用","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://ysluckly.github.io/tags/vim/"},{"name":"keybord","slug":"keybord","permalink":"https://ysluckly.github.io/tags/keybord/"},{"name":"emacs","slug":"emacs","permalink":"https://ysluckly.github.io/tags/emacs/"},{"name":"linux","slug":"linux","permalink":"https://ysluckly.github.io/tags/linux/"}]},{"title":"[转]字符编解码的故事（ASCII，ANSI，Unicode，Utf-8区别）","slug":"linux/转-字符编解码的故事（ASCII，ANSI，Unicode，Utf-8区别）","date":"2017-09-25T11:15:00.000Z","updated":"2022-02-19T09:27:58.527Z","comments":true,"path":"2017/09/25/ascii-ansi-unicode-utf-8/","link":"","permalink":"https://ysluckly.github.io/2017/09/25/ascii-ansi-unicode-utf-8/","excerpt":"","text":"很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们认为8个开关状态作为原子单位很好，于是他们把这称为”字节”。 再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出更多的状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机”。 开始计算机只在美国用。八位的字节一共可以组合出256（2的8次方）种不同的状态。 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端设备或者打印机遇上这些约定好的字节时，就要做一些约定的动作。遇上 00x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，对于终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20（十进制32）以下的字节状态称为”控制码”。 他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的 文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。 后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们用到的许多字母在ASCII中根本没有，为了也可以在计算机中保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称”扩展字符集”。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！ 等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉，并且规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 中国人民看到这样很不错，于是就把这种汉字方案叫做”GB2312”。GB2312 是对 ASCII 的中文扩展。 但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人（如朱镕基的“镕”字）。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS”（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍： “一个汉字算两个英文字符！一个汉字算两个英文字符……” 因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ 真是计算机的巴比伦塔命题啊！ 正在这时，大天使加百列及时出现了——一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “UNICODE”。 UNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ascii里的那些”半角”字符，UNICODE 包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高 8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。 这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是 的，从 UNICODE 开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”一个字符”！同时，也都是统一的”两个字节”，请注意”字符”和”字节”两个术语的不同， “字节”是一个8位的物理存贮单元，而”字符”则是一个文化相关的符号。在UNICODE 中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。 从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE 对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS 趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE 方式工作的版本，从这时开始，WINDOWS 系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。 但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得 GBK 与UNICODE 在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。 如前所述，UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），这大概可以用到银河联邦成立那一天吧！ UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF16就是每次16个位，只不过为了传输时的可靠性，从UNICODE到 UTF时并不是直接的对应，而是要过一些算法和规则来转换。 受到过网络编程加持的计算机僧侣们都知道，在网络里传递信息时有一个很重要的问题，就是对于数据高低位的解读方式，一些计算机是采用低位先发送的方法，例如我们PC机采用的 INTEL 架构；而另一些是采用高位先发送的方式。在网络中交换数据时，为了核对双方对于高低位的认识是否是一致的，采用了一种很简便的方法，就是在文本流的开始时向对方发送一个标志符——如果之后的文本是高位在位，那就发送”FEFF”，反之，则发送”FFFE”。不信你可以用二进制方式打开一个UTF-X格式的文件，看看开头两个字节是不是这两个字节？ 下面是Unicode和UTF-8转换的规则 Unicode UTF-8 0000 - 007F 0xxxxxxx 0080 - 07FF 110xxxxx 10xxxxxx 0800 - FFFF 1110xxxx 10xxxxxx 10xxxxxx 例如”汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以要用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 1100 0100 1001，将这个比特流按三字节模板的分段方法分为0110 110001 001001，依次代替模板中的x，得到：1110-0110 10-110001 10-001001，即E6 B1 89，这就是其UTF8的编码。 讲到这里，我们再顺便说说一个很著名的奇怪现象：当你在 windows 的记事本里新建一个文件，输入”联通”两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码！呵呵，有人说这就是联通之所以拼不过移动的原因。 其实这是因为GB2312编码与UTF8编码产生了编码冲撞的原因。 当一个软件打开一个文本时，它要做的第一件事是决定这个文本究竟是使用哪种字符集的哪种编码保存的。软件一般采用三种方式来决定文本的字符集和编码： 检测文件头标识，提示用户选择，根据一定的规则猜测 最标准的途径是检测文本最开头的几个字节，开头字节 Charset/encoding,如下表： EF BB BF UTF-8 FF FE UTF-16/UCS-2, little endian FE FF UTF-16/UCS-2, big endian FF FE 00 00 UTF-32/UCS-4, little endian. 00 00 FE FF UTF-32/UCS-4, big-endian. 当你新建一个文本文件时，记事本的编码默认是ANSI（代表系统默认编码，在中文系统中一般是GB系列编码）, 如果你在ANSI的编码输入汉字，那么他实际就是GB系列的编码方式，在这种编码下，”联通”的内码是： c1 1100 0001 aa 1010 1010 cd 1100 1101 a8 1010 1000 注意到了吗？第一二个字节、第三四个字节的起始部分的都是”110”和”10”，正好与UTF8规则里的两字节模板是一致的， 于是当我们再次打开记事本时，记事本就误认为这是一个UTF8编码的文件，让我们把第一个字节的110和第二个字节的10去掉，我们就得到了”00001 101010”，再把各位对齐，补上前导的0，就得到了”0000 0000 0110 1010”，不好意思，这是UNICODE的006A，也就是小写的字母”j”，而之后的两字节用UTF8解码之后是0368，这个字符什么也不是。这就是只有”联通”两个字的文件没有办法在记事本里正常显示的原因。 而如果你在”联通”之后多输入几个字，其他的字的编码不见得又恰好是110和10开始的字节，这样再次打开时，记事本就不会坚持这是一个utf8编码的文件，而会用ANSI的方式解读之，这时乱码又不出现了。","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"encoding","slug":"encoding","permalink":"https://ysluckly.github.io/tags/encoding/"}]},{"title":"搭建dubbo+zookeeper平台","slug":"back-end/搭建dubbo-zookeeper平台","date":"2017-09-25T08:29:07.000Z","updated":"2022-02-20T13:01:31.275Z","comments":true,"path":"2017/09/25/搭建dubbo+zookeeper平台/","link":"","permalink":"https://ysluckly.github.io/2017/09/25/%E6%90%AD%E5%BB%BAdubbo+zookeeper%E5%B9%B3%E5%8F%B0/","excerpt":"","text":"前言本文将介绍在SpringMVC+Spring+Mybatis项目中添加 dubbo 作为 rpc 服务。 文末有项目代码地址。 一.搭建zookeeper使用 docker 一句话创建： docker run -dit --name zookeeper --hostname zookeeper-host -v /data:/data -p 2181:2181 jplock/zookeeper:latest 二.安装zkui（非必须）这个项目为 zookeeper 提供一个 web 的管理界面。当然我们也可以直接在zookeeper中使用命令查看，所以此步骤可以忽略 在开始前需要安装 Java 环境、Maven 环境。 到 zkui 的项目中下载代码。git clone https://github.com/DeemOpen/zkui.git 执行 mvn clean install 生成jar文件。 将config.cfg复制到上一步生成的jar文件所在目录，然后修改配置文件中的zookeeper地址。 执行 nohup java -jar zkui-2.0-SNAPSHOT-jar-with-dependencies.jar &amp; 测试 http://localhost:9090，如果能看到如下页面，表示安装成功。 三.使用dubbo 在原来 SpringMVC+Spring+Mybatis 项目中，除了原来 spring 相关依赖外，还需要加入以下依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.2&lt;/version&gt; &lt;/dependency&gt; 定义服务接口 public interface IPersonService &#123; List&lt;Person&gt; listAll(); Person getById(Integer id); Integer delById(Person person); Integer updatePerson(Person person); &#125; 定义服务实现类 @Service public class PersonService implements IPersonService &#123; @Autowired PersonMapper personMapper; public List&lt;Person&gt; listAll() &#123; return personMapper.findAll(); &#125; public Person getById(Integer id) &#123; return personMapper.findOneById(id); &#125; public Integer delById(Person person) &#123; return personMapper.del(person); &#125; public Integer updatePerson(Person person) &#123; return personMapper.update(person); &#125; &#125; 配置生产者，注册服务信息 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!--定义了提供方应用信息，用于计算依赖关系；--&gt; &lt;dubbo:application name=&quot;demotest-provider&quot; /&gt; &lt;!-- 使用 zookeeper 注册中心暴露服务地址 --&gt; &lt;dubbo:registry address=&quot;zookeeper://192.168.0.86:2181&quot;/&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt; &lt;!-- 和本地bean一样实现服务 --&gt; &lt;bean id=&quot;personService&quot; class=&quot;com.ssm.service.PersonService&quot;/&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;dubbo:service interface=&quot;com.ssm.iservice.IPersonService&quot; ref=&quot;personService&quot;/&gt; &lt;/beans&gt; 配置消费者，订阅服务 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt; &lt;dubbo:application name=&quot;demo-consumer&quot;/&gt; &lt;!-- 使用 zookeeper 注册中心暴露发现服务地址 --&gt; &lt;dubbo:registry address=&quot;zookeeper://192.168.0.86:2181&quot;/&gt; &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt; &lt;dubbo:reference id=&quot;personService&quot; check=&quot;false&quot; interface=&quot;com.ssm.iservice.IPersonService&quot;/&gt; &lt;/beans&gt; 调用远程服务配置完成后，我们就可以像使用本地 bean 一样，使用 rpc 的 service； @Controller public class IndexController &#123; @Autowired IPersonService personService; @RequestMapping(&quot;/index.html&quot;) public String index(Model model) &#123; RpcContext.getContext().setAttachment(&quot;index&quot;, &quot;1&quot;);//测试ThreadLocal List&lt;Person&gt; list = personService.listAll(); model.addAttribute(&quot;command&quot;,list); return &quot;index&quot;; &#125; &#125; 最后至此，单机运行的 rpc 服务已搭建完成。 代码传送文 ssm","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"}],"tags":[{"name":"dubbo","slug":"dubbo","permalink":"https://ysluckly.github.io/tags/dubbo/"},{"name":"zookeeper","slug":"zookeeper","permalink":"https://ysluckly.github.io/tags/zookeeper/"}]},{"title":"docker报错集锦","slug":"linux/docker报错集锦","date":"2017-09-25T02:03:50.000Z","updated":"2022-02-19T09:27:58.517Z","comments":true,"path":"2017/09/25/docker-errors/","link":"","permalink":"https://ysluckly.github.io/2017/09/25/docker-errors/","excerpt":"","text":"docker创建容器1. iptables failed创建 tale 容器时，如下命令： docker run -d --privileged --hostname tale --name tale \\ -v /etc/localtime:/etc/localtime:ro \\ -v /home/tale:/var/tale_home -p 127.0.0.1:234:9000 \\ -m 1024m --memory-swap -1 tale:1.0 然后就报了以下错误： docker: Error response from daemon: driver failed programming external connectivity on endpoint tale (263775ff559176224428ec44dcec416a1c20e6c69198d9760b38f35849914260): iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 127.0.0.1 --dport 234 -j DNAT --to-destination 172.17.0.4:9000 ! -i docker0: iptables: No chain/target/match by that name. (exit status 1). 解决办法：重启 docker 服务： $ service docker restart","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ysluckly.github.io/tags/docker/"}]},{"title":"Hexo加速渲染速度之fragment_cache","slug":"tools/hexo-fragment_cache","date":"2017-09-21T11:34:37.000Z","updated":"2022-02-19T09:27:58.562Z","comments":true,"path":"2017/09/21/hexo-fragment_cache/","link":"","permalink":"https://ysluckly.github.io/2017/09/21/hexo-fragment_cache/","excerpt":"","text":"前文从开发 3-hexo 主题到现在已过去 9 个月时间了，累计在博客中写 132 篇文章了。 现在发现了严重的问题，hexo generate 渲染的速度越来越慢，现在132篇左右，每次渲染时间到达了 50+ s，相当不爽。 今日抽时间，查看了官方api，看到了 fragment_cache 局部缓存这个东西，解决了渲染速度的问题。 使用官方文档局部缓存。它储存局部内容，下次使用时就能直接使用缓存。 &lt;%- fragment_cache(id, fn); %&gt; 替换简单文本区域a. 我们可以将所有页面都一样的区域，如下所示，缓存下来。当下一篇文章在渲染到这个位置时，将不再渲染，直接拿缓存数据。 &lt;%- fragment_cache(&#39;header&#39;, function()&#123; return partial(&#39;&lt;head&gt;&lt;/head&gt;&#39;); &#125;) %&gt; b. 文章模块也可以使用，原来公共引用部分（没有和当前文章耦合的内容）使用下面的方式： &lt;%- partial(&#39;_partial/header&#39;); %&gt; 改进为以下代码： &lt;%- fragment_cache(&#39;header&#39;, function()&#123; return partial(&#39;_partial/header&#39;); &#125;) %&gt; 最后这个语法只适用于所有页面都相同，不随文章内容变化的部分。 作者在 3-hexo 中加入了此语法，渲染132篇文章的速度已从 50+s 到现在 3s 左右了。","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"},{"name":"fragment_cache","slug":"fragment-cache","permalink":"https://ysluckly.github.io/tags/fragment-cache/"}]},{"title":"[转]浏览器前进/后退缓存（BF Cache）","slug":"front-end/bf-cache","date":"2017-09-21T07:35:24.000Z","updated":"2022-02-19T09:27:58.496Z","comments":true,"path":"2017/09/21/bf-cache/","link":"","permalink":"https://ysluckly.github.io/2017/09/21/bf-cache/","excerpt":"","text":"[浏览器前进/后退缓存](https://developer.mozilla.org/en-US/docs/Working_with_BFCache)（Backward/Forward Cache，BF Cache）是指浏览器在前进后退过程中， 会应用更强的缓存策略，表现为 DOM、window、甚至 JavaScript 对象被缓存，以及同步 XHR 也被缓存。 这一现象在移动端浏览器尤为常见，除 Chrome for Android、Android Browser 之外的浏览器基本都会触发。 BF Cache 本来是一项浏览器优化，但在某些情况下（比如前端路由的 Web App）会引起困惑。 本文主要讨论 BF Cache 的行为、如何检测 BF Cache 缓存、以及如何 workaround。 缓存行为BF Cache 是一种浏览器优化，HTML 标准并未指定其如何进行缓存，因此缓存行为是与浏览器实现相关的。 User agents may discard the Document objects of entries other than the current entry that are not referenced from any script, reloading the pages afresh when the user or script navigates back to such pages. This specification does not specify when user agents should discard Document objects and when they should cache them. – Session history and navigation, WHATWG Desktop Chrome：阻塞的资源和同步发出的 XHR 都会被缓存，但不缓存渲染结果。因此可以看到明显的载入过程，此时脚本也会重新执行。 Chrome for Android：有些情况下不会缓存，缓存时与 Desktop Chrome 行为一致。 Desktop Firefox：页面会被 Frozen，定时器会被暂停，DOM、Window、JavaScript 对象会被缓存，返回时页面脚本重新开始运行。 iOS Safari：渲染结果也会被缓存，因此才能支持左右滑动手势来前进/后退。 Desktop Firefox 暂停计时器的行为非常有趣，以下 HTML 中显示一个每秒加一的数字。 当页面导航时就会暂停，返回时继续增加（因此直接使用 setInterval 倒计时不仅不精确，而且不可靠）： &lt;span id=&quot;timer-tick&quot;&gt;&lt;/span&gt; &lt;a href=&quot;http://harttle.com&quot;&gt;External Link&lt;/a&gt; &lt;script&gt; var i = 0 setInterval(() =&gt; document.querySelector(&#39;#timer-tick&#39;).innerHTML = i++, 1000) &lt;/script&gt; pagehide/pageshow 事件会话（Session）中的某一个页面显示/隐藏时，会触发 pagehide 和 pageshow 事件。 这两个事件都有一个 persisted 属性用来指示当前页面是否被 BF Cache 缓存。 因此可以通过 persisted 属性来达到禁用 BF Cache 的效果： window.onpageshow = function(event) &#123; if (event.persisted) &#123; window.location.reload() &#125; &#125;; 注意无论页面是否被缓存 pageshow 总会触发，因此需要检测器 persisted 属性。 另外 pageshow 的时机总是在 load 事件之后。 这一点很容易检测，下面的 pageshow 日志总在 load 之前： window.addEventListener(&#39;pageshow&#39;, function () &#123; console.log(&#39;on pageshow&#39;) &#125;) window.addEventListener(&#39;load&#39;, function () &#123; console.log(&#39;load&#39;) &#125;) XHR 缓存同步（阻塞加载的）脚本发出的 XMLHttpRequest 也会被 Chrome 强制缓存， 因此即使在断网的情况下后退到访问过的页面仍然是可以完美渲染的。 如果页面中有这样一段外部脚本： sendXHR(); function sendXHR () &#123; var xhr = new XMLHttpRequest() xhr.open(&#39;GET&#39;, &#39;/data.json&#39;) xhr.onreadystatechange = function () &#123; if (xhr.readyState === XMLHttpRequest.DONE &amp;&amp; xhr.status === 200) &#123; console.log(&#39;xhr arrived&#39;, xhr.responseText) &#125; &#125; xhr.send() &#125; 超链接跳转后回来，该 xhr 也会被缓存。注意下图中的 XHR 一项 size 为 “from disk cache”： 为了强制发送 xhr，可以将 xhr 改为异步发送，或者加一个不重要的 query。 setTimeout(sendXHR, 1000) 这样就能看到 xhr 真正发送出去了 :) 异步 xhr 缓存时机未经兼容性测试， 还是建议读者使用一个随机产生的 query。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://ysluckly.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://ysluckly.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"js","slug":"js","permalink":"https://ysluckly.github.io/tags/js/"}]},{"title":"解决iphone下后退不执行js的问题","slug":"front-end/解决iphone下后退不执行js的问题","date":"2017-09-21T07:25:32.000Z","updated":"2022-02-19T09:27:58.506Z","comments":true,"path":"2017/09/21/iphone-bf-no-run-js/","link":"","permalink":"https://ysluckly.github.io/2017/09/21/iphone-bf-no-run-js/","excerpt":"","text":"直接上解决方法不论页面是否被缓存，都会触发 pageshow，所以后退后需要执行的方法可以都放在下面事件内： window.addEventListener(&#39;pageshow&#39;, function () &#123; console.log(&#39;on pageshow&#39;) &#125;) 浏览器缓存行为 的详细介绍可以参考： [转]浏览器前进&#x2F;后退缓存（BF Cache）","categories":[{"name":"大前端","slug":"大前端","permalink":"https://ysluckly.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ysluckly.github.io/tags/js/"}]},{"title":"CentOS7使用Firewalld","slug":"linux/CentOS7使用Firewalld","date":"2017-09-19T01:53:53.000Z","updated":"2022-02-19T09:27:58.508Z","comments":true,"path":"2017/09/19/CentOS7使用Firewalld/","link":"","permalink":"https://ysluckly.github.io/2017/09/19/CentOS7%E4%BD%BF%E7%94%A8Firewalld/","excerpt":"","text":"介绍FirewallD 提供了支持网络/防火墙区域(zone)定义网络链接以及接口安全等级的动态防火墙管理工具。它支持 IPv4, IPv6 防火墙设置以及以太网桥接，并且拥有运行时配置和永久配置选项。它也支持允许服务或者应用程序直接添加防火墙规则的接口。 安装$ yum install firewalld # 如果需要图形界面的话，则再安装 $ yum install firewall-config zoneFirewall 能将不同的网络连接归类到不同的信任级别。 $ firewall-cmd --list-all-zones #查看所有zone信息 Zone 提供了以下几个级别： drop: 丢弃所有进入的包，而不给出任何响应 block: 拒绝所有外部发起的连接，允许内部发起的连接 public: 允许指定的进入连接 external: 同上，对伪装的进入连接，一般用于路由转发 dmz: 允许受限制的进入连接 work: 允许受信任的计算机被限制的进入连接，类似 workgroup home: 同上，类似 homegroup internal: 同上，范围针对所有互联网用户 trusted: 信任所有连接 过滤规则 source: 根据源地址过滤 interface: 根据网卡过滤 service: 根据服务名过滤 port: 根据端口过滤 icmp-block: icmp 报文过滤，按照 icmp 类型配置 masquerade: ip 地址伪装 forward-port: 端口转发 rule: 自定义规则 过滤规则的优先级遵循如下顺序 source interface firewalld.conf 使用$ systemctl start firewalld # 启动 $ systemctl stop firewalld # 关闭 $ systemctl enable firewalld # 开机启动 $ systemctl disable firewalld # 取消开机启动 具体的规则管理，可以使用 firewall-cmd,具体的使用方法 $ firewall-cmd --help --zone=NAME # 指定 zone --permanent # 永久修改，--reload 后生效 --timeout=seconds # 持续效果，到期后自动移除，用于调试，不能与 --permanent 同时使用 查看规则查看运行状态 $ firewall-cmd --state 查看已被激活的 Zone 信息 $ firewall-cmd --get-active-zones public interfaces: eth0 eth1 查看指定接口的 Zone 信息 $ firewall-cmd --get-zone-of-interface=eth0 public 查看指定级别的接口 $ firewall-cmd --zone=public --list-interfaces eth0 查看指定级别的所有信息，譬如 public $ firewall-cmd --zone=public --list-all public (default, active) interfaces: eth0 sources: services: dhcpv6-client http ssh ports: masquerade: no forward-ports: icmp-blocks: rich rules: 查看所有级别被允许的信息 $ firewall-cmd --get-service 查看重启后所有 Zones 级别中被允许的服务，即永久放行的服务 $ firewall-cmd --get-service --permanent 管理规则$ firewall-cmd --panic-on # 丢弃 $ firewall-cmd --panic-off # 取消丢弃 $ firewall-cmd --query-panic # 查看丢弃状态 $ firewall-cmd --reload # 更新规则，不重启服务 $ firewall-cmd --complete-reload # 更新规则，重启服务 添加某接口至某信任等级，譬如添加 eth0 至 public，永久修改 $ firewall-cmd --zone=public --add-interface=eth0 --permanent 设置 public 为默认的信任级别 $ firewall-cmd --set-default-zone=public a. 管理端口列出 dmz 级别的被允许的进入端口 $ firewall-cmd --zone=dmz --list-ports 允许 tcp 端口 8080 至 dmz 级别 $ firewall-cmd --zone=dmz --add-port=8080/tcp 允许某范围的 udp 端口至 public 级别，并永久生效 $ firewall-cmd --zone=public --add-port=5060-5059/udp --permanent b. 网卡接口列出 public zone 所有网卡 $ firewall-cmd --zone=public --list-interfaces 将 eth0 添加至 public zone，永久 $ firewall-cmd --zone=public --permanent --add-interface=eth0 eth0 存在与 public zone，将该网卡添加至 work zone，并将之从 public zone 中删除 $ firewall-cmd --zone=work --permanent --change-interface=eth0 删除 public zone 中的 eth0，永久 $ firewall-cmd --zone=public --permanent --remove-interface=eth0 c. 管理服务添加 smtp 服务至 work zone $ firewall-cmd --zone=work --add-service=smtp 移除 work zone 中的 smtp 服务 $ firewall-cmd --zone=work --remove-service=smtp d. 配置 external zone 中的 ip 地址伪装查看 $ firewall-cmd --zone=external --query-masquerade 打开伪装 $ firewall-cmd --zone=external --add-masquerade 关闭伪装 $ firewall-cmd --zone=external --remove-masquerade e. 配置 public zone 的端口转发要打开端口转发，则需要先 $ firewall-cmd --zone=public --add-masquerade 然后转发 tcp 22 端口至 3753 $ firewall-cmd --zone=public --add-forward-port=port=22:proto=tcp:toport=3753 转发 22 端口数据至另一个 ip 的相同端口上 $ firewall-cmd --zone=public --add-forward-port=port=22:proto=tcp:toaddr=192.168.1.100 转发 22 端口数据至另一 ip 的 2055 端口上 $ firewall-cmd --zone=public --add-forward-port=port=22:proto=tcp:toport=2055:toaddr=192.168.1.100 f. 配置 public zone 的 icmp查看所有支持的 icmp 类型 $ firewall-cmd --get-icmptypes destination-unreachable echo-reply echo-request parameter-problem redirect router-advertisement router-solicitation source-quench time-exceeded 列出 $ firewall-cmd --zone=public --list-icmp-blocks 添加 echo-request 屏蔽 $ firewall-cmd --zone=public --add-icmp-block=echo-request [--timeout=seconds] 移除 echo-reply 屏蔽 $ firewall-cmd --zone=public --remove-icmp-block=echo-reply g. IP 封禁 $ firewall-cmd --permanent --add-rich-rule=&quot;rule family=&#39;ipv4&#39; source address=&#39;222.222.222.222&#39; reject&quot; 当然，我们仍然可以通过 ipset 来封禁 ip 封禁 ip $ firewall-cmd --permanent --zone=public --new-ipset=blacklist --type=hash:ip $ firewall-cmd --permanent --zone=public --ipset=blacklist --add-entry=222.222.222.222 封禁网段 $ firewall-cmd --permanent --zone=public --new-ipset=blacklist --type=hash:net $ firewall-cmd --permanent --zone=public --ipset=blacklist --add-entry=222.222.222.0/24 倒入 ipset 规则 $ firewall-cmd --permanent --zone=public --new-ipset-from-file=/path/blacklist.xml 然后封禁 blacklist $ firewall-cmd --permanent --zone=public --add-rich-rule=&#39;rule source ipset=blacklist drop&#39; 重新载入以生效 $ firewall-cmd --reload","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"firewall","slug":"firewall","permalink":"https://ysluckly.github.io/tags/firewall/"}]},{"title":"docker备份恢复之save与export","slug":"linux/docker-save-与-docker-export","date":"2017-09-18T14:38:52.000Z","updated":"2022-02-19T09:27:58.513Z","comments":true,"path":"2017/09/18/docker-save-export/","link":"","permalink":"https://ysluckly.github.io/2017/09/18/docker-save-export/","excerpt":"","text":"docker save导出docker save 命令用于持久化 镜像，先获得镜像名称，再执行保存： # 通过此命令查出要持久化的镜像名称 $ docker images # 持久化镜像名为 image_name 的镜像， $ docker save image_name -o ~/save.tar 注意： 如果镜像是在远程仓库，执行保存镜像的时候可能会报 Cowardly refusing to save to a terminal. Use the -o flag or redirect. 的错，可以通过 docker save image_name &gt; image_name.tar 将镜像从远程仓库持久化到本地。 导入# 导入 save.tar $ docker load &lt; ~/save.tar # 查看镜像 $ docker images images docker export导出docker export 命令用于持久化 容器，先获取容器ID，再执行保存。 # 通过此命令查出要持久化的容器ID $ docker ps -a # 持久化容器id为 container_id 的容器 $ docker export container_id &gt; ~/export.tar 导入# 从 export.tar 导入镜像 $ cat ~/export.tar | docker import - my-images:latest # 查看镜像 $ sudo docker images 不同通过 sudo docker images --tree 可以查看到镜像的所有层，就会发现， docker export 丢失了所有的历史，而docker save 则会保存所有历史。","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ysluckly.github.io/tags/docker/"}]},{"title":"sudo命令免密码设置","slug":"linux/sudo命令免密码设置","date":"2017-09-11T01:30:55.000Z","updated":"2022-02-19T09:27:58.523Z","comments":true,"path":"2017/09/11/sudo命令免密码设置/","link":"","permalink":"https://ysluckly.github.io/2017/09/11/sudo%E5%91%BD%E4%BB%A4%E5%85%8D%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"如果某台linux只有自己在使用，比如个人系统，每次调用 sudo 时都需要输入密码，长期下来着实厌烦，因此本文介绍如何配置 sudo 命令，使其在运行时不需要输入密码。 步骤 执行命令 $ sudo visudo 添加以下两行， 下面的 sys 表示 sys 组成员不用密码使用sudo aaronkilik ALL=(ALL) NOPASSWD: ALL %sys ALL=(ALL) NOPASSWD: ALL 现在在使用 sudo 命令， 将不再需要输入密码。 扩展如果只允许用户使用 kill 和 rm 命令时，不需要输入密码，见如下配置 %sys ALL=(ALL) NOPASSWD: /bin/kill, /bin/rm","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://ysluckly.github.io/tags/linux/"}]},{"title":"搭建Maven私服-Nexus","slug":"linux/搭建Maven私服-Nexus","date":"2017-09-06T15:01:31.000Z","updated":"2022-02-19T09:27:58.525Z","comments":true,"path":"2017/09/06/build-Maven-Nexus/","link":"","permalink":"https://ysluckly.github.io/2017/09/06/build-Maven-Nexus/","excerpt":"","text":"Maven 私服，可以代理远程仓库和部署自己或第三方构件。本文介绍使用最广泛搭建 Maven 私服的工具： Sonatype Nexus。 作者环境 本次搭建私服是在局域网的一台服务器上，操作系统为 CentOS 。 需要部署到私服的项目 soul ssm 项目需要引用 soul 安装Java 确保服务器已经安装了 java 环境，这个过程不是本文重点，安装过程自行百度。 安装Nexus 官网 pro 版本的是需要付费的。所以我们使用免费的 OSS 版本，下载地址 (https://www.sonatype.com/download-oss-sonatype) # 上传到服务器并解压 $ tar xvf nexus-3.5.1-02-unix.tar.gz 启动Nexus# 启动服务 $ cd /nexus-3.5.1-02/bin/ $ ./nexus start 验证打开网址：(http://192.168.0.86:8081/) , ip 为搭建私服的服务器 ip 。用户名/密码： admin/admin123出现一下画面，就说明安装成功了。 发布soul项目到私服创建仓库 创建yelog-release仓库（名字自定义）, type选择 ： release 创建yelog-snapshot仓库（名字自定义）， type选择 ： snapshot重复上面 ① 和 ② 步，根据下图选择类型: 两个都创建完成后，效果如下： pom中添加部署配置url 复制上图中新建的仓库的 copy 按钮，复制url。 &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;yelog-release&lt;/id&gt; &lt;name&gt;Release Repository of yelog&lt;/name&gt; &lt;url&gt;http://192.168.0.86:8081/repository/yelog-release/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;yelog-snapshot&lt;/id&gt; &lt;name&gt;Snapshot Repository of yelog&lt;/name&gt; &lt;url&gt;http://192.168.0.86:8081/repository/yelog-snapshot/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; 在maven的 settings.xml 中配置这里配置 maven 的账号密码，id 要与 distributionManagement 中的id一致。默认账号/密码：admin/admin123 &lt;servers&gt; &lt;server&gt; &lt;id&gt;yelog-realease&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;yelog-snapshot&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; 执行maven命令部署项目到私服上我这里直接使用IDE的插件执行部署完成后，可以在 yelog-snapshot 仓库中，查看部署的情况，如下图所示 从私服拉去依赖库 上一步我们已经将项目 soul 部署到私服上了，这一步介绍项目 ssm 如何依赖引用 soul。私服中的 maven-central 可以链接远程仓库。这样，当有依赖在私服中找不到后，就可以通过远程仓库自动下载依赖。 pom 文件中添加如下配置 public库成员仓库中添加我们自定义的仓库 配置远程仓库为私服地址。&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;public Repository&lt;/name&gt; &lt;url&gt;http://192.168.0.86:8081/repository/maven-public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;url&gt;http://192.168.0.86:8081/repository/maven-public/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; 引入依赖&lt;dependency&gt; &lt;groupId&gt;org.soul&lt;/groupId&gt; &lt;artifactId&gt;commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; ssm项目就可以引用到soul代码 本文结束。","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ysluckly.github.io/tags/java/"},{"name":"maven","slug":"maven","permalink":"https://ysluckly.github.io/tags/maven/"},{"name":"nexus","slug":"nexus","permalink":"https://ysluckly.github.io/tags/nexus/"}]},{"title":"Mybatis常用Mapper语句","slug":"database/mybatis-Mapper","date":"2017-08-04T07:54:47.000Z","updated":"2022-02-19T09:27:58.493Z","comments":true,"path":"2017/08/04/mybatis-Mapper/","link":"","permalink":"https://ysluckly.github.io/2017/08/04/mybatis-Mapper/","excerpt":"","text":"插入/* 简单插入 */ &lt;insert id=&quot;insertOne&quot; parameterType=&quot;Person&quot;&gt; insert into person (id, name, age) VALUES(#&#123;id&#125;, #&#123;name&#125;, #&#123;age&#125;); &lt;/insert&gt; /* 插入并返回对象的主键（数据库序列） */ &lt;insert id=&quot;insertOne&quot; parameterType=&quot;Person&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into person (name, age) VALUES(#&#123;name&#125;, #&#123;age&#125;); &lt;/insert&gt; 更新/* 简单更新 */ &lt;update id=&quot;updateName&quot;&gt; update person set name = #&#123;name&#125; where id = #&#123;id&#125;; &lt;/update&gt; /* 更新值并返回 */ &lt;select id=&quot;updateAge&quot; parameterType=&quot;Person&quot;&gt; update person set age = age + #&#123;age&#125; where id = #&#123;id&#125; returning age; &lt;/select&gt; 插入或更新记录玩家在某种类型游戏下的统计记录： 如果没有记录，则从插入，count字段为1；如果有记录，则更新count字段+1； 方式一 &lt;insert id=&quot;addCount&quot; parameterType=&quot;CountRecord&quot;&gt; /*如果有记录，则更新；无记录，则noting*/ update count_record set &quot;count&quot; = &quot;count&quot;+1 where type_id = #&#123;typeId&#125; and user_id = #&#123;userId&#125;; /*如果有记录，则noting；无记录，则插入*/ insert into count_record(type_id, user_id, &quot;count&quot;) select #&#123;typeId&#125;, #&#123;userId&#125;, 1 where not exists (select * from count where type_id = #&#123;typeId&#125; and user_id = #&#123;userId&#125;); &lt;/insert&gt; 方式二 /* 利用 PostgreSQL 的 conflic 特性 */ &lt;insert id=&quot;addCount&quot; parameterType=&quot;CountRecord&quot;&gt; insert into count_record(type_id, user_id, &quot;count&quot;) VALUES (#&#123;typeId&#125;, #&#123;userId&#125;, #&#123;count&#125;) on conflict(type_id,user_id) do update set &quot;count&quot; = count_record.&quot;count&quot; + 1 &lt;/insert&gt;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://ysluckly.github.io/tags/mybatis/"}]},{"title":"MathJax适配Pjax","slug":"tools/MathJax-pjax","date":"2017-07-05T11:24:10.000Z","updated":"2022-02-19T09:27:58.549Z","comments":true,"path":"2017/07/05/MathJax-pjax/","link":"","permalink":"https://ysluckly.github.io/2017/07/05/MathJax-pjax/","excerpt":"","text":"hexo 添加 MathJax 的过程网上很多，这里就不细讲，这里贴一张写的不错的文章 Hexo博客(13)添加MathJax数学公式渲染 由于 3-hexo 这个主题使用了 pjax ，刷新和第一次加载没有问题，但是点到其他文章，再点回来，渲染就无效了。 这个问题和之前适配多说和高亮时，是同样的问题，只需要在下面配置即可。 $(document).on(&#123; /*pjax请求回来页面后触发的事件*/ &#39;pjax:end&#39;: function () &#123; /*渲染MathJax数学公式*/ $.getScript(&#39;//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&#39;,function () &#123; MathJax.Hub.Typeset(); &#125;); &#125; &#125;); 这样就解决了pjax的适配问题。","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"mathjax","slug":"mathjax","permalink":"https://ysluckly.github.io/tags/mathjax/"},{"name":"pjax","slug":"pjax","permalink":"https://ysluckly.github.io/tags/pjax/"}]},{"title":"3-hexo配置MathJax数学公式渲染","slug":"tools/3-hexo-mathjax","date":"2017-07-05T07:09:42.000Z","updated":"2022-02-19T09:27:58.542Z","comments":true,"path":"2017/07/05/3-hexo-mathjax/","link":"","permalink":"https://ysluckly.github.io/2017/07/05/3-hexo-mathjax/","excerpt":"","text":"在用 markdown 写文档时，免不了碰到数学公式。 处理hexo的MarkDown渲染器与MathJax的冲突由于hexo的MarkDown渲染器与MathJax有冲突，所以在使用之前需要修改两个地方。 编辑 node_modules\\marked\\lib\\marked.js 脚本 将451行 ，这一步取消了对 \\\\,\\&#123;,\\&#125; 的转义(escape)escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()# +\\-.!_&gt;])/, 改为 escape: /^\\\\([`*\\[\\]()# +\\-.!_&gt;])/, 将459行，这一步取消了对斜体标记 _ 的转义em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 改为 em:/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 开启MathJax修改 3-hexo/_config.yml # MathJax 数学公式支持 mathjax: on: true #是否启用 per_page: false # 若只渲染单个页面，此选项设为false，页面内加入 mathjax: true 考虑到页面的加载速度，支持渲染单个页面。 设置 per_page: false ,在需要渲染的页面内 加入 mathjax: true 这样，就可以在页面内写MathJax公式了。 MathJax公式书写公式书写依然按照MarkDown语法来，基本上也和LaTeX相同，单 $ 符引住的是行内公式，双$符引住的是行间公式。 MathJax公式书写参考MathJax basic tutorial and quick reference 1.MathJax行内公式含有下划线 _ 的公式 $x_mu$ ： $x_mu$ 希腊字符 $\\sigma$ ： $\\sigma$ 双 \\\\ 公式内换行 $$ f(n) = \\begin&#123;cases&#125; n/2, &amp; \\text&#123;if $n$ is even&#125; \\\\ 3n+1, &amp; \\text&#123;if $n$ is odd&#125; \\end&#123;cases&#125; $$ $$f(n) =\\begin{cases}n/2, &amp; \\text{if $n$ is even} \\3n+1, &amp; \\text{if $n$ is odd}\\end{cases}$$ 行内公式 $y=ax+b$：$y=ax+b$ 行内公式 $\\cos 2\\theta = \\cos^2 \\theta - \\sin^2 \\theta = 2 \\cos^2 \\theta$：$\\cos 2\\theta = \\cos^2 \\theta - \\sin^2 \\theta = 2 \\cos^2 \\theta$ 行内公式 $M(\\beta^&#123;\\ast&#125;(D),D) \\subseteq C$ ： $M(\\beta^{\\ast}(D),D) \\subseteq C$ 2.MathJax行间公式行间公式$$ \\sum_&#123;i=0&#125;^n i^2 = \\frac&#123;(n^2+n)(2n+1)&#125;&#123;6&#125; $$：$$ \\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6} $$ 行间公式$$ x = \\dfrac&#123;-b \\pm \\sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$：$$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 3.MathJax公式自动编号书写时使用 $$ \\begin&#123;equation&#125; \\end&#123;equation&#125; $$ 进行公式自动编号，同时会自动连续编号，例如： $$ \\begin&#123;equation&#125; \\sum_&#123;i=0&#125;^n F_i \\cdot \\phi (H, p_i) - \\sum_&#123;i=1&#125;^n a_i \\cdot ( \\tilde&#123;x_i&#125;, \\tilde&#123;y_i&#125;) + b_i \\cdot ( \\tilde&#123;x_i&#125;^2 , \\tilde&#123;y_i&#125;^2 ) \\end&#123;equation&#125; $$ $$ \\begin&#123;equation&#125; \\beta^*(D) = \\mathop&#123;argmin&#125; \\limits_&#123;\\beta&#125; \\lambda &#123;||\\beta||&#125;^2 + \\sum_&#123;i=1&#125;^n max(0, 1 - y_i f_&#123;\\beta&#125;(x_i)) \\end&#123;equation&#125; $$ $$\\begin{equation}\\sum_{i=0}^n F_i \\cdot \\phi (H, p_i) - \\sum_{i=1}^n a_i \\cdot ( \\tilde{x_i}, \\tilde{y_i}) + b_i \\cdot ( \\tilde{x_i}^2 , \\tilde{y_i}^2 )\\end{equation}$$$$\\begin{equation}\\beta^*(D) = \\mathop{argmin} \\limits_{\\beta} \\lambda {||\\beta||}^2 + \\sum_{i=1}^n max(0, 1 - y_i f_{\\beta}(x_i))\\end{equation}$$ MathJax公式手动编号可以在公式书写时使用 \\tag&#123;手动编号&#125; 添加手动编号，例如： $$ \\begin&#123;equation&#125; \\sum_&#123;i=0&#125;^n F_i \\cdot \\phi (H, p_i) - \\sum_&#123;i=1&#125;^n a_i \\cdot ( \\tilde&#123;x_i&#125;, \\tilde&#123;y_i&#125;) + b_i \\cdot ( \\tilde&#123;x_i&#125;^2 , \\tilde&#123;y_i&#125;^2 ) \\tag&#123;1.2.3&#125; \\end&#123;equation&#125; $$ $$\\begin{equation}\\sum_{i=0}^n F_i \\cdot \\phi (H, p_i) - \\sum_{i=1}^n a_i \\cdot ( \\tilde{x_i}, \\tilde{y_i}) + b_i \\cdot ( \\tilde{x_i}^2 , \\tilde{y_i}^2 ) \\tag{1.2.3}\\end{equation}$$ 不加 \\begin&#123;equation&#125; \\end&#123;equation&#125; 也可以，例如： $$ \\beta^*(D) = \\mathop&#123;argmin&#125; \\limits_&#123;\\beta&#125; \\lambda &#123;||\\beta||&#125;^2 + \\sum_&#123;i=1&#125;^n max(0, 1 - y_i f_&#123;\\beta&#125;(x_i)) \\tag&#123;我的公式3&#125; $$ $$\\beta^*(D) = \\mathop{argmin} \\limits_{\\beta} \\lambda {||\\beta||}^2 + \\sum_{i=1}^n max(0, 1 - y_i f_{\\beta}(x_i)) \\tag{我的公式3}$$ 行内公式加\\tag{}后会自动成为行间公式，例如： $z = (p_0, ..... , p_n) \\tag&#123;公式21&#125; $$z = (p_0, ….. , p_n) \\tag{公式21} $ 4.其他公式书写技巧如何将下标放到正下方？① 如果是数学符号，那么直接用 \\limits 命令放在正下方，如Max函数下面的取值范围，需要放在Max的正下方。可以如下实现：$ \\max \\limits_&#123;a&lt;x&lt;b&#125;\\&#123;f(x)\\&#125; $$ \\max \\limits_{a&lt;x&lt;b}{f(x)} $ ② 若是普通符号，那么要用 \\mathop 先转成数学符号再用 \\limits，如$ \\mathop&#123;a&#125;\\limits_&#123;i=1&#125; $$ \\mathop{a}\\limits_{i=1} $ MathJax矩阵输入无括号矩阵： $$ \\begin&#123;matrix&#125; 1 &amp; x &amp; x^2 \\\\ 1 &amp; y &amp; y^2 \\\\ 1 &amp; z &amp; z^2 \\\\ \\end&#123;matrix&#125; $$ $$\\begin{matrix}1 &amp; x &amp; x^2 \\1 &amp; y &amp; y^2 \\1 &amp; z &amp; z^2 \\\\end{matrix}$$ 有括号有竖线矩阵： $$ \\left[ \\begin&#123;array&#125;&#123;cc|c&#125; 1&amp;2&amp;3\\\\ 4&amp;5&amp;6 \\end&#123;array&#125; \\right] $$ $$\\left[ \\begin{array}{cc|c} 1&amp;2&amp;3\\ 4&amp;5&amp;6 \\end{array}\\right]$$ 行内小矩阵：$\\bigl( \\begin&#123;smallmatrix&#125; a &amp; b \\\\ c &amp; d \\end&#123;smallmatrix&#125; \\bigr)$$\\bigl( \\begin{smallmatrix} a &amp; b \\ c &amp; d \\end{smallmatrix} \\bigr)$ 这里有个问题，上面的写法在矩阵内没有换行，我看了下源码，双反斜杠\\又被MarkDown渲染引擎转义为单个反斜杠了，解决方法是写三个反斜杠\\\\或在双反斜杠后换行即可： $\\bigl( \\begin&#123;smallmatrix&#125; a &amp; b \\\\\\ c &amp; d \\end&#123;smallmatrix&#125; \\bigr)$$\\bigl( \\begin{smallmatrix} a &amp; b \\\\ c &amp; d \\end{smallmatrix} \\bigr)$ 参考Hexo博客(13)添加MathJax数学公式渲染在Hexo中渲染MathJax数学公式MathJax basic tutorial and quick reference","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"mathjax","slug":"mathjax","permalink":"https://ysluckly.github.io/tags/mathjax/"}]},{"title":"CentOS7安装配置匿名访问Samba","slug":"linux/CentOS7-安装配置匿名访问Samba","date":"2017-07-03T11:40:14.000Z","updated":"2022-02-19T09:27:58.507Z","comments":true,"path":"2017/07/03/CentOS7-anonymous-Samba/","link":"","permalink":"https://ysluckly.github.io/2017/07/03/CentOS7-anonymous-Samba/","excerpt":"","text":"介绍 Samba，是种用来让UNIX系列的操作系统与微软Windows操作系统的SMB/CIFS（Server Message Block/Common Internet File System）网络协议做链接的自由软件 –wikipedia 本文就以 CentOS7 搭建 Samba 匿名完全访问（读/写）为目标，实现一个局域网内的文件共享平台。 1.安装Samba服务使用 yum 工具进行安装 $ yum install samba samba-client 2.检查是否安装成功$ rpm -qa | grep samba 3.防火墙开放端口在 /etc/sysconfig/iptables 中添加配置 -A INPUT -p tcp -m state --state NEW -m tcp --dport 137 -j ACCEPT -A INPUT -p tcp -m state --state NEW -m tcp --dport 138 -j ACCEPT -A INPUT -p tcp -m state --state NEW -m tcp --dport 139 -j ACCEPT -A INPUT -p tcp -m state --state NEW -m tcp --dport 389 -j ACCEPT -A INPUT -p tcp -m state --state NEW -m tcp --dport 445 -j ACCEPT -A INPUT -p tcp -m state --state NEW -m tcp --dport 901 -j ACCEPT 重启 iptables 服务 $ service iptables restart 设置开机自启动 $ chkconfig --level 35 smb on 4.共享配置Samba Server的验证方式有四种： share：匿名访问共享，不需要提供用户名和口令, 安全性能较低。 user：共享目录只能被授权的用户访问,由Samba Server负责检查账号和密码的正确性。账号和密码要在本Samba Server中建立。 server：依靠其他Windows Server或Samba Server来验证用户的账号和密码,是一种代理验证。此种安全模式下,系统管理员可以把所有的Windows用户和口令集中到一个Server系统上,使用 Windows Server进行Samba认证, 远程服务器可以自动认证全部用户和口令,如果认证失败,Samba将使用用户级安全模式作为替代的方式。 domain：域安全级别,使用主域控制器(PDC)来完成认证。 创建一个匿名共享访问，需要使用share模式，但在CentOS安装的samba4中share 和 server验证方式已被弃用 配置如下： [global] workgroup = MYGROUP server string = Samba Server Version %v log file = /var/log/samba/log.%m max log size = 50 security = user map to guest = Bad User load printers = yes cups options = raw [share] comment = share path = /home/samba directory mask = 0777 create mask = 0777 #不可视目录 #browseable = yes guest ok=yes writable=yes 创建 /home/samba 共享目录 $ mkdir /home/samba 重启 smb 服务 $ service smb restart 检查服务是否在运行 $ pgrep smbd 检查配置参数 $ testparm Load smb config files from /etc/samba/smb.conf Processing section &quot;[share]&quot; Loaded services file OK. Server role: ROLE_STANDALONE Press enter to see a dump of your service definitions # Global parameters [global] server string = Samba Server Version %v workgroup = MYGROUP log file = /var/log/samba/log.%m max log size = 50 map to guest = Bad User security = USER idmap config * : backend = tdb cups options = raw [share] comment = share path = /home/samba create mask = 0777 directory mask = 0777 guest ok = Yes read only = No 访问以上就配置完成，如服务器地址为192.168.0.87 windows 系统访问，直接运行 \\\\192.168.0.87\\share linux 系统访问， smb://192.168.0.87/share 遇到的问题 linux 系统可以正常读写修改，但 windows 系统只可以读写，直接打开修改时就，就为只读文件了。 *解决办法**：修改 /etc/samba/smb.conf ,在 [share] 中加入以下内容create mask = 0777 访问部分文件可以正常访问，但部分文件无法访问。 *解决方法**：修改文件访问权限$ chmod -R 1777 /home/samba $ chown nobody:nobody 参考 CentOS7 安装Samba服务 CentOS7 安装配置匿名访问Samba","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"samba","slug":"samba","permalink":"https://ysluckly.github.io/tags/samba/"}]},{"title":"完美替代多说-gitment","slug":"tools/gitment","date":"2017-06-26T04:08:13.000Z","updated":"2022-02-19T09:27:58.560Z","comments":true,"path":"2017/06/26/gitment/","link":"","permalink":"https://ysluckly.github.io/2017/06/26/gitment/","excerpt":"","text":"自从多说要停止服务时，就开始关注第三方评论系统，现在的评论系统都有这样或那样的问题，见 关于第三方评论系统 。忽然看到作者 孙士权 的一片文章 Gitment：使用 GitHub Issues 搭建评论系统 。 立即就将 gitment 集成到 3-hexo 主题内。本篇文章只讲在 3-hexo 内如何使用，如果想自定义，可以参考上面原文。 注册 OAuth Application点击此处 来注册一个新的 OAuth Application。其他内容可以随意填写，但要确保填入正确的 callback URL（一般是评论页面对应的域名，如 http://yelog.org）。 使用 gitment 评论系统修改主题 _config.yml gitment: on: true # 启用gitment评论系统 owner: yelog # 你的github账号 repo: yelog.github.io # 评论issue保存的仓库，我选择保存在blog仓库，也可以新建一个仓库 client_id: d64ceca0d8a4e8b1f5c9 # 上一步注册后生成的client_id client_secret: fb17d5f0aba31372f61a03df707bb20a39a73a06 # 上一步注册后生成的client_secret 部署并初始化1.发布 hexo $ hexo clear &amp;&amp; hexo g &amp;&amp; hexo d 2.打开发布的blog，登录github账号，并点击 Initialize Comments。 3.现在其他人就可以进行评论了 感受整体评论系统做的简洁，整体来说是个不错的系统。","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"}]},{"title":"解决粘贴到vim缩进错乱问题","slug":"linux/解决粘贴到vim缩进错乱问题","date":"2017-06-01T11:45:24.000Z","updated":"2022-02-19T09:27:58.526Z","comments":true,"path":"2017/06/01/vim-paste/","link":"","permalink":"https://ysluckly.github.io/2017/06/01/vim-paste/","excerpt":"","text":"遇见当我使用vim，想要粘贴下面这段脚本到 xx.sh 文件中 #!/bin/bash if [ $1 ] then if [ $1 == &quot;help&quot; ]; then echo -e &quot;\\033[37m pay 参数1 [参数2] \\033[0m&quot; else if [ $2 ]; then filename = $2 fi fi else echo -e &quot;\\033[37m 缺少关键词，通过&#39;pay help&#39;查看帮助信息 \\033[0m&quot; fi 却出现了错乱,如下图所示 分析vim 没有相应的程序来处理这个从其他应用复制粘贴的过程，所以Vim通过插入键盘输入的buffer来模拟这个粘贴的过程，这个时候Vim会以为这是用户输入的。 所以问题是：当上一行结束，光标进入下一行时Vim会自动以上一行的的缩进为初始位置。这样就会破坏原始文件的缩进。 解决问题经过一番google，发现vim提供了 paste 选项，进入 paste 模式后，就可以正常缩进了。 # 进入 paste 模式 :set paste # 退出 paste 模式 :set nopaste 如果不想每次都执行这个命令，可以在 ～/.vimrc 中添加一行配置 set pastetoggle=&lt;F12&gt; ，这样就可以通过F12快速在paste模式中切换。","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://ysluckly.github.io/tags/vim/"}]},{"title":"进入docker容器命令制作","slug":"linux/进入docker容器命令制作","date":"2017-06-01T09:25:11.000Z","updated":"2022-02-19T09:27:58.528Z","comments":true,"path":"2017/06/01/entering-docker/","link":"","permalink":"https://ysluckly.github.io/2017/06/01/entering-docker/","excerpt":"","text":"通过attach进入容器# 进入容器（Docker自带的命令） $ sudo docker attach [name] 通过这命令进入容器后，执行ctrl+d退出容器后发现容器也停止了。所以可以通过 先按，ctrl+p 再按，ctrl+q 退出 制作进入容器的命令既然attach退出很麻烦，一不小心容器就down掉了 通过 docker exec 进入容器是安全的，但是命令过长 所以我们可以通过下面操作，简化命令 1.创建文件 /usr/bin/ctn,内容如下 docker exec -it $1 /bin/bash 2.检查环境变量有没有配置目录 /usr/bin $PATH bash: /usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games: No such file or directory 配置环境变量的方式自行百度 3.完成上面两步即可通过命令 ctn 进入容器 $ ctn [name] 注意：如果是使用非root账号创建的命令，而docker命令是root权限，可能会存在权限问题可以设置 chmod 777 /usr/bin/ctn 设置权限使用 sudo ctn [name] 即可进入容器 4.自动补全docker名使用上面命令时，docker的名字都是手动输入，很麻烦，而且容易出错。 我们可以借助complete命令，来补全docker信息。 在~/.bashrc(作用于当前用户，如果所有用户，修改/etc/bashrc)文件中添加一行 # ctn auto complete complete -W &quot;$(docker ps --format &quot;&#123;&#123;.Names&#125;&#125;&quot;)&quot; ctn 再执行 source .bashrc 使之生效。 这样我们输入 ctn 后，按 Tab 就会提示或自动补全了。 注意： 由于提示的docker名是 .bashrc 生效时的列表，所以如果之后docker列表有变动，需重新执行 source .bashrc 使之更新提示列表","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ysluckly.github.io/tags/docker/"}]},{"title":"tale博客搭建及体验","slug":"tools/tale-build-experience","date":"2017-05-24T03:29:30.000Z","updated":"2022-02-19T09:27:58.569Z","comments":true,"path":"2017/05/24/tale-build-experience/","link":"","permalink":"https://ysluckly.github.io/2017/05/24/tale-build-experience/","excerpt":"","text":"不久之前在逛blog时，发现了这款tale，今天抽空搭建了一下，将搭建过程写于此。demo website：https://tale.biezhi.me 搭建思路看了tale作者的(github)[https://github.com/otale] 发现有建好docker，所以果断使用docker搭建tale的环境 构建docker镜像下载tale-docker到本地。 # 下载官方Dockerfile $ git clone https://github.com/otale/tale-docker.git # 构建 tale 镜像 $ docker build -t tale:1.0 . 下载tale博客文件# 下载压缩包 $ sudo wget http://7xls9k.dl1.z0.glb.clouddn.com/tale.zip # 讲解压出来的文件夹移入home目录 $ unzip tale.zip $ mv tale /home 构建tale镜像docker run -d --privileged --hostname tale --name tale \\ -v /etc/localtime:/etc/localtime:ro \\ -v /home/tale:/var/tale_home -p 80:9000 \\ -m 1024m --memory-swap -1 tale:1.0 访问浏览器进入 127.0.0.1 即可访问 体验管理后台 文章支持Markdown和富文本。 文章/评论/友链/标签管理/主题，设置简单，一目了然 支持插件扩展 博客 主题简洁（当然支持切换主题） 使用 instantclick ，页面切换流畅 评论系统，简洁易用 搜索只支持文章标题 整体 管理简单方便 使用docker后，迁移数据也方便 主题还不是很多 对于常年使用静态blog，手动渲染/发布，使用这个之后还有点小清新。 最后tale整体不错，值得入手。 不过目前没有笔者喜欢的主题（当然默认主题也不错），暂时不打算更换blog，笔者也打算过一段时间开发一个tale的主题，然后正式迁入tale。","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"软件记录","slug":"工具/软件记录","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"tale","slug":"tale","permalink":"https://ysluckly.github.io/tags/tale/"}]},{"title":"docker数据管理","slug":"linux/docker数据管理","date":"2017-05-23T13:43:06.000Z","updated":"2022-02-19T09:27:58.518Z","comments":true,"path":"2017/05/23/docker-data-manager/","link":"","permalink":"https://ysluckly.github.io/2017/05/23/docker-data-manager/","excerpt":"","text":"数据卷数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性： 数据卷可以在容器之间共享和重用 对数据卷的修改会立马生效 对数据卷的更新，不会影响镜像 数据卷默认会一直存在，即使容器被删除 注意：数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷。 创建一个数据卷在用 docker run 命令的时候，使用 -v 标记来创建一个数据卷并挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。 下面创建一个名为 web 的容器，并加载一个数据卷到容器的 /webapp 目录。 $ sudo docker run -d -P --name web -v /webapp training/webapp python app.py 注意：也可以在 Dockerfile 中使用 VOLUME 来添加一个或者多个新的卷到由该镜像创建的任意容器。 删除数据卷数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。无主的数据卷可能会占据很多空间，要清理会很麻烦。Docker官方正在试图解决这个问题，相关工作的进度可以查看这个PR。 挂载一个主机目录作为数据卷使用 -v 标记也可以指定挂载一个本地主机的目录到容器中去。 $ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py 上面的命令加载主机的 /src/webapp 目录到容器的 /opt/webapp 目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。 注意：Dockerfile 中不支持这种用法，这是因为 Dockerfile 是为了移植和分享用的。然而，不同操作系统的路径格式不一样，所以目前还不能支持。 Docker 挂载数据卷的默认权限是读写，用户也可以通过 :ro 指定为只读。 $ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py 加了 :ro 之后，就挂载为只读了。 查看数据卷的具体信息在主机里使用以下命令可以查看指定容器的信息 $ docker inspect web 在输出的内容中找到其中和数据卷相关的部分，可以看到所有的数据卷都是创建在主机的/var/lib/docker/volumes/下面的 &quot;Volumes&quot;: &#123; &quot;/webapp&quot;: &quot;/var/lib/docker/volumes/fac362...80535&quot; &#125;, &quot;VolumesRW&quot;: &#123; &quot;/webapp&quot;: true &#125; ... 注：从Docker 1.8.0起，数据卷配置在”Mounts”Key下面，可以看到所有的数据卷都是创建在主机的/mnt/sda1/var/lib/docker/volumes/….下面了。 &quot;Mounts&quot;: [ &#123; &quot;Name&quot;: &quot;b53ebd40054dae599faf7c9666acfe205c3e922fc3e8bc3f2fd178ed788f1c29&quot;, &quot;Source&quot;: &quot;/mnt/sda1/var/lib/docker/volumes/b53ebd40054dae599faf7c9666acfe205c3e922fc3e8bc3f2fd178ed788f1c29/_data&quot;, &quot;Destination&quot;: &quot;/webapp&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;&quot; &#125; ] ... 挂载一个本地主机文件作为数据卷-v 标记也可以从主机挂载单个文件到容器中 $ sudo docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash 这样就可以记录在容器输入过的命令了。 注意：如果直接挂载一个文件，很多文件编辑工具，包括 vi 或者 sed --in-place，可能会造成文件 inode 的改变，从 Docker 1.1 .0起，这会导致报错误信息。所以最简单的办法就直接挂载文件的父目录。 数据卷容器如果你有一些持续更新的数据需要在容器之间共享，最好创建数据卷容器。 数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。 首先，创建一个名为 dbdata 的数据卷容器： $ sudo docker run -d -v /dbdata --name dbdata training/postgres echo Data-only container for postgres 然后，在其他容器中使用 –volumes-from 来挂载 dbdata 容器中的数据卷。 $ sudo docker run -d --volumes-from dbdata --name db1 training/postgres $ sudo docker run -d --volumes-from dbdata --name db2 training/postgres 可以使用超过一个的 --volumes-from 参数来指定从多个容器挂载不同的数据卷。 也可以从其他已经挂载了数据卷的容器来级联挂载数据卷。 $ sudo docker run -d --name db3 --volumes-from db1 training/postgres 注意：使用 –volumes-from 参数所挂载数据卷的容器自己并不需要保持在运行状态。 如果删除了挂载的容器（包括 dbdata、db1 和 db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用 docker rm -v 命令来指定同时删除关联的容器。 这可以让用户在容器之间升级和移动数据卷。具体的操作将在下一节中进行讲解。 利用数据卷容器来备份、恢复、迁移数据卷可以利用数据卷对其中的数据进行进行备份、恢复和迁移。 备份首先使用 –volumes-from 标记来创建一个加载 dbdata 容器卷的容器，并从主机挂载当前目录到容器的 /backup 目录。命令如下： $ sudo docker run --volumes-from dbdata -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata 容器启动后，使用了 tar 命令来将 dbdata 卷备份为容器中 /backup/backup.tar 文件，也就是主机当前目录下的名为 backup.tar 的文件。 恢复如果要恢复数据到一个容器，首先创建一个带有空数据卷的容器 dbdata2。 $ sudo docker run -v /dbdata --name dbdata2 ubuntu /bin/bash 然后创建另一个容器，挂载 dbdata2 容器卷中的数据卷，并使用 untar 解压备份文件到挂载的容器卷中。 $ sudo docker run --volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf /backup/backup.tar 为了查看/验证恢复的数据，可以再启动一个容器挂载同样的容器卷来查看 $ sudo docker run --volumes-from dbdata2 busybox /bin/ls /dbdata","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ysluckly.github.io/tags/docker/"}]},{"title":"docker容器","slug":"linux/docker容器","date":"2017-05-23T13:29:38.000Z","updated":"2022-02-19T09:27:58.516Z","comments":true,"path":"2017/05/23/docker-container/","link":"","permalink":"https://ysluckly.github.io/2017/05/23/docker-container/","excerpt":"","text":"容器镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。 命令# 创建一个名为myubuntu的容器 # -t:分配一个伪终端 -i:让容器的标准输入保持打开 $ docker run --name=myubuntu -t -i ubuntu /bin/bash # 创建一个名为webserver 的nginx容器，使用卷映射本机/home/faker/myspace/nginx目录到docker目录/usr/share/nginx/html $ docker run --name=webserver -d -v /home/faker/myspace/nginx:/usr/share/nginx/html -p 80:80 nginx # 查看容器的输出信息（打印信息，如 echo） # run的时候，使用-d将会不展示在宿主机上，可通过下面命令查看打印信息 $ docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot; $ docker logs [container ID or NAMES] # 启动容器 myubuntu $ docker start myubuntu # 关闭容器 myubuntu $ docker stop myubuntu # 查看已启动的容器 -a:查看包括未启动的容器在内的所有容器 $ docker ps [-a] # 进入容器（Docker自带的命令） $ docker attach [name] # 进入容器（通过exec） $ docker exec -it [name] /bin/bash # 导出容器快照到本地文件 $ docker export [container id] &gt; ubuntu.tar # 将容器快照导入为镜像 $ cat ubuntu.tar | docker import - test/ubuntu:v1.0 # 从制定 URL 或者某个目录导入 $ docker import http://example.com/exampleimage.tgz example/imagerepo # 删除容器 -f:删除正在运行的容器 $ docker [-f] rm myubuntu # 删除所有已关闭的容器 $ docker rm $(docker ps -a -q) # 查询各容器资源使用情况 $ docker stats $(docker ps --format=&#123;&#123;.Names&#125;&#125;)","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ysluckly.github.io/tags/docker/"}]},{"title":"docker仓库","slug":"linux/docker仓库","date":"2017-05-23T13:15:52.000Z","updated":"2022-02-19T09:27:58.514Z","comments":true,"path":"2017/05/23/docker-registry/","link":"","permalink":"https://ysluckly.github.io/2017/05/23/docker-registry/","excerpt":"","text":"Docker Hub目前 Docker 官方维护了一个公共仓库 Docker Hub，其中已经包括了超过 15,000 的镜像。大部分需求，都可以通过在 Docker Hub 中直接下载镜像来实现。 登录可以通过执行 docker login 命令来输入用户名、密码和邮箱来完成注册和登录。 注册成功后，本地用户目录的 .dockercfg 中将保存用户的认证信息。 基本操作用户无需登录即可通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。 例如以 centos 为关键词进行搜索： $ sudo docker search centos NAME DESCRIPTION STARS OFFICIAL AUTOMATED centos The official build of CentOS. 465 [OK] tianon/centos CentOS 5 and 6, created using rinse instea... 28 blalor/centos Bare-bones base CentOS 6.5 image 6 [OK] saltstack/centos-6-minimal 6 [OK] tutum/centos-6.4 DEPRECATED. Use tutum/centos:6.4 instead. ... 5 [OK] ... 可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、星级（表示该镜像的受欢迎程度）、是否官方创建、是否自动创建。 官方的镜像说明是官方项目组创建和维护的，automated 资源允许用户验证镜像的来源和内容。 根据是否是官方提供，可将镜像资源分为两类。 一种是类似 centos 这样的基础镜像，被称为基础或根镜像。这些基础镜像是由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。 还有一种类型，比如 tianon/centos 镜像，它是由 Docker 的用户创建并维护的，往往带有用户名称前缀。可以通过前缀 user_name/ 来指定使用某个用户提供的镜像，比如 tianon 用户。 另外，在查找的时候通过 -s N 参数可以指定仅显示评价为 N 星以上的镜像。 下载官方 centos 镜像到本地。 $ sudo docker pull centos Pulling repository centos 0b443ba03958: Download complete 539c0211cd76: Download complete 511136ea3c5a: Download complete 7064731afe90: Download complete 用户也可以在登录后通过 docker push 命令来将镜像推送到 Docker Hub。 私有仓库安装 docker-registry容器运行在安装了 Docker 后，可以通过获取官方 registry 镜像来运行。 $ sudo docker run -d -p 5000:5000 registry 这将使用官方的 registry 镜像来启动本地的私有仓库。 用户可以通过指定参数来配置私有仓库位置，例如配置镜像存储到 Amazon S3 服务。 $ sudo docker run \\ -e SETTINGS_FLAVOR=s3 \\ -e AWS_BUCKET=acme-docker \\ -e STORAGE_PATH=/registry \\ -e AWS_KEY=AKIAHSHB43HS3J92MXZ \\ -e AWS_SECRET=xdDowwlK7TJajV1Y7EoOZrmuPEJlHYcNP2k4j49T \\ -e SEARCH_BACKEND=sqlalchemy \\ -p 5000:5000 \\ registry 此外，还可以指定本地路径（如 /home/user/registry-conf ）下的配置文件。 $ sudo docker run -d -p 5000:5000 -v /home/user/registry-conf:/registry-conf -e DOCKER_REGISTRY_CONFIG=/registry-conf/config.yml registry 默认情况下，仓库会被创建在容器的 /tmp/registry 下。可以通过 -v 参数来将镜像文件存放在本地的指定路径。 例如下面的例子将上传的镜像放到 /opt/data/registry 目录。 $ sudo docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry 本地安装对于 Ubuntu 或 CentOS 等发行版，可以直接通过源安装。1.Ubuntu $ sudo apt-get install -y build-essential python-dev libevent-dev python-pip liblzma-dev $ sudo pip install docker-registry 2.CentOS $ sudo yum install -y python-devel libevent-devel python-pip gcc xz-devel $ sudo python-pip install docker-registry 3.源码安装 $ sudo apt-get install build-essential python-dev libevent-dev python-pip libssl-dev liblzma-dev libffi-dev $ git clone https://github.com/docker/docker-registry.git $ cd docker-registry $ sudo python setup.py install 然后修改配置文件，主要修改 dev 模板段的 storage_path 到本地的存储仓库的路径。 $ cp config/config_sample.yml config/config.yml 之后启动 Web 服务。 $ sudo gunicorn -c contrib/gunicorn.py docker_registry.wsgi:application 或者 $ sudo gunicorn --access-logfile - --error-logfile - -k gevent -b 0.0.0.0:5000 -w 4 --max-requests 100 docker_registry.wsgi:application 此时使用 curl 访问本地的 5000 端口，看到输出 docker-registry 的版本信息说明运行成功。 注：config/config_sample.yml 文件是示例配置文件。 在私有仓库上传、下载、搜索镜像创建好私有仓库之后，就可以使用 docker tag 来标记一个镜像，然后推送它到仓库，别的机器上就可以下载下来了。例如私有仓库地址为 192.168.7.26:5000。 先在本机查看已有的镜像。 $ sudo docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu latest ba5877dc9bec 6 weeks ago 192.7 MB ubuntu 14.04 ba5877dc9bec 6 weeks ago 192.7 MB 使用docker tag 将 ba58 这个镜像标记为 192.168.7.26:5000/test（格式为 docker tag IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]）。 $ sudo docker tag ba58 192.168.7.26:5000/test root ~ # docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu 14.04 ba5877dc9bec 6 weeks ago 192.7 MB ubuntu latest ba5877dc9bec 6 weeks ago 192.7 MB 192.168.7.26:5000/test latest ba5877dc9bec 6 weeks ago 192.7 MB 使用 docker push 上传标记的镜像。 $ sudo docker push 192.168.7.26:5000/test The push refers to a repository [192.168.7.26:5000/test] (len: 1) Sending image list Pushing repository 192.168.7.26:5000/test (1 tags) Image 511136ea3c5a already pushed, skipping Image 9bad880da3d2 already pushed, skipping Image 25f11f5fb0cb already pushed, skipping Image ebc34468f71d already pushed, skipping Image 2318d26665ef already pushed, skipping Image ba5877dc9bec already pushed, skipping Pushing tag for rev [ba5877dc9bec] on &#123;http://192.168.7.26:5000/v1/repositories/test/tags/latest&#125; 用 curl 查看仓库中的镜像。 $ curl http://192.168.7.26:5000/v1/search &#123;&quot;num_results&quot;: 7, &quot;query&quot;: &quot;&quot;, &quot;results&quot;: [&#123;&quot;description&quot;: &quot;&quot;, &quot;name&quot;: &quot;library/miaxis_j2ee&quot;&#125;, &#123;&quot;description&quot;: &quot;&quot;, &quot;name&quot;: &quot;library/tomcat&quot;&#125;, &#123;&quot;description&quot;: &quot;&quot;, &quot;name&quot;: &quot;library/ubuntu&quot;&#125;, &#123;&quot;description&quot;: &quot;&quot;, &quot;name&quot;: &quot;library/ubuntu_office&quot;&#125;, &#123;&quot;description&quot;: &quot;&quot;, &quot;name&quot;: &quot;library/desktop_ubu&quot;&#125;, &#123;&quot;description&quot;: &quot;&quot;, &quot;name&quot;: &quot;dockerfile/ubuntu&quot;&#125;, &#123;&quot;description&quot;: &quot;&quot;, &quot;name&quot;: &quot;library/test&quot;&#125;]&#125; 这里可以看到 {“description”: “”, “name”: “library/test”}，表明镜像已经被成功上传了。 现在可以到另外一台机器去下载这个镜像。 $ sudo docker pull 192.168.7.26:5000/test Pulling repository 192.168.7.26:5000/test ba5877dc9bec: Download complete 511136ea3c5a: Download complete 9bad880da3d2: Download complete 25f11f5fb0cb: Download complete ebc34468f71d: Download complete 2318d26665ef: Download complete $ sudo docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE 192.168.7.26:5000/test latest ba5877dc9bec 6 weeks ago 192.7 MB 可以使用 这个脚本 批量上传本地的镜像到注册服务器中，默认是本地注册服务器 127.0.0.1:5000。例如： $ wget https://github.com/yeasy/docker_practice/raw/master/_local/push_images.sh; sudo chmod a+x push_images.sh $ ./push_images.sh ubuntu:latest centos:centos7 The registry server is 127.0.0.1 Uploading ubuntu:latest... The push refers to a repository [127.0.0.1:5000/ubuntu] (len: 1) Sending image list Pushing repository 127.0.0.1:5000/ubuntu (1 tags) Image 511136ea3c5a already pushed, skipping Image bfb8b5a2ad34 already pushed, skipping Image c1f3bdbd8355 already pushed, skipping Image 897578f527ae already pushed, skipping Image 9387bcc9826e already pushed, skipping Image 809ed259f845 already pushed, skipping Image 96864a7d2df3 already pushed, skipping Pushing tag for rev [96864a7d2df3] on &#123;http://127.0.0.1:5000/v1/repositories/ubuntu/tags/latest&#125; Untagged: 127.0.0.1:5000/ubuntu:latest Done Uploading centos:centos7... The push refers to a repository [127.0.0.1:5000/centos] (len: 1) Sending image list Pushing repository 127.0.0.1:5000/centos (1 tags) Image 511136ea3c5a already pushed, skipping 34e94e67e63a: Image successfully pushed 70214e5d0a90: Image successfully pushed Pushing tag for rev [70214e5d0a90] on &#123;http://127.0.0.1:5000/v1/repositories/centos/tags/centos7&#125; Untagged: 127.0.0.1:5000/centos:centos7 Done 仓库配置文件Docker 的 Registry 利用配置文件提供了一些仓库的模板（flavor），用户可以直接使用它们来进行开发或生产部署。 模板在 config_sample.yml 文件中，可以看到一些现成的模板段： common：基础配置 local：存储数据到本地文件系统 s3：存储数据到 AWS S3 中 dev：使用 local 模板的基本配置 test：单元测试使用 prod：生产环境配置（基本上跟s3配置类似） gcs：存储数据到 Google 的云存储 swift：存储数据到 OpenStack Swift 服务 glance：存储数据到 OpenStack Glance 服务，本地文件系统为后备 glance-swift：存储数据到 OpenStack Glance 服务，Swift 为后备 elliptics：存储数据到 Elliptics key/value 存储 用户也可以添加自定义的模版段。 默认情况下使用的模板是 dev，要使用某个模板作为默认值，可以添加 SETTINGS_FLAVOR 到环境变量中，例如 export SETTINGS_FLAVOR=dev 另外，配置文件中支持从环境变量中加载值，语法格式为 _env:VARIABLENAME[:DEFAULT]。 示例配置common: loglevel: info search_backend: &quot;_env:SEARCH_BACKEND:&quot; sqlalchemy_index_database: &quot;_env:SQLALCHEMY_INDEX_DATABASE:sqlite:////tmp/docker-registry.db&quot; prod: loglevel: warn storage: s3 s3_access_key: _env:AWS_S3_ACCESS_KEY s3_secret_key: _env:AWS_S3_SECRET_KEY s3_bucket: _env:AWS_S3_BUCKET boto_bucket: _env:AWS_S3_BUCKET storage_path: /srv/docker smtp_host: localhost from_addr: docker@myself.com to_addr: my@myself.com dev: loglevel: debug storage: local storage_path: /home/myself/docker test: storage: local storage_path: /tmp/tmpdockertmp","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ysluckly.github.io/tags/docker/"},{"name":"docker仓库","slug":"docker仓库","permalink":"https://ysluckly.github.io/tags/docker%E4%BB%93%E5%BA%93/"}]},{"title":"CentOS修改DNS/GW/IP","slug":"linux/CentOS修改DNS-GW-IP","date":"2017-05-23T01:53:52.000Z","updated":"2022-02-19T09:27:58.509Z","comments":true,"path":"2017/05/23/CentOS-DNS-GW-IP/","link":"","permalink":"https://ysluckly.github.io/2017/05/23/CentOS-DNS-GW-IP/","excerpt":"","text":"1.修改DNS解决方案一：修改网卡的DNS的配置文件 $ vim /etc/resolv.conf 添加以下内容,设置两条dns nameserver 8.8.8.8 #google域名服务器 nameserver 8.8.4.4 #google域名服务器 若未生效，可执行 chattr +i /etc/resolv.conf 设置文件属性只有root用户才能修改然后执行 service NetworkManager restart 解决方案二：对接口添加dns信息；编辑/etc/sysconfig/network-scripts/ifcfg-xxx，xxx为你的网卡名，但一般是ifcfg-eth0的，具体的xxx根据你的网卡确定，在最下面添加： DNS1=8.8.8.8 #google dns服务器, 根据实际情况更换 DNS2=8.8.4.4 #google dns服务器, 根据实际情况更换 保存后重启网络 $ service network restart 2.修改网关修改网关的配置文件(第3部分也可以设置) $ vim /etc/sysconfig/network 修改为一下内容 NETWORKING=yes(表示系统是否使用网络，一般设置为yes。如果设为no，则不能使用网络，而且很多系统服务程序将无法启动) HOSTNAME=centos(设置本机的主机名，这里设置的主机名要和/etc/hosts中设置的主机名对应) GATEWAY=192.168.1.1(设置本机连接的网关的IP地址。例如，网关为10.0.0.2) 3.修改ip修改对应的网卡的IP地址的配置文件 $ vim /etc/sysconfig/network-scripts/ifcfg-eth0 修改为一下内容 DEVICE=eth0 #描述网卡对应的设备别名，例如ifcfg-eth0的文件中它为eth0 BOOTPROTO=static #设置网卡获得ip地址的方式，可能的选项为static，dhcp或bootp，分别对应静态指定的 ip地址，通过dhcp协议获得的ip地址，通过bootp协议获得的ip地址 BROADCAST=192.168.0.255 #对应的子网广播地址 HWADDR=00:07:E9:05:E8:B4 #对应的网卡物理地址 IPADDR=12.168.1.2 #如果设置网卡获得 ip地址的方式为静态指定，此字段就指定了网卡对应的ip地址 IPV6INIT=no IPV6_AUTOCONF=no NETMASK=255.255.255.0 #网卡对应的网络掩码 NETWORK=192.168.1.0 #网卡对应的网络地址 ONBOOT=yes #系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/tags/%E8%BF%90%E7%BB%B4/"},{"name":"centos","slug":"centos","permalink":"https://ysluckly.github.io/tags/centos/"}]},{"title":"Dockerfile指令详解","slug":"linux/Dockerfile指令详解","date":"2017-05-22T11:11:42.000Z","updated":"2022-02-19T09:27:58.511Z","comments":true,"path":"2017/05/22/Dockerfile/","link":"","permalink":"https://ysluckly.github.io/2017/05/22/Dockerfile/","excerpt":"","text":"Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 构建镜像命令格式： $ docker build [选项] &lt;上下文路径/URL/-&gt; 示例： # 构建一个名为 nginx:v3 的镜像 $ docker build -t nginx:v3 . RUN 执行命令 shell格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockrfile 中的 RUN 指令就是这种格式。RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html exec格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。 COPY 复制文件格式： COPY &lt;源路径&gt;... &lt;目标路径&gt; COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。比如：COPY package.json /usr/src/app/ &lt;源路径&gt; 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如： COPY hom* /mydir/ COPY hom?.txt /mydir/ &lt;目标路径&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。 此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。 ADD更高级的复制文件ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。 比如 &lt;源路径&gt; 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。 如果 &lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去。 在 Docker 官方的最佳实践文档中要求，尽可能的使用 COPY 。 因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。 CMD 容器启动命令CMD 指令的格式和 RUN 相似，也是两种格式：1） shell 格式：CMD &lt;命令&gt;2） exec 格式：CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]3） 参数列表格式：CMD [&quot;参数1&quot;, &quot;参数2&quot;...]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。 Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。 在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是 /bin/bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release。这就是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，输出了系统版本信息。 在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 “，而不要使用单引号。 ENTRYPOINT 入口点ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 –entrypoint 来指定。 当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为： &lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot; 场景一：让镜像变成像命令一样使用 FROM ubuntu:16.04 RUN apt-get update \\ &amp;&amp; apt-get install -y curl \\ &amp;&amp; rm -rf /var/lib/apt/lists/* ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ] $ docker run myip -i 这是因为当存在 ENTRYPOINT 后，CMD 的内容将会作为参数传给 ENTRYPOINT，而这里 -i 就是新的 CMD，因此会作为参数传给 curl，从而达到了我们预期的效果。 场景二：应用运行前的准备工作可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是 ）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的： FROM alpine:3.4 ... RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis ... ENTRYPOINT [&quot;docker-entrypoint.sh&quot;] EXPOSE 6379CMD [ “redis-server” ] 可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 ENTRYPOINT 为 docker-entrypoint.sh 脚本。 ```bash #!/bin/sh ... # allow the container to be started with `--user` if [ &quot;$1&quot; = &#39;redis-server&#39; -a &quot;$(id -u)&quot; = &#39;0&#39; ]; then chown -R redis . exec su-exec redis &quot;$0&quot; &quot;$@&quot; fi exec &quot;$@&quot; 该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行。比如： $ docker run -it redis id uid=0(root) gid=0(root) groups=0(root) ENV 设置环境变量格式有两种： ENV &lt;key&gt; &lt;value&gt; ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;... 这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。 ENV VERSION=1.0 DEBUG=on \\ NAME=&quot;Happy Feet&quot; 这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。 定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 node 镜像 Dockerfile 中，就有类似这样的代码： ENV NODE_VERSION 7.2.0 RUN curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot; \\ &amp;&amp; curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot; \\ &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \\ &amp;&amp; grep &quot; node-v$NODE_VERSION-linux-x64.tar.xz\\$&quot; SHASUMS256.txt | sha256sum -c - \\ &amp;&amp; tar -xJf &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; -C /usr/local --strip-components=1 \\ &amp;&amp; rm &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; SHASUMS256.txt.asc SHASUMS256.txt \\ &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs 在这里先定义了环境变量 NODE_VERSION，其后的 RUN 这层里，多次使用 $NODE_VERSION 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 7.2.0 即可，Dockerfile 构建维护变得更轻松了。 下列指令可以支持环境变量展开： ADD、COPY、ENV、EXPOSE、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD。 可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 Dockerfile 制作更多的镜像，只需使用不同的环境变量即可。 ARG 构建参数格式：ARG &lt;参数名&gt;[=&lt;默认值&gt;] 构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。 Dockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 docker build 中用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。 在 1.13 之前的版本，要求 –build-arg 中的参数名，必须在 Dockerfile 中用 ARG 定义过了，换句话说，就是 –build-arg 指定的参数，必须在 Dockerfile 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 Dockerfile 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。 VOLUME 定义匿名卷格式为： VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...] VOLUME &lt;路径&gt; 之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。 VOLUME /data 这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如： $ docker run -d -v mydata:/data xxxx 在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。 EXPOSE 声明端口格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]。 EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 此外，在早期 Docker 版本中还有一个特殊的用处。以前所有容器都运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个 Docker 引擎参数 –icc=false，当指定该参数后，容器间将默认无法互访，除非互相间使用了 –links 参数的容器才可以互通，并且只有镜像中 EXPOSE 所声明的端口才可以被访问。这个 –icc=false 的用法，在引入了 docker network 后已经基本不用了，通过自定义网络可以很轻松的实现容器间的互联与隔离。 要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 WORKDIR 指定工作目录格式为 WORKDIR &lt;工作目录路径&gt;。 使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。 之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误： RUN cd /app RUN echo &quot;hello&quot; &gt; world.txt 如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是 hello。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dokerfile 构建分层存储的概念不了解所导致的错误。 之前说过每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUN cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。 因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。 USER 指定当前用户格式：USER &lt;用户名&gt; USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。 当然，和 WORKDIR 一样，USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。 RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis USER redis RUN [ &quot;redis-server&quot; ] 如果以 root 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 su 或者 sudo，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 gosu，可以从其项目网站看到进一步的信息：https://github.com/tianon/gosu # 建立 redis 用户，并使用 gosu 换另一个用户执行命令 RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis # 下载 gosu RUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot; \\ &amp;&amp; chmod +x /usr/local/bin/gosu \\ &amp;&amp; gosu nobody true # 设置 CMD，并以另外的用户执行 CMD [ &quot;exec&quot;, &quot;gosu&quot;, &quot;redis&quot;, &quot;redis-server&quot; ] HEALTHCHECK 健康检查格式： HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令 HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令 HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。 在没有 HEALTHCHECK 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。 而自 1.12 之后，Docker 提供了 HEALTHCHECK 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。 当在一个镜像指定了 HEALTHCHECK 指令后，用其启动容器，初始状态会为 starting，在 HEALTHCHECK 指令检查成功后变为 healthy，如果连续一定次数失败，则会变为 unhealthy。 HEALTHCHECK 支持下列选项： --interval=&lt;间隔&gt;：两次健康检查的间隔，默认为 30 秒； --timeout=&lt;时长&gt;：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒； --retries=&lt;次数&gt;：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。 和 CMD, ENTRYPOINT 一样，HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。 在 HEALTHCHECK [选项] CMD 后面的命令，格式和 ENTRYPOINT 一样，分为 shell 格式，和 exec 格式。命令的返回值决定了该次健康检查的成功与否：0：成功；1：失败；2：保留，不要使用这个值。 假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 curl 来帮助判断，其 Dockerfile 的 HEALTHCHECK 可以这么写： FROM nginx RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/* HEALTHCHECK --interval=5s --timeout=3s \\ CMD curl -fs http://localhost/ || exit 1 这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 curl -fs http://localhost/ || exit 1 作为健康检查命令。 使用 docker build 来构建这个镜像： $ docker build -t myweb:v1 . 构建好了后，我们启动一个容器： $ docker run -d --name web -p 80:80 myweb:v1 当运行该镜像后，可以通过 docker ps 看到最初的状态为 (health: starting)： $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 03e28eb00bd0 myweb:v1 &quot;nginx -g &#39;daemon off&quot; 3 seconds ago Up 2 seconds (health: starting) 80/tcp, 443/tcp web 在等待几秒钟后，再次 docker ps，就会看到健康状态变化为了 (healthy)： $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 03e28eb00bd0 myweb:v1 &quot;nginx -g &#39;daemon off&quot; 18 seconds ago Up 16 seconds (healthy) 80/tcp, 443/tcp web 如果健康检查连续失败超过了重试次数，状态就会变为 (unhealthy)。 为了帮助排障，健康检查命令的输出（包括 stdout 以及 stderr）都会被存储于健康状态里，可以用 docker inspect 来查看。 $ docker inspect --format &#39;&#123;&#123;json .State.Health&#125;&#125;&#39; web | python -m json.tool &#123; &quot;FailingStreak&quot;: 0, &quot;Log&quot;: [ &#123; &quot;End&quot;: &quot;2016-11-25T14:35:37.940957051Z&quot;, &quot;ExitCode&quot;: 0, &quot;Output&quot;: &quot;&lt;!DOCTYPE html&gt;\\n&lt;html&gt;\\n&lt;head&gt;\\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\\n&lt;style&gt;\\n body &#123;\\n width: 35em;\\n margin: 0 auto;\\n font-family: Tahoma, Verdana, Arial, sans-serif;\\n &#125;\\n&lt;/style&gt;\\n&lt;/head&gt;\\n&lt;body&gt;\\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\\nworking. Further configuration is required.&lt;/p&gt;\\n\\n&lt;p&gt;For online documentation and support please refer to\\n&lt;a href=\\&quot;http://nginx.org/\\&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\\nCommercial support is available at\\n&lt;a href=\\&quot;http://nginx.com/\\&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\\n\\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\\n&lt;/body&gt;\\n&lt;/html&gt;\\n&quot;, &quot;Start&quot;: &quot;2016-11-25T14:35:37.780192565Z&quot; &#125; ], &quot;Status&quot;: &quot;healthy&quot; &#125; ONBUILD 为他人做嫁衣裳格式：ONBUILD &lt;其它指令&gt;。 ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。 Dockerfile 中的其它指令都是为了定制当前镜像而准备的，唯有 ONBUILD 是为了帮助别人定制自己而准备的。 假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 npm 进行包管理，所有依赖、配置、启动信息等会放到 package.json 文件里。在拿到程序代码后，需要先进行 npm install 才可以获得所有需要的依赖。然后就可以通过 npm start 来启动应用。因此，一般来说会这样写 Dockerfile： FROM node:slim RUN &quot;mkdir /app&quot; WORKDIR /app COPY ./package.json /app RUN [ &quot;npm&quot;, &quot;install&quot; ] COPY . /app/ CMD [ &quot;npm&quot;, &quot;start&quot; ] 把这个 Dockerfile 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 Dockerfile 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。 如果第一个 Node.js 项目在开发过程中，发现这个 Dockerfile 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 Dockerfile，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 Dockerfile 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 Dockerfile，而第二个项目的 Dockerfile 就会被自动修复。 那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 Dockerfile 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 Dockerfile 就会变为： FROM node:slim RUN &quot;mkdir /app&quot; WORKDIR /app CMD [ &quot;npm&quot;, &quot;start&quot; ] 这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 my-node 的话，各个项目内的自己的 Dockerfile 就变为： FROM my-node COPY ./package.json /app RUN [ &quot;npm&quot;, &quot;install&quot; ] COPY . /app/ 基础镜像变化后，各个项目都用这个 Dockerfile 重新构建镜像，会继承基础镜像的更新。 那么，问题解决了么？没有。准确说，只解决了一半。如果这个 Dockerfile 里面有些东西需要调整呢？比如 npm install 都需要加一些参数，那怎么办？这一行 RUN 是不可能放入基础镜像的，因为涉及到了当前项目的 ./package.json，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 Dockerfile 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。 ONBUILD 可以解决这个问题。让我们用 ONBUILD 重新写一下基础镜像的 Dockerfile: FROM node:slim RUN &quot;mkdir /app&quot; WORKDIR /app ONBUILD COPY ./package.json /app ONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ] ONBUILD COPY . /app/ CMD [ &quot;npm&quot;, &quot;start&quot; ] 这次我们回到原始的 Dockerfile，但是这次将项目相关的指令加上 ONBUILD，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 Dockerfile 就变成了简单地： FROM my-node 是的，只有这么一行。当在各个项目目录中，用这个只有一行的 Dockerfile 构建镜像时，之前基础镜像的那三行 ONBUILD 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 npm install，生成应用镜像。 ReferenceDocker–从入门到实践: https://yeasy.gitbooks.io/docker_practice/content/Dockerfie 官方文档：https://docs.docker.com/engine/reference/builder/Dockerfile 最佳实践文档：https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ysluckly.github.io/tags/docker/"}]},{"title":"docker镜像","slug":"linux/docker镜像","date":"2017-05-19T08:47:33.000Z","updated":"2022-02-19T09:27:58.519Z","comments":true,"path":"2017/05/19/docker-image/","link":"","permalink":"https://ysluckly.github.io/2017/05/19/docker-image/","excerpt":"","text":"WhatDocker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。 安装# 官方 的安装脚本 $ curl -sSL https://get.docker.com/ | sh # 阿里云 的安装脚本 $ curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh - # DaoCloud 的安装脚本 $ curl -sSL https://get.daocloud.io/docker | sh 镜像# 获取镜像，registry为空默认从Docker Hub上获取 docker pull [选项] [Docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt; # 交互式运行，退出删除: -i:交互式 ,-t:终端,--rm 退出删除 ,bash 启动bash窗口 $ docker run -it --rm ubuntu:14.04 bash # 列出已下载的镜像（只显示顶层镜像） -a:显示所有镜像 image_name:指定列出某个镜像 $ docker images [-a] [image_name] # 只显示虚悬镜像(dangling image) -f:--filter 过滤 $ docker images -f dangling=true # 过滤从mongo:3.2建立之后的镜像 $ docker images -f since=mongo:3.2 # 通过label过滤 $ docker images -f label=com.example.version=0.1 # 只显示镜像id $ docker images -q # 只包含镜像ID和仓库名 $ docker images --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot; # 以表格等距显示 有标题行，和默认一样，不过自己定义列 $ docker images --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Repository&#125;&#125;\\t&#123;&#123;.Tag&#125;&#125;&quot; # 删除镜像ID为image_id的镜像 $ docker rmi &lt;image_id&gt; # 删除虚悬镜像 $ docker rmi $(docker images -q -f dangling=true) # 将容器保存为镜像 $ docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]] # 将容器保存为镜像 $ docker commit \\ --author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; \\ --message &quot;修改了默认网页&quot; \\ webserver \\ nginx:v2 $ docker history nginx:v2","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ysluckly.github.io/tags/docker/"}]},{"title":"docker初体验","slug":"linux/docker初体验","date":"2017-05-19T08:32:23.000Z","updated":"2022-02-19T09:27:58.515Z","comments":true,"path":"2017/05/19/docker-first/","link":"","permalink":"https://ysluckly.github.io/2017/05/19/docker-first/","excerpt":"","text":"安装笔者环境操作系统：deepin 15.4 Desktop 64Bit 安装# 官方 的安装脚本 $ curl -sSL https://get.docker.com/ | sh # 阿里云 的安装脚本 $ curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh - # DaoCloud 的安装脚本 $ curl -sSL https://get.daocloud.io/docker | sh 获取镜像Docker Hub 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像并运行。从 Docker Registry 获取镜像的命令是 docker pull。其命令格式为： $ docker pull [选项] [Docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt; 具体的选项可以通过 docker pull --help 命令看到，这里我们说一下镜像名称的格式。 Docker Registry地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。 仓库名：如之前所说，这里的仓库名是两段式名称，既 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。 $ sudo docker pull ubuntu 运行有了镜像后，我们就可以以这个镜像为基础启动一个容器来运行。以上面的 ubuntu 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。 $ sudo docker run -it --rm ubuntu root@0ae011f7b5be:/# cat /etc/os-release NAME=&quot;Ubuntu&quot; VERSION=&quot;16.04.2 LTS (Xenial Xerus)&quot; ID=ubuntu ID_LIKE=debian PRETTY_NAME=&quot;Ubuntu 16.04.2 LTS&quot; VERSION_ID=&quot;16.04&quot; HOME_URL=&quot;http://www.ubuntu.com/&quot; SUPPORT_URL=&quot;http://help.ubuntu.com/&quot; BUG_REPORT_URL=&quot;http://bugs.launchpad.net/ubuntu/&quot; VERSION_CODENAME=xenial UBUNTU_CODENAME=xenial docker run 就是运行容器的命令 -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 --rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。 ubuntu：这是指用 ubuntu 镜像为基础来启动容器。 bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。 进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 16.04.2 LTS 系统。 最后通过 exit 退出了这个容器。","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ysluckly.github.io/tags/docker/"}]},{"title":"linux无损调整分区大小","slug":"linux/linux无损调整分区大小","date":"2017-05-17T14:00:42.000Z","updated":"2022-02-19T09:27:58.520Z","comments":true,"path":"2017/05/17/linux无损调整分区大小/","link":"","permalink":"https://ysluckly.github.io/2017/05/17/linux%E6%97%A0%E6%8D%9F%E8%B0%83%E6%95%B4%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F/","excerpt":"","text":"summary 系统环境: Red Hat 4.8.5-11 情况： home：500G root：50G root分区不够用 思路：把home分区的空间划一部分到root分区 # 设置home分区大小为200G，释放300G空间 $ lvreduce -L 200G /dev/centos/home # 将空闲空间扩展到root分区 $ lvextend -l +100%FREE /dev/centos/root # 使用XFS文件系统自带的命令集增加分区空间 $ xfs_growfs /dev/mapper/centos-root 实例situation挂载在根目录的分区 /dev/mapper/centos-root 爆满，占用100% $ df -h Filesystem Size Used Avail Use% Mounted on /dev/mapper/centos-root 50G 50G 19M 100% / devtmpfs 32G 0 32G 0% /dev tmpfs 32G 0 32G 0% /dev/shm tmpfs 32G 2.5G 29G 8% /run tmpfs 32G 0 32G 0% /sys/fs/cgroup /dev/mapper/centos-home 476G 33M 476G 1% /home /dev/sda1 497M 238M 259M 48% /boot tmpfs 6.3G 0 6.3G 0% /run/user/0 analyze挂载在根目录的分区空间太小，只有50G，而服务器 home 目录为非常用目录，挂在了近500G的空间。 思路：从 centos-home 分区划出300G空间到 centos-root 分区。 operation1.查看各分区信息$ lvdisplay --- Logical volume --- LV Path /dev/centos/home LV Name home VG Name centos LV UUID 1fAt1E-bQsa-1HXR-MCE2-5VZ1-xzBz-iI1SLv LV Write Access read/write LV Creation host, time localhost, 2016-10-26 17:23:47 +0800 LV Status available # open 0 LV Size 475.70 GiB Current LE 121778 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 256 Block device 253:2 --- Logical volume --- LV Path /dev/centos/root LV Name root VG Name centos LV UUID lD64zY-yc3Z-SZaB-dAjK-03YM-2gM8-pfj4oo LV Write Access read/write LV Creation host, time localhost, 2016-10-26 17:23:48 +0800 LV Status available # open 1 LV Size 50.00 GiB Current LE 12800 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 256 Block device 253:0 2.减少/home分区空间# 释放 /dev/centos/home 分区 300G 的空间 # 命令设置 /dev/centos/home 分区 200G空间 $ lvreduce -L 200G /dev/centos/home WARNING: Reducing active logical volume to 200.00 GiB. THIS MAY DESTROY YOUR DATA (filesystem etc.) Do you really want to reduce centos/home? [y/n]: y Size of logical volume centos/home changed from 475.70 GiB (121778 extents) to 200.00 GiB (51200 extents). Logical volume centos/home successfully resized. 3.增加/root分区空间$ lvextend -l +100%FREE /dev/centos/root Size of logical volume centos/root changed from 50.06 GiB (12816 extents) to 325.76 GiB (83394 extents). Logical volume centos/root successfully resized. 4.扩展XFS文件空间大小$ xfs_growfs /dev/mapper/centos-root meta-data=/dev/mapper/centos-root isize=256 agcount=4, agsize=3276800 blks = sectsz=512 attr=2, projid32bit=1 = crc=0 finobt=0 spinodes=0 data = bsize=4096 blocks=13107200, imaxpct=25 = sunit=0 swidth=0 blks naming =version 2 bsize=4096 ascii-ci=0 ftype=0 log =internal bsize=4096 blocks=6400, version=2 = sectsz=512 sunit=0 blks, lazy-count=1 realtime =none extsz=4096 blocks=0, rtextents=0 data blocks changed from 13107200 to 85395456 完成","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/tags/%E8%BF%90%E7%BB%B4/"},{"name":"磁盘分区","slug":"磁盘分区","permalink":"https://ysluckly.github.io/tags/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"}]},{"title":"Git统计操作","slug":"tools/git-log","date":"2017-05-16T01:26:11.000Z","updated":"2022-02-19T09:27:58.555Z","comments":true,"path":"2017/05/16/git-log/","link":"","permalink":"https://ysluckly.github.io/2017/05/16/git-log/","excerpt":"","text":"按commit统计# 统计当前作者今天（从凌晨1点开始）提交次数 $ git log --author=&quot;$(git config --get user.name)&quot; --no-merges --since=1am --stat # 按提交作者统计，按提交次数排序 $ git shortlog -sn $ git shortlog --numbered --summary # 只看某作者提交的commit数 $ git log --author=&quot;faker&quot; --oneline --shortstat # 按提交作者统计，提交数量排名前5（看全部，去掉head管道即可） $ git log --pretty=&#39;%aN&#39; | sort | uniq -c | sort -k1 -n -r | head -n 5 # 按提交者邮箱统计，提交数量排名前5 $ git log --pretty=format:%ae | gawk -- &#39;&#123; ++c[$0]; &#125; END &#123; for(cc in c) printf &quot;%5d %s\\n&quot;,c[cc],cc; &#125;&#39; | sort -u -n -r | head -n 5 # 统计贡献者数量 $ git log --pretty=&#39;%aN&#39; | sort -u | wc -l # 统计提交数量 $ git log --oneline | wc -l 按代码行数统计# 统计指定作者增删行数 $ git log --author=&quot;faker&quot; --pretty=tformat: --numstat | awk &#39;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\\n&quot;, add, subs, loc &#125;&#39; - # 统计当前作者增删行数 $ git log --author=&quot;$(git config --get user.name)&quot; --pretty=tformat: --numstat | gawk &#39;&#123; add += $1 ; subs += $2 ; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s removed lines : %s total lines: %s\\n&quot;,add,subs,loc &#125;&#39; - # 统计所有邮箱前缀的增删行数 -英文版 $ git log --shortstat --pretty=&quot;%cE&quot; | sed &#39;s/\\(.*\\)@.*/\\1/&#39; | grep -v &quot;^$&quot; | awk &#39;BEGIN &#123; line=&quot;&quot;; &#125; !/^ / &#123; if (line==&quot;&quot; || !match(line, $0)) &#123;line = $0 &quot;,&quot; line &#125;&#125; /^ / &#123; print line &quot; # &quot; $0; line=&quot;&quot;&#125;&#39; | sort | sed -E &#39;s/# //;s/ files? changed,//;s/([0-9]+) ([0-9]+ deletion)/\\1 0 insertions\\(+\\), \\2/;s/\\(\\+\\)$/\\(\\+\\), 0 deletions\\(-\\)/;s/insertions?\\(\\+\\), //;s/ deletions?\\(-\\)//&#39; | awk &#39;BEGIN &#123;name=&quot;&quot;; files=0; insertions=0; deletions=0;&#125; &#123;if ($1 != name &amp;&amp; name != &quot;&quot;) &#123; print name &quot;: &quot; files &quot; files changed, &quot; insertions &quot; insertions(+), &quot; deletions &quot; deletions(-), &quot; insertions-deletions &quot; net&quot;; files=0; insertions=0; deletions=0; name=$1; &#125; name=$1; files+=$2; insertions+=$3; deletions+=$4&#125; END &#123;print name &quot;: &quot; files &quot; files changed, &quot; insertions &quot; insertions(+), &quot; deletions &quot; deletions(-), &quot; insertions-deletions &quot; net&quot;;&#125;&#39; # 统计所有邮箱前缀的增删行数 -中文版 $ git log --shortstat --pretty=&quot;%cE&quot; | sed &#39;s/\\(.*\\)@.*/\\1/&#39; | grep -v &quot;^$&quot; | awk &#39;BEGIN &#123; line=&quot;&quot;; &#125; !/^ / &#123; if (line==&quot;&quot; || !match(line, $0)) &#123;line = $0 &quot;,&quot; line &#125;&#125; /^ / &#123; print line &quot; # &quot; $0; line=&quot;&quot;&#125;&#39; | sort | sed -E &#39;s/# //;s/ files? changed,//;s/([0-9]+) ([0-9]+ deletion)/\\1 0 insertions\\(+\\), \\2/;s/\\(\\+\\)$/\\(\\+\\), 0 deletions\\(-\\)/;s/insertions?\\(\\+\\), //;s/ deletions?\\(-\\)//&#39; | awk &#39;BEGIN &#123;name=&quot;&quot;; files=0; insertions=0; deletions=0;&#125; &#123;if ($1 != name &amp;&amp; name != &quot;&quot;) &#123; print name &quot;: &quot; files &quot; 个文件被改变, &quot; insertions &quot; 行被插入(+), &quot; deletions &quot; 行被删除(-), &quot; insertions-deletions &quot; 行剩余&quot;; files=0; insertions=0; deletions=0; name=$1; &#125; name=$1; files+=$2; insertions+=$3; deletions+=$4&#125; END &#123;print name &quot;: &quot; files &quot; 个文件被改变, &quot; insertions &quot; 行被插入(+), &quot; deletions &quot; 行被删除(-), &quot; insertions-deletions &quot; 行剩余&quot;;&#125;&#39; # 统计所有作者增删行数 --英文版 $ git log --format=&#39;%aN&#39; | sort -u | while read name; do echo -en &quot;$name\\t&quot;; git log --author=&quot;$name&quot; --pretty=tformat: --numstat | awk &#39;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\\n&quot;, add, subs, loc &#125;&#39; -; done # 统计所有作者增删行数 --中文版 $ git log --format=&#39;%aN&#39; | sort -u | while read name; do echo -en &quot;$name\\t&quot;; git log --author=&quot;$name&quot; --pretty=tformat: --numstat | awk &#39;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;添加行数: %s, 删除行数: %s, 总行数: %s\\n&quot;, add, subs, loc &#125;&#39; -; done git log 说明 git log 参数说明：--author 指定作者--stat 显示每次更新的文件修改统计信息，会列出具体文件列表--shortstat 统计每个commit 的文件修改行数，包括增加，删除，但不列出文件列表：--numstat 统计每个commit 的文件修改行数，包括增加，删除，并列出文件列表： -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新 例如：git log -p -2--name-only 仅在提交信息后显示已修改的文件清单--name-status 显示新增、修改、删除的文件清单--abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符--relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）--graph 显示 ASCII 图形表示的分支合并历史--pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式） 例如： git log --pretty=oneline ; git log --pretty=short ; git log --pretty=full ; git log –pretty=fuller--pretty=tformat: 可以定制要显示的记录格式，这样的输出便于后期编程提取分析 例如： git log --pretty=format:&quot;&quot;%h - %an, %ar : %s&quot;&quot; 下面列出了常用的格式占位符写法及其代表的意义。 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 -date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明--since 限制显示输出的范围， 例如： git log --since=2.weeks 显示最近两周的提交 选项 说明 -(n) 仅显示最近的 n 条提交 --since, --after 仅显示指定时间之后的提交。 --until, --before 仅显示指定时间之前的提交。 --author 仅显示指定作者相关的提交。 --committer 仅显示指定提交者相关的提交。 一些例子：git log --until=1.minute.ago // 一分钟之前的所有 loggit log --since=1.day.ago //一天之内的loggit log --since=1.hour.ago //一个小时之内的 loggit log --since=1.month.ago --until=2.weeks.ago //一个月之前到半个月之前的loggit log --since ==2013-08.01 --until=2013-09-07 //某个时间段的 loggit blame 看看某一个文件的相关历史记录例如：git blame index.html --date short","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"工具/git","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://ysluckly.github.io/tags/git/"}]},{"title":"解决linux下zip文件解压乱码","slug":"linux/解决linux下zip文件解压乱码","date":"2017-04-25T01:10:40.000Z","updated":"2022-02-19T09:27:58.526Z","comments":true,"path":"2017/04/25/解决linux下zip文件解压乱码/","link":"","permalink":"https://ysluckly.github.io/2017/04/25/%E8%A7%A3%E5%86%B3linux%E4%B8%8Bzip%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B%E4%B9%B1%E7%A0%81/","excerpt":"","text":"原因由于zip格式并没有指定编码格式，Windows下生成的zip文件中的编码是GBK/GB2312等，因此，导致这些zip文件在Linux下解压时出现乱码问题，因为Linux下的默认编码是UTF8。 解决方案使用7z解压。 安装p7zip和convmv # fedora $ su -c &#39;yum install p7zip convmv&#39; # ubuntu $ sudo apt-get install p7zip convmv 执行一下命令解压缩 # 使用7z解压缩 $ LANG=C 7za x your-zip-file.zip # 递归转码 $ convmv -f GBK -t utf8 --notest -r .","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"linux命令","slug":"linux命令","permalink":"https://ysluckly.github.io/tags/linux%E5%91%BD%E4%BB%A4/"}]},{"title":"加密算法简介","slug":"back-end/加密算法简介","date":"2017-04-22T01:30:41.000Z","updated":"2022-02-20T13:01:40.474Z","comments":true,"path":"2017/04/22/encryption-algorithm/","link":"","permalink":"https://ysluckly.github.io/2017/04/22/encryption-algorithm/","excerpt":"","text":"一、对称密钥算法概述对称加密（Symmetric-key algorithm）是指加解密用同一个密钥的算法，根据具体实现分为流加密和分组加密两种类型： 流加密（Stream cipher）是对称加密常用的一种实现方法，加密和解密双方使用相同伪随机加密数据流，一般都是逐位异或随机密码本的内容。 分组加密加密（Block cipher），也叫块加密，将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。现代分组加密建立在迭代的思想上产生密文。迭代产生的密文在每一轮加密中使用不同的子密钥，而子密钥生成自原始密钥。 对称加密普遍比非对称加密速度要快，实现更简单，适合大量内容的加密 DESDES (Data Encryption Standard) 是一种分组加密算法 DES算法的入口参数有三个:Key,Data,Mode，Key是密钥密钥占7个字节56位（64位里另外8位是用来校验的），Data是加密内容，占8个字节64位，Mode是加密还是解密。 DES算法于1976被确定，现在已经被认为不够安全，主要原因是56位的密钥过短。据说这个算法因为包含一些机密设计元素，被怀疑内含美国国家安全局（NSA）的后门。 DES算法有个拓展算法叫3DES，就是对数据块进行三次DES加密，增加爆破成本，但本质上也不够安全。 RC4RC4 (Rivest Cipher 4) 是一种流加密算法 RC4起源于1987年，现在已经被认为不够安全。RC4由伪随机数生成器和异或运算组成。RC4的密钥长度可变，范围是[1,255]。RC4一个字节一个字节地加解密。给定一个密钥，伪随机数生成器接受密钥并产生一个S盒。S盒用来加密数据，而且在加密过程中S盒会变化。 由于异或运算的对合性，RC4加密解密使用同一套算法。这个算法实现起来很简单，只用了最基本的加、异或、循环，话说我大学时某个课程设计的做的加密算法就是简化版的RC4。 之后还出现了RC5、RC6加密算法，但RC5和RC6都是分组加密，和RC4原理并不一样。 RC5RC5 （Rivest Cipher 5） 是一种分组加密算法，它和RC2，RC4，RC6都是同一个叫Ronald Rivest的人设计的。 相比RC4，RC5的密钥成了128位，但RC5仍然只需要基础的加、异或、循环运算，可以在很多硬件上实现。RC5有三个参数：字的大小，循环轮数（round），密钥中的8位字节个数，所以可以说RC5是一种可变加密算法。实际上循环轮数12轮以下的RC5都被认为是不安全的，会被差分分析法（Differential cryptanalysis）攻击，18-20轮才足够安全。 目前来说，RC5还是挺安全的，因为实现简单，消耗资源少，在一些传感器、嵌入式设备上使用很合适。 RC6RC6 （Rivest Cipher 6） 是RC5的加强版，也属于分组加密算法。 RC6算法在RC5算法基础之上针对RC5算法中的漏洞，主要是循环移位的位移量并不取决于要移动次数的所有比特，通过采用引入乘法运算来决定循环移位次数的方法，对RC5算法进行了改进，从而大大提高了RC6算法的安全性。 RC6曾作为AES（高级加密标准）备选算法之一，但最终AES选择了Rijndael算法。 AES最后压轴出场的是最著名的单密钥对称加密算法AES (Rijndael)，AES是Advanced Encryption Standard的缩写，是美国国家标准与技术研究院2001年发布的新加密标准。 AES现在就是指的限定了区块长度和密钥长度的Rijndael算法，同样属于分组加密算法，该算法是两位比利时学者1998年发布的。起初还有很多算法参与了AES甄选，最终Rijndael凭借高安全性和清晰的数学结构而被选用。 AES将Rijndael算法的区块长度固定为128位，密钥长度可选128，192或256比特（Rijndael原版支持128-256，n*32的区块长度和密钥长度）。 AES算法包括4个步骤： AddRoundKey—矩阵中的每一个字节都与该次回合密钥（round key）做XOR运算；每个子密钥由密钥生成方案产生。 SubBytes—通过一个非线性的替换函数，用查找表的方式把每个字节替换成对应的字节。 ShiftRows—将矩阵中的每个横列进行循环式移位。 MixColumns—为了充分混合矩阵中各个直行的操作。这个步骤使用线性转换来混合每内联的四个字节。最后一个加密循环中省略MixColumns步骤，而以另一个AddRoundKey替换。 截止现在（2016），AES在算法层面上是安全的。2005年有人公布过一种缓存时序攻击法，但使用场景非常极端。 二、非对称秘钥算法概述公钥加密的思想于1974年被提出，相比对称加密无需共享密钥，更加安全。但是没法加密大量数据，一般用来加密对称加密的密钥，而用对称加密加密大量数据。非对称加密的原理如下： 消息发送方A在本地构建密钥对，公钥和私钥； 消息发送方A将产生的公钥发送给消息接收方B； B向A发送数据时，通过公钥进行加密，A接收到数据后通过私钥进行解密，完成一次通信； 反之，A向B发送数据时，通过私钥对数据进行加密，B接收到数据后通过公钥进行解密。 RSARSA算法是最著名的非对称加密算法。RSA是1977年提出的，名字来源于Rivest、Shmir和Adleman三位作者。我们平时用到的SSL协议，TLS协议都采用了该算法加密，SSH（Secure Shell）也是基于RSA实现的。 RSA的数学基础是极大整数的因数分解，具体实现过程如下： 随意选择两个大的质数p和q，p不等于q，计算N=pq。 根据欧拉函数，求得r=varphi (N) = varphi(p) * varphi(q)=(p-1)(q-1) 选择一个小于r的整数e，使e与r互质。并求得e关于r的模反元素，命名为d。 (N,e)是公钥，(N,d)是私钥。 加密时，加密的块 n^e ≡ c(MOD N)，得到的c就是密文。解密时，c^d ≡ n(MOD N)。 要破解RSA要解决怎么把一个极大数分解为两个质数p和q，然后通过欧拉函数再得到公钥和私钥。但极大数因数分解目前还没什么好办法，所以只要N足够大，RSA在算法层面上就是安全的。 当N的长度为256时，用普通电脑花几小时即可以分解，当N长度为512时需要花数月时间分解，1024时需要大型分布式系统才能分解，长度到2046则可以确保是完全安全的。目前已有记录里，被分解的极大数最大位数是768位，于2009年被分解。 RSA也常被用来做数字签名，在消息内附加一个私钥加密过的散列值（Message digest），以此来确保消息发送人是可靠的。公钥私钥对生成 # 1.该命令会生成1024位的私钥,此时我们就可以在当前路径下看到rsa_private_key.pem文件了. genrsa -out rsa_private_key.pem 1024 # 2.生成的密钥不是pcs8格式，我们需要转成pkcs8格式 pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt # 3.生成 rsa 公钥 rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem 椭圆曲线算法椭圆曲线算法（Elliptic curve cryptography）也是一种非对称加密算法，于1985年被提出，以下简称ECC。相比RSA，同等破解难度时ECC的秘钥更短。另外，ECC可定义椭圆曲线群的双线性映射，该特性可能将来被用来实现身份基加密体制（Identity-Based Encryption，IBE）。 ECC的数学基础是求椭圆曲线离散对数问题。实现比较复杂我就不写了，因为我也看不懂(⊙﹏⊙)b。 也正因为实现复杂，ECC的加解密速度慢，消耗资源也更多。 ECC也同样可以实现数字签名，叫做ECDSA。 ECC的秘钥长度最小要求是160位，建议是163位。目前已有的破解记录是109位，一万台机器破解了一年半。所以ECC在算法层面是可以保证安全的。 ElGamalElGamal加密算法是一种用于对采用Diff-Hellman方式进行交换的公钥进行加密，常被用于数字签名和密钥加密的算法，ElGamal的数学基础是有限域上的离散对数问题。 选择一个素数p和两个随机数g 、x （g、 x &lt; p ），计算 y ≡ g^x（ mod p ） ，则其公钥为 y, g 和p ，私钥是x ，g和p可由一组用户共享。 ElGamal方法中一个明文对应两个加密结果(g^a和g^b)，因此密文空间的大小是明文空间大小的两倍，也就是说纵观整个通信过程，收发密文的大小是实际明文大小的两倍。 三、哈希算法概述我们经常说MD5加密，但追根究底的话，MD5应该是哈希函数（Hash Function），而哈希函数并不等同于加密（Encrypt），不过我们平常也把哈希叫做加密。哈希函数也叫散列函数，散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用来代表一个短的随机字母和数字组成的字符串。 说人话就是哈希（Hash）是将目标文本转换成具有相同长度的、不可逆的杂凑字符串，而加密（Encrypt）是将目标文本转换成具有不同长度的、可逆的密文。 哈希主要用来校验身份，错误检查，完整性检查。 MD5MD5（Message-Digest5 Algorithm）即消息摘要算法，是最著名、应用最为广泛的一种哈希算法，于1992年被公开。MD5之前还有MD4、MD3、MD2等哥哥算法，MD5是最终的改进版。 MD5输入不定长度信息，输出固定长度为128-bits的散列 未完 待补充REFERENCE常见加密算法简介","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"其他","slug":"后端/其他","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"encryption","slug":"encryption","permalink":"https://ysluckly.github.io/tags/encryption/"}]},{"title":"JSP操作记录","slug":"front-end/JSP操作记录","date":"2017-04-21T03:22:12.000Z","updated":"2022-02-19T09:27:58.495Z","comments":true,"path":"2017/04/21/jsp-use-record/","link":"","permalink":"https://ysluckly.github.io/2017/04/21/jsp-use-record/","excerpt":"","text":"问题EL表达式失效&lt;!-- jsp渲染器不识别el表达式，结果页面展示效果如下 --&gt; &#123;person.id&#125; &#123;person.name&#125; 解决方法：在页面内加入下面代码即可 &lt;%@ page isELIgnored=&quot;false&quot; %&gt; Map遍历&lt;c:forEach items=&quot;$&#123;map&#125;&quot; var=&quot;entry&quot;&gt; &lt;c:out value=&quot;$&#123;entry.key&#125;&quot; /&gt; &lt;c:out value=&quot;$&#123;entry.value&#125;&quot; /&gt; &lt;/c:forEach&gt; 取值&lt;c:out value=&quot;$&#123;map[key]&#125;&quot; /&gt;","categories":[{"name":"大前端","slug":"大前端","permalink":"https://ysluckly.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"https://ysluckly.github.io/tags/jsp/"},{"name":"jstl","slug":"jstl","permalink":"https://ysluckly.github.io/tags/jstl/"}]},{"title":"[转]SpringMVC执行流程及源码解析","slug":"back-end/转-SpringMVC执行流程及源码解析","date":"2017-04-15T02:22:05.000Z","updated":"2022-02-20T13:01:47.794Z","comments":true,"path":"2017/04/15/SpringMVC-implementation-process/","link":"","permalink":"https://ysluckly.github.io/2017/04/15/SpringMVC-implementation-process/","excerpt":"","text":"在SpringMVC中主要是围绕着DispatcherServlet来设计，可以把它当做指挥中心。这里先说明一下SpringMVC文档给出的执行流程，然后是我们稍微具体的执行流程，最后是流程大致的源码跟踪。关于很很很详细的源码解析，这里暂先不做。 官方文档中的流程首先看下SpringMVC文档上给的流程图：这张图片给了我们大概的执行流程： 用户请求首先发送到前端控制器DispatcherServlet，DispatcherServlet根据请求的信息来决定使用哪个页面控制器Controller（也就是我们通常编写的Controller）来处理该请求。找到控制器之后，DispatcherServlet将请求委托给控制器去处理。 接下来页面控制器开始处理用户请求，页面控制器会根据请求信息进行处理，调用业务层等等，处理完成之后，会把结果封装成一个ModelAndView返回给DispatcherServlet。 前端控制器DispatcherServlet接到页面控制器的返回结果后，根据返回的视图名选择相应的试图模板，并根据返回的数据进行渲染。 最后前端控制器DispatcherServlet将结果返回给用户。 更具体的流程上面只是总体流程，接下来我们稍微深入一点，看下更具体的流程，这里没有图，只有步骤解析： 用户请求发送到前端控制器DispatcherServlet。 前端控制器DispatcherServlet接收到请求后，DispatcherServlet会使用HandlerMapping来处理，HandlerMapping会查找到具体进行处理请求的Handler对象。 HandlerMapping找到对应的Handler之后，并不是返回一个Handler原始对象，而是一个Handler执行链，在这个执行链中包括了拦截器和处理请求的Handler。HandlerMapping返回一个执行链给DispatcherServlet。 DispatcherServlet接收到执行链之后，会调用Handler适配器去执行Handler。 Handler适配器执行完成Handler（也就是我们写的Controller）之后会得到一个ModelAndView，并返回给DispatcherServlet。 DispatcherServlet接收到Handler适配器返回的ModelAndView之后，会根据其中的视图名调用视图解析器。 视图解析器根据逻辑视图名解析成一个真正的View视图，并返回给DispatcherServlet。 DispatcherServlet接收到视图之后，会根据上面的ModelAndView中的model来进行视图中数据的填充，也就是所谓的视图渲染。 渲染完成之后，DispatcherServlet就可以将结果返回给用户了。 源码DispatcherServlet是一个Servlet，我们知道在Servlet在处理一个请求的时候会交给service方法进行处理，这里也不例外，DispatcherServlet继承了FrameworkServlet，首先进入FrameworkServlet的service方法： protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //请求方法 String method = request.getMethod(); //PATCH方法单独处理 if (method.equalsIgnoreCase(RequestMethod.PATCH.name())) &#123; processRequest(request, response); &#125; else &#123;//其他的请求类型的方法经由父类，也就是HttpServlet处理 super.service(request, response); &#125; &#125; HttpServlet中会根据请求类型的不同分别调用doGet或者doPost等方法，FrameworkServlet中已经重写了这些方法，在这些方法中会调用processRequest进行处理，在processRequest中会调用doService方法，这个doService方法就是在DispatcherServlet中实现的。下面就看下DispatcherServlet中的doService方法的实现。 请求到达DispatcherServletdoService方法： protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //给request中的属性做一份快照 Map&lt;String, Object&gt; attributesSnapshot = null; if (WebUtils.isIncludeRequest(request)) &#123; logger.debug(&quot;Taking snapshot of request attributes before include&quot;); attributesSnapshot = new HashMap&lt;String, Object&gt;(); Enumeration&lt;?&gt; attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) &#123; String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith(&quot;org.springframework.web.servlet&quot;)) &#123; attributesSnapshot.put(attrName, request.getAttribute(attrName)); &#125; &#125; &#125; //如果我们没有配置类似本地化或者主题的处理器之类的 //SpringMVC会使用默认的值 //默认配置文件是DispatcherServlet.properties request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext()); request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver); request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver); request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource()); FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response); if (inputFlashMap != null) &#123; request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap)); &#125; request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap()); request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager); try &#123; //开始处理 doDispatch(request, response); &#125; finally &#123; if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; return; &#125; // Restore the original attribute snapshot, in case of an include. if (attributesSnapshot != null) &#123; restoreAttributesAfterInclude(request, attributesSnapshot); &#125; &#125; &#125; DispatcherServlet开始真正的处理，doDispatch方法： protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; //SpringMVC中异步请求的相关知识，暂先不解释 WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; //先检查是不是Multipart类型的，比如上传等 //如果是Multipart类型的，则转换为MultipartHttpServletRequest类型 processedRequest = checkMultipart(request); multipartRequestParsed = processedRequest != request; //获取当前请求的Handler mappedHandler = getHandler(processedRequest, false); if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return; &#125; //获取当前请求的Handler适配器 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // 对于header中last-modified的处理 String method = request.getMethod(); boolean isGet = &quot;GET&quot;.equals(method); if (isGet || &quot;HEAD&quot;.equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; //拦截器的preHandle方法进行处理 if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; try &#123; //真正调用Handler的地方 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; &#125; //处理成默认视图名，就是添加前缀和后缀等 applyDefaultViewName(request, mv); //拦截器postHandle方法进行处理 mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; //处理最后的结果，渲染之类的都在这里 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Error err) &#123; triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); return; &#125; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125; 可以看到大概的步骤还是按照我们上面分析的走的。 查找请求对应的Handler对象对应着这句代码 mappedHandler = getHandler(processedRequest, false);，看下具体的getHandler方法： protected HandlerExecutionChain getHandler(HttpServletRequest request, boolean cache) throws Exception &#123; return getHandler(request); &#125; 继续往下看getHandler： protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; //遍历所有的handlerMappings进行处理 //handlerMappings是在启动的时候预先注册好的 for (HandlerMapping hm : this.handlerMappings) &#123; HandlerExecutionChain handler = hm.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; return null; &#125; 继续往下看getHandler，在AbstractHandlerMapping类中： public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; //根据request获取handler Object handler = getHandlerInternal(request); if (handler == null) &#123; //如果没有找到就使用默认的handler handler = getDefaultHandler(); &#125; if (handler == null) &#123; return null; &#125; //如果Handler是String，表明是一个bean名称 //需要超照对应bean if (handler instanceof String) &#123; String handlerName = (String) handler; handler = getApplicationContext().getBean(handlerName); &#125; //封装Handler执行链 return getHandlerExecutionChain(handler, request); &#125; 根据requrst获取handler首先看下根据requrst获取handler步骤getHandlerInternal方法，在AbstractHandlerMethodMapping中： protected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception &#123; //获取request中的url，用来匹配handler String lookupPath = getUrlPathHelper().getLookupPathForRequest(request); //根据路径寻找Handler HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request); //根据handlerMethod中的bean来实例化Handler并添加进HandlerMethod return (handlerMethod != null) ? handlerMethod.createWithResolvedBean() : null; &#125; 看下根据路径寻找handler的方法lookupHandlerMethod： protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception &#123; List&lt;Match&gt; matches = new ArrayList&lt;Match&gt;(); //直接匹配 List&lt;T&gt; directPathMatches = this.urlMap.get(lookupPath); //如果有匹配的，就添加进匹配列表中 if (directPathMatches != null) &#123; addMatchingMappings(directPathMatches, matches, request); &#125; //还没有匹配的，就遍历所有的处理方法查找 if (matches.isEmpty()) &#123; // No choice but to go through all mappings addMatchingMappings(this.handlerMethods.keySet(), matches, request); &#125; //找到了匹配的 if (!matches.isEmpty()) &#123; Comparator&lt;Match&gt; comparator = new MatchComparator(getMappingComparator(request)); Collections.sort(matches, comparator); //排序之后，获取第一个 Match bestMatch = matches.get(0); //如果有多个匹配的，会找到第二个最合适的进行比较一下 if (matches.size() &gt; 1) &#123; Match secondBestMatch = matches.get(1); if (comparator.compare(bestMatch, secondBestMatch) == 0) &#123; Method m1 = bestMatch.handlerMethod.getMethod(); Method m2 = secondBestMatch.handlerMethod.getMethod(); throw new IllegalStateException( &quot;Ambiguous handler methods mapped for HTTP path &#39;&quot; + request.getRequestURL() + &quot;&#39;: &#123;&quot; + m1 + &quot;, &quot; + m2 + &quot;&#125;&quot;); &#125; &#125; //设置request参数 handleMatch(bestMatch.mapping, lookupPath, request); //返回匹配的url的处理的方法 return bestMatch.handlerMethod; &#125; else &#123;//最后还没有找到，返回null return handleNoMatch(handlerMethods.keySet(), lookupPath, request); &#125; &#125; 获取默认Handler如果上面没有获取到Handler，就会获取默认的Handler。如果还获取不到就返回null。 处理String类型的Handler如果上面处理完的Handler是String类型的，就会根据这个handlerName获取bean。 封装Handler执行链上面获取完Handler，就开始封装执行链了，就是将我们配置的拦截器加入到执行链中去，getHandlerExecutionChain： protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) &#123; //如果当前Handler不是执行链类型，就使用一个新的执行链实例封装起来 HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain) ? (HandlerExecutionChain) handler : new HandlerExecutionChain(handler); //先获取适配类型的拦截器添加进去拦截器链 chain.addInterceptors(getAdaptedInterceptors()); //当前的url String lookupPath = urlPathHelper.getLookupPathForRequest(request); //遍历拦截器，找到跟当前url对应的，添加进执行链中去 for (MappedInterceptor mappedInterceptor : mappedInterceptors) &#123; if (mappedInterceptor.matches(lookupPath, pathMatcher)) &#123; chain.addInterceptor(mappedInterceptor.getInterceptor()); &#125; &#125; return chain; &#125; 获取对应请求的Handler适配器getHandlerAdapter： protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123; //遍历所有的HandlerAdapter，找到和当前Handler匹配的就返回 //我们这里会匹配到RequestMappingHandlerAdapter for (HandlerAdapter ha : this.handlerAdapters) &#123; if (ha.supports(handler)) &#123; return ha; &#125; &#125; &#125; 缓存的处理也就是对last-modified的处理 执行拦截器的preHandle方法就是遍历所有的我们定义的interceptor，执行preHandle方法 使用Handler适配器执行当前的Handlerha.handle执行当前Handler，我们这里使用的是RequestMappingHandlerAdapter，首先会进入AbstractHandlerMethodAdapter的handle方法： public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return handleInternal(request, response, (HandlerMethod) handler); &#125; handleInternal方法，在RequestMappingHandlerAdapter中： protected final ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123; // Always prevent caching in case of session attribute management. checkAndPrepare(request, response, this.cacheSecondsForSessionAttributeHandlers, true); &#125; else &#123; // Uses configured default cacheSeconds setting. checkAndPrepare(request, response, true); &#125; // Execute invokeHandlerMethod in synchronized block if required. if (this.synchronizeOnSession) &#123; HttpSession session = request.getSession(false); if (session != null) &#123; Object mutex = WebUtils.getSessionMutex(session); synchronized (mutex) &#123; return invokeHandleMethod(request, response, handlerMethod); &#125; &#125; &#125; //执行方法，封装ModelAndView return invokeHandleMethod(request, response, handlerMethod); &#125; 组装默认视图名称前缀和后缀名都加上 执行拦截器的postHandle方法遍历intercepter的postHandle方法。 处理最后的结果，渲染之类的processDispatchResult方法： private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throws Exception &#123; boolean errorView = false; if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123; mv = ((ModelAndViewDefiningException) exception).getModelAndView(); &#125; else &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); &#125; &#125; // Did the handler return a view to render? if (mv != null &amp;&amp; !mv.wasCleared()) &#123; //渲染 render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else &#123; &#125; if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Concurrent handling started during a forward return; &#125; if (mappedHandler != null) &#123; mappedHandler.triggerAfterCompletion(request, response, null); &#125; &#125; 重点看下render方法，进行渲染： protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //设置本地化 Locale locale = this.localeResolver.resolveLocale(request); response.setLocale(locale); View view; if (mv.isReference()) &#123; //解析视图名，得到视图 view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request); &#125; else &#123; // No need to lookup: the ModelAndView object contains the actual View object. view = mv.getView(); if (view == null) &#123; throw new ServletException(&quot;ModelAndView [&quot; + mv + &quot;] neither contains a view name nor a &quot; + &quot;View object in servlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;); &#125; &#125; //委托给视图进行渲染 view.render(mv.getModelInternal(), request, response); &#125; view.render就是进行视图的渲染，然后跳转页面等处理。 到这里大概的流程就走完了。其中涉及到的东西还有很多，暂先不做详细处理。 原文：SpringMVC执行流程及源码解析","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ysluckly.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://ysluckly.github.io/tags/spring/"},{"name":"springmvc","slug":"springmvc","permalink":"https://ysluckly.github.io/tags/springmvc/"}]},{"title":"PostgreSQL常用SQL操作","slug":"database/PostgreSQL常用SQL操作","date":"2017-04-14T08:37:24.000Z","updated":"2022-02-20T13:03:11.101Z","comments":true,"path":"2017/04/14/postgres-sql-use/","link":"","permalink":"https://ysluckly.github.io/2017/04/14/postgres-sql-use/","excerpt":"","text":"说明：文章中实例均在 PostgreSQL 环境操作。 DDL数据定义语言数据库/角色/schema-- 创建一个数据库用户 create role &quot;sp-boss&quot; createdb createrole login password &#39;sp-boss&#39;; -- 使用上面角色登录 postgres 数据库 psql -U sp-boss -d postgres -- 创建自己的数据库 create database &quot;sp-boss&quot; -- 登录自己的数据库 psql -U sp-boss -- 创建一个其他用户 create role &quot;sp-manager&quot; login password &#39;sp-manager&#39;; -- 赋予 create 权限 grant create on database &quot;sp-boss&quot; to &quot;sp-manager&quot;; -- 使用 新用户 登录数据库 psql -U sp-manager -d sp-boss -- 创建自己的 schema create schema &quot;sp-manager&quot;; 表--创建表 create table user_info ( id serial primary key, name varchar(20), age integer, create_time timestamp, type integer, display boolean default true, unique (name, type) ); --删除表 drop table exists user_info; --重命名表 alter table user_info rename to user_infos; 字段（列）--添加一列 alter table user_info add [column] username varchar(50); --删除一列 alter table user_info drop [column] username; --重命名列 alter table user_info rename [column] username to name; --修改结构 alter table user_info alter [column] username set not null; -- 唯一约束-- 添加名为 uk_name 的联合唯一约束，组合列为column1和column2 alter table sys_theme add constraint uk_name unique(column1,column2); -- 删除名为 uk_name 的约束 alter table sys_theme drop constraint uk_name; DML数据库操作语言SELECT查询包含json格式的text类型的数据postgres=# select * from person; id | name | other ----+--------+---------------------------------------------------------- 1 | faker | &#123;&quot;gender&quot;:&quot;male&quot;,&quot;address&quot;:&quot;xiamen&quot;,&quot;college&quot;:&quot;xmut&quot;&#125; 2 | watson | &#123;&quot;gender&quot;:&quot;male&quot;,&quot;address&quot;:&quot;shenzhen&quot;,&quot;college&quot;:&quot;szu&quot;&#125; 3 | lance | &#123;&quot;gender&quot;:&quot;male&quot;,&quot;address&quot;:&quot;shenzhen&quot;,&quot;college&quot;:&quot;xmut&quot;&#125; 4 | jine | &#123;&quot;gender&quot;:&quot;female&quot;,&quot;address&quot;:&quot;xiamen&quot;,&quot;college&quot;:&quot;xmut&quot;&#125; 5 | jobs | &#123;&quot;gender&quot;:&quot;male&quot;,&quot;address&quot;:&quot;beijing&quot;,&quot;college&quot;:&quot;xmu&quot;&#125; 6 | yak | &#123;&quot;gender&quot;:&quot;female&quot;,&quot;address&quot;:&quot;xiamen&quot;,&quot;college&quot;:&quot;xmut&quot;&#125; 7 | alice | &#123;&quot;gender&quot;:&quot;female&quot;,&quot;address&quot;:&quot;shanghai&quot;,&quot;college&quot;:&quot;thu&quot;&#125; 8 | anita | &#123;&quot;gender&quot;:&quot;female&quot;,&quot;address&quot;:&quot;xiongan&quot;,&quot;college&quot;:&quot;hku&quot;&#125; (8 行记录) -- 查询深圳学生的高校分部情况 select other::json-&gt;&gt;&#39;college&#39; college, count(1) from person where other::json-&gt;&gt;&#39;address&#39;=&#39;shenzhen&#39; group by other::json-&gt;&gt;&#39;college&#39;; ___________________________ college | count ---------+------- szu | 1 xmut | 1 (1 行记录) --- 结果可得深圳一共有两个学生， --- 在深圳大学和厦门理工学院各一个。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"PostgreSQL","slug":"数据库/PostgreSQL","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL/"}],"tags":[{"name":"postgres","slug":"postgres","permalink":"https://ysluckly.github.io/tags/postgres/"},{"name":"sql","slug":"sql","permalink":"https://ysluckly.github.io/tags/sql/"}]},{"title":"deepin系统使用记录","slug":"tools/deepin-linux","date":"2017-03-30T10:58:50.000Z","updated":"2022-02-19T09:27:58.552Z","comments":true,"path":"2017/03/30/deepin-linux/","link":"","permalink":"https://ysluckly.github.io/2017/03/30/deepin-linux/","excerpt":"","text":"传送门 官网 论坛 deepin’wiki Deepin应用列表 输入法安装输入法，除了商店下载（好多输入法没有被收录进deepin商店），可以使用fcitx安装。如安装google拼音输入法： $ sudo aptitude install fcitx fcitx-googlepinyin 如果当前在使用ibus，而不是fcitx的话，看下面1）安装fcitx，并安装google拼音 $ sudo apt-get install fcitx fcitx-googlepinyin im-config 2）打开输入法配置 $ im-config 依次：ok-&gt;yes,选择fcitx为默认输入法框架,ok-&gt;ok 制作启动器图标以创建 atom 这款编辑器的启动器图标为例。1）进入 /usr/share/applications/ 目录，创建 atom.desktop 文件2）编辑 atom.desktop 文件 [Desktop Entry] Name=Atom Comment=A hackable text editor for the 21st century Exec=/opt/atom/atom %F Icon=/opt/atom/atom.png Type=Application StartupNotify=true Categories=TextEditor;Development;Utility; MimeType=text/plain; 解释：Name：创建的图标名称Comment：备注，随便填Exec：启动文件的位置Icon：图标位置Type：类型，启动程序就填ApplicationStartupNotify: 启动通知，填true就行了。详细可查 Startup notificationCategories： 分类，随便填，比如：Application;MimeType： 打开文件类型 修改apt源修改 /etc/apt/sources.list默认的源 deb [by-hash=force] http://packages.deepin.com/deepin/ unstable main contrib non-free 阿里云的源 deb [by-hash=force] http://mirrors.aliyun.com/deepin unstable main contrib non-free 更换文件管理器Nautilus 深度商店下载安装 Nautilus2）卸载深度任务管理器$ sudo apt remove dde-file-manager Nautilus 常用的快捷键 快捷键 作用 F2 重命名 Ctrl + 1 图标视图 Ctrl + 2 列表视图 Ctrl + T 新建标签页 Ctrl + W 关闭标签页 Alt + 数字 切换到指定标签页 Ctrl + D 收藏到当前文件夹到书签 Shift + F10 打开鼠标右键菜单 Alt + 左方向键 后退 Alt + 右方向键 前进 Ctrl + Q 退出","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"软件记录","slug":"工具/软件记录","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/tags/%E8%BF%90%E7%BB%B4/"},{"name":"deepin","slug":"deepin","permalink":"https://ysluckly.github.io/tags/deepin/"}]},{"title":"hexo报错合集","slug":"tools/hexo-error-collection","date":"2017-03-27T11:40:42.000Z","updated":"2022-02-19T09:27:58.561Z","comments":true,"path":"2017/03/27/hexo-error-collection/","link":"","permalink":"https://ysluckly.github.io/2017/03/27/hexo-error-collection/","excerpt":"","text":"hexo server时报错FATAL watch … ENOSPC日志：2017-03-27 执行 hexo server 后报错。如图：分析问题：node.js 中 watch 的文件数是有限制的。解决问题： $ echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"}]},{"title":"3-hexo快捷键说明","slug":"tools/3-hexo-shortcuts","date":"2017-03-24T08:45:31.000Z","updated":"2022-02-19T09:27:58.544Z","comments":true,"path":"2017/03/24/3-hexo-shortcuts/","link":"","permalink":"https://ysluckly.github.io/2017/03/24/3-hexo-shortcuts/","excerpt":"","text":"今日公司断网了半个小时，就利用这段时间给主题添加了快捷键操作，方便使用。 快捷键为vim风格的。按键可能与vimium（chrome插件）的快捷键有冲突，插件设置屏蔽掉此站的快捷键即可 如果有比较好的建议，欢迎骚扰。 说明全局 Key Descption s/S 全屏/取消全屏 w/W 打开/关闭文章目录 i/I 获取搜索框焦点 j/J 向下滑动 k/K 向上滑动 gg/GG 到最顶端 shift+G/g 到最下端 搜索框 Key Descption ESC 1.如果输入框有内容，清除内容2.如果输入框无内容，失去焦点 下 向下选择文章 上 向上选择文章 回车 打开当前选中的文章，若没有，则默认打开第一个 关闭快捷键在主题下 _config.yml 中 找到 shortcutKey 设为 false shortcutKey: false","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"},{"name":"3-hexo","slug":"3-hexo","permalink":"https://ysluckly.github.io/tags/3-hexo/"}]},{"title":"3-hexo使用说明","slug":"tools/3-hexo-instruction","date":"2017-03-23T07:13:47.000Z","updated":"2022-02-19T09:27:58.539Z","comments":true,"path":"2017/03/23/3-hexo-instruction/","link":"","permalink":"https://ysluckly.github.io/2017/03/23/3-hexo-instruction/","excerpt":"","text":"下面如果没有特殊说明， _config.yml 都指主题配置文件，即 3-hexo 目录下 一、初始化博客下 _config.yml1.1 国际化language: zh-CN #支持 zh-CN、en 1.2 关掉 hexo 自带的代码高亮主题内置了主题高亮，所以需要禁用 hexo 自带的高亮 highlight: enable: false 二、功能相关2.1 自定义首页可查看这篇文章： 3-hexo配置首页 2.3 blog快捷键可查看这篇文章： 3-hexo快捷键说明 2.4 多作者模式可查看这篇文章： 3-hexo多作者模式 2.5 开启关于页面 在 hexo 根目录执行以下，创建 关于 页面hexo new page &quot;about&quot; 位置： source/aoubt/index.md ，根据需要进行编辑。 在主题中开启显示：修改主题根目录 _config.yml 中的 about 的 on 为 true，如下所示menu: about: # &#39;关于&#39; 按钮 on: true # 是否显示 url: /about # 跳转链接 type: 1 # 跳转类型 1：站内异步跳转 2：当前页面跳转 3：打开新的tab页 2.6 添加音乐插件3-hexo 添加音乐插件 2.7 配置评论系统3-hexo评论设置 三、样式设置3.1 代码高亮首先要关闭hexo根目录下_config.yml中的高亮设置： highlight: enable: false 配置主题下_config.yml中的高亮设置：可以根据提示，配置喜欢的高亮主题 highlight: on: true # true开启代码高亮 lineNum: true # true显示行号 theme: darcula # 代码高亮主题,效果可以查看 https://highlightjs.org/static/demo/ # 支持主题： # sublime : 参考sublime的高亮主题 # darcula : 参考idea中的darcula的主题 # atom-dark : 参考Atom的dark主题 # atom-light : 参考Atom的light主题 # github : 参考GitHub版的高亮主题 # github-gist : GitHub-Gist主题 # brown-paper : 牛皮纸效果 # gruvbox-light : gruvbox的light主题 # gruvbox-dark ： gruvbox的dark主题 # rainbow : # railscasts : # sunburst : # kimbie-dark : # kimbie-light : # school-book : 纸张效果 3.2 MathJax数学公式修改 _config.yml # MathJax 数学公式支持 mathjax: on: true #是否启用 per_page: false # 若只渲染单个页面，此选项设为false，页面内加入 mathjax: true 考虑到页面的加载速度，支持渲染单个页面。设置 per_page: false ,在需要渲染的页面内 加入 mathjax: true 注意: 由于hexo的MarkDown渲染器与MathJax有冲突，可能会造成矩阵等使用不正常。所以在使用之前需要修改两个地方编辑 node_modules\\marked\\lib\\marked.js 脚本 将451行 ，这一步取消了对 \\\\,\\&#123;,\\&#125; 的转义(escape)escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()# +\\-.!_&gt;])/, 改为 escape: /^\\\\([`*\\[\\]()# +\\-.!_&gt;])/, 将459行，这一步取消了对斜体标记 _ 的转义em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 改为 em:/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 3.3 表格样式目前提供了3中样式，修改 _config.yml table: green_title # table 的样式 # 为空时类似github的table样式 # green 绿色样式 # green_title 头部为青色的table样式 3.4 文章列表的hover样式鼠标移入的背景色和文字颜色变动，设置 _config.yml #文章列表 鼠标移上去的样式, 为空时使用默认效果 article_list: hover: background: &#39;#e2e0e0&#39; # 背景色:提供几种：&#39;#c1bfc1&#39; &#39;#fbf4a8&#39; color: # 文字颜色 提供几种：&#39;#ffffff&#39; # 注意：由于颜色如果包含#，使用单引号 &#39; 引起来 3.5 开启字数统计 开启此功能需先安装插件，在 hexo根目录 执行 npm i hexo-wordcount --save 修改 _config.yml word_count: true 3.6 更换头像两种方式： 替换 source/img/avatar.jpg 图片。 修改 _config.yml 中头像的配置记录 # 你的头像url avatar: /img/avatar.jpg favicon: /img/avatar.jpg 3.7 设置链接图标 如果需要自定义图标可以看这篇文章 3-hexo添加自定义图标 如下，如果没有连接，则不展示图标。 #链接图标，链接为空则不显示 link: rss: /atom.xml github: https://github.com/yelog facebook: https://www.facebook.com/faker.tops twitter: linkedin: instagram: reddit: https://www.reddit.com/user/yelog/ weibo: http://weibo.com/u/2307534817 email: jaytp@qq.com 四、排序及置顶4.1 分类排序默认按照首字母正序排序，由于中文在 nodejs 环境下不能按照拼音首字母排序，所以添加了自定义排序方式，在主题下 _config.yml 中找到如下配置，category.sort则是定义分类顺序的。 规则：在 sort中定义的 category 比 没有在 sort 中定义的更靠前 # 文章分类设置 category: num: true # 分类显示文章数 sub: true # 开启多级分类 sort: - 读书 - 大前端 - 后端 - 数据库 - 工具 - 运维 4.2 文章排序 2020-05-20 更新：无需安装插件或修改源码，主题已经内置排序算法 文章列表默认按照创建时间（如下文章内定义的date）倒序。 使用 top 将会置顶文章，多个置顶文章时，top 定义的值越大，越靠前。 --- title: 每天一个linux命令 date: 2017-01-23 11:41:48 top: 1 categories: - 运维 tags: - linux命令 --- 五、关于写文章5.1 如何写每篇文章最好写上文集和标签，方便筛选和查看。一般推荐一篇文章设置一个文集，一个或多个标签categories:文集，为左侧列表tags:标签，通过#来筛选例如 本篇文章的设置 --- title: 3-hexo使用说明 date: 2017-03-23 15:13:47 categories: - 工具 tags: - hexo - 3-hexo --- 5.2 写作1.设置模板，blog根目录 scaffolds/post.md加入categories,tags等，这样以后通过 hexo new 生成的模板就不用写这两个单词了。当然，你也可以写入任何你每个文章中都会有的部分。 --- title: &#123;&#123; title &#125;&#125; date: &#123;&#123; date &#125;&#125; categories: tags: --- 六、技巧6.1 快捷命令其实就通过alias，触发一些命令的集合在 ~/.bashrc 文件中添加 alias hs=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&#39; #启动本地服务 alias hd=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d&#39; #部署博客 甚至你也可以加入备份文章的命令，可以自由发挥。 6.3 博客备份（快捷命令升级版）为了保证我们写的文章不丢失、快速迁移博客，都需要备份我们的blog。 博客根目录，执行 git init 创建 git 仓库。 在 github（或其他托管平台、自建远程仓库等） 创建仓库并和本地仓库建立联系。 在 ~/.bashrc 文件中添加alias hs=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&#39; alias hd=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; git add . &amp;&amp; git commit -m &quot;update&quot; &amp;&amp; git push -f&#39; 这样，我们在执行 hd 进行部署时，就一同将博客进行备份了","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"},{"name":"3-hexo","slug":"3-hexo","permalink":"https://ysluckly.github.io/tags/3-hexo/"}]},{"title":"关于第三方评论系统","slug":"tools/the-third-comment","date":"2017-03-23T03:59:50.000Z","updated":"2022-02-20T12:03:17.199Z","comments":true,"path":"2017/03/23/the-third-comment/","link":"","permalink":"https://ysluckly.github.io/2017/03/23/the-third-comment/","excerpt":"","text":"前言昨天登录blog看到了多说的通知：将于2017年6月1日正式关停服务，其实并没有太大的意外。 自从去年9月份disqus被GFW认证后，被迫转移到多说，一看就是很久没有维护了，感觉关闭就是迟早的事，没想到刚用5个月。。 不能用disqus不开心，然后就又开始调查第三方评论系统。 友言特点 界面挺像disqus的 查询最近的评论，需要打开新的页面 支持表情，不支持图片 支持自定义界面 注册即用 网易云跟帖特点 界面简洁 网易作为后台，不容易倒 不支持表情，不支持图片 支持自定义界面 我在国外加载巨慢，不过查了国内的延迟，平均20ms左右。 注册即用 畅言特点 界面简介 打印记的功能 支持表情和图片 支持获取评论数 需要ICP备案 最后想要尝试一下畅言，功能符合我的预期，不过要ICP备案，最近由于想要开启国内CDN加速，也需要备案。 蛋四！！ 我在国外，等回国的时候再备案吧，暂时现使用 disqus,如果想评论，国内只能翻墙了。╮（╯＿╰）╭ 最后，多说一路走好。","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"}]},{"title":"windows环境下使用hexo搭建blog平台","slug":"tools/windows-hexo","date":"2017-03-17T06:02:55.000Z","updated":"2022-02-19T09:27:58.571Z","comments":true,"path":"2017/03/17/windows-hexo/","link":"","permalink":"https://ysluckly.github.io/2017/03/17/windows-hexo/","excerpt":"","text":"之前已经出过几期搭建 hexo 的文章，但是有不少朋友私信说系统是windows的，希望出一期windows环境下的hexo搭建文章。 为此，确保可用性，笔者在linux（笔者的系统环境）环境下安装了windows虚拟机重新演练了一边，确保没有什么漏洞，才写下了此文。 本文会非常详细，以确保没有计算机背景的小白也可以轻松上手 环境搭建安装git1).下载：从官网下载windows版本的git,地址在下方。https://git-scm.com/download/win2).安装：双击安装，一直点击下一步即可 安装node.js1).下载：从官网下载windows版本的node.js安装包（.msi后缀），地址下方https://nodejs.org/zh-cn/download/2).安装：双击安装，一直点击下一步即可 安装hexo在任意目录如桌面，点击鼠标右键，选择Git Bash Here这一项，打开git bash命令框（前提是git安装成功），如下图在打开的命令窗内输入下面的命令进行安装 npm install hexo-cli -g 安装过后，输入 hexo -v，出现下面信息，则表示安装成功 $ hexo -v hexo-cli: 1.0.2 os: Windows_NT 6.1.7601 win32 x64 http_parser: 2.7.0 node: 6.10.0 v8: 5.1.281.93 uv: 1.9.1 zlib: 1.2.8 ares: 1.10.1-DEV icu: 58.2 modules: 48 openssl: 1.0.2k 初始化blog进入准备创建blog的目录，同样点击鼠标右键，打开git bash命令框，执行一下命令进行初始化 $ hexo init myblog 就会自动创建一个名字为myblog目录，这时本地blog就已经创建好了。进入blog目录，启动 blog $ cd myblog $ hexo server 在浏览器输入 127.0.0.1:4000就可以访问到刚刚创建好的blog了。 换皮肤如果觉的自带的皮肤太难看。可以根据以下步奏更换皮肤在官网 可以查看各种各样的皮肤，挑选自己喜欢的皮肤 这里以 3-hexo 这款皮肤为例（这款皮肤是笔者写的，效果可查看 yelog.org）1）进入皮肤的 github 官网，如3-hexo的网址找到 clone or download ,复制它的url：https://github.com/yelog/hexo-theme-3-hexo.git 2）进入 myblog 目录，打开 git bash 命令框，执行以下命令将皮肤下载到themes目录下 $ git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo 修改 myblog/_config.yml 中的 theme: landscape 为 theme: 3-hexo 如果使用 3-hexo 主题的话，还需要注意两点①因为主题使用了自己的高亮效果，还需要修改 highlight enable: true 的 true 改为 false。②由于主题启用了文章字数统计功能，需要安装一个插件，在 myblog 目录下，打开 git bash 命令框，执行 npm i --save hexo-wordcount 即可 重新渲染，启动服务器 $ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 打开浏览器查看效果，换肤成功 如何写文章文章在 myblog/source/_posts/ 下，以markdown格式写成，笔者推荐使用atom作为写作工具。可以通过 hexo new 文章名 来创建一篇文章，当然也可以直接在 _posts 目录下直接新建.md文件。执行命令 仍是在 myblog 目录下，打开 git bash 命令框。以下是常用命令，其他可以查阅官网。 # 创建一个标题为“git教程”的文章 $ hexo new &quot;git教程&quot; # 清除所有渲染的页面 $ hexo clean # 将markdown渲染成页面 $ hexo g # 启动hexo $ hexo s 发布到网上如果想要在github上搭建blog，或者在自己的购买的服务器上搭建blog可以查看笔者的往期文章 今天的教程就到这里，有什么问题可以在评论区交流。","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"}]},{"title":"npm使用介绍","slug":"front-end/npm使用介绍","date":"2017-03-16T12:09:48.000Z","updated":"2022-02-19T09:27:58.500Z","comments":true,"path":"2017/03/16/npm/","link":"","permalink":"https://ysluckly.github.io/2017/03/16/npm/","excerpt":"","text":"Whatnpm（全称Node Package Manager，即node包管理器）是Node.js默认的、以JavaScript编写的软件包管理系统。作者：艾萨克·施吕特（Isaac Z. Schlueter） 安装npm 是随同node.js一起安装的，所以安装node.js即可。 使用# 查看版本 $ npm -v # 升级 $ sudo npm install npm -g # 安装模块 $ npm install &lt;Module Name&gt; #本地安装 # 本地安装：安装到./node_modules(命令运行目录) $ npm install &lt;Module Name&gt; -g #全局安装 # 全局安装：放在 /usr/local 下或者你 node 的安装目录。 # 卸载模块 $ npm uninstall &lt;Module Name&gt; # 更新模块 $ npm update &lt;Module Name&gt; # 查看所有安装的模块 $ npm ls #所有本地模块 $ npm ls -g #所有全局模块 # 搜索模块 $ npm search &lt;Module Name&gt;","categories":[{"name":"大前端","slug":"大前端","permalink":"https://ysluckly.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"https://ysluckly.github.io/tags/node/"}]},{"title":"为Hexo添加RSS和Sitemap","slug":"tools/Hexo-RSS-Sitemap","date":"2017-03-14T01:44:29.000Z","updated":"2022-02-19T09:27:58.547Z","comments":true,"path":"2017/03/14/Hexo-RSS-Sitemap/","link":"","permalink":"https://ysluckly.github.io/2017/03/14/Hexo-RSS-Sitemap/","excerpt":"","text":"添加RSS使用RSS是为自己的blog提供订阅功能。 1.用npm安装插件$ npm install hexo-generator-feed --save 2.配置根目录_config.yml# Extensions ## Plugins: http://hexo.io/plugins/ #RSS订阅 plugin: - hexo-generator-feed #Feed Atom feed: type: atom path: atom.xml limit: 20 3.验证配置是否成功执行 hexo g，查看一下public目录下，如果有 atom.xml 文件，则表明配置成功。 4.显示RSS图标这里以3-hexo主题为例，给rss添加链接/atom.xml修改/themes/3-hexo/_config.yml link: rss: /atom.xml 5.效果链接图标：链接地址效果 添加SitemapSitemap，网站地图，是网站优化中重要的一环，无论是对于访问者还是对于搜索引擎。 1.用npm安装插件$ npm install hexo-generator-sitemap --save 2.配置根目录_config.ymlplugin: - hexo-generator-feed - hexo-generator-sitemap 3.验证配置是否成功执行 hexo g，查看一下public目录下，如果有 sitemap.xml 文件，则表明配置成功。 4.效果访问 /sitemap.xml 就能看到生成的站点地图了","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"}]},{"title":"3-hexo开发日志-持续更新","slug":"tools/3-hexo-logs","date":"2017-03-13T07:44:57.000Z","updated":"2022-02-19T09:27:58.541Z","comments":true,"path":"2017/03/13/3-hexo-logs/","link":"","permalink":"https://ysluckly.github.io/2017/03/13/3-hexo-logs/","excerpt":"","text":"2022年0202-16 fix 修复首页使用自定义 html 标题时，大纲和文章关联关系丢失报错的问题 2021年09月09-26 fix 修复 gitalk 代理节点的问题，并升级为官方最新的代码 2021年02月02-22 enhance 按标题搜索支持字符级别模糊查询，并高亮显示 2020年12月12-28 fix 修复了右下角按钮错位问题 enhance 优化图标样式，支持自定义图标引入 change 分类超出隐藏 2020年8月08-09 fix 修复了切换大纲时，未关闭全局搜索框(in:) 的问题2. add 代码块新增显示代码类型和复制代码功能 fix分类支持 \\/#.[]() 特殊字符 fix 大纲支持URI 编码，兼容 hexo5+ 2020年5月05-29 fix 修复了旧版 hexo 报错的问题 05-23 change 由于 cloudflare 国内访问不稳定，故 cdn 切换到 jsdelivr fix 修复文章大纲为空时，同步大纲报错的问题 change 文章内 toc 生成从 @【toc】 改为 【toc】 enhance 快捷键支持关闭 shortcutKey: false add 添加第三方评论 来必力 和 utteranc remove 移除网易云评论 05-21 add 添加备案号配置 05-20 enhance 内置文章排序，无需再引入排序插件或修改源代码 enhance 支持自定义分类的顺序， 具体可以查看 3-hexo使用说明 中的排序相关内容 05-19 change 重做了文章大纲 change 重做了搜索/标签页 style 优化了整体界面风格 fix修复了诸如 分类选中动画闪烁 等细节问题 2020年2月02-041.fix: 修复 gitalk 使用 app API query parameter 弃用的问题 2019年11月11-121.fix: 修复 hexo4.0 版本链接外跳的问题2.add: 支持 mermaid 3-hexo支持mermaid图表 09-241.add: 支持文章内 toc 生成 3-hexo文章内toc生成 09-051.fix: pjax 兼容 jsfiddle 的渲染 3-hexo支持jsfiddle渲染 2019年8月08-201.fix: 左下角菜单个数为一个时，在移动端出现的位置错乱的问题 08-13 add 添加自定义左侧分类栏宽度 category.width，详情见 _config.yml 08-01 fix 修复 友链 区域超出不滚动的问题 2019年7月07-22 add 新增修改文章列表颜色的参数 07-15 fix 修复 gitalk 由于作者停止了跨域的服务，借用其他人的跨域服务解决问题 07-12 add 新增图标：qq、酷狗、网易云音乐 fix 修复文末声明跨行的问题 2019年6月06-09 fix 修复了标签按钮在某些分辨率下错位问题。 fix 修复了代码行数超百行时，行号溢出的问题 2019年5月05-21 add 文章分类可以显示文章数 category&gt;num add 文章分类支持多级显示 category&gt;sub fix 修复gitalk显示评论数错误的问题 添加背景图设置： ① _config.xml 配置默认背景图片 首页背景图： index_bg_img: xxx.jpg 文章页面背景图：other_bg_img: xxx.jpg ② 我们还可以单独给某篇文章设置背景图（优先级最高） title: 3-hexo开发日志-持续更新 bgImg: xxx.jpg #设置这篇文章的背景图 05-05 add 添加代码段高亮样式配置，对应 markdown 语法 `` ，位置：_config.yml 关键字 code 2019年1月01-05 fix 修复Firefox下，Tags 图标失效问题 2018年11月11-30 add 应用彩色图标，新增简书、知乎、csdn、oschina等图标 fix 修复 gitment 登录报错的问题 enhance 升级gitalk插件，并跟随官方版本 2018年8月08-08 修复 fix : 修复左侧栏出现滚动条的问题 2018年4月04-18 修复 fix : 调整原文地址key，解决和 encrypt 的冲突 2017年12月12-31 优化 enhance : 关闭打赏，则屏蔽相关代码。 12-28 添加自定义菜单功能 add : 添加自定义菜单功能，见配置文件 menu: 相关 fix : 修复 photoSwipe 一些问题：手机端右上角图标遮挡、首页图片渲染失败、CDN引入配置文件 12-27 插件添加 add : 引入 photoSwipe 图片相册，可在 _config 中 配置 img_resize: photoSwipe fix : 左侧分类列表过多，则显示滚动条 change : 由于cdnjs最近在国内网络波动较大，将默认CDN改到bootcdn 12-26 功能优化 enhance : 全文检索支持通过方向键选择文章，回车跳转 12-24 功能添加 add : 添加全文检索功能， 输入in:开头即可开始检索 2017年10月10-21 样式调整 enhance : 优化了高亮样式 atom-light 10-20 样式调整与添加 add : 添加列表样式 thread add : 添加引用块样式 bracket add : 文章列表可加入背景图 10-07 add : 加入关于/友链页面 2017年9月09-21 polish : 引入fragment_cache局部缓存，大幅缩减渲染(hexo g)的时间 Hexo加速渲染速度之fragment_cache enhance : 加入 SEO ，tag转keywords , title转description add : 添加文末说明参数 lit : 头像跳转首页的请求也处理为 pjax 2017年7月07-05 添加MathJax数学公式支持 add : 添加MathJax数学公式支持 3-hexo配置MathJax数学公式渲染 2017年6月06-26 添加gitment评论系统 add : 添加gitment评论系统，具体可参考 完美替代多说-gitment 2017年4月04-27 调整样式 change：调整引用块内p的样式。 04-19 调整样式和修复bug change:调整文章目录间距 fix:修复可能出现的访问量不显示的问题 04-17 调整样式及修复bug change:调整大屏下文章最大宽度（从780调到900），代码字号调整为比文字小3px fix:修复在过滤条件下，鼠标上下键不能正常在第一个，最后一个进行跳转的问题 fix:修复首页可能出现的错误渲染，导致没有样式的情况。 2017年3月03-29 增强文章列表上下键功能 enhance:增强列表跟随选择的文章上下滚动 enhance:文章列表上下循环 03-24 修复搜索及添加快捷键 fix:修复title关键字和标签关键字冲突的情况 fix:修复前进后退时对图片的错误处理 enhance:在搜索时，可以键盘上下键来选择文章 enhance:添加了一些快捷键，详情查看 3-hexo快捷键说明 03-22 添加评论系统 enhance: 添加网易云跟帖评论系统 03-21 图片放大动画 enhance:增加图片放大动画，增加过度感，最大放大至原图大小（若尺寸超过屏幕，按屏幕大小限制） 03-20 评论添加锚点 enhance:添加文章meta(标题下)中的评论数点击事件，滑动到评论区，评论区若隐藏，则自动打开 03-19 修复firfox错位问题 fix:修复firefox错位问题 enhance:文章标题下的分类、标签、作者在文章列表隐藏的情况下（包括移动端）点击，自动呼出文章列表 03-18 动画优化及修复bug enhance:给所有锚点添加动画 fix:修复文章列表页自适应宽度,解决由于firefox不支持自定义滚动条导致的错位 change:改动页面内站点访问量统计的标签，改动查看 — 3-hexo配置首页 03-17 评论调整优化 修复预加载时的评论数 首页添加评论框 03-16 文章meta样式修改 将文章meta（包括文集、标签、时间、字数等）改到文章title下方 站点版权信息（@2017 Yelog）,自定义，在主题 _config.yml 中配置 文章meta中添加评论数 03-15 增加样式 扩展了文章列表的移入样式，位置 _config.yml 中 article_list 03-14 打赏优化 加入切换二维码动画 移动端样式调整 03-13 首页重构 将首页改写为md格式，方便博主更改，位置：/layout/index.md 03-09 修复多说、添加流量统计 修复多说在pjax中的使用 添加字数统计功能 添加文章版权信息 03-06 添加打赏功能 添加打赏功能 添加table样式 03-04 添加作者和标签的提示 输入#或@显示下拉提示 03-03 修复多作者模式 修复开启多作者模式时，文章没有作者引起的异常 03-02 图片样式改动 alt显示在图片下方 图片放大功能 移动端图片宽度100% 2017年2月02-28 多作者模式 添加多作者模式 02-27 调整样式 修改a的样式 调整移动端宽度 02-25 修改github仓库名 修改github仓库名：从 3-hexo 到 hexo-theme-3-hexo 添加回到顶端功能：小火箭 修复safari滑动bug 02-24 站点版权、ICON和置顶 添加站点版权信息 更换icon到icoMoon 添加置顶功能 02-20 代码块高亮主题 添加十几种代码高亮主题 移动端适配（ipad、手机） 02-19 移动端适配 添加文章加载动画进度条 开始进行移动端适配 02-08 评论系统 添加多说评论 添加disqus评论 02-07 样式及动画新增修改 添加标题和时间的title 添加头像下外链图标（facebook等） 添加目录显示动画 02-06 功能和样式开发 添加全屏和目录功能 搜索框下添加tags的显示，并支持使用#搜索 CDN改为在_config.yml中配置 02-05 开源3-hexo主题 设计主题页面结构 分类过滤和标题关键字搜索 使用pjax方式加载页面 添加引用、表格等样式 使用highlight.js来处理代码块高亮 命名为3-hexo并在github上开源e","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"},{"name":"3-hexo","slug":"3-hexo","permalink":"https://ysluckly.github.io/tags/3-hexo/"}]},{"title":"3-hexo配置首页","slug":"tools/3-hexo-homepage","date":"2017-03-13T01:56:07.000Z","updated":"2022-02-19T09:27:58.538Z","comments":true,"path":"2017/03/13/3-hexo-homepage/","link":"","permalink":"https://ysluckly.github.io/2017/03/13/3-hexo-homepage/","excerpt":"","text":"今日将首页提到md文件中了，方便大家的更改。 首页文件位置 /layout/indexs.md ，既然是md格式，要怎么写大家应该都熟门熟路了，阿杰就不赘述了。 如果需要使用以下信息，可以按照下面的方式使用（以下内容不限首页使用） 文章数统计/字数统计加入含有 class=&quot;article_number&quot;的html标签可显示文章数量。加入含有 class=&quot;site_word_count&quot;的html标签可显示站点总字数。 &lt;!-- 我这里是借用了code的样式，所以直接使用code标签。 自定义样式，可加入style属性设置--&gt; &lt;code class=&quot;article_number&quot;&gt;&lt;/code&gt; &lt;code class=&quot;site_word_count&quot;&gt;&lt;/code&gt; 上面代码的效果：文章：篇；总字数：字； 流量统计 日志： 2017-03-18改动，由原来的 id 改为现在的 class，可在页面添加多个同类标签 加入含有 class=&quot;site_uv&quot;的html标签可显示站点访问人次。加入含有 class=&quot;site_pv&quot;的html标签可显示站点访问量。 &lt;!-- 我这里是借用了code的样式，所以直接使用code标签。 自定义样式，可加入style属性设置--&gt; &lt;code class=&quot;site_uv&quot;&gt;&lt;/code&gt; &lt;code class=&quot;site_pv&quot;&gt;&lt;/code&gt; 上面代码的效果：访问人数：人，访问量：次。","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"},{"name":"3-hexo","slug":"3-hexo","permalink":"https://ysluckly.github.io/tags/3-hexo/"}]},{"title":"不蒜子适配pjax","slug":"front-end/不蒜子适配pjax","date":"2017-03-09T12:15:51.000Z","updated":"2022-02-19T09:27:58.503Z","comments":true,"path":"2017/03/09/busuanzi-pjax/","link":"","permalink":"https://ysluckly.github.io/2017/03/09/busuanzi-pjax/","excerpt":"","text":"不蒜子一般配置加入脚本 &lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;!--pv方式 --&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次 &lt;/span&gt; &lt;!--uv方式 --&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次 &lt;/span&gt; &lt;!--pv方式 --&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次 &lt;/span&gt; 只安装脚本，不安装标签代码，即可实现只记数，不显示。 适配pjax最近开发3-hexo主题，由于主题使用的pjax，异步加载页面时不蒜子会出现加载不到多说js的问题。在pjax：end加载下面js代替标签即可 $.getScript(&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;);","categories":[{"name":"大前端","slug":"大前端","permalink":"https://ysluckly.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://ysluckly.github.io/tags/jQuery/"},{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"}]},{"title":"多说适配pjax","slug":"front-end/多说适配pjax","date":"2017-03-09T11:50:45.000Z","updated":"2022-02-19T09:27:58.504Z","comments":true,"path":"2017/03/09/duoshuo-pjax/","link":"","permalink":"https://ysluckly.github.io/2017/03/09/duoshuo-pjax/","excerpt":"","text":"最近开发3-hexo主题，由于主题使用的pjax，异步加载页面时多说会出现加载不到多说js的问题。 多说加载代码如下： //加载多说 function loadComment() &#123; duoshuoQuery = &#123;short_name: $(&quot;.theme_duoshuo_domain&quot;).val()&#125;; var d = document, s = d.createElement(&#39;script&#39;); s.src = &#39;https://static.duoshuo.com/embed.js?t=&#39;+new Date().getTime(); s.async = true; s.charset = &#39;UTF-8&#39;; (d.head || d.body).appendChild(s); &#125; 当局部加载页面时，就会无法加载多说。需要编写一个js方法，参考文档：(http://dev.duoshuo.com/docs/50b344447f32d30066000147) /** * pjax后需要回调函数.加载多说 */ function pajx_loadDuodsuo()&#123; if(typeof duoshuoQuery ==&quot;undefined&quot;)&#123; loadComment(); &#125; else &#123; var dus=$(&quot;.ds-thread&quot;); if($(dus).length==1)&#123; var el = document.createElement(&#39;div&#39;); el.setAttribute(&#39;data-thread-key&#39;,$(dus).attr(&quot;data-thread-key&quot;));//必选参数 el.setAttribute(&#39;data-url&#39;,$(dus).attr(&quot;data-url&quot;)); DUOSHUO.EmbedThread(el); $(dus).html(el); &#125; &#125; &#125; 在pjax:end中调用此方法即可。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://ysluckly.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://ysluckly.github.io/tags/jQuery/"},{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"}]},{"title":"Hexo加入字数统计WordCount","slug":"tools/hexo-wordcount","date":"2017-03-09T08:57:10.000Z","updated":"2022-02-19T09:27:58.566Z","comments":true,"path":"2017/03/09/hexo-wordcount/","link":"","permalink":"https://ysluckly.github.io/2017/03/09/hexo-wordcount/","excerpt":"","text":"只需要安装一个插件 WordCount 安装$ npm i hexo-wordcount --save 使用单篇文章字数 &lt;%=wordcount(post.content) %&gt; 所有文章的总字数 &lt;%=totalcount(site) %&gt; 日志2017年3月9日，给3-hexo添加字数统计功能","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"}]},{"title":"前端页面开发规范","slug":"front-end/font-develop-rule","date":"2017-03-08T00:58:21.000Z","updated":"2022-02-19T09:27:58.497Z","comments":true,"path":"2017/03/08/font-develop-rule/","link":"","permalink":"https://ysluckly.github.io/2017/03/08/font-develop-rule/","excerpt":"","text":"一、前言随着开发人员的不断增加，在没有规范的情况下，就会导致开发的页面不统一，不像是一个系统。为了解决这个问题，就有了此规范的出现，当然为了不影响各个功能的灵活性，此规范要求不高， 请耐心阅读，并应用到日常开发中。 当然，如果你有更好的建议，可以通过邮件联系 &#x79;&#97;&#x6e;&#x67;&#121;&#106;&#49;&#x33;&#64;&#108;&#x65;&#110;&#x6f;&#x76;&#x6f;&#x2e;&#99;&#x6f;&#x6d;，进行沟通来完善此篇规范。 二、编程规范2.1 命名规范2.1.1 文件命名全部采用小写方式，以横杠分割。 正例: resource.vue、user-info.vue 反例: basic_data.vue、EventLog.vue 2.1.2 目录命名全部采用小写方式，以横杠分割。 正例: system、ship-support 反例: errorPage、Components 2.1.3 JS、CSS、SCSS、HTML、PNG文件命名全部采用小写方式，以横杠分割。 正例: btn.scss、element-ui.scss、lenovo-logo.png 反例: leftSearch.scss、LeGrid.js 2.1.4 命名规范性代码中命名严禁使用拼音和英文混合的方式，更不允许直接使用中文的方式。说明: 正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音的命名方式也要避免采用。 正例: loading、searchForm、tableHeight、dmsLoading、rmb 专有名词缩写，视同英文反例: getLiaoPanName、DMSLoading 2.2 插件使用2.2.1 eslint 代码规范注意：前端的代码格式化已经在 eslint 中声明了，所以确保自己已经启用了 eslint，并使 eslint 进行代码格式化。 2.2.2 i18n 国际化所有展示的内容都要支持国际化。国际化内容写到 /src/lang/ 下的对应模块，通过 this.$t(&#39;xx.xx.xx&#39;) 来使用。 英文国际化的列或标签，请使用开头字母大写的方式，如: UserId、Status、UserName。 2.3 组件使用2.3.1 table 表格表格组件推荐使用 vxe-table，功能更加全面，之后也会主力优化此表格。比如可编辑表格的样式经过优化：可编辑表格 2.3.2 dialog 弹窗弹窗组件推荐使用 vxe-modal，代码设计更加合理，功能也更加全面。 2.3.2 element-ui除 table 和 modal 外，其他组件比如 form、button、DateTimePicker 优先使用 element-ui 。 2.3.2.1 icon 图标图标优先使用 element-ui 的图标。如果没有合适的，可以在 iconfont 上寻找到合适的图标后，找 &#121;&#x61;&#x6e;&#103;&#x79;&#x6a;&#x31;&#x33;&#64;&#108;&#x65;&#110;&#x6f;&#x76;&#x6f;&#x2e;&#99;&#x6f;&#x6d; 进行添加。 2.3.2.2 button 按钮按钮大小：除了在表格中的按钮要使用 size=&quot;mini&quot; 外，其他情况使用默认大小即可。 按钮颜色：普通的 查询/修改/操作 等按钮使用蓝色 type=&quot;primary&quot;，新增使用绿色 type=&quot;success&quot;，删除等“危险”操作使用红色 type=&quot;danger&quot;。推荐给按钮添加图标，可在 element-ui-icon 寻找合适的图标。 2.3.3 其他组件如果上述组件并不能满足业务需求，可以优先在网上找到合适的组件后，与 &#x79;&#97;&#x6e;&#x67;&#x79;&#106;&#49;&#x33;&#64;&#x6c;&#101;&#110;&#x6f;&#111;&#118;&#x2e;&#99;&#x6f;&#x6d; 联系后添加。 2.4 页面布局2.4.1 新增/修改表单普通的表单，采用中间对其的方案，也就是整个表单的 label-width 设置为一样的。 注意：一般的，新增修改使用弹窗的方式，展示表单。新增/修改可以共用代码，具体可以参考 common/system/va-config.vue &lt;el-form ref=&quot;dialogForm&quot; v-loading=&quot;edit.loading&quot; :model=&quot;edit.form&quot; :rules=&quot;edit.formRules&quot; label-width=&quot;150px&quot; style=&quot;padding-right: 30px;&quot; &gt; ... &lt;/el-form&gt; 2.4.2 查询表单+表格这种应该是最长间的需求方案了，可以参考 /common/system/user.vue，在写的时候注意以下几点： label-width 不要设置，保证标签文字开头和表格对齐。 el-form 使用 :inline=&quot;true&quot; 设置表单内容行内显示。 设置 vxe-table 的 height 属性，保证表格底部贴住网页底部，又不会有滚动条（表格内允许有滚动条） 按钮也放到表单中，不要单独一行。 最终效果如下：","categories":[{"name":"大前端","slug":"大前端","permalink":"https://ysluckly.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"translation","slug":"translation","permalink":"https://ysluckly.github.io/tags/translation/"}]},{"title":"[译]理解浏览器关键渲染路径","slug":"front-end/理解浏览器关键渲染路径-译","date":"2017-03-08T00:58:21.000Z","updated":"2022-02-19T09:27:58.505Z","comments":true,"path":"2017/03/08/understanding-the-critical-rendering-path/","link":"","permalink":"https://ysluckly.github.io/2017/03/08/understanding-the-critical-rendering-path/","excerpt":"","text":"当一个浏览器接收到从服务器发来的html页面，在渲染并呈现到屏幕上之前，有很多步骤要做。浏览器渲染页面需要做的一系列行为被称作“关键渲染路径（Critical Rendering Path 简称CRP）”。 CRP 的知识对于如何提升网站性能是相当有用的。CRP有6个步骤： 构建DOM树 构建CSSOM树 运行JavaScript 创建渲染树 生成布局 绘制页面 构建DOM树DOM（Document Object Model）树是一个表示整个解析过的HTML页面的对象，从根节点&lt;html&gt;开始，会创建页面中的每个 元素/文本 节点。嵌套在其他元素中的元素作为字节点，每个节点都包含了其所有的元素属性，例如： 一个&lt;a&gt;节点将有 href 属性与其关联。 举个例子 &lt;html&gt; &lt;head&gt; &lt;title&gt;Understanding the Critical Rendering Path&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;h1&gt;Understanding the Critical Rendering Path&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;h2&gt;Introduction&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;small&gt;Copyright 2017&lt;/small&gt; &lt;/footer&gt; &lt;/body&gt; &lt;/html&gt; 上面的 HTML 将会被解析成下面的DOM树HTML的优点在于它不必等待整个页面加载完成才呈现页面，可以解析一部分，显示一部分。但是像CSS、JavaScript等其他资源会阻止页面渲染。 构建CSSOM树CSSOM（CSS Object Model） 是一个跟DOM相关的样式对象。它跟DOM的表示方法是相似的，但是不论显式声明还是隐式继承，每个节点都存在关联样式。 In the style.css file from the document mentioned above, we have the folowing styles在上面提到的html页面的style.css中的样式如下 body &#123; font-size: 18px; &#125; header &#123; color: plum; &#125; h1 &#123; font-size: 28px; &#125; main &#123; color: firebrick; &#125; h2 &#123; font-size: 20px; &#125; footer &#123; display: none; &#125; 它会被构建成下面的CSSOM树CSS 被认为是 “渲染阻塞资源”，它意味着如果不首先完全解析资源，渲染树是无法构建的。CSS由于它的层叠继承的性质，不能像HTML一样解析一部分，显示一部分。定义在文档后面的样式会覆盖或改写之前定义的样式，因为在整个样式表都被解析之前，如果我们使用了在样式表中较早定义的样式，那错误的样式将被应用。这意味着CSS必须被全部解析之后，才能开始下一步。 如果CSS文件适用于当前设备的话，仅仅只是会阻塞渲染。&lt;link rel=&quot;stylesheet&quot;&gt;标签可以使用media属性，用来指定特定样式宽度的特定媒体查询。 举个例子，如果我们有一个包含媒体属性orientation:landscape的样式，我们使用纵向模式（portrait mode）查看页面，这个资源将不会阻塞渲染。 CSS 也会导致脚本阻塞。这是因为JavaScript文件必须等待CSSOM被构建后才能运行。 运行JavaScriptJavaScript被认为是解析阻塞资源，这意味着HTML的解析会被JavaScript阻塞。 当解析器解析到 &lt;script&gt; 标签时，无论该资源是内部还是外链的都会停止解析，先去下载资源。这也是为什么，当页面内有引用JavaScript文件时，引用标签要放到可视元素之后了。 为避免JavaScript解析阻塞，它可以通过设定 async 属性来要求其异步加载。 &lt;script async src=&quot;script.js&quot;&gt; 创建渲染树渲染树是DOM和CSSOM的结合体，它代表最终会渲染在页面上的元素的结构对象。这意味着它只关注可见内容，对于被隐藏或者CSS属性 display:none 的属性，不会被包含在结构内。 使用上面例子的DOM和CSSOM，渲染树被创建如下： 生成布局布局决定了浏览器视窗的大小,它提供了上下文依赖的CSS样式，如百分比或窗口的单位。视窗尺寸通常通过 &lt;head&gt; 标签中的 &lt;meta&gt; 中的 viewport 设定来决定。如果不存在该标签，则通常默认为 980px 例如，最常用的 meta veiwport 的值将会被设置为和设备宽度相符： &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; 如果用户访问网页的设备宽度为1000px。然后整体视窗尺寸就会基于这个宽度值了，比如 50% 就是500px, 10vw 就是100px 等等。 绘制页面最后，在绘制页面步骤。页面上的所有可见内容都会被转换为像素并呈现在屏幕上。 具体的绘制时间跟DOM数以及应用的样式有关。有些样式会花费更多的执行时间，比如复杂的渐变背景图片所需要的计算时间远超过简单固定背景色。 整合所有想要看到关键渲染路径的执行流程，可以使用DevTools，在Chrome中，它是根据时间轴展示的。 举个例子, 上面的页面加入&lt;script&gt;标签 &lt;html&gt; &lt;head&gt; &lt;title&gt;Understanding the Critical Rendering Path&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;h1&gt;Understanding the Critical Rendering Path&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;h2&gt;Introduction&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;small&gt;Copyright 2017&lt;/small&gt; &lt;/footer&gt; &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 可以看关于页面加载时的事件日志，以下是我们获得的： Send Request - 发送到index.html的GET请求 Parse HTML and Send Request - 开始解析HTML并构建DOM，然后发送 GET 请求style.css和main.js Parse Stylesheet - 根据 style.css 创建的CSSOM Evaluate Script - 执行 main.js Layout - 基于HTML的元视窗标签，生成布局 Paint - 绘制网页基于这些信息，我们可以知道如何优化关键渲染路径。 原文： Understanding the Critical Rendering Path","categories":[{"name":"大前端","slug":"大前端","permalink":"https://ysluckly.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"translation","slug":"translation","permalink":"https://ysluckly.github.io/tags/translation/"}]},{"title":"Hexo主题3-hexo","slug":"tools/3-hexo","date":"2017-03-07T03:15:50.000Z","updated":"2022-02-19T09:27:58.546Z","comments":true,"path":"2017/03/07/3-hexo/","link":"","permalink":"https://ysluckly.github.io/2017/03/07/3-hexo/","excerpt":"","text":"阮一峰曾言：喜欢写blog的人，会经历三个阶段 第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。 有对搭建个人blog有兴趣的朋友，可以翻看我往期文章。 笔者从去年开始通过hexo写blog，使用了yilia主题，但是随着文章数量的上升，检索等操作就显得特别笨重。 在遍寻无果的情况下，就写下了3-hexo主题。Demo:http://yelog.org 多图预警 ↓↓↓ 设计思路整体设计三段式设计: 通过分类过滤 通过标题关键字搜索 通过作者搜索若开启了多作者模式，则可以通过输入@，进行作者搜索，如下所示 通过标签搜索输入#，就会出现标签提示 评论功能 打赏功能 文章置顶 返回头部 使用1.安装$ git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo 2.配置1） 修改hexo根目录的_config.yml的两处，如下 theme: 3-hexo highlight: enable: false #关闭hexo渲染高亮，使用主题代码块高亮 2） 在hexo 根目录source下添加avatar.jpg文件，作为头像 安装字数统计(由于主题使用这个插件，必须安装，否则会报错)$ $ npm i --save hexo-wordcount 注意： 如果没有安装会在 hexo g 的时候报错 3.更新$ cd themes/3-hexo $ git pull","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"},{"name":"3-hexo","slug":"3-hexo","permalink":"https://ysluckly.github.io/tags/3-hexo/"}]},{"title":"Vim命令速查表","slug":"linux/Vim命令速查表","date":"2017-03-06T03:23:36.000Z","updated":"2022-02-19T09:27:58.512Z","comments":true,"path":"2017/03/06/Vim-command/","link":"","permalink":"https://ysluckly.github.io/2017/03/06/Vim-command/","excerpt":"","text":"去年上半年开始全面使用linux进行开发和娱乐了，现在已经回不去windows了。 话归正传，在linux上一直使用vim，慢慢熟悉了它的命令，才终于领悟了什么是编辑器之神。 最近抽空整理了这份速查表，收获颇丰，并分享给大家。 进入vim 命令 描述 vim filename 打开或新建文件,并将光标置于第一行首 vim +n filename 打开文件，并将光标置于第n行首 vim + filename 打开文件，并将光标置于最后一行首 vim +/pattern filename 打开文件，并将光标置于第一个与pattern匹配的串处 vim -r filename 在上次正用vim编辑时发生系统崩溃，恢复filename vim filename….filename 打开多个文件，依次编辑 vim配置 命令 描述 all 列出所有选项设置情况 term 设置终端类型 ignorance 在搜索中忽略大小写 list 显示制表位(Ctrl+I)和行尾标志（$) number 显示行号 report 显示由面向行的命令修改过的数目 terse 显示简短的警告信息 warn 在转到别的文件时若没保存当前文件则显示NO write信息 nomagic 允许在搜索模式中，使用前面不带“\\”的特殊字符 nowrapscan 禁止vi在搜索到达文件两端时，又从另一端开始 mesg 允许vi显示其他用户用write写到自己终端上的信息 :set number / set nonumber 显示/不显示行号 :set ruler /set noruler 显示/不显示标尺 :set hlsearch 高亮显示查找到的单词 :set nohlsearch 关闭高亮显示 :syntax on 语法高亮 :set nu 显示行号 :set ignorecase 搜索时忽略大小写 :set smartcase 搜索时匹配大小写 :set ruler 显示光标位置坐标 :set hlsearch 搜索匹配全高亮 :set tabstop=8 设置tab大小,8为最常用最普遍的设置 :set softtabstop=8 4:4个空格,8:正常的制表符,12:一个制表符4个空格,16:两个制表符 :set autoindent 自动缩进 :set cindent C语言格式里面的自动缩进 移动光标 命令 描述 k nk 上 向上移动n行 j nj 下 向下移动n行 h nh 左 向左移动n行 l nl 右 向右移动n行 Space 光标右移一个字符 Backspace 光标左移一个字符 Enter 光标下移一行 w/W 光标右移一个字至字首 b/B 光标左移一个字至字首 e或E 光标右移一个字至字尾 ) 光标移至句尾 ( 光标移至句首 } 光标移至段落开头 { 光标移至段落结尾 n$ 光标移至第n行尾 H 光标移至屏幕顶行 M 光标移至屏幕中间行 L 光标移至屏幕最后行 0 （注意是数字零）光标移至当前行首 ^ 移动光标到行首第一个非空字符上去 $ 光标移至当前行尾 gg 移到第一行 G 移到最后一行 f 移动光标到当前行的字符a上 F 相反 % 移动到与制匹配的括号上去（），{}，[]，&lt;&gt;等 nG 移动到第n行上 G 到最后一行 屏幕滚动 命令 描述 Ctrl+e 向文件首翻一行 Ctrl+y 向文件尾翻一行 Ctrl+u 向文件首翻半屏 Ctrl+d 向文件尾翻半屏 Ctrl+f 向文件尾翻一屏 Ctrl+b 向文件首翻一屏 nz 将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部 插入文本类 命令 描述 i 在光标前 I 在当前行首 a 光标后 A 在当前行尾 o 在当前行之下新开一行 O 在当前行之上新开一行 r 替换当前字符 R 替换当前字符及其后的字符，直至按ESC键 s 从当前光标位置处开始，以输入的文本替代指定数目的字符 S 删除指定数目的行，并以所输入文本代替之 ncw/nCW 修改指定数目的字 nCC 修改指定数目的行 删除命令 命令 描述 x/X 删除一个字符，x删除光标后的，而X删除光标前的 dw 删除一个单词(删除光标位置到下一个单词开始的位置) dnw 删除n个单词 dne 也可，只是删除到单词尾 do 删至行首 d$ 删至行尾 dd 删除一行 ndd 删除当前行及其后n-1行 dnl 向右删除n个字母 dnh 向左删除n个字母 dnj 向下删除n行,当前行+其上n行 dnk 向上删除n行,当期行+其下n行 cnw[word] 将n个word改变为word C$ 改变到行尾 cc 改变整行 shift+j 删除行尾的换行符，下一行接上来了 复制粘贴 命令 描述 p 粘贴用x或d删除的文本 ynw 复制n个单词 yy 复制一行 ynl 复制n个字符 y$ 复制当前光标至行尾处 nyy 拷贝n行 撤销 命令 描述 u 撤销前一次的操作 shif+u(U) 撤销对该行的所有操作 搜索及替换 命令 描述 /pattern 从光标开始处向文件尾搜索pattern ?pattern 从光标开始处向文件首搜索pattern n 在同一方向重复上一次搜索命令 N 在反方向上重复上一次搜索命令 cw newword 替换为newword n 继续查找 . 执行替换 :s/p1/p2/g 将当前行中所有p1均用p2替代,g表示执行 用c表示需要确认 :n1,n2 s/p1/p2/g 将第n1至n2行中所有p1均用p2替代 :g/p1/s//p2/g 将文件中所有p1均用p2替换 :1,$ s/string1/string2/g 在全文中将string1替换为string2 书签 命令 描述 m[a-z] 在文中做标记，标记号可为a-z的26个字母 `a 移动到标记a处 visual模式 命令 描述 v 进入visual 模式 V 进入行的visual 模式 ctrl+v 进如块操作模式用o和O改变选择的边的大小 在所有行插入相同的内容如include&lt; 将光标移到开始插入的位置，按CTRL+V进入VISUAL模式，选择好模块后按I（shift+i)，后插入要插入的文本，按[ESC]完成 行方式命令 命令 描述 :n1,n2 co n3 将n1行到n2行之间的内容拷贝到第n3行下 :n1,n2 m n3 将n1行到n2行之间的内容移至到第n3行下 :n1,n2 d 将n1行到n2行之间的内容删除 :n1,n2 w!command 将文件中n1行至n2行的内容作为command的输入并执行之若不指定n1，n2，则表示将整个文件内容作为command的输入 宏 命令 描述 q[a-z] 开始记录但前开始的操作为宏，名称可为【a-z】，然后用q终止录制宏 reg 显示当前定义的所有的宏，用@[a-z]来在当前光标处执行宏[a-z] 窗口操作 命令 描述 :split 分割一个窗口 :split file.c 为另一个文件file.c分隔窗口 :nsplit file.c 为另一个文件file.c分隔窗口，并指定其行数 ctrl＋w 在窗口中切换 :close 关闭当前窗口 文件及其他 命令 描述 :q 退出vi :q! 不保存文件并退出vi :e filename 打开文件filename进行编辑 :e! 放弃修改文件内容，重新载入该文件编辑 :w 保存当前文件 :wq 存盘退出 :ZZ 保存当前文档并退出VIM :!command 执行shell命令command :r!command 将命令command的输出结果放到当前行 :n1,n2 write temp.c :read file.c 将文件file.c的内容插入到当前光标所在的下面","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://ysluckly.github.io/tags/vim/"}]},{"title":"如何在linux中搭建ftp服务","slug":"linux/如何在linux中搭建ftp服务","date":"2017-03-06T00:47:48.000Z","updated":"2022-02-19T09:27:58.524Z","comments":true,"path":"2017/03/06/linux-ftp/","link":"","permalink":"https://ysluckly.github.io/2017/03/06/linux-ftp/","excerpt":"","text":"什么是 FTPFTP 是文件传输协议File Transfer Protocol的缩写。顾名思义，FTP用于计算机之间通过网络进行文件传输。你可以通过FTP在计算机账户间进行文件传输，也可以在账户和桌面计算机之间传输文件，或者访问在线软件归档。但是，需要注意的是多数的FTP站点的使用率非常高，可能需要多次重连才能连接上。 FTP地址和HTTP地址（即网页地址）非常相似，只是FTP地址使用 ftp://前缀而不是http:// FTP 服务器是什么通常，拥有FTP地址的计算机是专用于接收FTP连接请求的。一台专用于接收FTP连接请求的计算机即为FTP服务器或者FTP站点。 现在，我们来开始一个特别的冒险，我们将会搭建一个FTP服务用于和家人、朋友进行文件共享。在本教程，我们将以vsftpd作为ftp服务。 VSFTPD是一个自称为最安全的FTP服务端软件。事实上VSFTPD的前两个字母表示“非常安全的very secure”。该软件的构建绕开了FTP协议的漏洞。 尽管如此，你应该知道还有更安全的方法进行文件管理和传输，如：SFTP（使用OpenSSH）。FTP协议对于共享非敏感数据是非常有用和可靠的。 安装 VSFTP#使用 rpm 安装 $ dnf -y install vsftpd #使用 deb 安装 $ sudo apt-get install vsftpd #在 Arch 中安装 $ sudo pacman -S vsftpd 配置 FTP 服务多数的VSFTPD配置项都在/etc/vsftpd.conf配置文件中。这个文件本身已经有非常良好的文档说明了，因此，在本节中，我只强调一些你可能进行修改的重要选项。使用man页面查看所有可用的选项和基本的 文档说明： $ man vsftpd.conf 根据文件系统层级标准，FTP共享文件默认位于/srv/ftp目录中。允许上传：为了允许ftp用户可以修改文件系统的内容，如上传文件等，“write_enable”标志必须设置为 YES write_enable=YES 允许本地（系统）用户登录：为了允许文件/etc/passwd中记录的用户可以登录ftp服务，“local_enable”标记必须设置为YES。 local_enable=YES 匿名用户登录下面配置内容控制匿名用户是否允许登录： # 允许匿名用户登录 anonymous_enable=YES # 匿名登录不需要密码（可选） no_anon_password=YES # 匿名登录的最大传输速率，Bytes/second（可选） anon_max_rate=30000 # 匿名登录的目录（可选） anon_root=/example/directory/ 根目录限制（Chroot Jail）（ LCTT 译注：chroot jail是类unix系统中的一种安全机制，用于修改进程运行的根目录环境，限制该线程不能感知到其根目录树以外的其他目录结构和文件的存在。详情参看chroot jail） 有时我们需要设置根目录（chroot）环境来禁止用户离开他们的家（home）目录。在配置文件中增加/修改下面配置开启根目录限制（Chroot Jail）: chroot_list_enable=YES chroot_list_file=/etc/vsftpd.chroot_list “chroot_list_file”变量指定根目录限制所包含的文件/目录（ LCTT 译注：即用户只能访问这些文件/目录） 最后你必须重启ftp服务，在命令行中输入以下命令： $ sudo systemctl restart vsftpd 到此为止，你的ftp服务已经搭建完成并且启动了。","categories":[{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"ftp","slug":"ftp","permalink":"https://ysluckly.github.io/tags/ftp/"}]},{"title":"AngularJs快速入门","slug":"front-end/AngularJs快速入门","date":"2017-03-04T00:40:58.000Z","updated":"2022-02-19T09:27:58.494Z","comments":true,"path":"2017/03/04/AngularJs/","link":"","permalink":"https://ysluckly.github.io/2017/03/04/AngularJs/","excerpt":"","text":"简介 AngularJS是一个JavaScript框架，为了克服HTML在构建应用上的不足而设计的。 AngularJS通过使用我们称为标识符(directives)的结构，让浏览器能够识别新的语法。 AngularJS 使得开发现代的单一页面应用程序（SPAs：Single Page Applications）变得更加容易。 表达式AngularJS 使用 表达式 把数据绑定到 HTML。 表达式AngularJS 表达式写在双大括号内：{{ expression }} 。AngularJS 表达式把数据绑定到 HTML，这与 ng-bind 指令有异曲同工之妙。AngularJS 将在表达式书写的位置”输出”数据。AngularJS 表达式 很像 JavaScript 表达式：它们可以包含文字、运算符和变量。实例： {{ 5 + 5 }} 或 {{ firstName + \" \" + lastName }} &lt;div ng-app=&quot;&quot;&gt; &lt;p&gt;我的第一个表达式: &#123;&#123; 5 + 5 &#125;&#125;&lt;/p&gt; &lt;/div&gt; 效果 数字&lt;div ng-app=&quot;&quot; ng-init=&quot;quantity=1;cost=5&quot;&gt; &lt;p&gt;总价： &#123;&#123; quantity * cost &#125;&#125;&lt;/p&gt; &lt;/div&gt;","categories":[{"name":"大前端","slug":"大前端","permalink":"https://ysluckly.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"AngularJs","slug":"AngularJs","permalink":"https://ysluckly.github.io/tags/AngularJs/"}]},{"title":"3-hexo多作者模式","slug":"tools/3-hexo-multiple-author","date":"2017-02-28T02:55:31.000Z","updated":"2022-02-19T09:27:58.543Z","comments":true,"path":"2017/02/28/3-hexo-multiple-author/","link":"","permalink":"https://ysluckly.github.io/2017/02/28/3-hexo-multiple-author/","excerpt":"","text":"尽管hexo是为个人blog而生的工具，但是有时也可能会有多作者需求，比如他人投稿等等，为此笔者在写3-hexo主题时,顺便添加了此功能 。 1.修改配置文件修改 3-hexo/_config.yml，开启多作者模式，并添加blog中出现的作者，为搜索提供数据 author: on: true #true：开启多作者模式 authors: author1: yelog #添加两个作者yelog、小马哥 author2: 小马哥 2.修改文章头部信息添加 author: yelog ，表示这篇文章的作者为yelog --- title: reading-list date: 2017-01-31 15:29:32 author: yelog top: 2 categories: - 读书 tags: - reading --- 效果： 搜索某个作者的所有文章在搜索栏中输入@小马哥就可以显示出所有小马哥的文章。如果你在_config.xml中配置了作者名，就可以出现提示,具体看第一部分效果如下：","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"},{"name":"3-hexo","slug":"3-hexo","permalink":"https://ysluckly.github.io/tags/3-hexo/"}]},{"title":"Hexo创建404页面","slug":"tools/hexo-create-404-page","date":"2017-02-25T07:18:39.000Z","updated":"2022-02-19T09:27:58.560Z","comments":true,"path":"2017/02/25/hexo-create-404-page/","link":"","permalink":"https://ysluckly.github.io/2017/02/25/hexo-create-404-page/","excerpt":"","text":"对于github page来说，只要在根目录又404.html，当页面找不到时，就会被转发到/404.html页面，所以我们只要更改这个页面，就可以实现自定义404页面了。 但是我们通常会需要与本主题相符的404页面。那我们就需要以下操作 新建404页面 进入 Hexo 所在文件夹，输入 hexo new page 404 ; 打开刚新建的页面文件，默认在 Hexo 文件夹根目录下 /source/404/index.md； 在顶部插入一行，写上 enlink: /404，这表示指定该页固定链接为 http://&quot;主页&quot;/404.html --- title: 404 enlink: /404 date: 2016-09-27 11:31:01 --- --- ## 页面未找到！ 效果 http://yelog.org/举个404例子","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"}]},{"title":"Hexo置顶及排序问题","slug":"tools/hexo-top-sort","date":"2017-02-24T07:50:38.000Z","updated":"2022-02-19T09:27:58.565Z","comments":true,"path":"2017/02/24/hexo-top-sort/","link":"","permalink":"https://ysluckly.github.io/2017/02/24/hexo-top-sort/","excerpt":"","text":"近期在写3-hexo主题时，发现文章（site.posts）排序按照.md文件的创建时间排序，而没有按照文章中的date排序。 这就导致了一个问题，我重装了一次电脑，.md文件通过git备份了，还原回来的时候，md的创建时间都是一样的，所以文章列表就按照文章标题排序了 随后就想起了以前使用yilia主题时，设置过置顶文章。所以做了排序，顺便做了置顶的功能。 @牵猪的松鼠根据这篇文章写了一个npm插件 hexo-generator-topindex安装插件命令： npm install hexo-generator-topindex --save如果安装插件，可跳过第一部分 #修改hexo的js代码，直接看第二部分 #设置置顶 修改hexo的js代码直接上操作，修改node_modules/hexo-generator-index/lib/generator.js &#39;use strict&#39;; var pagination = require(&#39;hexo-pagination&#39;); module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &#39;page&#39;; return pagination(&#39;&#39;, posts, &#123; perPage: config.index_generator.per_page, layout: [&#39;index&#39;, &#39;archive&#39;], format: paginationDir + &#39;/%d/&#39;, data: &#123; __index: true &#125; &#125;); &#125;; 设置置顶给需要置顶的文章加入top参数，如下 --- title: 每天一个linux命令 date: 2017-01-23 11:41:48 top: 1 categories: - 运维 tags: - linux命令 --- 如果存在多个置顶文章，top后的参数越大，越靠前。 2020-05-20 更新3-hexo 主题已经内置排序算法，无需上面下载插件或修改源码，可以直接使用，具体可看 3-hexo使用说明 中的排序相关内容 References Netcan 的 解决Hexo置顶问题","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"}]},{"title":"[译]Java内存泄露介绍","slug":"back-end/Java内存泄露介绍","date":"2017-02-21T07:05:39.000Z","updated":"2022-02-20T13:00:51.343Z","comments":true,"path":"2017/02/21/the-introduction-of-memory-leak-what-why-and-how/","link":"","permalink":"https://ysluckly.github.io/2017/02/21/the-introduction-of-memory-leak-what-why-and-how/","excerpt":"","text":"内存管理是Java最大的优势之一；你可以很简单的创建一个对象，内存的分配和释放则交给Java垃圾收集器处理；然而实际情况并非如此简单，因为在Java应用程序中会频繁的发生内存泄露。 这个教程将会说明内存泄露是什么？它为什么会发生？我们如何防止它？ 内存泄露是什么内存泄露的定义：对象不再被应用程序使用，但是由于它们还在被引用，垃圾收集器不能清除掉它们。 为了理解这个定义，我们需要理解对象在内存中的状态；下面的图表说明什么是未被使用和未被引用。 图表中，有被引用的对象和未被引用的对象；未被引用的对象将会被当做垃圾回收，而被引用的对象将不会被当做垃圾回收；未被引用的对象由于没有被其他对象引用，它当然也是不被使用的对象，然而，不被使用的对象不全是不被引用的，它们中的一些是被引用的！这就是内存泄露的来源。 内存泄露为什么会发生让我们来看一下下面这个例子，它说明了内存泄露为什么会发生。在下面这个列子中，对象A引用了对象B，A的生命周期（t1t4）是比B（t2t3）的长；当B不再被应用程序使用时，A仍然在引用它；在这种情况下，垃圾收集器不能从内存中移除B；如果A引用了很多类似B这样的对象，它们不能被回收，又消耗着内存空间的资源，这样很有可能造成内存不足的问题。 还有一种可能的事情，B又引用了一些对象，这些被B引用的对象也不能被回收，那所有这些不被使用的对象将消耗大量宝贵的内存空间。 如何防止内存泄露下面有一些防止内存泄露的快速实践技巧 注意集合类，如：HashMap、ArrayList等等，因为它们是在常见的地方发生内存泄露；当它们被static声明时，它们和应用程序的生命周期是一样长的。 注意事件监听和回调，当一个监听事件被注册，而这个类再也没有被使用时可能会发生内存泄露。 “如果一个类管理自己的内存，程序员应该被提醒内存泄漏了”，通常，一个对象的指向其他对象的成员变量需要被置为null。 References：[1] Program Creek :The Introduction of Java Memory Leaks","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ysluckly.github.io/tags/java/"},{"name":"translation","slug":"translation","permalink":"https://ysluckly.github.io/tags/translation/"}]},{"title":"pjax用法","slug":"front-end/pjax用法","date":"2017-02-08T12:18:54.000Z","updated":"2022-02-19T09:27:58.501Z","comments":true,"path":"2017/02/08/pjax/","link":"","permalink":"https://ysluckly.github.io/2017/02/08/pjax/","excerpt":"最近在开发一款hexo主题3-hexo，其中使用了pjax大大提高了用户体验和加载速度，在此简单介绍一下pjax的用法github链接","text":"最近在开发一款hexo主题3-hexo，其中使用了pjax大大提高了用户体验和加载速度，在此简单介绍一下pjax的用法github链接 pjax是什么 pjax是一款jQuery插件，使用了ajax和pushState的技术，在保留真正永久链接，网页标题和可用的返回功能的情况下，带来一种快速的浏览体验。 –官方介绍 用人话说，就是当跳转过去的网页和当前网页的一部分是一样的，这时可以通过pjax就会从响应页面中取出 不同的那部分 （需指定），替换掉原来的内容。 如果在服务端判断处理，直接返回 不同的那部分内容，这样就可以减少带宽占用，提升加载速度。 这样做的优势： 由于从服务器取回的数据量变少，加载速度将会提升。 并且采用异步刷新页面中的不一样的地方，用户体验也是满满的。 保留了浏览器回退的功能（解决了ajax的尴尬） 好了，开始操作。 Demo第一步：引入jQuery和jQuery.pjax &lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/jquery.pjax/1.9.6/jquery.pjax.min.js&quot;&gt;&lt;/script&gt; 第二步：将指定的a的链接，转为pjax风格 /*将#menu中的a的链接的页面，只取回class=pjax元素中的内容，替换掉当前页面class=pjax元素中的内容*/ $(document).pjax(&#39;.#menu a&#39;, &#39;.pjax&#39;, &#123;fragment:&#39;.pjax&#39;, timeout:8000&#125;); 第三步：如果需要在请求的过程中做一些自定义的事件，可以使用下面的方法 $(document).on(&#123; &#39;pjax:click&#39;: function() &#123; //点击链接时，需要触发的事件写到这里 &#125;, &#39;pjax:start&#39;: function() &#123; //当开始获取请求时，需要触发的事件写在这里 &#125;, &#39;pjax:end&#39;: function() &#123; //当请求完成后，需要触发的事件写在这里 &#125; &#125;); 结束。 详细文档翻译于官方 参数$(document).pjax(selector, [container], options) selector 触发点击事件的选择器，String类型 container 一个选择器，为唯一的pjax容器 options 一个可以包含下面这些选项的对象 pjax options key default description timeout 650 ajax超时时间，单位毫秒，超时后将请求整个页面进行刷新 push true 使用 pushState 添加一个浏览器历史导航条目 replace false 替换URL，而不添加浏览器历史条目 maxCacheLength 20 历史内容 cache 的最大size version string ： 当前pjax版本 scrollTo 0 垂直位置滚动，为了避免改变滚动条位置 type “GET” 可以查看jQuery.ajax() dataType “html” 可以查看jQuery.ajax() container css选择器，此元素内容将被替换 url link.href string: ajax 请求的URL target link eventually the relatedTarget value for pjax events fragment 从ajax响应的页面中抽取的‘片段’ Events除了pjax:click和pjax:clicked外的所有pjax事件从pjax容器中触发，是不需要点击链接的。所有事件的生命周期在通过pjax请求链接的过程中 event cancel arguments notes pjax:click ✔︎ options 在一个链接被激活（点击）时触发此事件，可以在此取消阻止pjax pjax:beforeSend ✔︎ xhr, options 可以设置 XHR 头 pjax:start xhr, options pjax:send xhr, options pjax:clicked options 当链接被点击，并且已经开始pjax请求后触发 pjax:beforeReplace contents, options 从服务器已经加载到HTML内容，在替换HTML内容之前触发 pjax:success data, status, xhr, options 从服务器已经加载到HTML内容，在替换HTML内容之后触发 pjax:timeout ✔︎ xhr, options 页面将会在options.timeout之后直接发起请求刷新页面，除非取消pjax pjax:error ✔︎ xhr, textStatus, error, options ajax 错误，将会请求刷新页面，除非取消pjax pjax:complete xhr, textStatus, options 不管结果是什么，在ajax后，都触发 pjax:end xhr, options 生命周期在浏览器返回或前进时触发 event cancel arguments notes pjax:popstate 事件方向(前进，后退)属性: “back”/“forward” pjax:start null, options 替换内容前 pjax:beforeReplace contents, options 从cache中读取内容后，替换html前 pjax:end null, options 替换内容后","categories":[{"name":"大前端","slug":"大前端","permalink":"https://ysluckly.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://ysluckly.github.io/tags/jQuery/"}]},{"title":"reading-list","slug":"reading/reading-list","date":"2017-01-31T07:29:32.000Z","updated":"2022-02-19T09:27:58.531Z","comments":true,"path":"2017/01/31/reading-list/","link":"","permalink":"https://ysluckly.github.io/2017/01/31/reading-list/","excerpt":"下面是一些我读过的书","text":"下面是一些我读过的书 ★ ★ ★ ★ ☆ ☆ ☆ ：推荐指数，7星制。此乃余之私见，或显偏薄。 文学小说 《棋王 树王 孩子王》 by 阿城 2015年9月 ★ ★ ★ ★ ☆ ☆ ☆ 《达芬奇密码》 by 丹.布朗 2015年9月 ★ ★ ★ ★ ★ ★ ☆ 《追风筝的人》 by 卡勒德·胡赛尼 2016年6月 ★ ★ ★ ★ ★ ☆ ☆ 《霍乱时期的爱情》 by 加西亚·马尔克斯 2016年8月 ★ ★ ★ ★ ★ ☆ ☆ 《查令十字街84号》 by 海莲·汉芙 2016年9月 ★ ★ ★ ★ ☆ ☆ ☆ 《围城》 by 钱钟书 2017年1月 ★ ★ ★ ★ ★ ☆ ☆ 《一个陌生女人的来信》 by 茨威格 2017年1月 ★ ★ ★ ★ ★ ★ ☆ 《一颗心的沦亡》 by 茨威格 2017年1月 ★ ★ ★ ★ ☆ ☆ ☆ 《情感的迷茫》 by 茨威格 2017年1月 ★ ★ ★ ★ ★ ☆ ☆ 《一个女人一生中的二十四个小时》 by 茨威格 2017年1月 ★ ★ ★ ★ ☆ ☆ ☆ 《摆渡人》 by 克莱尔·麦克福尔 2019年3月28 ★ ☆ ☆ ☆ ☆ ☆ ☆ 《悟空传》 by 今何在 2016年8月 ★ ★ ★ ★ ★ ☆ ☆ 《岛上书店》 by 加·泽文 2019年4月 ★ ★ ★ ★ ☆ ☆ ☆ 《月亮与六便士》 by 毛姆 2019年4月 ★ ★ ★ ★ ★ ☆ ☆ 《活着》 by 余华 2019年5月★ ★ ★ ★ ★ ★ ☆ 旅行 《不去会死》 by 石田裕辅 2017年2月 ★ ★ ★ ☆ ☆ ☆ ☆ 历史 《秦迷·秦始皇的秘密》 by 李开元 2016年3月 ★ ★ ★ ★ ☆ ☆ ☆ 《鱼羊野史·第1卷》 by 高晓松 2016年9月 ★ ★ ★ ★ ★ ☆ ☆ 心理学 《天才在左，疯子在右》 by 高铭 2016年3月 ★ ★ ★ ★ ★ ★ ☆ 经济 《历代经济变革得失》 by 吴晓波 2017年2月 ★ ★ ★ ★ ★ ★ ☆ 科幻 《球状闪电》 by 刘慈欣 2016年3月 ★ ★ ★ ★ ☆ ☆ ☆ 《三体·“地球往事”三部曲之一》 by 刘慈欣 2016年4月 ★ ★ ★ ★ ★ ☆ ☆ 《流浪地球》 by 刘慈欣 2019年3月 ★ ★ ★ ★ ☆ ☆ ☆ 创业 《从零到一》 by 彼得·蒂尔 2015年6月 ★ ★ ★ ★ ☆ ☆ ☆ 《创业维艰》 by 本·霍洛维茨 2015年6月 ★ ★ ★ ★ ★ ☆ ☆ 《餐巾纸上的创业课》 by 神田昌典 2016年6月 ★ ★ ★ ★ ☆ ☆ ☆ 方法论 《如何高效学习》 by 斯科特·扬 2017年1月 ★ ★ ★ ★ ★ ☆ ☆ 《DISCover自我探索》 by 李海峰 2017年1月 ★ ★ ★ ★ ★ ★ ☆ 计算机 《淘宝技术这十年》 by 子柳 2015年6月 ★ ★ ★ ★ ★ ☆ ☆ 待读/在读 《基督山伯爵》 by 大仲马","categories":[{"name":"读书","slug":"读书","permalink":"https://ysluckly.github.io/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"书单","slug":"读书/书单","permalink":"https://ysluckly.github.io/categories/%E8%AF%BB%E4%B9%A6/%E4%B9%A6%E5%8D%95/"}],"tags":[{"name":"reading","slug":"reading","permalink":"https://ysluckly.github.io/tags/reading/"}]},{"title":"人生若只如初见-《围城》","slug":"reading/Fortress-Besieged","date":"2017-01-03T03:27:04.000Z","updated":"2022-02-19T09:27:58.529Z","comments":true,"path":"2017/01/03/Fortress-Besieged/","link":"","permalink":"https://ysluckly.github.io/2017/01/03/Fortress-Besieged/","excerpt":"婚姻是被围困的城堡，城外的人想冲进去，城里的人想逃出来 –法国谚语","text":"婚姻是被围困的城堡，城外的人想冲进去，城里的人想逃出来 –法国谚语 方鸿渐对于鲍小姐，不堪抵抗；对于苏小姐的垂青，已再纠缠不清（导致方唐感情破裂的导火索）；最后与孙柔嘉的婚姻，因属于现实的无奈吧；至于唐晓芙，方对她应该有着最纯粹的爱意。 整部小说给我留下深刻印象的就是唐小姐，她在整部小说的占比是非常少的。 总而言之，唐小姐是摩登文明社会里的那桩罕物――一个真正的女孩子。有许多都市女孩子已经是装模作样的早熟的女人，算不得孩子；有许多女孩子只是浑沌痴顽的无性别的孩子，还说不上女人。 唐晓芙的聪明漂亮、活泼可爱，令方鸿渐一见倾心。 当初，是苏小姐的干预，激起了唐晓芙的逆反心理，不让接近我偏接近，书信往来，见面谈话，时间推移，俩人都投入了真正的感情。 作为苏的姐妹，唐晓芙骨子里也有跟苏小姐的高傲。 方先生的过去太丰富了！我爱的人，我要能够占领他整个生命，他在碰见我以前，没有过去，留着空白等待我—— 方下定决心写信给苏撇清两人关系，苏的狭隘的心理从中挑拨导致方与唐之间的破裂 他象一个受了责骂的孩子那样，泪水在眼睛里打转，却一句话也说不出口。 所以当唐得知方的一些列斑斑劣迹后，愈心痛愈心恨，最后一次见方，连珠炮的发问，又恨方鸿渐为什么不辩护，她的心溶成了苦水。而方鸿渐的悲剧在于，他再次懦弱，该辩解时不辩解，该在屋外多淋雨时而过早走开，接到电话后，不问来人就大声呵斥，俩人都是好面子的人，看不到俩人为这段感情而去采取任何补救措施，而是各自松开了手。两人年轻，都不知退让，任彼此失之交臂。 从此直到最后，唐也没有再次出现。 但唐给我们的留下了一个近乎完美的形象，正是因为她没有和方走在一起，没有真实世俗的一面，才能留下那种只如初见的模样。 生活亦是如此，我们心目中的“女神”、“男神”，完美无缺的人，是那些我们曾经追求不得的人。想想若是得之，经过世俗的一面，ta的完美的形象，还会在你的心中站的稳吗。 唐晓芙这个角色是钱老钟爱的角色，是钱老心中完美的女性形象，简单说就是女神！是围城里任何男人都配不上的，所以不舍得把她许配给任何人。 --杨绛先生 《围城》写出了婚姻的一方面，但不是全部，很多人要冲进这座城，自有其道理，城中有争吵，但更有温情。愿诸位在现实生活中，相互欣赏，相敬如宾，如初见一样，相互爱戴，生活一定更加美好 在新春佳节祝大家幸福美满，阖家欢乐。","categories":[{"name":"读书","slug":"读书","permalink":"https://ysluckly.github.io/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"阅读笔记","slug":"读书/阅读笔记","permalink":"https://ysluckly.github.io/categories/%E8%AF%BB%E4%B9%A6/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"reading","slug":"reading","permalink":"https://ysluckly.github.io/tags/reading/"}]},{"title":"Git之reset揭秘","slug":"tools/git-reset","date":"2016-12-24T03:19:24.000Z","updated":"2022-02-19T09:27:58.557Z","comments":true,"path":"2016/12/24/git-reset/","link":"","permalink":"https://ysluckly.github.io/2016/12/24/git-reset/","excerpt":"本文主要选自于《Pro Git》这本书，加上自己平时使用时的理解整理于此，以此给大家借鉴。本文主要讨论 reset 与 checkout。它们能做很多事情，所以我们要真正理解他们到底在底层做了哪些工作，以便能够恰当的运用它们。","text":"本文主要选自于《Pro Git》这本书，加上自己平时使用时的理解整理于此，以此给大家借鉴。本文主要讨论 reset 与 checkout。它们能做很多事情，所以我们要真正理解他们到底在底层做了哪些工作，以便能够恰当的运用它们。 三棵树理解 reset 和 checkout 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。） 树 描述 HEAD 上一次提交的快照，下一次提交的父结点 Index 预期的下一次提交的快照 Working Directory 沙盒 HEADHEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做 你的上一次提交 的快照。 其实，查看快照的样子很容易。 下例就显示了 HEAD 快照实际的目录列表，以及其中每个文件的 SHA-1 校验和： $ git cat-file -p HEAD tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf author Scott Chacon 1301511835 -0700 committer Scott Chacon 1301511835 -0700 initial commit $ git ls-tree -r HEAD 100644 blob a906cb2a4a904a152... README 100644 blob 8f94139338f9404f2... Rakefile 040000 tree 99f1a6d12cb4b6f19... lib cat-file 与 ls-tree 是底层命令，它们一般用于底层工作，在日常工作中并不使用。不过它们能帮助我们了解到底发生了什么。 索引(Index)索引是你的 预期的下一次提交。 我们也会将这个概念引用为 Git 的 “暂存区域”，这就是当你运行 git commit 时 Git 看起来的样子。 Git 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。 之后你会将其中一些文件替换为新版本，接着通过 git commit 将它们转换为树来用作新的提交。 $ git ls-files -s 100644 a906cb2a4a904a152e80877d4088654daad0c859 0 README 100644 8f94139338f9404f26296befa88755fc2598c289 0 Rakefile 100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0 lib/simplegit.rb 再说一次，我们在这里又用到了 ls-files 这个幕后的命令，它会显示出索引当前的样子。 确切来说，索引并非技术上的树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。 工作目录(Working Directory)最后，你就有了自己的工作目录。 另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 .git 文件夹中。 工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 沙盒。在你将修改提交到暂存区并记录到历史之前，可以随意更改。 $ tree . ├── README ├── Rakefile └── lib └── simplegit.rb 1 directory, 3 files 工作流程Git 主要的目的是通过操纵这三棵树来以更加连续的状态记录项目的快照。让我们来可视化这个过程：假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 v1 版本，将它标记为蓝色。 现在运行 git init，这会创建一个 Git 仓库，其中的 HEAD 引用指向未创建的分支（master 还不存在）。此时，只有工作目录有内容。 现在我们想要提交这个文件，所以用 git add 来获取工作目录中的内容，并将其复制到索引中。接着运行 git commit，它首先会移除索引中的内容并将它保存为一个永久的快照，然后创建一个指向该快照的提交对象，最后更新 master 来指向本次提交。此时如果我们运行 git status，会发现没有任何改动，因为现在三棵树完全相同。 现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 v2 版本，并将它标记为红色。如果现在运行 git status，我们会看到文件显示在 “Changes not staged for commit,” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 git add 来将它暂存到索引中。此时，由于索引和 HEAD 不同，若运行 git status 的话就会看到 “Changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 git commit 来完成提交。现在运行 git status 会没有输出，因为三棵树又变得相同了。 切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 HEAD 指向新的分支引用，将 索引 填充为该次提交的快照，然后将 索引 的内容复制到 工作目录 中。 重置的作用在以下情景中观察 reset 命令会更有意义。 为了演示这些例子，假设我们再次修改了 file.txt 文件并第三次提交它。 现在的历史看起来是这样的：让我们跟着 reset 看看它都做了什么。 它以一种简单可预见的方式直接操纵这三棵树。 它做了三个基本操作。 1.移动 HEADreset 做的第一件事是移动 HEAD 的指向。 这与改变 HEAD 自身不同（checkout 所做的）；reset 移动 HEAD 指向的分支。 这意味着如果 HEAD 设置为 master 分支（例如，你正在 master 分支上），运行 git reset 9e5e64a 将会使 master 指向 9e5e64a。无论你调用了何种形式的带有一个提交的 reset，它首先都会尝试这样做。 使用 reset --soft，它将仅仅停在那儿。 现在看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 git commit 命令。 当你在运行 git commit 时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。 当你将它 reset 回 HEAD~（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 git commit 来完成 git commit --amend 所要做的事情了。 2.更新索引(–mixed)注意，如果你现在运行 git status 的话，就会看到新的 HEAD 和以绿色标出的它和索引之间的区别。 接下来，reset 会用 HEAD 指向的当前快照的内容来更新索引。如果指定 --mixed 选项，reset 将会在这时停止。 这也是默认行为，所以如果没有指定任何选项（在本例中只是 git reset HEAD~），这就是命令将会停止的地方。 现在再看一眼上图，理解一下发生的事情：它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有 git add 和 git commit 的命令执行之前。 3.更新工作目录reset 要做的的第三件事情就是让工作目录看起来像索引。 如果使用 –hard 选项，它将会继续这一步。现在让我们回想一下刚才发生的事情。 你撤销了最后的提交、git add 和 git commit 命令以及工作目录中的所有工作。 必须注意，--hard 标记是 reset 命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 reset 调用都可以轻松撤消，但是 --hard 选项不能，因为它强制覆盖了工作目录中的文件。 在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 v3 版本，我们可以通过 reflog 来找回它。但是若该文件还未提交，Git 仍会覆盖它从而导致无法恢复。 回顾reset 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止： 移动 HEAD 分支的指向 （若指定了 --soft，则到此停止） 使索引看起来像 HEAD （不带参数或 --mixed，则到此停止） 使工作目录看起来像索引 (指定了 --hard) 通过路径来重置前面讲述了 reset 基本形式的行为，不过你还可以给它提供一个作用路径。 若指定了一个路径，reset 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。 这样做自然有它的道理，因为 HEAD 只是一个指针，你无法让它同时指向两个提交中各自的一部分。 不过索引和工作目录 可以部分更新，所以重置会继续进行第 2、3 步。 现在，假如我们运行 git reset file.txt （这其实是 git reset --mixed HEAD file.txt 的简写形式，因为你既没有指定一个提交的 SHA-1 或分支，也没有指定 --soft 或 --hard），它会： 移动 HEAD 分支的指向 （已跳过） 让索引看起来像 HEAD （到此处停止） 所以它本质上只是将 file.txt 从 HEAD 复制到索引中。它还有 取消暂存文件 的实际效果。 如果我们查看该命令的示意图，然后再想想 git add 所做的事，就会发现它们正好相反。 这就是为什么 git status 命令的输出会建议运行此命令来取消暂存一个文件。 （查看 取消暂存的文件 来了解更多。） 我们可以不让 Git 从 HEAD 拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。 我们只需运行类似于 git reset eb43bf file.txt 的命令即可。它其实做了同样的事情，也就是把工作目录中的文件恢复到 v1 版本，运行 git add 添加它，然后再将它恢复到 v3 版本（只是不用真的过一遍这些步骤）。 如果我们现在运行 git commit，它就会记录一条“将该文件恢复到 v1 版本”的更改，尽管我们并未在工作目录中真正地再次拥有它。 还有一点同 git add 一样，就是 reset 命令也可以接受一个 --patch 选项来一块一块地取消暂存的内容。 这样你就可以根据选择来取消暂存或恢复内容了。 压缩我们来看看如何利用这种新的功能来做一些有趣的事情 - 压缩提交。 假设你的一系列提交信息中有 “oops.”、“WIP” 和 “forgot this file”， 聪明的你就能使用 reset 来轻松快速地将它们压缩成单个提交，也显出你的聪明。 （压缩提交 展示了另一种方式，不过在本例中用 reset 更简单。） 假设你有一个项目，第一次提交中有一个文件，第二次提交增加了一个新的文件并修改了第一个文件，第三次提交再次修改了第一个文件。 由于第二次提交是一个未完成的工作，因此你想要压缩它。那么可以运行 git reset --soft HEAD~2 来将 HEAD 分支移动到一个旧一点的提交上（即你想要保留的第一个提交）：然后只需再次运行 git commit：现在你可以查看可到达的历史，即将会推送的历史，现在看起来有个 v1 版 file-a.txt 的提交，接着第二个提交将 file-a.txt 修改成了 v3 版并增加了 file-b.txt。 包含 v2 版本的文件已经不在历史中了。 checkout最后，你大概还想知道 checkout 和 reset 之间的区别。 和 reset 一样，checkout 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。 不带路径运行 git checkout [branch] 与运行 git reset --hard [branch] 非常相似，它会更新所有三棵树使其看起来像 [branch]，不过有两点重要的区别。 首先不同于 reset --hard，checkout 对工作目录是安全的，它会通过检查来确保不会将已更改的文件吹走。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有_还未修改过的_文件都会被更新。 而 reset --hard 则会不做检查就全面地替换所有东西。 第二个重要的区别是如何更新 HEAD。 reset 会移动 HEAD 分支的指向，而 checkout 只会移动 HEAD 自身来指向另一个分支。 例如，假设我们有 master 和 develop 分支，它们分别指向不同的提交；我们现在在 develop 上（所以 HEAD 指向它）。 如果我们运行 git reset master，那么 develop 自身现在会和 master 指向同一个提交。 而如果我们运行 git checkout master 的话，develop 不会移动，HEAD 自身会移动。 现在 HEAD 将会指向 master。 所以，虽然在这两种情况下我们都移动 HEAD 使其指向了提交 A，但_做法_是非常不同的。 reset 会移动 HEAD 分支的指向，而 checkout 则移动 HEAD 自身。 带路径运行 checkout 的另一种方式就是指定一个文件路径，这会像 reset 一样不会移动 HEAD。 它就像 git reset [branch] file 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 git reset --hard [branch] file（如果 reset 允许你这样运行的话）- 这样对工作目录并不安全，它也不会移动 HEAD。 此外，同 git reset 和 git add 一样，checkout 也接受一个 –patch 选项，允许你根据选择一块一块地恢复文件内容。 总结希望你现在熟悉并理解了 reset 命令，不过关于它和 checkout 之间的区别，你可能还是会有点困惑，毕竟不太可能记住不同调用的所有规则。 下面的速查表列出了命令对树的影响。 “HEAD” 一列中的 “REF” 表示该命令移动了 HEAD 指向的分支引用，而‘HEAD’ 则表示只移动了 HEAD 自身。 特别注意 WD Safe? 一列 - 如果它标记为 NO，那么运行该命令之前请考虑一下。 **head****index****workdir****wd safe****commit level**`reset --soft [commit]`refnonoyes`reset [commit]`refyesnoyes`reset --hard [commit]`refyesyesno`checkout [commit]`headyesyesyes**file level**`reset (commit) [file]`noyesnoyes`checkout (commit) [file]`noyesyesno","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"工具/git","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ysluckly.github.io/tags/Git/"}]},{"title":"Git操作之高手过招","slug":"tools/git-master","date":"2016-12-23T02:59:01.000Z","updated":"2022-02-19T09:27:58.556Z","comments":true,"path":"2016/12/23/git-master/","link":"","permalink":"https://ysluckly.github.io/2016/12/23/git-master/","excerpt":"在使用git的过程中，总有一天你会遇到下面的问题：）这些也是在开发过程中很常见的问题，以下也是作者的经验之谈，有不对的地方还请指出。","text":"在使用git的过程中，总有一天你会遇到下面的问题：）这些也是在开发过程中很常见的问题，以下也是作者的经验之谈，有不对的地方还请指出。 最后一次commit信息写错了如果只是提交信息写错了信息，可以通过以下命令单独修改提交信息 $ git commit --amend 注意： 通过这样的过程修改提交信息后，相当于删除原来的提交，重新提交了一次。所有如果你在修改前已经将错误的那次提交push到服务端，那在修改后就需要通过 git pull 来合并代码（类似于两个分支了）。通过 git log --graph --oneline 查看就会发现两个分支合并的痕迹 最后一次commit少添加一个文件$ git add file1 $ git commit --amend 最后一次commit多添加一个文件$ git rm --cached file1 $ git commit --amend 移除add过的文件#方法一 $ git rm --cache [文件名] #方法二 $ git reset head [文件/文件夹] 回退本地commit（还未push）这种情况发生在你的本地仓库，可能你add，commit以后发现代码有点问题，打算取消提交，用到下面命令 #只会保留源码（工作区），回退commit(本地仓库)与index（暂存区）到某个版本 $ git reset &lt;commit_id&gt; #默认为 --mixed模式 $ git reset --mixed &lt;commit_id&gt; #保留源码（工作区）和index（暂存区），只回退commit（本地仓库）到某个版本 $ git reset --soft &lt;commit_id&gt; #源码（工作区）、commit（本地仓库）与index（暂存区）都回退到某个版本 $ git reset --hard &lt;commit_id&gt; 当然有人在push代码以后，也是用reset –hard回退代码到某个版本之前，但是这样会有一个问题，你线上的代码没有变化。 !!!可以通过 git push –force 将本地的回退推送到服务端,但是除非你很清楚在这么做, 不推荐. 所以，这种情况你要使用下面的方式了。 回退本地commit（已经push）对于已经把代码push到线上仓库,你回退本地代码其实也想同时回退线上代码,回滚到某个指定的版本,线上,线下代码保持一致.你要用到下面的命令 $ git revert &lt;commit_id&gt; 注意： git revert 用于反转提交，执行命令时要求工作树必须是干净的。 git revert 用一个新的提交来消除一个历时提交所做出的修改 回退单个文件的历史版本#查看历史版本 git log 1.txt #回退该文件到指定版本 git reset [commit_id] 1.txt git checkout 1.txt #提交 git commit -m &quot;回退1.txt的历史版本&quot; 修改提交历史中的author和email旧的：author:Old-Author email:old@mail.com新的：author:New-Author email:new@mail.com1.在git仓库内创建下面的脚本，如change.sh # !/bin/sh git filter-branch --env-filter &#39; an=&quot;$GIT_AUTHOR_NAME&quot; am=&quot;$GIT_AUTHOR_EMAIL&quot; cn=&quot;$GIT_COMMITTER_NAME&quot; cm=&quot;$GIT_COMMITTER_EMAIL&quot; if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;old@mail.com&quot; ] then cn=&quot;New-Author&quot; cm=&quot;new@mail.com&quot; fi if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;old@mail.com&quot; ] then an=&quot;New-Author&quot; am=&quot;new@mail.com&quot; fi export GIT_AUTHOR_NAME=&quot;$an&quot; export GIT_AUTHOR_EMAIL=&quot;$am&quot; export GIT_COMMITTER_NAME=&quot;$cn&quot; export GIT_COMMITTER_EMAIL=&quot;$cm&quot; &#39; 2.运行脚本 $ sh change.sh 忽略已提交的文件（.iml） 删除已提交的文件# 删除项目中所有的.iml后缀的文件 $ find . -name &quot;*.iml&quot; | xargs rm -f 添加.gitignore文件```bash .iml/**/.iml --- 持续更新中～～～","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"工具/git","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ysluckly.github.io/tags/Git/"}]},{"title":"Git之SSH与HTTPS免密码配置","slug":"tools/git-ssh-https-verify-configuration","date":"2016-12-21T07:31:55.000Z","updated":"2022-02-19T09:27:58.558Z","comments":true,"path":"2016/12/21/git-ssh-https-verify-configuration/","link":"","permalink":"https://ysluckly.github.io/2016/12/21/git-ssh-https-verify-configuration/","excerpt":"Git作为当前最受欢迎的版本控制软件，使用是很频繁的。但每次使用git push等操作时都要输入密码，实在是挺麻烦的。本文对使用ssh与https两种通讯协议讨论一下免密码配置。注：这个过程在所有操作系统上都是相似的：）","text":"Git作为当前最受欢迎的版本控制软件，使用是很频繁的。但每次使用git push等操作时都要输入密码，实在是挺麻烦的。本文对使用ssh与https两种通讯协议讨论一下免密码配置。注：这个过程在所有操作系统上都是相似的：） SSH通信协议GitHub版许多Git服务器都使用SSH公钥进行认证，当然也包括github。首先你需要确认一下自己是否已经拥有密钥了，默认情况下，用户的 SSH 密钥存储在其 ~/.ssh 目录下。进入该目录并列出其中内容，你变可以下快速确认自己是否已经拥有密钥： $ cd ~/.ssh $ ls authorized_keys2 id_rsa known_hosts config id_rsa.pub 我们需要寻找一对 id_rsa 或 id_dsa 命名的文件，其中一个带 .pub 扩展名。 ‘.pub’文件是你的公钥，另一个则是私钥。如果没有找不到这样的文件（或者根本就没有.ssh目录），我们可以通过 ssh-keygen 程序来创建它们。 #邮箱可以随便填 $ ssh-keygen -t rsa -C &quot;xx@xx.com&quot; 首先 ssh-keygen 会确认密钥的存储位置和文件名（默认是 .ssh/id_rsa）,然后他会要求你输入两次密钥口令，留空即可。所以一般选用默认，全部回车即可。 接下来我们登陆到GitHub上，右上角小头像-&gt;Setting-&gt;SSH and GPG keys中，点击new SSH key。Title：可以随便填写，但最好起的名字能让自己知道这个公钥是哪个设备的。Key：将上面生成的.pub文件中的所有内容复制到这里。点击下面的Add SSH key即可。然后你就会发现可以免密码访问了 Git服务器如果服务端是自己搭建的git服务器，生成密钥公钥对的步骤是一样的。然后将生成的 .pub 文件内容，导入到git服务器 /home/git/.ssh/authorized_keys 文件内，一行一个。然后你就会发现git push 不再需要密码了搭建git服务器和相关免登陆的详细步骤可参考我的另一篇 搭建Git服务器 HTTPS通信协议上面讲了SSH方式的免密码，接下来讲一下越来越常用的HTTPS方式的免密码新建文件并保存密码 $ touch ~/.git-credentials $ vim ~/.git-credentials 添加内容 https://&#123;username&#125;:&#123;passwd&#125;@github.com 添加git配置 $ git config --global credential.helper store 查看～/.gitconfig文件变化 [credential] helper = store 然后再尝试一下git push不再在需要密码了","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"工具/git","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ysluckly.github.io/tags/Git/"}]},{"title":"jQuery之checkbox|radio|select操作","slug":"front-end/jQuery之checkbox-radio-select操作","date":"2016-11-23T08:19:34.000Z","updated":"2022-02-19T09:27:58.499Z","comments":true,"path":"2016/11/23/jQuery-checkbox-radio-select/","link":"","permalink":"https://ysluckly.github.io/2016/11/23/jQuery-checkbox-radio-select/","excerpt":"jQuery1.6中添加了prop方法,看起来和用起来都和attr方法一样,但是在一些特殊情况下,attribute和properties的区别非常大,在jQuery1.6之前，.attr()方法在获取一些attributes的时候使用了property值，这样会导致一些不一致的行为。在jQuery1.6中，.prop()方法提供了一中明确的获取property值得方式，这样.attr()方法仅返回attributes。 –摘自jQuery API文档","text":"jQuery1.6中添加了prop方法,看起来和用起来都和attr方法一样,但是在一些特殊情况下,attribute和properties的区别非常大,在jQuery1.6之前，.attr()方法在获取一些attributes的时候使用了property值，这样会导致一些不一致的行为。在jQuery1.6中，.prop()方法提供了一中明确的获取property值得方式，这样.attr()方法仅返回attributes。 –摘自jQuery API文档 checkbox&lt;input type=&#39;checkbox&#39; value=&#39;1&#39;/&gt; &lt;input type=&#39;checkbox&#39; value=&#39;2&#39;/&gt; &lt;input type=&#39;checkbox&#39; value=&#39;3&#39;/&gt; $(&quot;input[type=checkbox]&quot;) //获取所有的checkbox $(&quot;input[type=checkbox]:checked&quot;) //获取所有的被选中的checkbox $(&quot;input[type=checkbox]:not(:checked)&quot;) //获取所有未被选中的checkbox $(&quot;input[type=checkbox]&quot;).not(&quot;:checked&quot;) //获取所有未被选中的checkbox $(&quot;input[type=checkbox]:first&quot;) //获取第一个checkbox的value值 $(&quot;input[type=checkbox]:checked&quot;).length //获取被选中checkbox的数量 $(&quot;input[type=checkbox]:first&quot;).prop(&quot;checked&quot;) //判断第一个checkbox是否被选中 $(&quot;input[type=checkbox]:first&quot;).prop(&quot;checkbox&quot;,true) //选中第一个checkbox $(&quot;input[type=checkbox]:not(:checked)&quot;).prop(&quot;checked&quot;,true) //全选 $(&quot;input[type=checkbox]:checkbox&quot;).prop(&quot;checked&quot;,false) //都不选中 //反选 $(&quot;input[type=checkbox]&quot;).each(function()&#123; if($(this).prop(&quot;checked&quot;))&#123; $(this).prop(&quot;checked&quot;,false); &#125;else&#123; $(this).prop(&quot;checked&quot;,true); &#125; &#125;) radio&lt;input type=&#39;radio&#39; name=&#39;rank&#39; value=&#39;1&#39; /&gt; &lt;input type=&#39;radio&#39; name=&#39;rank&#39; value=&#39;2&#39; /&gt; &lt;input type=&#39;radio&#39; name=&#39;rank&#39; value=&#39;3&#39; /&gt; $(&quot;input[type=radio]&quot;) //获取所有的radio $(&quot;input[type=radio]:checked&quot;) //获取被选中的radio $(&quot;input[type=radio]:not(:checkbox)&quot;) //获取所有没有被选中的radio $(&quot;input[type=radio]:checked&quot;).val() //获取被选中的radio的value值 $(&quot;input[type=radio]:first&quot;).prop(&quot;checked&quot;) //判断第一个radio是否被选中 $(&quot;input[type=radio]:first&quot;).prop(&quot;checked&quot;,true) //选中第一个radio select&lt;select&gt; &lt;option value=&#39;1&#39;&gt;1&lt;/option&gt; &lt;option value=&#39;2&#39;&gt;2&lt;/option&gt; &lt;option value=&#39;4&#39;&gt;3&lt;/option&gt; &lt;/select&gt; $(&quot;select option:selected&quot;) //获取被选中的option $(&quot;select&quot;).val() //获取选中option的value值 $(&quot;select option:selected&quot;).text() //获取被选中的option的text值 $(&quot;select option:first&quot;).prop(&quot;selected&quot;) //判断第一个option是否被选中 $(&quot;select option:first&quot;).prop(&quot;selected&quot;,true) //选中第一个option $(&quot;select option:selected&quot;).prop(&quot;selected&quot;,false) //取消当前选中,然后默认选中第一个","categories":[{"name":"大前端","slug":"大前端","permalink":"https://ysluckly.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://ysluckly.github.io/tags/jQuery/"}]},{"title":"jQuery选择器与节点操作","slug":"front-end/jQuery选择器与节点操作","date":"2016-11-22T09:11:48.000Z","updated":"2022-02-19T09:27:58.499Z","comments":true,"path":"2016/11/22/jQuery-selector/","link":"","permalink":"https://ysluckly.github.io/2016/11/22/jQuery-selector/","excerpt":"jQuery 是一个 JavaScript 函数库。jQuery的语法设计使得许多操作变得容易，如操作文档对象（document）、选择文档对象模型（DOM）元素、创建动画效果、处理事件、以及开发Ajax程序。jQuery也提供了给开发人员在其上创建插件的能力。这使开发人员可以对底层交互与动画、高级效果和高级主题化的组件进行抽象化。","text":"jQuery 是一个 JavaScript 函数库。jQuery的语法设计使得许多操作变得容易，如操作文档对象（document）、选择文档对象模型（DOM）元素、创建动画效果、处理事件、以及开发Ajax程序。jQuery也提供了给开发人员在其上创建插件的能力。这使开发人员可以对底层交互与动画、高级效果和高级主题化的组件进行抽象化。 jQuery获取元素元素选择器//元素选择器 &lt;div &gt; $(&quot;div&quot;) id选择器//id选择器 &lt;div id=&#39;id&#39;&gt; $(&quot;#id&quot;) $(&quot;div#id&quot;) class选择器//class选择器 &lt;div class=&#39;class&#39;&gt; $(&quot;.class&quot;) $(&quot;div.class&quot;) 属性过滤选择器&lt;li class=&#39;check&#39; type=&#39;li_01&#39;&gt;&lt;/li&gt; &lt;li type=&#39;li_02&#39;&gt;&lt;/li&gt; &lt;li type=&#39;li_03&#39;&gt;&lt;/li&gt; //通过属性获取 如果属性值为有特殊字符，一定要加引号 $(&quot;[type]&quot;) //获取有type属性的元素 $(&quot;[type=&#39;li_01&#39;]&quot;) //获取type值等于&#39;li_01&#39;的元素 $(&quot;[type!=&#39;li_01&#39;]&quot;) //获取type值不等于&#39;li_01&#39;的元素 $(&quot;[type*=&#39;li&#39;]&quot;) //模糊匹配 获取type值包含&#39;li&#39;的元素 $(&quot;[type^=&#39;li&#39;]&quot;) //模糊匹配 获取type值以&#39;li&#39;开始的元素 $(&quot;[type$=&#39;01&#39;]&quot;) //模糊匹配 获取type值以&#39;01&#39;结尾的元素 $(&quot;li[class=&#39;check&#39;][type]&quot;) //获取多个条件同时满足的元素 * 选择器//遍历form下的所有元素,将其margin设置0 $(&#39;form *&#39;).css(&#39;margin&#39;,&#39;0px&#39;) 并列选择器$(&#39;p, div&#39;).css(&#39;color&#39;,&#39;red&#39;); //将p元素和div元素的字体颜色设置为red 层叠选择器&lt;div class=&#39;a&#39;&gt; &lt;!-- 父级div --&gt; &lt;div class=&#39;a1&#39;&gt; &lt;!-- 子级div1 --&gt; &lt;div class=&#39;a11&#39;&gt;&lt;/div&gt; &lt;!-- 孙级div1 --&gt; &lt;/div&gt; &lt;div class=&#39;a2&#39;&gt;&lt;/div&gt; &lt;!-- 子级div2 --&gt; &lt;div class=&#39;a3&#39;&gt;&lt;/div&gt; &lt;!-- 子级div3 --&gt; &lt;span&gt;&lt;/span&gt; &lt;!-- 子级span1 --&gt; &lt;/div&gt; $(&quot;.a div&quot;) //选择class=a的元素下所有的div 即选择到子级div1,2,3 孙级div1 $(&quot;.a &gt; div&quot;) //选择class=a的元素的所有子div元素, 即选择到子级div1,2,3; $(&quot;div + span&quot;) //选择所有的div元素的下一个input元素节点,即选择到:子级div3 $(&quot;.a1 ~ div&quot;) //同胞选择器,返回class为a2的标签元素的所有属于同一个父元素的div标签,即div1,2,3 基本过滤选择器&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; $(&quot;li:first&quot;) //选择所有li元素的第一个 $(&quot;li:last&quot;) //选择所有li元素的最后一个 $(&quot;li:even&quot;) //选择所有li元素的第0,2,4... ...个元素(序号从0开始) $(&quot;li:odd&quot;) //选择所有li元素的第1,3,5... ...个元素 $(&quot;li:eq(2)&quot;) //选择所有li元素中的第三个(即序号为2) $(&quot;li:gt(3)&quot;) //选择所有li元素中序号大于3的li元素 $(&quot;li:ll(2)&quot;) //选择所有li元素中序号小于2的li元素 &lt;input type=&quot;checkbox&quot; /&gt; &lt;input type=&quot;checkbox&quot; /&gt; $(&quot;input[type=&#39;checkbox&#39;]:checked&quot;) //获取所有已被选中的type等于checkbox的input元素 $(&quot;input[type=&#39;checkbox&#39;]:not(:checked)&quot;) //获取所有未被选中的type等于checkbox的input元素 内容过滤器$(&quot;div:contains(&#39;Faker&#39;)&quot;) //选择所有div中含有Faker文本的元素 $(&quot;div:empty&quot;) //选择所有div中为空(不包含任何元素/文本)的元素 $(&quot;div:has(&#39;p&#39;)&quot;) //选择所有div中包含p元素的元素 $(&quot;div:parent&quot;) //选择所有的含有子元素或文本的div 可视化过滤器$(&quot;div:hidden&quot;) //选择所有被hidden的div元素 $(&quot;div:not(:hidden)&quot;) //选择所有没有被hidden的div元素 $(&quot;div:visible&quot;) //所有可视化的div元素 $(&quot;div:not(:visible)&quot;) //所有非可视化的div元素 子元素过滤器&lt;body&gt; &lt;div class=&#39;d1&#39;&gt; &lt;div class=&#39;d11&#39;&gt; &lt;div class=&#39;d111&#39;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; $(&quot;body div:first-child&quot;) //返回所有的body元素下 所有div 为父元素的第一个元素 的元素. //:first 与 :first-child 的区别用法 //$(&quot;body div:first&quot;)只匹配到第一个合适的元素 即只匹配到 d1 //$(&quot;body div:first-child&quot;) 匹配所有合适的元素:d1是body的第一个元素,d11是d1的第一个元素.. //所以匹配到d1,d11,d111 $(&quot;div span:last-child&quot;) //返回所有的body元素下 所有div 为父元素的最后一个元素 的元素. //:last 与 :last-child 的区别参考first $(&quot;div button:only-child&quot;) //如果button是它父级元素的唯一子元素,此button将会被匹配 表单元素选择器$(&quot;:input&quot;) //选择所有的表单输入元素，包括input, textarea, select 和 button $(&quot;:text&quot;) //选择所有的text input元素 $(&quot;:password&quot;) //选择所有的password input元素 $(&quot;:radio&quot;) //选择所有的radio input元素 $(&quot;:checkbox&quot;) //选择所有的checkbox input元素 $(&quot;:submit&quot;) //选择所有的submit input元素 $(&quot;:image&quot;) //选择所有的image input元素 $(&quot;:reset&quot;) //选择所有的reset input元素 $(&quot;:button&quot;) //选择所有的button input元素 $(&quot;:file&quot;) //选择所有的file input元素 $(&quot;:hidden&quot;) //选择所有类型为hidden的input元素或表单的隐藏域 表单元素过滤器$(&quot;:enabled&quot;) //选择所有的可操作的表单元素 $(&quot;:disabled&quot;) //选择所有的不可操作的表单元素 $(&quot;:checked&quot;) //选择所有的被checked的表单元素 $(&quot;select option:selected&quot;) //选择所有的select 的子元素中被selected的元素 节点操作获取和操作节点属性&lt;a href=&#39;index.html&#39; data-type=&#39;a&#39; style=&quot;color:red;&quot;&gt;index&lt;/a&gt; &lt;input value=&#39;user&#39; /&gt; $(&quot;a&quot;).attr(&quot;href&quot;); //获取href属性值 $(&quot;a&quot;).attr(&quot;href&quot;,&quot;about.html&quot;); //设置href属性值 $(&quot;a&quot;).data(&quot;type&quot;); //获取data-type属性值 $(&quot;a&quot;).css(&quot;color&quot;); //通过key(color/display/....)获取css值 $(&quot;a&quot;).css(&quot;color&quot;,&quot;black&quot;); //通过key/value 设置css属性 $(&quot;a&quot;).text(); //获取a的文本节点值 $(&quot;a&quot;).text(&quot;Index.html&quot;); //设置a的文本节点值 $(&quot;input&quot;).val(); //获取input的value值 $(&quot;input&quot;).val(&quot;username&quot;); //设置input的value值 插入节点的方法&lt;div class=&quot;head&quot;&gt; &lt;span&gt;Faker&lt;span&gt; &lt;/div&gt; $(&quot;.head&quot;).append(&quot;&lt;span&gt;hello&lt;/span&gt;&quot;) //在.head中的最后插入一段html //结果: &lt;div class=&quot;head&quot;&gt;&lt;span&gt;Faker&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/div&gt; $(&quot;&lt;span&gt;hello&lt;/span&gt;&quot;).appendTo(&quot;.head&quot;) //在.head中的最后插入一段html, //结果: &lt;div class=&quot;head&quot;&gt;&lt;span&gt;Faker&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/div&gt; $(&quot;.head&quot;).prepend(&quot;&lt;span&gt;hello&lt;/span&gt;&quot;) //在.head中的开始插入一段html, //结果: &lt;div class=&quot;head&quot;&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;Faker&lt;/span&gt;&lt;/div&gt; $(&quot;&lt;span&gt;hello&lt;/span&gt;&quot;).prependTo(&quot;.head&quot;) //在.head中的开始插入一段html, //结果: &lt;div class=&quot;head&quot;&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;Faker&lt;/span&gt;&lt;/div&gt; $(&quot;.head *:first&quot;).after(&quot;&lt;span&gt;hello&lt;/span&gt;&quot;) //在.head中的第一个元素后插入一段html, //结果: &lt;div class=&quot;head&quot;&gt;&lt;span&gt;Faker&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/div&gt; $(&quot;&lt;span&gt;hello&lt;/span&gt;&quot;).insertAfter(&quot;.head *:first&quot;) //在.head中的第一个元素后插入一段html, //结果: &lt;div class=&quot;head&quot;&gt;&lt;span&gt;Faker&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/div&gt; $(&quot;.head *:first&quot;).before(&quot;&lt;span&gt;hello&lt;/span&gt;&quot;) //在.head中的第一个元素前插入一段html, //结果: &lt;div class=&quot;head&quot;&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;Faker&lt;/span&gt;&lt;/div&gt; $(&quot;&lt;span&gt;hello&lt;/span&gt;&quot;).insertBefore(&quot;.head *:first&quot;) //在.head中的第一个元素后插入一段html, //结果: &lt;div class=&quot;head&quot;&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;Faker&lt;/span&gt;&lt;/div&gt; $.load()方法 在指定位置加载请求回来的html页面 &lt;div class=&quot;head&quot;&gt; &lt;/div&gt; $(&quot;.head&quot;).load(url[,data][,callback]) url: 请求HTML页面的URL地址 data(可选): 请求的key/value参数 callback(可选) 请求完成的回调函数","categories":[{"name":"大前端","slug":"大前端","permalink":"https://ysluckly.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://ysluckly.github.io/tags/jQuery/"}]},{"title":"idea常用快捷键","slug":"tools/idea-shortcuts","date":"2016-11-05T07:22:48.000Z","updated":"2022-02-19T09:27:58.567Z","comments":true,"path":"2016/11/05/idea-shortcuts/","link":"","permalink":"https://ysluckly.github.io/2016/11/05/idea-shortcuts/","excerpt":"工欲善其事 , 必先利其器","text":"工欲善其事 , 必先利其器 Idea作为IDE是相当niubility,但是要运用自如还得掌握一些常用快捷键,才能在开发过程中运用自如以下是idea的默认快捷键,如果英语能力没有问题,可以在Help-&gt;Keymap Reference 查看官方文档当然作为一款优秀的IDE,怎么会少了自定义快捷键(File-&gt;Setting-&gt;Keymap,可通过动作名/快捷键组合双向查找)好了,下面是博主在Java相关开发过程中常用到的一些快捷键 常用快捷键组合编辑 序号 快捷键组合 作用 Ctrl+D 重复光标所在行/或选中部分 Ctrl+C 复制光标所在行/或选中部分 Ctrl+V 粘贴 Ctrl+Shift+V 选择粘贴最近5次复制的内容 Ctrl+X 删除光标所在行/或选中部分 Ctrl+Y 删除光标所在行/或选中行 Shift+Enter 向下插入新行 Alt+Shift+↑/↓ 移动当前行到上/下一行 Ctrl+Alt+←/→ 定位到上/下一次光标位置 Ctrl+I 实现接口方法 Ctrl+Shift+o 删除没用的import Ctrl+O 重写父类方法 Ctrl+W 选中当前单词 Ctrl+P 提示参数 Ctrl+Q 查看方法/类的注释文档 Ctrl+Alt+L 格式化当前模板 Ctrl+/ 注释当前行,或选中行 Ctrl+Shift+/ 注释选中部分 /**+回车(类/方法/属性前) 添加注释 搜索/替换 序号 快捷键组合 作用 Ctrl+N 通过类名(文件名)的关键字快速打开文件(仅限.java文件) Ctrl+Shift+N 通过文件名关键字快速打开文件 Ctrl+Shift+N(两次) 通过文件名关键字快速打开文件(包括非本项目内文件,如Maven引入的) Ctrl+Shift+Alt+N 通过关键字(包括类名/方法名/url映射)快速打开文件,定位到类名/方法名/url映射的方法 Ctrl+F 搜索关键字(支持正则)在当前文件 F3 找下一个 Shift+F3 找上一个 Ctrl+R 替换关键字(支持正则)在当前文件 Ctrl+Shift+F 在所有文件(可以指定过滤文件)中查找关键字(支持正则) Ctrl+Shift+R 在所有文件(可以指定过滤文件)中替换关键字(支持正则) debugging 序号 快捷键组合 作用 F8 Step over(跳过下一行) F7 Step into(跳入当前行调用的方法体内) Shift+F7 Smart Step into(跳过) 未完待续","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"软件记录","slug":"工具/软件记录","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"IntellijIDEA","slug":"IntellijIDEA","permalink":"https://ysluckly.github.io/tags/IntellijIDEA/"}]},{"title":"web.xml详解","slug":"back-end/web-xml详解","date":"2016-10-24T02:10:45.000Z","updated":"2022-02-20T13:01:18.444Z","comments":true,"path":"2016/10/24/web-xml/","link":"","permalink":"https://ysluckly.github.io/2016/10/24/web-xml/","excerpt":"web.xml文件是用来配置:欢迎页、servlet、filter、listener等的. 当你的web项目工程没用到这些时,你可以不用web.xml文件来配置你的web工程。如果项目中有多项标签,其加载顺序依次是:context-param &gt;&gt; listener &gt;&gt; filter &gt;&gt; servlet(同类多个节点出现顺序依次加载)","text":"web.xml文件是用来配置:欢迎页、servlet、filter、listener等的. 当你的web项目工程没用到这些时,你可以不用web.xml文件来配置你的web工程。如果项目中有多项标签,其加载顺序依次是:context-param &gt;&gt; listener &gt;&gt; filter &gt;&gt; servlet(同类多个节点出现顺序依次加载) web.xml先读取context-param和listener这两种节点； 然后容器创建一个ServletContext(上下文)，应用于整个项目； 容器会将读取到的context-param转化为键值对并存入servletContext； 根据listener创建监听； 容器会读取，根据指定的类路径来实例化过滤器； 此时项目初始化完成； 在发起第一次请求是，servlet节点才会被加载实例化。 参数设置context-paramcontext-param节点是web.xml中用于配置应用于整个web项目的​上下文。包括两个子节点，其中param-name 设定上下文的参数名称。必须是唯一名称；param-value 设定的参数名称的值。 读取节点的方法如下： $&#123;initParam.参数名&#125; Servlet中String paramValue=getServletContext().getInitParameter(“参数名”)​ web.xml中配置spring必须使用listener节点，但context-param节点可有可无，如果缺省则默认contextConfigLocation路径为“/WEB-INF/applicationContext.xml”；如果有多个xml文件，使用”,“分隔 listener&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt; &lt;/listener&gt; 为web应用程序定义监听器，监听器用来监听各种事件，比如：application和session事件，所有的监听器按照相同的方式定义，功能取决去它们各自实现的接口，常用的Web事件接口有如下几个：ServletContextListener：用于监听Web应用的启动和关闭；ServletContextAttributeListener：用于监听ServletContext范围（application）内属性的改变；ServletRequestListener：用于监听用户的请求；ServletRequestAttributeListener：用于监听ServletRequest范围（request）内属性的改变；HttpSessionListener：用于监听用户session的开始和结束；HttpSessionAttributeListener：用于监听HttpSession范围（session）内属性的改变。 配置Listener只要向Web应用注册Listener实现类即可，无序配置参数之类的东西，因为Listener获取的是Web应用ServletContext（application）的配置参数。为Web应用配置Listener的两种方式： 使用@WebListener修饰Listener实现类即可。 在web.xml文档中使用进行配置。 servletservlet即配置所需用的servlet，用于处理及响应客户的请求。容器的Context对象对请求路径(URL)做出处理，去掉请求URL的上下文路径后，按路径映射规则和Servlet映射路径（）做匹配，如果匹配成功，则调用这个Servlet处理请求。 为Servlet命名：&lt;servlet&gt; &lt;servlet-name&gt;servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.whatisjava.TestServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 为Servlet定制URL&lt;servlet-mapping&gt; &lt;servlet-name&gt;servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Load-on-startupLoad-on-startup 元素在web应用启动的时候指定了servlet被加载的顺序，它的值必须是一个整数。如果它的值是一个负整数或是这个元素不存在，那么容器会在该servlet被调用的时候，加载这个servlet 。如果值是正整数或零，容器在配置的时候就加载并初始化这个servlet，容器必须保证值小的先被加载。如果值相等，容器可以自动选择先加载谁。当值为0或者大于0时，表示容器在应用启动时就加载这个servlet；当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载。正数的值越小，启动该servlet的优先级越高。 filter设置过滤器:如编码过滤器,过滤所有资源 &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; session设置会话(Session)过期时间,其中时间以分钟为单位,加入设置60分超时: &lt;session-config&gt; &lt;session-timeout&gt;60&lt;/session-timeout&gt; &lt;/session-config&gt; welcom-file-list&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; PS:指定了两个欢迎页面,显示时按顺序从第一个找起，如果第一个存在，就显示第一个，后面的不起作用。如果第一个不存在，就找第二个，以此类推。如果都没有就404. 关于欢迎页面：访问一个网站时，默认看到的第一个页面就叫欢迎页，一般情况下是由首页来充当欢迎页的。一般情况下，我们会在web.xml中指定欢迎页。但 web.xml并不是一个Web的必要文件，没有web.xml，网站仍然是可以正常工作的。只不过网站的功能复杂起来后，web.xml的确有非常大用处，所以，默认创建的动态web工程在WEB-INF文件夹下面都有一个web.xml文件。 error-page&lt;!-- 错误码 --&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error404.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;!-- 错误类型 --&gt; &lt;error-page&gt; &lt;exception-type&gt;java.lang.Exception&lt;exception-type&gt; &lt;location&gt;/exception.jsp&lt;location&gt; &lt;/error-page&gt;","categories":[{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"后端/Java","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ysluckly.github.io/tags/java/"},{"name":"javaee","slug":"javaee","permalink":"https://ysluckly.github.io/tags/javaee/"}]},{"title":"Hexo+Git服务器搭建blog","slug":"tools/hexo-git-server-blog","date":"2016-10-23T01:24:03.000Z","updated":"2022-02-19T09:27:58.563Z","comments":true,"path":"2016/10/23/hexo-git-server-blog/","link":"","permalink":"https://ysluckly.github.io/2016/10/23/hexo-git-server-blog/","excerpt":"博主最近在服务器上搭建Hexo发布平台，感觉整个搭建过程和搭建思想蛮有意思，在此记录一下，供猿友参考Hexo 是一个快速，简单，功能强大，主题社区特别庞大的开源blog框架-》官网本次搭建是通过在服务器上搭建Git服务器来实现一键发布blog","text":"博主最近在服务器上搭建Hexo发布平台，感觉整个搭建过程和搭建思想蛮有意思，在此记录一下，供猿友参考Hexo 是一个快速，简单，功能强大，主题社区特别庞大的开源blog框架-》官网本次搭建是通过在服务器上搭建Git服务器来实现一键发布blog 搭建思路 客户端就是自己的电脑,可以把hexo的静态资源目录当成一个git仓库. 首先配置好远程git仓库,通过 hexo d 将静态网站资源push到远程git仓库 git仓库接收到push处理完成后,自动触发post-receive这个钩子. 执行钩子内容,进入到 /var/www/blog 目录(也是一个git仓库),拉取刚才hexo推送到git服务端的静态网站资源. 配置nginx,将80端口映射到 /var/www/blog 目录. 就可以直接通过ip访问到静态blog了 搭建过程环境准备在服务器上安装git并创建git远程仓库 如 blog.git搭建过程移步 搭建Git服务器 在 _config.yml 中配置git服务器deploy: type: git repo: git@server:/home/git/blog.git branch: master 如果ssh端口不是默认的22的话，如下配置,8080改为自己服务器上ssh端口 deploy: type: git repo: ssh://git@server:8080/home/git/blog.git branch: master 配置nginx现在已经可以使用 hexo d 将hexo中的生成的静态资源发送到远程服务器中，接下来我们要配置nginx来配置静态web。安装过程可以自行Google，在此只说明nginx如何配置静态web首先创建一个目录作为存放web资源（hexo生成的）的目录，如： /var/www/blog cd /var/www #创建blog目录，并克隆blog.git仓库的内容 git clone /home/git/blog.git blog 找到 nginx.conf 添加以下信息 server &#123; listen 80; charset utf-8; root /var/www/blog; index index.htm index.html index.jsp; &#125; #重启并加载配置文件 $ nginx -s reload 配置git服务器hooks这个钩子的作用是，当git服务器接受客户端push完成更新，执行此文件内容 #创建并编辑post-receive $ vim blog.git/hooks/post-receive 内容如下 #!/bin/sh unset GIT_DIR #还原环境变量，否则会拉不到代码 cd /var/www/blog git pull origin master #拉取最新代码 测试效果在本地的hexo下执行 hexo d查看 /var/www/blog文件夹内的内容也发生变化","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"},{"name":"Git","slug":"Git","permalink":"https://ysluckly.github.io/tags/Git/"}]},{"title":"Hexo+GitHub Pages搭建属于自己的blog","slug":"tools/hexo-gitHub-pages-create-own-blog","date":"2016-10-22T13:24:05.000Z","updated":"2022-02-19T09:27:58.564Z","comments":true,"path":"2016/10/22/hexo-gitHub-pages-create-own-blog/","link":"","permalink":"https://ysluckly.github.io/2016/10/22/hexo-gitHub-pages-create-own-blog/","excerpt":"Hexo是一个快速，简单，功能强大的开源博客框架-》官网GitHub Pages 是一个不受限的网站空间。两者相得益彰。给那些喜欢自己折腾的人提供一些借鉴。","text":"Hexo是一个快速，简单，功能强大的开源博客框架-》官网GitHub Pages 是一个不受限的网站空间。两者相得益彰。给那些喜欢自己折腾的人提供一些借鉴。 搭建过程环境介绍博主使用系统：Deepin Linux 15.3桌面版安装 node与npm 安装Hexonpm install hexo-cli -g 初始化bloghexo init blog 至此，本地blog已经创建完成，是不是很简单，简单到没朋友 选择主题可以在hexo官网查看自己喜欢的主题通过git clone [url] themes/xxx 将主题克隆到本地，修改 _config.yml 中的theme：xxx 常用命令#创建一个新的文章 $ hexo new &quot;文章名&quot; #生成静态文件 $ hexo generate #将一个草稿发布出去 $ hexo publish [layout] &lt;filename&gt; #启动一个本地服务器 $ hexo server 更多命令移步官方文档 搭建github pages本地blog已经搭建完成，现在可以发布到github pages上 注册github账户到github官网注册一个github账户 配置登录免密码移步 Git之SSH与HTTPS免密码配置 创建github远程仓库在github上创建一个仓库 xxx.github.io xxx为自己的github用户名 安装插件$ npm install hexo-deployer-git --save 配置Hexo修改 _comfig.yml,xxx为你的用户名 deploy: type: git repo: git@github.com:xxx/xxx.github.io.git branch: master 推送服务器$ hexo deploy 若出现ERROR Deployer not found: git报错，请执行上面安装插件步骤 测试打开 xxx.github.io ，就能看到你的blog了","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"},{"name":"Git","slug":"Git","permalink":"https://ysluckly.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://ysluckly.github.io/tags/GitHub/"}]},{"title":"搭建Git服务器","slug":"tools/set-up-git-server-on-vps","date":"2016-10-22T12:08:04.000Z","updated":"2022-02-19T09:27:58.569Z","comments":true,"path":"2016/10/22/set-up-git-server-on-vps/","link":"","permalink":"https://ysluckly.github.io/2016/10/22/set-up-git-server-on-vps/","excerpt":"最近由于准备在公司的服务器上面搭建静态博客（Hexo），然后需要先搭建一个git服务器作为转接，整个过程看似顺利，十几分钟就搭建完成，不过最后在验证这块卡了两个小时，在此记录下来，供准备搭建git服务器的新手小伙伴们借鉴。","text":"最近由于准备在公司的服务器上面搭建静态博客（Hexo），然后需要先搭建一个git服务器作为转接，整个过程看似顺利，十几分钟就搭建完成，不过最后在验证这块卡了两个小时，在此记录下来，供准备搭建git服务器的新手小伙伴们借鉴。 搭建git服务器通过ssh链接到服务器，开始进行操作 第一步在服务器上安装 git $ sudo apt-get install git 第二步创建 git 用户，用来运行git服务 $ sudo adduser git 第三步创建证书，免密码登录：收集所有需要登录的用户的公钥（id_rsa.pub）文件，把所有公钥导入到 /home/git/.ssh/authorized_keys 文件内，一行一个。如果个人的git中的公钥已经连接了其他服务器如：github，可以参考 一个客户端设置多个github账号 注意：一定要通过下面的命令将该文件其他用户的所有权限移除，否则会出现文章尾部问题 $ chmod 600 authorized_keys 第四步初始化git仓库 $ git init --bare test.git git创建一个裸仓库，裸仓库没有工作区，因为服务器上的git仓库纯粹为了共享，所有不能让用户直接登录到服务器上去改工作区，并且服务器的git仓库通常以 .git 结尾。然后，修改owner改为git： $ sudo chown -R git:git test.git 第五步禁用shell登录：处于安全的考虑，第二步创建的git用户不允许登录shell，这可以通过编辑 /etc/passwd 文件完成。 git:x:1003:1003::/home/git:/bin/bash 改为 git:x:1003:1003::/home/git:/usr/bin/git-shell 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。 第六步克隆远程仓库：现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行： $ git clone git@server:/home/git/test.git 如果服务器的ssh端口不是默认的22的话，比如说6789，可以这样写： $ git clone ssh://git@server:6789/home/git/test.git 问题来了本来根据文档，根据广大猿友的经验，我的搭建之路已经完成了，然后最后一步出现了问题。每次跟服务器进行交互(clone,pull,push)，都让我输入git的密码，也就是说，我配置的ssh没有生效。然后就开始到处找原因，重新生成rsa，提升authorized_keys权限，重新创建服务器git账户，重新。。。。。 翻遍了 Stack Overflow 和 segmentfault ,两个小时过去了，问题仍然没有进展，这么简单的东西，问题到底出在哪里。 就在心灰意冷，准备放弃的时候，不知道是哪里来的灵感，准备把 authorized_keys 文件的其他用户的权限删掉，然后就能用了，后就能用了，就能用了，能用了，用了，了～～～～，命令如下，不想多说话，我想静静。 $ chmod 600 authorized_keys","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"工具/git","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ysluckly.github.io/tags/Git/"}]},{"title":"如何给GitHub上的项目贡献代码","slug":"tools/contributing-to-open-source-on-github","date":"2016-10-13T07:44:07.000Z","updated":"2022-02-19T09:27:58.550Z","comments":true,"path":"2016/10/13/contributing-to-open-source-on-github/","link":"","permalink":"https://ysluckly.github.io/2016/10/13/contributing-to-open-source-on-github/","excerpt":"最近一直在使用 hexo 的一款主题 yelee ，但是发现它的代码块由于空行不占位导致的显示错位，所以就去GitHub上翻issue，果然有好多人都在反映这个问题，并且作者已经打上bug标签，事情应该就马上结束了，就去忙别的了。这两天又去逛了一下issue，发现这个bug仍然屹立在那里，强迫症又犯了，趁着今天工作不怎么忙，就把这个bug解决了。然后问题来了，怎么才能给作者贡献代码呢。","text":"最近一直在使用 hexo 的一款主题 yelee ，但是发现它的代码块由于空行不占位导致的显示错位，所以就去GitHub上翻issue，果然有好多人都在反映这个问题，并且作者已经打上bug标签，事情应该就马上结束了，就去忙别的了。这两天又去逛了一下issue，发现这个bug仍然屹立在那里，强迫症又犯了，趁着今天工作不怎么忙，就把这个bug解决了。然后问题来了，怎么才能给作者贡献代码呢。 准备工作 首先通过 git clone 将项目克隆到本地（我早已拉下来，跳过此步骤） git pull 拉取最新代码（将所有的change都同步到本地） 将 原项目 fork 到 自己的github上,并复制代码url 在本地添加第二个仓库地址：git remote add [nickname] [your url] 修改 修改bug 或 新增功能 git commit [file1] [file2] ... -m [message] 本地提交代码 同步到github中并发到原项目 git push [nickname] 将代码 push 到自己的项目里，nickname就是添加的第二个仓库的名字 自己项目内，点击 pull requests -》 new pull request 将本次修改提交到原项目进行同步。","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"工具/git","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ysluckly.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://ysluckly.github.io/tags/GitHub/"}]},{"title":"PostgreSQL常用操作","slug":"database/PostgreSQL常用操作","date":"2016-10-12T12:27:07.000Z","updated":"2022-02-20T13:03:17.654Z","comments":true,"path":"2016/10/12/PostgreSQL-2/","link":"","permalink":"https://ysluckly.github.io/2016/10/12/PostgreSQL-2/","excerpt":"控制台命令\\h: #查看SQL命令的解释，比如\\h select。 \\?: #查看psql命令列表。 \\l: #列出所有数据库。 \\c [database_name]: #连接其他数据库。 \\d: #列出当前数据库的所有表格。 \\d [table_name]: #列出某一张表格的结构。 \\du: #列出所有用户。 \\e: #打开文本编辑器。 \\conninfo: #列出当前数据库和连接的信息。","text":"控制台命令\\h: #查看SQL命令的解释，比如\\h select。 \\?: #查看psql命令列表。 \\l: #列出所有数据库。 \\c [database_name]: #连接其他数据库。 \\d: #列出当前数据库的所有表格。 \\d [table_name]: #列出某一张表格的结构。 \\du: #列出所有用户。 \\e: #打开文本编辑器。 \\conninfo: #列出当前数据库和连接的信息。 数据库操作基本的数据库操作，就是使用一般的SQL语言 # 创建新表 CREATE TABLE user_tbl(name VARCHAR(20), signup_date DATE); # 插入数据 INSERT INTO user_tbl(name, signup_date) VALUES(&#39;张三&#39;, &#39;2013-12-22&#39;); # 选择记录 SELECT * FROM user_tbl; # 更新数据 UPDATE user_tbl set name = &#39;李四&#39; WHERE name = &#39;张三&#39;; # 删除记录 DELETE FROM user_tbl WHERE name = &#39;李四&#39; ; # 添加栏位 ALTER TABLE user_tbl ADD email VARCHAR(40); # 更新结构 ALTER TABLE user_tbl ALTER COLUMN signup_date SET NOT NULL; # 更名栏位 ALTER TABLE user_tbl RENAME COLUMN signup_date TO signup; # 删除栏位 ALTER TABLE user_tbl DROP COLUMN email; # 表格更名 ALTER TABLE user_tbl RENAME TO backup_tbl; # 删除表格 DROP TABLE IF EXISTS backup_tbl;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"PostgreSQL","slug":"数据库/PostgreSQL","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://ysluckly.github.io/tags/PostgreSQL/"}]},{"title":"PostgreSQL初体验","slug":"database/PostgreSQL初体验","date":"2016-10-12T11:49:40.000Z","updated":"2022-02-20T13:03:23.704Z","comments":true,"path":"2016/10/12/PostgreSQL-1/","link":"","permalink":"https://ysluckly.github.io/2016/10/12/PostgreSQL-1/","excerpt":"创建操作系统用户创建一个新的Linux用户：dbuser $sudo adduser dbuser #创建一个新的Linux用户：dbuser","text":"创建操作系统用户创建一个新的Linux用户：dbuser $sudo adduser dbuser #创建一个新的Linux用户：dbuser 登录PostgreSQL控制台切换到postgres用户 $sudo su - postgres #切换到postgres用户 系统用户postgres以同名数据库用户的身份，登录数据库 $psql #系统用户postgres以同名数据库用户的身份，登录数据库 成功登录到控制台后，显示 postgres=# 注意：后面分号不能省略 \\password postgres #给postgres用户设置密码 创建数据库用户dbuser CREATE USER dbuser WITH PASSWORD &#39;dbuser&#39;; #创建数据库用户dbuser 创建用户数据库，这里为exampledb，并指定所有者为dbuser。 CREATE DATABASE exampledb OWNER dbuser; #创建用户数据库，这里为exampledb，并指定所有者为dbuser。 将exampledb数据库的所有权限都赋予dbuser GRANT ALL PRIVILEGES ON DATABASE exampledb to dbuser; #将exampledb数据库的所有权限都赋予dbuser 推出控制台（也可以直接按ctrl+D） \\q #退出控制台","categories":[{"name":"数据库","slug":"数据库","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"PostgreSQL","slug":"数据库/PostgreSQL","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://ysluckly.github.io/tags/PostgreSQL/"}]},{"title":"PostgreSQL的介绍与安装","slug":"database/PostgreSQL的安装","date":"2016-10-12T07:44:16.000Z","updated":"2022-02-20T13:03:29.711Z","comments":true,"path":"2016/10/12/PostgreSQL-3/","link":"","permalink":"https://ysluckly.github.io/2016/10/12/PostgreSQL-3/","excerpt":"由于工作认识了PostgreSQL，在此系统学习一下这个数据库，本文除博主实践所得以外，大量译于 官方文档 PostgreSQL是什么 PostgreSQL 是一个基于 POSTGRES, Version 4.2 的对象关系数据库系统（ORDBMS），由加州大学伯克利分校计算机科学系开发。PostgreSQL 是一个开源的数据库，因为自由许可，任何人都可以免费的使用、修改、分发 PostgreSQL 数据库用于任何目的。","text":"由于工作认识了PostgreSQL，在此系统学习一下这个数据库，本文除博主实践所得以外，大量译于 官方文档 PostgreSQL是什么 PostgreSQL 是一个基于 POSTGRES, Version 4.2 的对象关系数据库系统（ORDBMS），由加州大学伯克利分校计算机科学系开发。PostgreSQL 是一个开源的数据库，因为自由许可，任何人都可以免费的使用、修改、分发 PostgreSQL 数据库用于任何目的。 它支持大部分的SQL标准并提供了许多流行的功能： 复杂查询（complex queries） 外键（foreign keys） 触发器（triggers） 可更新的视图（updatable views） 事务完整性（transactional integrity） 多版本并发控制（multiversion concurrency control） 用户也可以给PostgreSQL扩展很多东西，比如： 数据类型（data types） 函数（functions） 运算符（operators） 聚合函数（aggregate functions） 索引方法（index methods） 安装博主开发环境： 系统 ：深度Linux 15.3 桌面版 PostgreSQL ：9.4 通过apt-get安装$ apt-get install postgresql-9.4 仓库有许多不同的包（包括第三方插件），最常见、最重要的包（根据需要替换版本号）： postgresql-client-9.4 - 客户端库和二进制文件 postgresql-9.4 - 核心数据库服务器 postgresql-contrib-9.4 - 提供额外的模块 libpq-dev - C语言前端开发库和头文件 postgresql-server-dev-9.4 - C语言后端开发库和头文件 pgadmin3 - pgAdmin III 图形化管理工具","categories":[{"name":"数据库","slug":"数据库","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"PostgreSQL","slug":"数据库/PostgreSQL","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://ysluckly.github.io/tags/PostgreSQL/"}]},{"title":"FreeMarker语法详解","slug":"front-end/freemarker语法详解","date":"2016-10-05T03:58:50.000Z","updated":"2022-02-19T09:27:58.498Z","comments":true,"path":"2016/10/05/FreeMarker/","link":"","permalink":"https://ysluckly.github.io/2016/10/05/FreeMarker/","excerpt":"FreeMarker是一款 模板引擎 :即一种基于模板和要改变的数据，并用来生成输出文本（HTML网页、电子邮件、配置文件、源代码等）的通用工具。FreeMarker模板文件主要有4部分组成 文本，直接输出的部分 注释，即&lt;#–…–&gt;格式不会输出 插值（Interpolation）：即${..}或者#{..}格式的部分,将使用数据模型中的部分替代输出 FTL指令：FreeMarker指令，和HTML标记类似，名字前加#予以区分，不会输出。","text":"FreeMarker是一款 模板引擎 :即一种基于模板和要改变的数据，并用来生成输出文本（HTML网页、电子邮件、配置文件、源代码等）的通用工具。FreeMarker模板文件主要有4部分组成 文本，直接输出的部分 注释，即&lt;#–…–&gt;格式不会输出 插值（Interpolation）：即${..}或者#{..}格式的部分,将使用数据模型中的部分替代输出 FTL指令：FreeMarker指令，和HTML标记类似，名字前加#予以区分，不会输出。 一些规则FTL指令规则FreeMarker有三种FTL标签，这和HTML的标签是完全类似的 开始标签：&lt;#directivename parameters&gt; 结束标签：&lt;/#directivename&gt; 空标签： &lt;#directivename parameters /&gt; 实际上，使用标签时前面的#符号也可能变成@，如果该指令是一个用户指令而不是系统内建指令时，应将#符号改为@符号 插值规则FreeMarker的插值有如下两种类型 1、通用插值：${expr} 2、数字格式化插值：#{expr}或者#{expr;format}通用插值，有可以分为四种情况 a、插值结果为字符串值：直接输出表达式结果 b、插值结果为数字值：根据默认格式(#setting 指令设置)将表达式结果转换成文本输出。可以使用内建的字符串函数格式单个插值，例如 &lt;#setting number_format = &quot;currency&quot; /&gt; &lt;#assign str = 42 /&gt; $&#123;str&#125; $&#123;str?string&#125; $&#123;str?string.number&#125; $&#123;str?string.currency&#125; $&#123;str?string.percent&#125; $&#123;str?string.computer&#125; 日期处理 $&#123;openingTime?string.short&#125; $&#123;openingTime?string.medium&#125; $&#123;openingTime?string.long&#125; $&#123;openingTime?string.full&#125; $&#123;nextDiscountDay?string.short&#125; $&#123;nextDiscountDay?string.medium&#125; $&#123;nextDiscountDay?string.long&#125; $&#123;nextDiscountDay?string.full&#125; $&#123;lastUpdated?string.short&#125; $&#123;lastUpdated?string.medium&#125; $&#123;lastUpdated?string.long&#125; $&#123;lastUpdated?string.full&#125; $&#123;lastUpdated?string(&quot;yyyy-MM-dd HH:mm:ss zzzz&quot;)&#125; $&#123;lastUpdated?string(&quot;EEE, MMM d, &#39;&#39;yy&quot;)&#125; $&#123;lastUpdated?string(&quot;EEEE, MMMM dd, yyyy, hh:mm:ss a &#39;(&#39;zzz&#39;)&#39;&quot;)&#125; if,elseif,elseif&lt;#if condition&gt; …… &lt;#elseif condition2&gt; …… &lt;#else&gt; …… &lt;/#if&gt; switch,case&lt;#switch value&gt; &lt;#case refValue1&gt; ... &lt;#break&gt; &lt;#case refValue2&gt; ... &lt;#break&gt; ... &lt;#case refValueN&gt; ... &lt;#break&gt; &lt;#default&gt; ... &lt;/#switch&gt; &lt;#t&gt; 去掉左右空白和回车换行 &lt;#lt&gt;去掉左边空白和回车换行 &lt;#rt&gt;去掉右边空白和回车换行 &lt;#nt&gt;取消上面的效果 list&lt;#list sequence as item&gt; ... &lt;#if item = &quot;spring&quot;&gt; &lt;#break&gt; &lt;/#if&gt; ... &lt;/#list&gt; iterm_index:当前值得下标，从0开始item_has_next:判断list是否还有值 include&lt;#include filename [options]&gt; options 包含两个属性encoding=”GBK”parse=”true” 是否作为ftl语法解析，默认是true示例：&lt;#include “/common/copyright.ftl” encoding=”GBK” parse=”true”&gt; import&lt;#import path as hash&gt; 类似于java里的import,它导入文件，然后就可以在当前文件里使用被导入文件里的宏组件 compress&lt;#compress&gt; ... &lt;/#compress&gt; escape, noescape&lt;#escape identifier as expression&gt; ... &lt;#noescape&gt;...&lt;/#noescape&gt; ... &lt;/#escape&gt; 主要使用在相似的字符串变量输出，比如某一个模块的所有字符串输出都必须是html安全的，这个时候就可以使用该表达式示例： &lt;#escape x as x?html&gt; First name: $&#123;firstName&#125; &lt;#noescape&gt;Last name: $&#123;lastName&#125;&lt;/#noescape&gt; Maiden name: $&#123;maidenName&#125; &lt;/#escape&gt; 相同表达式 First name: $&#123;firstName?html&#125; Last name: $&#123;lastName &#125; Maiden name: $&#123;maidenName?html&#125; assign&lt;#assign name=value&gt; &lt;#-- 或则 --&gt; &lt;#assign name1=value1 name2=value2 ... nameN=valueN&gt; &lt;#-- 或则 --&gt; &lt;#assign same as above... in namespacehash&gt; &lt;#-- 或则 --&gt; &lt;#assign name&gt; capture this &lt;/#assign&gt; &lt;#-- 或则 --&gt; &lt;#assign name in namespacehash&gt; capture this &lt;/#assign&gt; 生成变量,并且给变量赋值 global&lt;#global name=value&gt; &lt;#--或则--&gt; &lt;#global name1=value1 name2=value2 ... nameN=valueN&gt; &lt;#--或则--&gt; &lt;#global name&gt; capture this &lt;/#global&gt; 全局赋值语法，利用这个语法给变量赋值，那么这个变量在所有的namespace [A1] 中是可见的, 如果这个变量被当前的assign 语法覆盖 如&lt;#global x=2&gt; &lt;#assign x=1&gt; 在当前页面里x=2 将被隐藏，或者通过${.global.x} 来访问 setting&lt;#setting name=value&gt; 用来设置整个系统的一个环境localenumber_formatboolean_formatdate_format , time_format , datetime_formattime_zoneclassic_compatible macro, nested, return&lt;#macro name param1 param2 ... paramN&gt; ... &lt;#nested loopvar1, loopvar2, ..., loopvarN&gt; ... &lt;#return&gt; ... &lt;/#macro&gt; t, lt, rt&lt;#t&gt; 去掉左右空白和回车换行 &lt;#lt&gt;去掉左边空白和回车换行 &lt;#rt&gt;去掉右边空白和回车换行 &lt;#nt&gt;取消上面的效果","categories":[{"name":"大前端","slug":"大前端","permalink":"https://ysluckly.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ysluckly.github.io/tags/java/"},{"name":"freemarker","slug":"freemarker","permalink":"https://ysluckly.github.io/tags/freemarker/"}]},{"title":"正则表达式详解","slug":"tools/regular-expression","date":"2016-10-04T01:41:40.000Z","updated":"2022-02-19T09:27:58.568Z","comments":true,"path":"2016/10/04/regular-expression/","link":"","permalink":"https://ysluckly.github.io/2016/10/04/regular-expression/","excerpt":"本文目标 本文旨在更加简洁清晰的展现正则表达式， 第一部分 是对正则表达式语法的简洁介绍， 第二部分 则是常用正则表达式的示例。","text":"本文目标 本文旨在更加简洁清晰的展现正则表达式， 第一部分 是对正则表达式语法的简洁介绍， 第二部分 则是常用正则表达式的示例。 简介及语法正则表达式是什么 在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。 正则表达式语言由两种基本字符类型组成：原义（正常）文本字符和元字符。元字符使正则表达式具有处理能力。 常用元字符 元字符 做什么用 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符，包括空格，制表符（Tab），换行符，中文全角空格等） \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 字符转义 如果你想查找元字符本身的话，比如你查找 . ,或者 * ,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用 \\ 来取消这些字符的特殊意义。因此，你应该使用 \\. 和 \\* 。当然，要查找 \\ 本身，你也得用 \\\\ .例如： deerchao\\.net 匹配 deerchao.net，C:\\\\Windows 匹配 C:\\Windows 。 重复 你已经看过了前面的 * , + , &#123;2&#125; , &#123;5,12&#125; 这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等) 元字符 做什么用 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 &#123;n&#125; 重复n次 &#123;n,&#125; 重复n次或更多次 &#123;n,m&#125; 重复n到m次 下面是一些重复的示例：Windows\\d+ 匹配Windows后面跟1个或更多数字^\\w+ 匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置) 字符类 要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？很简单，你只需要在方括号里列出它们就行了，像 [aeiou] 就匹配任何一个英文元音字母， [.?!] 匹配标点符号(.或?或!)。我们也可以轻松地指定一个字符范围，像 [0-9] 代表的含意与 \\d 就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于 \\w （如果只考虑英文的话）。下面是一个更复杂的表达式： \\(?0\\d&#123;2&#125;[) -]?\\d&#123;8&#125; 。这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\\d{8})。 分支条件 正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。示例： 0\\d&#123;2&#125;-\\d&#123;8&#125;|0\\d&#123;3&#125;-\\d&#123;7&#125;这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。示例： \\d&#123;5&#125;-\\d&#123;4&#125;|\\d&#123;5&#125;这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个示例是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成 \\d&#123;5&#125;|\\d&#123;5&#125;-\\d&#123;4&#125; 的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。 分组 重复单个字符，直接在字符后面加上限定符就行了。但如果想要重复多个字符，我们可以用小括号来指定 子表达式(也叫作分组)。(\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125; 是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它： \\d&#123;1,3&#125; 匹配1到3位的数字， (\\d&#123;1,3&#125;\\.)&#123;3&#125; 匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字 (\\d&#123;1,3&#125;) 。不幸的是，它也将匹配 256.300.888.999 这种不可能存在的IP地址。我们只能使用冗长的分组，选择，字符串来描述一个 正确的IP地址： ((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?) 反义 有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义： 元字符 做什么用 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 示例： \\S+ 匹配不包含空白符的字符串。 &lt;a[^&gt;]+&gt; 匹配用尖括号括起来的以a开头的字符串。 后向引用 使用小括号指定一个子表达式后，匹配这个子表达式 的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个 组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。 后向引用 用于重复搜索前面某个分组匹配的文本。示例： \\b(\\w+)\\b\\s+\\1\\b 可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字 \\b(\\w+)\\b ，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符\\s+，最后是分组1中捕获的内容（也就是前面匹配的那个单词） \\1 。你也可以自己指定子表达式的 组名.要指定一个子表达式的组名，请使用这样的语法： (?&lt;Word&gt;\\w+) (或者把尖括号换成 &#39; 也行： (?&#39;Word&#39;\\w+)),这样就把\\w+的组名指定为 Word 了。要反向引用这个分组捕获的内容，你可以使用 \\k&lt;Word&gt; ,所以上一个示例也可以写成这样： \\b(?&lt;Word&gt;\\w+)\\b\\s+\\k&lt;Word&gt;\\b 。 零宽断言 接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为 零宽断言。(?=exp) 也叫 零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找 I’m singing while you’re dancing. 时，它会匹配 sing 和 danc 。(?&lt;=exp) 也叫 零宽度正回顾后发断言 ，它断言自身出现的位置的前面能匹配表达式exp。比如 (?&lt;=\\bre)\\w+\\b 会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找 reading a book 时，它匹配ading。假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分： ((?&lt;=\\d)\\d&#123;3&#125;)+\\b ，用它对1234567890进行查找时结果是234567890。下面这个示例同时使用了这两种断言： (?&lt;=\\s)\\d+(?=\\s) 匹配以空白符间隔的数字( 再次强调，不包括这些空白符 )。 负向零宽断言 前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：\\b\\w*q[^u]\\w*\\b 匹配 包含后面不是字母u的字母q的单词 。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的 \\w*\\b 将会匹配下一个单词，于是 \\b\\w*q[^u]\\w*\\b 就能匹配整个Iraq fighting。负向零宽断言 能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题： \\b\\w*q(?!u)\\w*\\b 。零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如： \\d&#123;3&#125;(?!\\d) 匹配三位数字，而且这三位数字的后面不能是数字； \\b((?!abc)\\w)+\\b 匹配不包含连续字符串abc的单词。同理，我们可以用(?&lt;!exp),**零宽度负回顾后发断言来断言** 此位置的前面不能匹配表达式exp：(?&lt;![a-z])\\d{7}匹配前面不是小写字母的七位数字。一个更复杂的示例：(?&lt;=&lt;(\\w+)&gt;).*(?=&lt;\\/\\1&gt;) 匹配不包含属性的简单HTML标签内里的内容。(?&lt;=&lt;(\\w+)&gt;) 指定了这样的 **前缀**：被尖括号括起来的单词(比如可能是)，然后是. * (任意的字符串),最后是一个 **后缀** (?=&lt;\\/\\1&gt;)。注意后缀里的 / ，它用到了前面提过的字符转义；\\1则是一个反向引用，引用的正是捕获的第一组，前面的 (\\w+) 匹配的内容，这样如果前缀实际上是的话，后缀就是了。整个表达式匹配的是和之间的内容(再次提醒，不包括前缀和后缀本身)。 注释 小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\\d(?#200-249)|25[0-5](?#250-255)|[01]?\\d\\d?(?#0-199)。要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样： (?&lt;= # 断言要匹配的文本的前缀 &lt;(\\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签) ) # 前缀结束 .* # 匹配任意文本 (?= # 断言要匹配的文本的后缀 &lt;\\/\\1&gt; # 查找尖括号括起来的内容：前面是一个”/“，后面是先前捕获的标签 ) # 后缀结束 贪婪与懒惰 当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配 尽可能多 的字符。以这个表达式为例： a.*b ，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为 贪婪匹配。有时，我们更需要 懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 ? 。这样 .*? 就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。示例： a.*?b 匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。 语法 做什么用 *? 重复任意次，但尽可能少重复 +? 重复1次或更多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 &#123;n,m&#125;? 重复n到m次，但尽可能少重复 &#123;n,&#125;? 重复n次以上，但尽可能少重复 其他元字符 元字符 做什么用 \\a 报警字符(打印它的效果是电脑嘀一声) \\b 通常是单词分界位置，但如果在字符类里使用代表退格 \\t 制表符，Tab \\r 回车 \\v 竖向制表符 \\f 换页符 \\n 换行符 \\e Escape \\0nn ASCII代码中八进制代码为nn的字符 \\xnn ASCII代码中十六进制代码为nn的字符 \\unnnn Unicode代码中十六进制代码为nnnn的字符 \\cN ASCII控制字符。比如\\cC代表Ctrl+C \\A 字符串开头(类似^，但不受处理多行选项的影响) \\Z 字符串结尾或行尾(不受处理多行选项的影响) \\z 字符串结尾(类似$，但不受处理多行选项的影响) \\G 当前搜索的开头 \\p&#123;name&#125; Unicode中命名为name的字符类，例如\\p{IsGreek} (?&gt;exp) 贪婪子表达式 (?&lt;x&gt;-&lt;y&gt;exp) 平衡组 (?im-nsx:exp) 在子表达式exp中改变处理选项 (?im-nsx) 为表达式后面的部分改变处理选项 1 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no (?(exp)yes) 同上，只是使用空表达式作为no 2 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no (?(name)yes) 同上，只是使用空表达式作为no 正则表达式常用实例账号/密码帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线) = &quot;^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$&quot; 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线) = &quot;^[a-zA-Z]\\w&#123;5,17&#125;$&quot; 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间) = &quot;^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$&quot; 字符串校验汉字 = &quot;^[\\u4e00-\\u9fa5]&#123;0,&#125;$&quot;; 英文和数字 = &quot;^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$&quot;; 长度为3-20的所有字符 = &quot;^.&#123;3,20&#125;$&quot;； 由26个英文字母组成的字符串 = &quot;^[A-Za-z]+$&quot;； 由26个大写英文字母组成的字符串 = &quot;^[A-Z]+$&quot;； 由26个小写英文字母组成的字符串 = &quot;^[a-z]+$&quot;； 由数字和26个英文字母组成的字符串 = &quot;^[A-Za-z0-9]+$&quot;； 由数字、26个英文字母或者下划线组成的字符串 = &quot;^\\w+$ 或 ^\\w&#123;3,20&#125;$&quot;； 中文、英文、数字包括下划线 = &quot;^[\\u4E00-\\u9FA5A-Za-z0-9_]+$&quot;； 中文、英文、数字但不包括下划线等符号 = &quot;^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]&#123;2,20&#125;$&quot;； 禁止输入含有~的字符 = &quot;[^~\\x22]+&quot;； 手机号/** * 手机号码 * 移动：134,135,136,137,138,139,147,150,151,152,157,158,159,170,178,182,183,184,187,188 * 联通：130,131,132,145,152,155,156,1709,171,176,185,186 * 电信：133,134,153,1700,177,180,181,189 */ String MOBILE = &quot;^1(3[0-9]|4[57]|5[0-35-9]|7[01678]|8[0-9])\\\\d&#123;8&#125;$&quot;; /** * 中国移动：China Mobile * 134,135,136,137,138,139,147,150,151,152,157,158,159,170,178,182,183,184,187,188 */ String CM = &quot;^1(3[4-9]|4[7]|5[0-27-9]|7[0]|7[8]|8[2-478])\\\\d&#123;8&#125;$&quot;; /** * 中国联通：China Unicom * 130,131,132,145,152,155,156,1709,171,176,185,186 */ String CU = &quot;^1(3[0-2]|4[5]|5[56]|709|7[1]|7[6]|8[56])\\\\d&#123;8&#125;$&quot;; /** * 中国电信：China Telecom * 133,134,153,1700,177,180,181,189 */ String CT = &quot;^1(3[34]|53|77|700|8[019])\\\\d&#123;8&#125;$&quot;; IP地址String IPREGEXP = &quot;((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)&quot;; EMAIL地址Email地址 = &quot;^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$&quot;; 域名域名 = &quot;[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?&quot;; InternetURL = &quot;[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$&quot; 身份证身份证号(15位、18位数字) = &quot;^\\d&#123;15&#125;|\\d&#123;18&#125;$&quot; 短身份证号码(数字、字母x结尾) = &quot;^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$&quot; 数字类校验数字 = &quot;^[0-9]*$&quot;; n位的数字 = &quot;^\\d&#123;n&#125;$&quot;; 至少n位的数字 = &quot;^\\d&#123;n,&#125;$&quot;; m-n位的数字 = &quot;^\\d&#123;m,n&#125;$&quot;; 零和非零开头的数字 = &quot;^(0|[1-9][0-9]*)$&quot;; 非零开头的最多带两位小数的数字 = &quot;^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$&quot;; 带1-2位小数的正数或负数 = &quot;^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)?$&quot;; 正数、负数、和小数 = &quot;^(\\-|\\+)?\\d+(\\.\\d+)?$&quot;; 有两位小数的正实数 = &quot;^[0-9]+(.[0-9]&#123;2&#125;)?$&quot;; 有1~3位小数的正实数 = &quot;^[0-9]+(.[0-9]&#123;1,3&#125;)?$&quot;; 非零的正整数 = &quot;^[1-9]\\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\\+?[1-9][0-9]*$&quot;; 非零的负整数 = &quot;^\\-[1-9][]0-9&quot;*$&quot; 或 &quot;^-[1-9]\\d*$&quot;;","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"软件记录","slug":"工具/软件记录","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"regex","slug":"regex","permalink":"https://ysluckly.github.io/tags/regex/"}]},{"title":"Git常用命令","slug":"tools/git-command","date":"2016-10-02T09:15:39.000Z","updated":"2022-02-19T09:27:58.554Z","comments":true,"path":"2016/10/02/git-command/","link":"","permalink":"https://ysluckly.github.io/2016/10/02/git-command/","excerpt":"经常用到Git，但是很多命令记不住，将其整理于此。（大量摘自网络） 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要要记住60~100个命令。","text":"经常用到Git，但是很多命令记不住，将其整理于此。（大量摘自网络） 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要要记住60~100个命令。 下面整理的 Git 命令清单。几个专业名词的译名如下。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（本地仓库） Remote：远程仓库 新建版本仓库# 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史, -o 给远程仓库起名:faker,默认origin $ git clone [-o faker] [url] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name &quot;[name]&quot; $ git config [--global] user.email &quot;[email address]&quot; # 设置大小写敏感（windows不区分大小写的解决办法） $ git config core.ignorecase false 增加/删除文件# 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 代码提交# 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 分支# 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 列出所有本地分支，并展示没有分支最后一次提交的信息 $ git branch -v # 列出所有本地分支，并展示没有分支最后一次提交的信息和远程分支的追踪情况 $ git branch -vv # 列出所有已经合并到当前分支的分支 $ git branch --merged # 列出所有还没有合并到当前分支的分支 $ git branch --no-merged # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个与远程分支同名的分支，并切换到该分支 $ git checkout --track [branch-name] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream-to=[remote-branch] $ git branch --set-upstream [branch] [remote-branch] # 已被弃用 # 合并指定分支到当前分支 $ git merge [branch] # 中断此次合并（你可能不想处理冲突） $ git merge --abort # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] #新增远程分支 远程分支需先在本地创建,再进行推送 $ git push origin [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 标签# 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 查看信息/搜索# 显示有变更的文件 $ git status [-sb] #s:short,给一个短格式的展示，b:展示当前分支 # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 图形化显示所有分支 $ git log --oneline --graph --all # 显示在分支2而不在分支1中的提交 $ git log [分支1]..[分支2] $ git log ^[分支1] [分支2] $ git log [分支2] --not [分支1] # 显示两个分支不同时包含的提交 $ git log [分支1]...[分支2] # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog # 搜索你工作目录的文件，输出匹配行号 $ git grep -n [关键字] # 搜索你工作目录的文件，输出每个文件包含多少个匹配 $ git grep --count [关键字] # 优化阅读 $ git grep --break --heading [关键字] # 查询iCheck这个字符串那次提交的 $ git log -SiCheck --oneline # 查询git_deflate_bound函数每一次的变更 $ git log -L :git_deflate_bound:zlib.c 远程同步# 下载远程仓库的所有变动 [shortname] 为远程仓库的shortname, 如origin,为空时:默认origin $ git fetch [shortname] # 显示所有远程仓库 $ git remote -v #显式地获得远程引用的完整列表 [shortname] 为远程仓库的shortname, 如origin,为空时:默认origin $ git ls-remote [shortname] # 显示某个远程仓库的信息 [remote] 为远程仓库的shortname, 如origin $ git remote show [shortname] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 重命名一个远程仓库（shortname） $ git remote rename [旧仓库名] [新仓库名] # 删除一个远程链接 $ git remote rm [shortname] [url] $ git remote remove [shortname] [url] # 修改远程仓库地址 $ git remote set-url [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地当前分支到远程仓库 git push [remote] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 推送所有分支到远程仓库 $ git push [remote] --all # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force 撤销# 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . #只会保留源码（工作区），回退commit(本地仓库)与index（暂存区）到某个版本 $ git reset &lt;commit_id&gt; #默认为 --mixed模式 $ git reset --mixed &lt;commit_id&gt; #保留源码（工作区）和index（暂存区），只回退commit（本地仓库）到某个版本 $ git reset --soft &lt;commit_id&gt; #源码（工作区）、commit（本地仓库）与index（暂存区）都回退到某个版本 $ git reset --hard &lt;commit_id&gt; # 恢复到最后一次提交的状态 $ git reset --hard HEAD # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 将工作区和暂存区的代码全都存储起来了 $ git stash [save] # 只保存工作区，不存储暂存区 $ git stash --keep-index # 存储工作区、暂存区和未跟踪文件 $ git stash -u $ git stash --include-untracked # 不存储所有改动的东西，但会交互式的提示那些改动想要被储藏、哪些改动需要保存在工作目录中 $ git stash --patch # 不指定名字，Git认为指定最近的储藏，将存储的代码（工作区和暂存区）都应用到工作区 $ git stash apply [stash@&#123;2&#125;] # 存储的工作区和暂存区的代码应用到工作区和暂存区 $ git stash apply [stash@&#123;2&#125;] --index # 将存储的代码（工作区和暂存区）都应用到工作区，并从栈上扔掉他 $ git stash pop # 删除stash@&#123;2&#125;的存储 $ git stash drop [stash@&#123;2&#125;] # 获取储藏的列表 $ git stash list # 移除工作目录中所有未跟踪的文件及口口那个的子目录，不会移除.gitiignore忽略的文件 $ git clean -f -d 其他# 生成一个可供发布的压缩包 $ git archive","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"工具/git","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ysluckly.github.io/tags/Git/"}]},{"title":"一个客户端设置多个github账号","slug":"tools/computer-mutiple-github-account","date":"2016-09-30T08:42:48.000Z","updated":"2022-02-19T09:27:58.550Z","comments":true,"path":"2016/09/30/computer-mutiple-github-account/","link":"","permalink":"https://ysluckly.github.io/2016/09/30/computer-mutiple-github-account/","excerpt":"最近想要使用自己的GitHub搭建Hexo博客，同时还要使用工作的GitHub开发项目，所以在网上找寻了一些文章，在此将自己的搭建过程记录一下。","text":"最近想要使用自己的GitHub搭建Hexo博客，同时还要使用工作的GitHub开发项目，所以在网上找寻了一些文章，在此将自己的搭建过程记录一下。 前期工作两个GitHub账号（假设两个账号为one,two）取消Git全局设置 $ git config --global --unset user.name $ git config --global --unset user.email SSH配置生成id_rsa私钥，id_rsa.pub公钥。one可以直接回车，默认生成 id_rsa 和 id_rsa.pub 。 $ ssh-keygen -t rsa -C &quot;one@xx.com&quot; 添加two会出现提示输入文件名，输入与默认配置不一样的文件名，如：id_rsa_two。 $ cd ~/.ssh $ ssh-keygen -t rsa -C &quot;two@126.com&quot; # 之后会提示输入文件名 GitHub添加公钥 id_rsa.pub 、 id_rsa_two.pub，分别登陆one,two的账号，在 Account Settings 的 SSH Keys 里，点 Add SSH Keys ，将公钥(.pub文件)中的内容粘贴到 Key 中，并输入 Title。添加 ssh Key $ ssh-add ~/.ssh/id_rsa $ ssh-add ~/.ssh/id_rsa_two 可以在添加前使用下面命令删除所有的 key $ ssh-add -D 最后可以通过下面命令，查看 key 的设置 $ ssh-add -l 修改ssh config文件$ cd ~/.ssh/ $ touch config 打开 .ssh 文件夹下的 config 文件，进行配置 # default Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa # two Host two.github.com # 前缀名可以任意设置 HostName github.com User git IdentityFile ~/.ssh/id_rsa_two 这里必须采用这样的方式设置，否则 push 时会出现以下错误: ERROR: Permission to two/two.github.com.git denied to one. 简单分析下原因，我们可以发现 ssh 客户端是通过类似: git@github.com:one/one.github.com.git 这样的 Git 地址中的 User 和 Host 来识别使用哪个本地私钥的。很明显，如果 User 和 Host 始终为 git 和 github.com，那么就只能使用一个私钥。所以需要上面的方式配置，每个账号使用了自己的 Host，每个 Host 的域名做 CNAME 解析到 github.com，这样 ssh 在连接时就可以区别不同的账号了。 $ ssh -T git@github.com # 测试one ssh连接 # Hi ***! You&#39;ve successfully authenticated, but GitHub does not provide shell access. $ ssh -T git@two.github.com # 测试two ssh连接 # Hi ***! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 但是这样还没有完，下面还有关联的设置。 在Git项目中配置账号关联可以用 git init 或者 git clone 创建本地项目分别在one和two的git项目目录下，使用下面的命令设置名字和邮箱 $ git config user.name &quot;__name__&quot; # __name__ 例如 one $ git config user.email &quot;__email__&quot; # __email__ 例如 one@126.com 注意：由于我不知道Hexo怎样配置 局部的config，所以，我将two的config使用全局，而工作目录配置局部。 $ git config --global user.name &quot;__name__&quot; # __name__ 例如 two $ git config --global user.email &quot;__email__&quot; # __email__ 例如 two@126.com 查看git项目的配置 $ git config --list 查看 one 的 remote.origin.url=git@github.com:one/one.github.com.git查看 two 的 remote.origin.url=git@github.com:two/two.github.com.git由于 one 使用的是默认的 Host ，所以不需要修改，但是 two 使用的是 two.github.com ，则需要进行修改 $ git remote rm origin $ git remote add origin git@two.github.com:two/two.github.com.git 我在Hexo中的配置（使用two账号） deploy: type: git repo: git@two.github.com:two/two.github.io.git branch: master 上传更改上面所有的设置无误后，可以修改代码，然后上传了。 $ git add -A $ git commit -m &quot;your comments&quot; $ git push 如果遇到warning warning: push.default is unset; its implicit value is changing in Git 2.0 from ‘matching’ to ‘simple’. To squelch this messageand maintain the current behavior after the default changes, use… 推荐使用 $ git config --global push.default simple","categories":[{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"工具/git","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ysluckly.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://ysluckly.github.io/tags/GitHub/"}]}],"categories":[{"name":"数据库","slug":"数据库","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"数据库/MySQL","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"},{"name":"后端","slug":"后端","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"C语言","slug":"后端/C语言","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/C%E8%AF%AD%E8%A8%80/"},{"name":"Go","slug":"后端/Go","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Go/"},{"name":"工具","slug":"工具","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"网络编程","slug":"后端/网络编程","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Redis","slug":"后端/Redis","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Redis/"},{"name":"Python3","slug":"后端/Python3","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Python3/"},{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/"},{"name":"linux","slug":"运维/linux","permalink":"https://ysluckly.github.io/categories/%E8%BF%90%E7%BB%B4/linux/"},{"name":"markdown","slug":"工具/markdown","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/markdown/"},{"name":"hexo","slug":"工具/hexo","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/hexo/"},{"name":"Java","slug":"后端/Java","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"},{"name":"读书","slug":"读书","permalink":"https://ysluckly.github.io/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"大前端","slug":"大前端","permalink":"https://ysluckly.github.io/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"阅读笔记","slug":"读书/阅读笔记","permalink":"https://ysluckly.github.io/categories/%E8%AF%BB%E4%B9%A6/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"name":"程序人生","slug":"读书/程序人生","permalink":"https://ysluckly.github.io/categories/%E8%AF%BB%E4%B9%A6/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"},{"name":"软件记录","slug":"工具/软件记录","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E8%AE%B0%E5%BD%95/"},{"name":"PostgreSQL","slug":"数据库/PostgreSQL","permalink":"https://ysluckly.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL/"},{"name":"git","slug":"工具/git","permalink":"https://ysluckly.github.io/categories/%E5%B7%A5%E5%85%B7/git/"},{"name":"其他","slug":"后端/其他","permalink":"https://ysluckly.github.io/categories/%E5%90%8E%E7%AB%AF/%E5%85%B6%E4%BB%96/"},{"name":"书单","slug":"读书/书单","permalink":"https://ysluckly.github.io/categories/%E8%AF%BB%E4%B9%A6/%E4%B9%A6%E5%8D%95/"}],"tags":[{"name":"MySQL面试","slug":"MySQL面试","permalink":"https://ysluckly.github.io/tags/MySQL%E9%9D%A2%E8%AF%95/"},{"name":"通讯录","slug":"通讯录","permalink":"https://ysluckly.github.io/tags/%E9%80%9A%E8%AE%AF%E5%BD%95/"},{"name":"Go语言","slug":"Go语言","permalink":"https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80/"},{"name":"单元测试","slug":"单元测试","permalink":"https://ysluckly.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"mock框架","slug":"mock框架","permalink":"https://ysluckly.github.io/tags/mock%E6%A1%86%E6%9E%B6/"},{"name":"stub","slug":"stub","permalink":"https://ysluckly.github.io/tags/stub/"},{"name":"Go语言程序设计","slug":"Go语言程序设计","permalink":"https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"Go语言教程中文版","slug":"Go语言教程中文版","permalink":"https://ysluckly.github.io/tags/Go%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%E4%B8%AD%E6%96%87%E7%89%88/"},{"name":"golang","slug":"golang","permalink":"https://ysluckly.github.io/tags/golang/"},{"name":"mmap","slug":"mmap","permalink":"https://ysluckly.github.io/tags/mmap/"},{"name":"memory mapping","slug":"memory-mapping","permalink":"https://ysluckly.github.io/tags/memory-mapping/"},{"name":"windows","slug":"windows","permalink":"https://ysluckly.github.io/tags/windows/"},{"name":"网络编程","slug":"网络编程","permalink":"https://ysluckly.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"面试题","slug":"面试题","permalink":"https://ysluckly.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Go总结","slug":"Go总结","permalink":"https://ysluckly.github.io/tags/Go%E6%80%BB%E7%BB%93/"},{"name":"Go练习题","slug":"Go练习题","permalink":"https://ysluckly.github.io/tags/Go%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"game","slug":"game","permalink":"https://ysluckly.github.io/tags/game/"},{"name":"MySQL总结","slug":"MySQL总结","permalink":"https://ysluckly.github.io/tags/MySQL%E6%80%BB%E7%BB%93/"},{"name":"爬虫","slug":"爬虫","permalink":"https://ysluckly.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"Go面试","slug":"Go面试","permalink":"https://ysluckly.github.io/tags/Go%E9%9D%A2%E8%AF%95/"},{"name":"微服务","slug":"微服务","permalink":"https://ysluckly.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Go WebAssembly","slug":"Go-WebAssembly","permalink":"https://ysluckly.github.io/tags/Go-WebAssembly/"},{"name":"wasm","slug":"wasm","permalink":"https://ysluckly.github.io/tags/wasm/"},{"name":"gopherjs","slug":"gopherjs","permalink":"https://ysluckly.github.io/tags/gopherjs/"},{"name":"Protocol Buffers","slug":"Protocol-Buffers","permalink":"https://ysluckly.github.io/tags/Protocol-Buffers/"},{"name":"Protobuf","slug":"Protobuf","permalink":"https://ysluckly.github.io/tags/Protobuf/"},{"name":"Golang","slug":"Golang","permalink":"https://ysluckly.github.io/tags/Golang/"},{"name":"RPC","slug":"RPC","permalink":"https://ysluckly.github.io/tags/RPC/"},{"name":"TLS","slug":"TLS","permalink":"https://ysluckly.github.io/tags/TLS/"},{"name":"证书","slug":"证书","permalink":"https://ysluckly.github.io/tags/%E8%AF%81%E4%B9%A6/"},{"name":"鉴权","slug":"鉴权","permalink":"https://ysluckly.github.io/tags/%E9%89%B4%E6%9D%83/"},{"name":"golang test","slug":"golang-test","permalink":"https://ysluckly.github.io/tags/golang-test/"},{"name":"unit tests","slug":"unit-tests","permalink":"https://ysluckly.github.io/tags/unit-tests/"},{"name":"golang testing","slug":"golang-testing","permalink":"https://ysluckly.github.io/tags/golang-testing/"},{"name":"Go爬虫","slug":"Go爬虫","permalink":"https://ysluckly.github.io/tags/Go%E7%88%AC%E8%99%AB/"},{"name":"goquery","slug":"goquery","permalink":"https://ysluckly.github.io/tags/goquery/"},{"name":"Go进阶面试题","slug":"Go进阶面试题","permalink":"https://ysluckly.github.io/tags/Go%E8%BF%9B%E9%98%B6%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"go-qrcode","slug":"go-qrcode","permalink":"https://ysluckly.github.io/tags/go-qrcode/"},{"name":"二维码","slug":"二维码","permalink":"https://ysluckly.github.io/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://ysluckly.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Go面试题","slug":"Go面试题","permalink":"https://ysluckly.github.io/tags/Go%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"推箱子游戏","slug":"推箱子游戏","permalink":"https://ysluckly.github.io/tags/%E6%8E%A8%E7%AE%B1%E5%AD%90%E6%B8%B8%E6%88%8F/"},{"name":"Go项目","slug":"Go项目","permalink":"https://ysluckly.github.io/tags/Go%E9%A1%B9%E7%9B%AE/"},{"name":"mysql","slug":"mysql","permalink":"https://ysluckly.github.io/tags/mysql/"},{"name":"Gin","slug":"Gin","permalink":"https://ysluckly.github.io/tags/Gin/"},{"name":"并发编程","slug":"并发编程","permalink":"https://ysluckly.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"上下文","slug":"上下文","permalink":"https://ysluckly.github.io/tags/%E4%B8%8A%E4%B8%8B%E6%96%87/"},{"name":"信道","slug":"信道","permalink":"https://ysluckly.github.io/tags/%E4%BF%A1%E9%81%93/"},{"name":"超时退出","slug":"超时退出","permalink":"https://ysluckly.github.io/tags/%E8%B6%85%E6%97%B6%E9%80%80%E5%87%BA/"},{"name":"GO2","slug":"GO2","permalink":"https://ysluckly.github.io/tags/GO2/"},{"name":"泛型","slug":"泛型","permalink":"https://ysluckly.github.io/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"tcp/ip","slug":"tcp-ip","permalink":"https://ysluckly.github.io/tags/tcp-ip/"},{"name":"Redis","slug":"Redis","permalink":"https://ysluckly.github.io/tags/Redis/"},{"name":"教程","slug":"教程","permalink":"https://ysluckly.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"读写锁实现","slug":"读写锁实现","permalink":"https://ysluckly.github.io/tags/%E8%AF%BB%E5%86%99%E9%94%81%E5%AE%9E%E7%8E%B0/"},{"name":"核心原理","slug":"核心原理","permalink":"https://ysluckly.github.io/tags/%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"name":"Python3","slug":"Python3","permalink":"https://ysluckly.github.io/tags/Python3/"},{"name":"sqlx","slug":"sqlx","permalink":"https://ysluckly.github.io/tags/sqlx/"},{"name":"Go数据库","slug":"Go数据库","permalink":"https://ysluckly.github.io/tags/Go%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"VMware","slug":"VMware","permalink":"https://ysluckly.github.io/tags/VMware/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://ysluckly.github.io/tags/Ubuntu/"},{"name":"Markdown","slug":"Markdown","permalink":"https://ysluckly.github.io/tags/Markdown/"},{"name":"编辑器","slug":"编辑器","permalink":"https://ysluckly.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"jsDelivr","slug":"jsDelivr","permalink":"https://ysluckly.github.io/tags/jsDelivr/"},{"name":"CDN","slug":"CDN","permalink":"https://ysluckly.github.io/tags/CDN/"},{"name":"Cloudflare","slug":"Cloudflare","permalink":"https://ysluckly.github.io/tags/Cloudflare/"},{"name":"图床","slug":"图床","permalink":"https://ysluckly.github.io/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"PicGo","slug":"PicGo","permalink":"https://ysluckly.github.io/tags/PicGo/"},{"name":"搜索引擎","slug":"搜索引擎","permalink":"https://ysluckly.github.io/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"},{"name":"SEO","slug":"SEO","permalink":"https://ysluckly.github.io/tags/SEO/"},{"name":"hexo","slug":"hexo","permalink":"https://ysluckly.github.io/tags/hexo/"},{"name":"3-hexo","slug":"3-hexo","permalink":"https://ysluckly.github.io/tags/3-hexo/"},{"name":"java","slug":"java","permalink":"https://ysluckly.github.io/tags/java/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://ysluckly.github.io/tags/SpringCloud/"},{"name":"SkyWalking","slug":"SkyWalking","permalink":"https://ysluckly.github.io/tags/SkyWalking/"},{"name":"逆序字符串","slug":"逆序字符串","permalink":"https://ysluckly.github.io/tags/%E9%80%86%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"结构体","slug":"结构体","permalink":"https://ysluckly.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"二分查找","slug":"二分查找","permalink":"https://ysluckly.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"三子棋","slug":"三子棋","permalink":"https://ysluckly.github.io/tags/%E4%B8%89%E5%AD%90%E6%A3%8B/"},{"name":"栈桢","slug":"栈桢","permalink":"https://ysluckly.github.io/tags/%E6%A0%88%E6%A1%A2/"},{"name":"平均数","slug":"平均数","permalink":"https://ysluckly.github.io/tags/%E5%B9%B3%E5%9D%87%E6%95%B0/"},{"name":"c/c++代码规范","slug":"c-c-代码规范","permalink":"https://ysluckly.github.io/tags/c-c-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"扫雷","slug":"扫雷","permalink":"https://ysluckly.github.io/tags/%E6%89%AB%E9%9B%B7/"},{"name":"字符串旋转","slug":"字符串旋转","permalink":"https://ysluckly.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%8B%E8%BD%AC/"},{"name":"命令行参数 main函数","slug":"命令行参数-main函数","permalink":"https://ysluckly.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0-main%E5%87%BD%E6%95%B0/"},{"name":"linux","slug":"linux","permalink":"https://ysluckly.github.io/tags/linux/"},{"name":"五险一金","slug":"五险一金","permalink":"https://ysluckly.github.io/tags/%E4%BA%94%E9%99%A9%E4%B8%80%E9%87%91/"},{"name":"个税","slug":"个税","permalink":"https://ysluckly.github.io/tags/%E4%B8%AA%E7%A8%8E/"},{"name":"javascript","slug":"javascript","permalink":"https://ysluckly.github.io/tags/javascript/"},{"name":"docker","slug":"docker","permalink":"https://ysluckly.github.io/tags/docker/"},{"name":"reading","slug":"reading","permalink":"https://ysluckly.github.io/tags/reading/"},{"name":"活着","slug":"活着","permalink":"https://ysluckly.github.io/tags/%E6%B4%BB%E7%9D%80/"},{"name":"shell","slug":"shell","permalink":"https://ysluckly.github.io/tags/shell/"},{"name":"nginx","slug":"nginx","permalink":"https://ysluckly.github.io/tags/nginx/"},{"name":"人生在勤，不索何获","slug":"人生在勤，不索何获","permalink":"https://ysluckly.github.io/tags/%E4%BA%BA%E7%94%9F%E5%9C%A8%E5%8B%A4%EF%BC%8C%E4%B8%8D%E7%B4%A2%E4%BD%95%E8%8E%B7/"},{"name":"mac","slug":"mac","permalink":"https://ysluckly.github.io/tags/mac/"},{"name":"efficiency","slug":"efficiency","permalink":"https://ysluckly.github.io/tags/efficiency/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://ysluckly.github.io/tags/PostgreSQL/"},{"name":"vim","slug":"vim","permalink":"https://ysluckly.github.io/tags/vim/"},{"name":"keybord","slug":"keybord","permalink":"https://ysluckly.github.io/tags/keybord/"},{"name":"emacs","slug":"emacs","permalink":"https://ysluckly.github.io/tags/emacs/"},{"name":"encoding","slug":"encoding","permalink":"https://ysluckly.github.io/tags/encoding/"},{"name":"dubbo","slug":"dubbo","permalink":"https://ysluckly.github.io/tags/dubbo/"},{"name":"zookeeper","slug":"zookeeper","permalink":"https://ysluckly.github.io/tags/zookeeper/"},{"name":"fragment_cache","slug":"fragment-cache","permalink":"https://ysluckly.github.io/tags/fragment-cache/"},{"name":"浏览器","slug":"浏览器","permalink":"https://ysluckly.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"js","slug":"js","permalink":"https://ysluckly.github.io/tags/js/"},{"name":"firewall","slug":"firewall","permalink":"https://ysluckly.github.io/tags/firewall/"},{"name":"maven","slug":"maven","permalink":"https://ysluckly.github.io/tags/maven/"},{"name":"nexus","slug":"nexus","permalink":"https://ysluckly.github.io/tags/nexus/"},{"name":"mybatis","slug":"mybatis","permalink":"https://ysluckly.github.io/tags/mybatis/"},{"name":"mathjax","slug":"mathjax","permalink":"https://ysluckly.github.io/tags/mathjax/"},{"name":"pjax","slug":"pjax","permalink":"https://ysluckly.github.io/tags/pjax/"},{"name":"samba","slug":"samba","permalink":"https://ysluckly.github.io/tags/samba/"},{"name":"tale","slug":"tale","permalink":"https://ysluckly.github.io/tags/tale/"},{"name":"docker仓库","slug":"docker仓库","permalink":"https://ysluckly.github.io/tags/docker%E4%BB%93%E5%BA%93/"},{"name":"运维","slug":"运维","permalink":"https://ysluckly.github.io/tags/%E8%BF%90%E7%BB%B4/"},{"name":"centos","slug":"centos","permalink":"https://ysluckly.github.io/tags/centos/"},{"name":"磁盘分区","slug":"磁盘分区","permalink":"https://ysluckly.github.io/tags/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"},{"name":"git","slug":"git","permalink":"https://ysluckly.github.io/tags/git/"},{"name":"linux命令","slug":"linux命令","permalink":"https://ysluckly.github.io/tags/linux%E5%91%BD%E4%BB%A4/"},{"name":"encryption","slug":"encryption","permalink":"https://ysluckly.github.io/tags/encryption/"},{"name":"jsp","slug":"jsp","permalink":"https://ysluckly.github.io/tags/jsp/"},{"name":"jstl","slug":"jstl","permalink":"https://ysluckly.github.io/tags/jstl/"},{"name":"spring","slug":"spring","permalink":"https://ysluckly.github.io/tags/spring/"},{"name":"springmvc","slug":"springmvc","permalink":"https://ysluckly.github.io/tags/springmvc/"},{"name":"postgres","slug":"postgres","permalink":"https://ysluckly.github.io/tags/postgres/"},{"name":"sql","slug":"sql","permalink":"https://ysluckly.github.io/tags/sql/"},{"name":"deepin","slug":"deepin","permalink":"https://ysluckly.github.io/tags/deepin/"},{"name":"node","slug":"node","permalink":"https://ysluckly.github.io/tags/node/"},{"name":"jQuery","slug":"jQuery","permalink":"https://ysluckly.github.io/tags/jQuery/"},{"name":"translation","slug":"translation","permalink":"https://ysluckly.github.io/tags/translation/"},{"name":"ftp","slug":"ftp","permalink":"https://ysluckly.github.io/tags/ftp/"},{"name":"AngularJs","slug":"AngularJs","permalink":"https://ysluckly.github.io/tags/AngularJs/"},{"name":"Git","slug":"Git","permalink":"https://ysluckly.github.io/tags/Git/"},{"name":"IntellijIDEA","slug":"IntellijIDEA","permalink":"https://ysluckly.github.io/tags/IntellijIDEA/"},{"name":"javaee","slug":"javaee","permalink":"https://ysluckly.github.io/tags/javaee/"},{"name":"GitHub","slug":"GitHub","permalink":"https://ysluckly.github.io/tags/GitHub/"},{"name":"freemarker","slug":"freemarker","permalink":"https://ysluckly.github.io/tags/freemarker/"},{"name":"regex","slug":"regex","permalink":"https://ysluckly.github.io/tags/regex/"}]}